(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var rootReducer = function rootReducer() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var action = arguments[1];

    switch (action.type) {
        case 'UPDATE_DEPENDENCY_DROPDOWN':
            return _extends({}, action, {
                dependencyFieldName: action.fieldName
            });

        case 'CLEAR_DEPENDENCY_DROPDOWN':
            return _extends({}, action, {
                dependencyFieldName: action.fieldName
            });
        default:
            return state;
    }
};

exports.default = rootReducer;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _dependedDropdownReducer = require("./depended-dropdown-reducer");

var _dependedDropdownReducer2 = _interopRequireDefault(_dependedDropdownReducer);

var _redux = require("redux");

var _reduxDevtoolsExtension = require("redux-devtools-extension");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var composeEnhancers = (0, _reduxDevtoolsExtension.composeWithDevTools)({});

var customMiddleWare = function customMiddleWare(store) {
    return function (next) {
        return function (action) {
            next(action);
        };
    };
};

var dependedDropdownStore = (0, _redux.createStore)(_dependedDropdownReducer2.default, composeEnhancers((0, _redux.applyMiddleware)(customMiddleWare)));

exports.default = dependedDropdownStore;

},{"./depended-dropdown-reducer":1,"redux":216,"redux-devtools-extension":210}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _relationalSearchable = require("../../input/relational-searchable.jsx");

var _relationalSearchable2 = _interopRequireDefault(_relationalSearchable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DependedRelation = function (_React$Component) {
    _inherits(DependedRelation, _React$Component);

    function DependedRelation() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, DependedRelation);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DependedRelation.__proto__ || Object.getPrototypeOf(DependedRelation)).call.apply(_ref, [this].concat(args))), _this), _this.onSelectCallback = function (fieldName, fieldValue) {
            var onChangeCallback = _this.props.onChangeCallback;


            onChangeCallback.apply(_this, [fieldName, fieldValue]);
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(DependedRelation, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                fields = _props.fields,
                fieldName = _props.fieldName,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate,
                i18n = _props.i18n;

            var field = fields ? fields.find(function (field) {
                return field.fieldName === fieldName;
            }) : this.props;

            return React.createElement(_relationalSearchable2.default, {
                data: _extends({}, field),
                onSelectCallback: this.onSelectCallback,
                onComponentDidMount: relationalOnComponentDidMount,
                onComponentDidUpdate: relationalOnComponentDidUpdate,
                i18n: i18n
            });
        }
    }]);

    return DependedRelation;
}(React.Component);

DependedRelation.propTypes = {
    fields: _propTypes2.default.array,
    onChangeCallback: _propTypes2.default.func,
    relationalOnComponentDidMount: _propTypes2.default.func,
    relationalOnComponentDidUpdate: _propTypes2.default.func
};

exports.default = DependedRelation;

},{"../../input/relational-searchable.jsx":27,"prop-types":190}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dependedDropdownStore = exports.ProviderDependedRelation = undefined;

var _reactRedux = require('react-redux');

var _dependedRelation = require('./depended-relation.jsx');

var _dependedRelation2 = _interopRequireDefault(_dependedRelation);

var _dependedDropdownStore = require('./depended-dropdown-store');

var _dependedDropdownStore2 = _interopRequireDefault(_dependedDropdownStore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Example from: https://redux.js.org/basics/example-todo-list

var mapStateToProps = function mapStateToProps(state) {
    return {
        fields: state.fields,
        dependencyFieldName: state.fieldName,
        fieldValues: state.fieldValues,
        isReadOnly: state.isReadOnly,
        fieldValue: state.fieldValue,
        isNullable: state.isNullable,
        timestamp: state.timestamp
    };
};

var mapDispatchToProps = function mapDispatchToProps(dispatch, props) {
    return {
        onChangeCallback: function onChangeCallback(fieldName, fieldValue) {
            var fetchData = props.fetchData,
                state = _dependedDropdownStore2.default.getState(),
                fields = state.fields,
                didTriggerAnEvent = false,
                currentField = void 0;


            fields.forEach(function (field) {
                if (field.fieldName === fieldName) {
                    field.fieldValue = fieldValue;
                } else if (field.dependedFrom && field.dependedFrom.indexOf(fieldName) === 0) {
                    fetchData(fieldName, fieldValue).then(function (data) {
                        field.fieldValues = data;
                        field.fieldValue = '';

                        dispatch({
                            type: 'UPDATE_DEPENDENCY_DROPDOWN',
                            fields: fields,
                            fieldName: field.fieldName,
                            fieldValues: field.fieldValues,
                            isReadOnly: field.isReadOnly,
                            fieldValue: field.fieldValue,
                            isNullable: field.isNullable
                        });
                    }.bind(undefined));

                    didTriggerAnEvent = true;
                } else if (field.dependedFrom && field.dependedFrom.indexOf(fieldName) > 0) {
                    field.fieldValues = [];

                    return dispatch({
                        type: 'CLEAR_DEPENDENCY_DROPDOWN',
                        fields: fields,
                        fieldName: field.fieldName,
                        fieldValues: field.fieldValues,
                        isReadOnly: field.isReadOnly,
                        fieldValue: field.fieldValue,
                        isNullable: field.isNullable
                    });
                }
            });

            if (!didTriggerAnEvent) {
                currentField = fields.find(function (field) {
                    return field.fieldName === fieldName;
                });

                dispatch({
                    type: 'UPDATE_DEPENDENCY_DROPDOWN',
                    fields: fields,
                    fieldName: currentField.fieldName,
                    fieldValues: currentField.fieldValues,
                    isReadOnly: currentField.isReadOnly,
                    fieldValue: currentField.fieldValue,
                    isNullable: currentField.isNullable
                });
            }
        }
    };
};

var mergeProps = function mergeProps(stateProps, dispatchProps, ownProps) {
    return Object.assign({}, ownProps, stateProps, dispatchProps);
};

var ProviderDependedRelation = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps, mergeProps)(_dependedRelation2.default);

exports.ProviderDependedRelation = ProviderDependedRelation;
exports.dependedDropdownStore = _dependedDropdownStore2.default;

},{"./depended-dropdown-store":2,"./depended-relation.jsx":3,"react-redux":201}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkedValue = function (_React$Component) {
    _inherits(LinkedValue, _React$Component);

    function LinkedValue(props) {
        _classCallCheck(this, LinkedValue);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (LinkedValue.__proto__ || Object.getPrototypeOf(LinkedValue)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(LinkedValue, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }]);

    return LinkedValue;
}(React.Component);

exports.default = LinkedValue;

},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactRedux = require('react-redux');

var _text = require('./input/text.jsx');

var _text2 = _interopRequireDefault(_text);

var _textarea = require('./input/textarea.jsx');

var _textarea2 = _interopRequireDefault(_textarea);

var _richTexteditor = require('./input/rich-texteditor.jsx');

var _richTexteditor2 = _interopRequireDefault(_richTexteditor);

var _date = require('./input/date.jsx');

var _date2 = _interopRequireDefault(_date);

var _datetime = require('./input/datetime.jsx');

var _datetime2 = _interopRequireDefault(_datetime);

var _enum = require('./input/enum.jsx');

var _enum2 = _interopRequireDefault(_enum);

var _enumSearchable = require('./input/enum-searchable.jsx');

var _enumSearchable2 = _interopRequireDefault(_enumSearchable);

var _dropdown = require('./input/dropdown.jsx');

var _dropdown2 = _interopRequireDefault(_dropdown);

var _dropdownSearchable = require('./input/dropdown-searchable.jsx');

var _dropdownSearchable2 = _interopRequireDefault(_dropdownSearchable);

var _relationalSearchable = require('./input/relational-searchable.jsx');

var _relationalSearchable2 = _interopRequireDefault(_relationalSearchable);

var _relationalNative = require('./input/relational-native.jsx');

var _relationalNative2 = _interopRequireDefault(_relationalNative);

var _upload = require('./input/upload.jsx');

var _upload2 = _interopRequireDefault(_upload);

var _relationNN = require('./input/relation-n-n.jsx');

var _relationNN2 = _interopRequireDefault(_relationNN);

var _searchableRelationNN = require('./input/searchable-relation-n-n.jsx');

var _searchableRelationNN2 = _interopRequireDefault(_searchableRelationNN);

var _numeric = require('./input/numeric.jsx');

var _numeric2 = _interopRequireDefault(_numeric);

var _checkboxBoolean = require('./input/checkbox-boolean.jsx');

var _checkboxBoolean2 = _interopRequireDefault(_checkboxBoolean);

var _email = require('./input/email.jsx');

var _email2 = _interopRequireDefault(_email);

var _color = require('./input/color.jsx');

var _color2 = _interopRequireDefault(_color);

var _password = require('./input/password.jsx');

var _password2 = _interopRequireDefault(_password);

var _url = require('./input/url.jsx');

var _url2 = _interopRequireDefault(_url);

var _backendCallback = require('./input/backend-callback.js');

var _backendCallback2 = _interopRequireDefault(_backendCallback);

var _multiselectSearchable = require('./input/multiselect-searchable.js');

var _multiselectSearchable2 = _interopRequireDefault(_multiselectSearchable);

var _multiselect = require('./input/multiselect');

var _multiselect2 = _interopRequireDefault(_multiselect);

var _dependedRelation = require('./components/depended-relation/depended-relation.jsx');

var _dependedRelation2 = _interopRequireDefault(_dependedRelation);

var _providerDependedRelation = require('./components/depended-relation/provider-depended-relation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldInput = function (_React$Component) {
    _inherits(FieldInput, _React$Component);

    function FieldInput() {
        _classCallCheck(this, FieldInput);

        return _possibleConstructorReturn(this, (FieldInput.__proto__ || Object.getPrototypeOf(FieldInput)).apply(this, arguments));
    }

    _createClass(FieldInput, [{
        key: '__type_email',
        value: function __type_email(fieldName, data) {
            return React.createElement(_email2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_url',
        value: function __type_url(fieldName, data) {
            return React.createElement(_url2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_color',
        value: function __type_color(fieldName, data) {
            return React.createElement(_color2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_password',
        value: function __type_password(fieldName, data) {
            return React.createElement(_password2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_checkbox_boolean',
        value: function __type_checkbox_boolean(fieldName, data) {
            return React.createElement(_checkboxBoolean2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_dropdown',
        value: function __type_dropdown(fieldName, data) {
            return React.createElement(_dropdown2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_dropdown_search',
        value: function __type_dropdown_search(fieldName, data) {
            return React.createElement(_dropdownSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_enum',
        value: function __type_enum(fieldName, data) {
            return React.createElement(_enum2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_multiselect_searchable',
        value: function __type_multiselect_searchable(fieldName, data) {
            return React.createElement(_multiselectSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_multiselect_native',
        value: function __type_multiselect_native(fieldName, data) {
            return React.createElement(_multiselect2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_enum_searchable',
        value: function __type_enum_searchable(fieldName, data) {
            return React.createElement(_enumSearchable2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_int',
        value: function __type_int(fieldName, data) {
            return React.createElement(_numeric2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_relational',
        value: function __type_relational(fieldName, data) {
            var _props = this.props,
                i18n = _props.i18n,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate;

            return React.createElement(_relationalSearchable2.default, {
                key: fieldName,
                data: data,
                i18n: i18n,
                onComponentDidMount: relationalOnComponentDidMount,
                onComponentDidUpdate: relationalOnComponentDidUpdate
            });
        }
    }, {
        key: '__type_relational_native',
        value: function __type_relational_native(fieldName, data) {
            return React.createElement(_relationalNative2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_relational_n_n',
        value: function __type_relational_n_n(fieldName, data) {
            return React.createElement(_searchableRelationNN2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_native_relational_n_n',
        value: function __type_native_relational_n_n(fieldName, data) {
            return React.createElement(_relationNN2.default, { key: fieldName, data: data });
        }
    }, {
        key: '__type_numeric',
        value: function __type_numeric(fieldName, data) {
            return this.__type_int(fieldName, data);
        }
    }, {
        key: '__type_backend_callback',
        value: function __type_backend_callback(fieldName, data) {
            return React.createElement(_backendCallback2.default, { key: fieldName, data: data });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldType = _props$data.fieldType,
                data = this.props.data,
                _props2 = this.props,
                gcrudInstance = _props2.gcrudInstance,
                fetchData = _props2.fetchData,
                timestamp = Math.floor(Date.now() / 1000);


            if (this['__type_' + fieldType] !== undefined) {
                return this['__type_' + fieldType](fieldName, data);
            }

            if (/^texteditor$/i.test(fieldType)) {
                return React.createElement(_richTexteditor2.default, { data: data });
            }

            if (/^text$/i.test(fieldType)) {
                return React.createElement(_textarea2.default, { key: timestamp, data: data });
            }

            if (/^date$/i.test(fieldType)) {
                return React.createElement(_date2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance });
            }

            if (/^(datetime|timestamp)$/i.test(fieldType)) {
                return React.createElement(_datetime2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance });
            }

            if (/^upload$/i.test(fieldType)) {
                return React.createElement(_upload2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance, maxUploadLimit: 1 });
            }

            if (/^multiple_upload$/i.test(fieldType)) {
                return React.createElement(_upload2.default, { key: timestamp, data: data, gcrudInstance: gcrudInstance, maxUploadLimit: 100 });
            }

            /*if (/blob$/i.test(fieldType)) {
                return <InputUpload key={timestamp} data={data} gcrudInstance={gcrudInstance} maxUploadLimit={1} />;
            }*/

            if (/^depended_relational$/.test(fieldType)) {

                var fields = _providerDependedRelation.dependedDropdownStore.getState().fields,
                    fieldData = void 0;

                var _props3 = this.props,
                    i18n = _props3.i18n,
                    relationalOnComponentDidMount = _props3.relationalOnComponentDidMount,
                    relationalOnComponentDidUpdate = _props3.relationalOnComponentDidUpdate;


                if (!fields) {
                    fields = [];
                }

                fieldData = fields.find(function (field) {
                    return field.fieldName === data.fieldName;
                });

                data.fieldValues = _typeof(data.fieldValue) === 'object' ? data.fieldValue.permittedValues : data.fieldValues;
                data.fieldValue = _typeof(data.fieldValue) === 'object' ? data.fieldValue.value : data.fieldValue;

                // Workaround to mark it as always nullable as we have some issues with the refresh of the page
                data.isNullable = true;

                if (!fieldData) {
                    fieldData = {
                        fieldName: data.fieldName,
                        fieldValues: data.fieldValues,
                        isReadOnly: data.isReadOnly,
                        fieldValue: data.fieldValue,
                        isNullable: data.isNullable,
                        dependedFrom: data.options.dependedFrom
                    };
                    fields.push(fieldData);
                }

                fields.forEach(function (field) {
                    if (field.fieldName === data.fieldName) {
                        field.fieldValues = data.fieldValues;
                        field.isReadOnly = data.isReadOnly;
                        field.fieldValue = data.fieldValue;
                        field.isNullable = data.isNullable;
                    }
                });

                _providerDependedRelation.dependedDropdownStore.dispatch({
                    type: 'UPDATE_DEPENDENCY_DROPDOWN',
                    fields: fields,
                    fieldName: data.fieldName,
                    fieldValues: data.fieldValues,
                    isReadOnly: data.isReadOnly,
                    fieldValue: data.fieldValue,
                    isNullable: data.isNullable
                });

                return React.createElement(
                    _reactRedux.Provider,
                    { store: _providerDependedRelation.dependedDropdownStore },
                    React.createElement(_providerDependedRelation.ProviderDependedRelation, {
                        fieldName: data.fieldName,
                        fetchData: fetchData,
                        i18n: i18n,
                        relationalOnComponentDidMount: relationalOnComponentDidMount,
                        relationalOnComponentDidUpdate: relationalOnComponentDidUpdate
                    })
                );
            }

            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return FieldInput;
}(React.Component);

exports.default = FieldInput;

},{"./components/depended-relation/depended-relation.jsx":3,"./components/depended-relation/provider-depended-relation":4,"./input/backend-callback.js":9,"./input/checkbox-boolean.jsx":10,"./input/color.jsx":11,"./input/date.jsx":12,"./input/datetime.jsx":13,"./input/dropdown-searchable.jsx":14,"./input/dropdown.jsx":15,"./input/email.jsx":16,"./input/enum-searchable.jsx":17,"./input/enum.jsx":18,"./input/multiselect":21,"./input/multiselect-searchable.js":20,"./input/numeric.jsx":22,"./input/password.jsx":23,"./input/relation-n-n.jsx":25,"./input/relational-native.jsx":26,"./input/relational-searchable.jsx":27,"./input/rich-texteditor.jsx":30,"./input/searchable-relation-n-n.jsx":31,"./input/text.jsx":32,"./input/textarea.jsx":33,"./input/upload.jsx":35,"./input/url.jsx":37,"react-redux":201}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fieldRow = require('./field-row.jsx');

var _fieldRow2 = _interopRequireDefault(_fieldRow);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldList = function (_React$Component) {
    _inherits(FieldList, _React$Component);

    function FieldList() {
        _classCallCheck(this, FieldList);

        return _possibleConstructorReturn(this, (FieldList.__proto__ || Object.getPrototypeOf(FieldList)).apply(this, arguments));
    }

    _createClass(FieldList, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                gcrudInstance = _props.gcrudInstance,
                fetchData = _props.fetchData,
                FieldInputComponent = _props.FieldInputComponent,
                FieldRowWrapper = _props.FieldRowWrapper,
                fields = _props.fields,
                i18n = _props.i18n,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate;


            return React.createElement(
                'div',
                null,
                fields.map(function FieldsForEach(field) {
                    var fieldName = field.fieldName;


                    return React.createElement(_fieldRow2.default, {
                        key: fieldName,
                        data: field,
                        fetchData: fetchData,
                        gcrudInstance: gcrudInstance,
                        FieldInputComponent: FieldInputComponent,
                        FieldRowWrapper: FieldRowWrapper,
                        i18n: i18n,
                        relationalOnComponentDidMount: relationalOnComponentDidMount,
                        relationalOnComponentDidUpdate: relationalOnComponentDidUpdate
                    });
                })
            );
        }
    }]);

    return FieldList;
}(React.Component);

FieldList.propTypes = {
    gcrudInstance: _propTypes2.default.object,
    FieldInputComponent: _propTypes2.default.func,
    FieldRowWrapper: _propTypes2.default.func,
    fields: _propTypes2.default.array,
    relationalOnComponentDidMount: _propTypes2.default.func,
    relationalOnComponentDidUpdate: _propTypes2.default.func

};

exports.default = FieldList;

},{"./field-row.jsx":8,"prop-types":190}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _hidden = require('./input/hidden.jsx');

var _hidden2 = _interopRequireDefault(_hidden);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRow = function (_React$Component) {
    _inherits(FieldRow, _React$Component);

    function FieldRow() {
        _classCallCheck(this, FieldRow);

        return _possibleConstructorReturn(this, (FieldRow.__proto__ || Object.getPrototypeOf(FieldRow)).apply(this, arguments));
    }

    _createClass(FieldRow, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                data = _props.data,
                _props$data = _props.data,
                fieldType = _props$data.fieldType,
                isRequired = _props$data.isRequired,
                displayAs = _props$data.displayAs,
                gcrudInstance = _props.gcrudInstance,
                fetchData = _props.fetchData,
                FieldInputComponent = _props.FieldInputComponent,
                FieldRowWrapper = _props.FieldRowWrapper,
                i18n = _props.i18n,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate;


            if (/^hidden$/i.test(fieldType)) {
                return React.createElement(_hidden2.default, { data: data });
            }

            return React.createElement(FieldRowWrapper, {
                isRequired: isRequired,
                displayAs: displayAs,
                data: data,
                fetchData: fetchData,
                gcrudInstance: gcrudInstance,
                FieldInput: FieldInputComponent,
                i18n: i18n,
                relationalOnComponentDidMount: relationalOnComponentDidMount,
                relationalOnComponentDidUpdate: relationalOnComponentDidUpdate
            });
        }
    }]);

    return FieldRow;
}(React.Component);

FieldRow.propTypes = {
    data: _propTypes2.default.shape({
        displayAs: _propTypes2.default.string,
        fieldType: _propTypes2.default.string,
        isRequired: _propTypes2.default.bool
    }),
    gcrudInstance: _propTypes2.default.object,
    FieldInputComponent: _propTypes2.default.func,
    FieldRowWrapper: _propTypes2.default.func,
    relationalOnComponentDidMount: _propTypes2.default.func,
    relationalOnComponentDidUpdate: _propTypes2.default.func
};

FieldRow.defaultProps = {
    FieldInputComponent: function FieldInputComponent(props) {
        return React.createElement('input', { name: props.data.fieldName });
    },
    FieldRowWrapper: function FieldRowWrapper(props) {
        var isRequired = props.isRequired,
            displayAs = props.displayAs,
            FieldInput = props.FieldInput,
            data = props.data,
            gcrudInstance = props.gcrudInstance,
            fetchData = props.fetchData,
            i18n = props.i18n;


        return React.createElement(
            'div',
            null,
            React.createElement(
                'label',
                null,
                isRequired ? '*' : '',
                displayAs
            ),
            React.createElement(
                'div',
                null,
                React.createElement(FieldInput, { data: data, gcrudInstance: gcrudInstance, fetchData: fetchData, i18n: i18n })
            )
        );
    }
};

exports.default = FieldRow;

},{"./input/hidden.jsx":19,"prop-types":190}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputBackendCallback = function (_React$Component) {
    _inherits(InputBackendCallback, _React$Component);

    function InputBackendCallback(props) {
        _classCallCheck(this, InputBackendCallback);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputBackendCallback.__proto__ || Object.getPrototypeOf(InputBackendCallback)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputBackendCallback, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var defaultValue = this.props.data.defaultValue,
                fieldValue = this.state.fieldValue,
                dangerouslyInnerHTML = {
                __html: defaultValue ? defaultValue : fieldValue
            };


            return React.createElement('div', { dangerouslySetInnerHTML: dangerouslyInnerHTML });
        }
    }]);

    return InputBackendCallback;
}(React.Component);

InputBackendCallback.propTypes = {
    data: _propTypes2.default.shape({
        fieldValue: _propTypes2.default.string,
        defaultValue: _propTypes2.default.string
    })
};

exports.default = InputBackendCallback;

},{"prop-types":190}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputCheckboxBoolean = function (_React$Component) {
    _inherits(InputCheckboxBoolean, _React$Component);

    function InputCheckboxBoolean(props) {
        _classCallCheck(this, InputCheckboxBoolean);

        var _props$data = props.data,
            fieldValue = _props$data.fieldValue,
            defaultValue = _props$data.defaultValue,
            showDefaultValue = _props$data.showDefaultValue,
            value = showDefaultValue && defaultValue ? defaultValue : fieldValue;

        var _this = _possibleConstructorReturn(this, (InputCheckboxBoolean.__proto__ || Object.getPrototypeOf(InputCheckboxBoolean)).call(this, props));

        _this.state = {
            fieldValue: _this.getCheckboxValue(value),
            isChecked: _this.checkboxIsChecked(value)
        };
        return _this;
    }

    _createClass(InputCheckboxBoolean, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var _nextProps$data = nextProps.data,
                fieldValue = _nextProps$data.fieldValue,
                defaultValue = _nextProps$data.defaultValue,
                showDefaultValue = _nextProps$data.showDefaultValue,
                value = showDefaultValue && defaultValue ? defaultValue : fieldValue;


            this.setState({
                fieldValue: this.getCheckboxValue(value),
                isChecked: this.checkboxIsChecked(value)
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange() {
            var isChecked = this.state.isChecked;


            this.setState({
                fieldValue: isChecked ? '0' : '1',
                isChecked: !isChecked
            });
        }
    }, {
        key: 'getCheckboxValue',
        value: function getCheckboxValue(value) {
            return value === '1' ? '1' : '0';
        }
    }, {
        key: 'checkboxIsChecked',
        value: function checkboxIsChecked(value) {
            return value === '1';
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data2 = this.props.data,
                fieldName = _props$data2.fieldName,
                isReadOnly = _props$data2.isReadOnly,
                _state = this.state,
                fieldValue = _state.fieldValue,
                isChecked = _state.isChecked;


            if (isReadOnly) {
                return React.createElement(
                    'div',
                    { className: 'form-control gc-read-only-input' },
                    isChecked ? React.createElement('i', { className: 'fa fa-check' }) : ''
                );
            }

            return React.createElement(
                'div',
                null,
                React.createElement('input', { value: fieldValue,
                    disabled: isReadOnly,
                    checked: isChecked,
                    type: 'checkbox',
                    onChange: this.linkedChange.bind(this) }),
                React.createElement('input', { name: fieldName,
                    value: fieldValue,
                    type: 'hidden' })
            );
        }
    }]);

    return InputCheckboxBoolean;
}(React.Component);

InputCheckboxBoolean.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldValue: _propTypes2.default.string,
        defaultValue: _propTypes2.default.string,
        showDefaultValue: _propTypes2.default.bool
    })
};

exports.default = InputCheckboxBoolean;

},{"prop-types":190}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputColor = function (_InputText) {
    _inherits(InputColor, _InputText);

    function InputColor() {
        _classCallCheck(this, InputColor);

        return _possibleConstructorReturn(this, (InputColor.__proto__ || Object.getPrototypeOf(InputColor)).apply(this, arguments));
    }

    _createClass(InputColor, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputColor;
}(_text2.default);

InputColor.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldType: _propTypes2.default.string
    })
};

exports.default = InputColor;

},{"./text.jsx":32,"prop-types":190}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputDate = function (_React$Component) {
    _inherits(InputDate, _React$Component);

    function InputDate() {
        _classCallCheck(this, InputDate);

        return _possibleConstructorReturn(this, (InputDate.__proto__ || Object.getPrototypeOf(InputDate)).apply(this, arguments));
    }

    _createClass(InputDate, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.datepicker($(ReactDOM.findDOMNode(this)).find('.gc-input-date'), this.props.gcrudInstance);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly,
                extraInput = '',
                inputClasses = 'form-control gc-input-date';


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
                inputClasses += ' hidden';
            }
            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement('input', {
                    className: inputClasses,
                    name: fieldName,
                    readOnly: isReadOnly,
                    defaultValue: fieldValue,
                    type: 'text',
                    step: '1'
                })
            );
        }
    }]);

    return InputDate;
}(React.Component);

exports.default = InputDate;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"./read-only.jsx":24}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputDatetime = function (_React$Component) {
    _inherits(InputDatetime, _React$Component);

    function InputDatetime() {
        _classCallCheck(this, InputDatetime);

        return _possibleConstructorReturn(this, (InputDatetime.__proto__ || Object.getPrototypeOf(InputDatetime)).apply(this, arguments));
    }

    _createClass(InputDatetime, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            jQueryPlugins.datetimepicker($(ReactDOM.findDOMNode(this)).find('.gc-input-datetime'), this.props.gcrudInstance);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly,
                extraInput = '',
                inputClasses = 'form-control gc-input-datetime';


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
                inputClasses += ' hidden';
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement('input', {
                    className: inputClasses,
                    name: fieldName,
                    readOnly: isReadOnly,
                    defaultValue: fieldValue,
                    type: 'text',
                    step: '1'
                })
            );
        }
    }]);

    return InputDatetime;
}(React.Component);

exports.default = InputDatetime;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"./read-only.jsx":24}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputDropdownSearchable = function (_LinkedValue) {
    _inherits(InputDropdownSearchable, _LinkedValue);

    function InputDropdownSearchable() {
        _classCallCheck(this, InputDropdownSearchable);

        return _possibleConstructorReturn(this, (InputDropdownSearchable.__proto__ || Object.getPrototypeOf(InputDropdownSearchable)).apply(this, arguments));
    }

    _createClass(InputDropdownSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var isReadOnly = this.props.data.isReadOnly;


            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)).find('select'), isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var isReadOnly = this.props.data.isReadOnly;


            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                extraInput = '',
                options = [];


            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });
                if (optionValue === fieldValue) {
                    fieldValueDescription = optionDisplay;
                }
            });

            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        name: fieldName,
                        value: fieldValue,
                        onChange: this.linkedChange.bind(this),
                        className: 'form-control',
                        disabled: isReadOnly,
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputDropdownSearchable;
}(_linkedValue2.default);

exports.default = InputDropdownSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"../../../Resources/public/js/sections/i18n":102,"../components/linked-value.js":5,"./read-only.jsx":24,"underscore":225}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputDropdown = function (_LinkedValue) {
    _inherits(InputDropdown, _LinkedValue);

    function InputDropdown() {
        _classCallCheck(this, InputDropdown);

        return _possibleConstructorReturn(this, (InputDropdown.__proto__ || Object.getPrototypeOf(InputDropdown)).apply(this, arguments));
    }

    _createClass(InputDropdown, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                options = [];


            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });

                // For the select id show the option display instead of the id
                if (optionValue === fieldValue) {
                    fieldValueDescription = optionDisplay;
                }
            });

            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'select',
                {
                    name: fieldName,
                    value: fieldValue,
                    onChange: this.linkedChange.bind(this),
                    className: 'form-control',
                    disabled: isReadOnly },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        'option',
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputDropdown;
}(_linkedValue2.default);

exports.default = InputDropdown;

},{"../components/linked-value.js":5,"./read-only.jsx":24,"underscore":225}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputEmail = function (_InputText) {
    _inherits(InputEmail, _InputText);

    function InputEmail() {
        _classCallCheck(this, InputEmail);

        return _possibleConstructorReturn(this, (InputEmail.__proto__ || Object.getPrototypeOf(InputEmail)).apply(this, arguments));
    }

    _createClass(InputEmail, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputEmail;
}(_text2.default);

exports.default = InputEmail;

},{"./text.jsx":32}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputEnumSearchable = function (_LinkedValue) {
    _inherits(InputEnumSearchable, _LinkedValue);

    function InputEnumSearchable() {
        _classCallCheck(this, InputEnumSearchable);

        return _possibleConstructorReturn(this, (InputEnumSearchable.__proto__ || Object.getPrototypeOf(InputEnumSearchable)).apply(this, arguments));
    }

    _createClass(InputEnumSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var isReadOnly = this.props.data.isReadOnly;

            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)).find('select'), isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var isReadOnly = this.props.data.isReadOnly;

            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                extraInput = '',
                options = [];


            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }
            if (isNullable) {
                options.push('');
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            options = _underscore2.default.uniq(options);
            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        name: fieldName,
                        value: fieldValue,
                        className: 'form-control',
                        disabled: isReadOnly,
                        onChange: this.linkedChange.bind(this),
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function optionsForEach(field) {
                        return React.createElement(
                            'option',
                            { defaultValue: field, key: field },
                            field
                        );
                    })
                )
            );
        }
    }]);

    return InputEnumSearchable;
}(_linkedValue2.default);

exports.default = InputEnumSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"../../../Resources/public/js/sections/i18n":102,"../components/linked-value.js":5,"./read-only.jsx":24,"underscore":225}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputEnum = function (_LinkedValue) {
    _inherits(InputEnum, _LinkedValue);

    function InputEnum() {
        _classCallCheck(this, InputEnum);

        return _possibleConstructorReturn(this, (InputEnum.__proto__ || Object.getPrototypeOf(InputEnum)).apply(this, arguments));
    }

    _createClass(InputEnum, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                options = [];


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            if (isNullable) {
                options.push('');
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            options = _underscore2.default.uniq(options);
            return React.createElement(
                'select',
                { name: fieldName, value: fieldValue, className: 'form-control', disabled: isReadOnly, onChange: this.linkedChange.bind(this) },
                options.map(function optionsForEach(field) {
                    return React.createElement(
                        'option',
                        { defaultValue: field, key: field },
                        field
                    );
                })
            );
        }
    }]);

    return InputEnum;
}(_linkedValue2.default);

exports.default = InputEnum;

},{"../components/linked-value.js":5,"./read-only.jsx":24,"underscore":225}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputHidden = function (_React$Component) {
    _inherits(InputHidden, _React$Component);

    function InputHidden(props) {
        _classCallCheck(this, InputHidden);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputHidden.__proto__ || Object.getPrototypeOf(InputHidden)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputHidden, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var fieldName = this.props.data.fieldName,
                fieldValue = this.state.fieldValue;


            return React.createElement('input', {
                className: 'form-control',
                name: fieldName,
                value: fieldValue,
                readOnly: 'readOnly',
                type: 'hidden'
            });
        }
    }]);

    return InputHidden;
}(React.Component);

InputHidden.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        fieldValue: _propTypes2.default.string
    })
};

exports.default = InputHidden;

},{"prop-types":190}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _multiselect = require('./multiselect.js');

var _multiselect2 = _interopRequireDefault(_multiselect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var InputMultiselectSearchable = function (_InputMultiselect) {
    _inherits(InputMultiselectSearchable, _InputMultiselect);

    function InputMultiselectSearchable() {
        _classCallCheck(this, InputMultiselectSearchable);

        return _possibleConstructorReturn(this, (InputMultiselectSearchable.__proto__ || Object.getPrototypeOf(InputMultiselectSearchable)).apply(this, arguments));
    }

    _createClass(InputMultiselectSearchable, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var $select = $(ReactDOM.findDOMNode(this)).find('select'),
                isReadOnly = this.props.data.isReadOnly;

            jQueryPlugins.searchableSelect($select, isReadOnly);
            $select.on('change', function SearchableSelectUpdate(event) {
                this.linkedChange.apply(this, [event]);
            }.bind(this));
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var isReadOnly = this.props.data.isReadOnly;


            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)).find('select'), isReadOnly);
        }
    }]);

    return InputMultiselectSearchable;
}(_multiselect2.default);

exports.default = InputMultiselectSearchable;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"./multiselect.js":21}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputMultiselect = function (_React$Component) {
    _inherits(InputMultiselect, _React$Component);

    function InputMultiselect(props) {
        _classCallCheck(this, InputMultiselect);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputMultiselect.__proto__ || Object.getPrototypeOf(InputMultiselect)).call(this, props));

        _this.state = {
            fieldValue: fieldValue
        };
        return _this;
    }

    _createClass(InputMultiselect, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                selectedItems = void 0,
                selectedItemsAsString = void 0,
                fieldValueDescription = [],
                extraInput = null,
                options = [],
                selectClassName = 'form-control';


            selectedItems = fieldValue !== null ? fieldValue : [];
            selectedItemsAsString = selectedItems.join();

            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            _underscore2.default.each(fieldValues, function forEachFieldValue(optionDisplay, optionValue) {
                options.push({
                    id: optionValue,
                    title: optionDisplay
                });
                if (selectedItems.indexOf(optionValue) > -1) {
                    fieldValueDescription.push(optionDisplay);
                }
            });

            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription.join(', ') });
                selectClassName += ' hidden';
            } else {
                extraInput = React.createElement('input', { type: 'hidden', name: fieldName, value: selectedItemsAsString });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    {
                        multiple: true,
                        value: selectedItems,
                        onChange: this.linkedChange.bind(this),
                        className: selectClassName,
                        disabled: isReadOnly,
                        'data-placeholder': i18n.t('select_an_option') },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputMultiselect;
}(React.Component);

exports.default = InputMultiselect;

},{"../../../Resources/public/js/sections/i18n":102,"./read-only.jsx":24,"underscore":225}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputNumeric = function (_React$Component) {
    _inherits(InputNumeric, _React$Component);

    function InputNumeric() {
        _classCallCheck(this, InputNumeric);

        return _possibleConstructorReturn(this, (InputNumeric.__proto__ || Object.getPrototypeOf(InputNumeric)).apply(this, arguments));
    }

    _createClass(InputNumeric, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputNumeric;
}(React.Component);

exports.default = InputNumeric;

},{"./text.jsx":32}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputPassword = function (_InputText) {
    _inherits(InputPassword, _InputText);

    function InputPassword() {
        _classCallCheck(this, InputPassword);

        return _possibleConstructorReturn(this, (InputPassword.__proto__ || Object.getPrototypeOf(InputPassword)).apply(this, arguments));
    }

    _createClass(InputPassword, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputPassword;
}(_text2.default);

exports.default = InputPassword;

},{"./text.jsx":32}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputReadOnly = function (_React$Component) {
    _inherits(InputReadOnly, _React$Component);

    function InputReadOnly() {
        _classCallCheck(this, InputReadOnly);

        return _possibleConstructorReturn(this, (InputReadOnly.__proto__ || Object.getPrototypeOf(InputReadOnly)).apply(this, arguments));
    }

    _createClass(InputReadOnly, [{
        key: 'render',
        value: function render() {
            var fieldValue = this.props.fieldValue;


            if (!fieldValue) {
                fieldValue = '-';
            }

            return React.createElement(
                'div',
                { className: 'form-control gc-read-only-input' },
                fieldValue
            );
        }
    }]);

    return InputReadOnly;
}(React.Component);

InputReadOnly.propTypes = {
    fieldValue: _propTypes2.default.string
};

exports.default = InputReadOnly;

},{"prop-types":190}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require("../components/linked-value.js");

var _linkedValue2 = _interopRequireDefault(_linkedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputRelationNtoN = function (_LinkedValue) {
    _inherits(InputRelationNtoN, _LinkedValue);

    function InputRelationNtoN() {
        _classCallCheck(this, InputRelationNtoN);

        return _possibleConstructorReturn(this, (InputRelationNtoN.__proto__ || Object.getPrototypeOf(InputRelationNtoN)).apply(this, arguments));
    }

    _createClass(InputRelationNtoN, [{
        key: "linkedChange",
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: "render",
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                options = [];


            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });
            return React.createElement(
                "select",
                { name: fieldName, multiple: "multiple", className: "form-control",
                    disabled: isReadOnly, value: fieldValue, onChange: this.linkedChange.bind(this) },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        "option",
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputRelationNtoN;
}(_linkedValue2.default);

exports.default = InputRelationNtoN;

},{"../components/linked-value.js":5}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputRelationalNative = function (_React$Component) {
    _inherits(InputRelationalNative, _React$Component);

    function InputRelationalNative(props) {
        _classCallCheck(this, InputRelationalNative);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputRelationalNative.__proto__ || Object.getPrototypeOf(InputRelationalNative)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputRelationalNative, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            var _props = this.props,
                onSelectCallback = _props.onSelectCallback,
                fieldName = _props.data.fieldName,
                fieldValue = event.target.value;


            this.setState({
                fieldValue: fieldValue
            });

            if (onSelectCallback) {
                onSelectCallback.apply(this, [fieldName, fieldValue]);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isNullable = _props$data.isNullable,
                isReadOnly = _props$data.isReadOnly;
            var fieldValue = this.state.fieldValue,
                fieldValueDescription = '',
                options = [];


            if (fieldValue === null) {
                fieldValue = '';
            }
            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);

                if (optionValue.id === fieldValue) {
                    fieldValueDescription = optionValue.title;
                }
            });

            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'select',
                { name: fieldName,
                    value: fieldValue,
                    className: 'form-control',
                    disabled: isReadOnly,
                    onChange: this.linkedChange.bind(this) },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;


                    return React.createElement(
                        'option',
                        { value: id, key: id ? id : '-1' },
                        title
                    );
                })
            );
        }
    }]);

    return InputRelationalNative;
}(React.Component);

InputRelationalNative.propTypes = {
    fieldName: _propTypes2.default.string,
    fieldValues: _propTypes2.default.array,
    isNullable: _propTypes2.default.bool,
    isReadOnly: _propTypes2.default.bool,
    onSelectCallback: _propTypes2.default.func
};

exports.default = InputRelationalNative;

},{"./read-only.jsx":24,"prop-types":190}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputRelationalSearchable = function (_React$Component) {
    _inherits(InputRelationalSearchable, _React$Component);

    function InputRelationalSearchable(props) {
        _classCallCheck(this, InputRelationalSearchable);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputRelationalSearchable.__proto__ || Object.getPrototypeOf(InputRelationalSearchable)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputRelationalSearchable, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _props = this.props,
                isReadOnly = _props.data.isReadOnly,
                onComponentDidMount = _props.onComponentDidMount;

            onComponentDidMount.apply(this, [ReactDOM.findDOMNode(this), { isReadOnly: isReadOnly }]);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var _props2 = this.props,
                isReadOnly = _props2.data.isReadOnly,
                onComponentDidUpdate = _props2.onComponentDidUpdate;

            onComponentDidUpdate.apply(this, [ReactDOM.findDOMNode(this), { isReadOnly: isReadOnly }]);
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            var _props3 = this.props,
                onSelectCallback = _props3.onSelectCallback,
                fieldName = _props3.data.fieldName,
                fieldValue = event.target.value;


            this.setState({
                fieldValue: fieldValue
            });

            if (onSelectCallback) {
                onSelectCallback.apply(this, [fieldName, fieldValue]);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props4 = this.props,
                i18n = _props4.i18n,
                _props4$data = _props4.data,
                fieldName = _props4$data.fieldName,
                fieldValues = _props4$data.fieldValues,
                isNullable = _props4$data.isNullable,
                isReadOnly = _props4$data.isReadOnly,
                fieldValue = this.state.fieldValue,
                options = [],
                fieldValueDescription = '',
                extraInput = '';


            if (fieldValue === null) {
                fieldValue = '';
            }
            if (isNullable) {
                options.push({ id: '', title: '' });
            }
            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);

                if (optionValue.id === fieldValue) {
                    fieldValueDescription = optionValue.title;
                }
            });
            if (isReadOnly) {
                extraInput = React.createElement(_readOnly2.default, { fieldValue: fieldValueDescription });
            }

            return React.createElement(
                'div',
                null,
                extraInput,
                React.createElement(
                    'select',
                    { name: fieldName, value: fieldValue,
                        className: 'form-control', disabled: isReadOnly,
                        onChange: this.linkedChange.bind(this), 'data-placeholder': i18n.select_an_option },
                    options.map(function DropDownForEach(field) {
                        var id = field.id,
                            title = field.title;

                        return React.createElement(
                            'option',
                            { value: id, key: id },
                            title
                        );
                    })
                )
            );
        }
    }]);

    return InputRelationalSearchable;
}(React.Component);

InputRelationalSearchable.propTypes = {
    i18n: _propTypes2.default.shape({ select_an_option: _propTypes2.default.string }),
    onComponentDidMount: _propTypes2.default.func,
    onComponentDidUpdate: _propTypes2.default.func
};

InputRelationalSearchable.defaultProps = {
    i18n: {
        select_an_option: 'Select an option'
    },
    onComponentDidMount: function onComponentDidMount() {},
    onComponentDidUpdate: function onComponentDidUpdate() {}
};

exports.default = InputRelationalSearchable;

},{"./read-only.jsx":24,"prop-types":190}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var RichTexteditorReadOnly = function (_React$Component) {
    _inherits(RichTexteditorReadOnly, _React$Component);

    function RichTexteditorReadOnly(props) {
        _classCallCheck(this, RichTexteditorReadOnly);

        var _this = _possibleConstructorReturn(this, (RichTexteditorReadOnly.__proto__ || Object.getPrototypeOf(RichTexteditorReadOnly)).call(this, props));

        _this.state = {
            previewAsHtml: false
        };
        return _this;
    }

    _createClass(RichTexteditorReadOnly, [{
        key: 'togglePreviewAsHtml',
        value: function togglePreviewAsHtml() {
            var previewAsHtml = this.state.previewAsHtml;

            this.setState({
                previewAsHtml: !previewAsHtml
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                fieldValue = _props.fieldValue,
                i18n = _props.i18n,
                previewAsHtml = this.state.previewAsHtml;


            if (!fieldValue) {
                return React.createElement(_readOnly2.default, null);
            }

            return React.createElement(
                React.Fragment,
                null,
                previewAsHtml ? React.createElement('div', { className: 'gc-html-preview', dangerouslySetInnerHTML: { __html: fieldValue } }) : React.createElement(
                    'pre',
                    { className: 'gc-rich-texteditor-read-only' },
                    fieldValue
                ),
                React.createElement(
                    'button',
                    {
                        onClick: this.togglePreviewAsHtml.bind(this),
                        type: 'button',
                        className: 'btn btn-default btn-outline-dark'
                    },
                    previewAsHtml ? i18n.preview_as_plain_text : i18n.preview_as_html
                )
            );
        }
    }]);

    return RichTexteditorReadOnly;
}(React.Component);

RichTexteditorReadOnly.propTypes = {
    fieldValue: _propTypes2.default.string,
    i18n: _propTypes2.default.shape({
        preview_as_plain_text: _propTypes2.default.string,
        preview_as_html: _propTypes2.default.string
    })
};

RichTexteditorReadOnly.defaultProps = {
    i18n: {
        preview_as_plain_text: 'Preview as plain text',
        preview_as_html: 'Preview as HTML'
    }
};

exports.default = RichTexteditorReadOnly;

},{"./read-only.jsx":24,"prop-types":190}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery;

var RichTexteditorWithPlugin = function (_React$Component) {
    _inherits(RichTexteditorWithPlugin, _React$Component);

    function RichTexteditorWithPlugin(props) {
        _classCallCheck(this, RichTexteditorWithPlugin);

        var _this = _possibleConstructorReturn(this, (RichTexteditorWithPlugin.__proto__ || Object.getPrototypeOf(RichTexteditorWithPlugin)).call(this, props));

        _this.state = {
            fieldValue: props.fieldValue
        };
        return _this;
    }

    _createClass(RichTexteditorWithPlugin, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldName = nextProps.fieldName,
                fieldValue = nextProps.fieldValue;

            jQueryPlugins.updateTexteditor(fieldName, fieldValue);
            this.setState({
                fieldValue: fieldValue
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _props = this.props,
                fieldName = _props.fieldName,
                fieldValue = _props.fieldValue;

            jQueryPlugins.texteditor($(ReactDOM.findDOMNode(this)), fieldName, fieldValue);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var fieldName = this.props.fieldName;

            jQueryPlugins.destroyTexteditor(fieldName);
        }
    }, {
        key: 'render',
        value: function render() {
            var fieldName = this.props.fieldName,
                fieldValue = this.state.fieldValue;


            return React.createElement('textarea', {
                className: 'form-control',
                name: fieldName,
                value: fieldValue,
                onChange: this.linkedChange.bind(this)
            });
        }
    }]);

    return RichTexteditorWithPlugin;
}(React.Component);

RichTexteditorWithPlugin.propTypes = {
    fieldName: _propTypes2.default.string,
    fieldValue: _propTypes2.default.string
};

exports.default = RichTexteditorWithPlugin;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"prop-types":190}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _richTexteditorWithPlugin = require('./rich-texteditor-with-plugin');

var _richTexteditorWithPlugin2 = _interopRequireDefault(_richTexteditorWithPlugin);

var _richTexteditorReadOnly = require('./rich-texteditor-read-only.jsx');

var _richTexteditorReadOnly2 = _interopRequireDefault(_richTexteditorReadOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputRichTexteditor = function (_React$Component) {
    _inherits(InputRichTexteditor, _React$Component);

    function InputRichTexteditor() {
        _classCallCheck(this, InputRichTexteditor);

        return _possibleConstructorReturn(this, (InputRichTexteditor.__proto__ || Object.getPrototypeOf(InputRichTexteditor)).apply(this, arguments));
    }

    _createClass(InputRichTexteditor, [{
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValue = _props$data.fieldValue,
                isReadOnly = _props$data.isReadOnly;


            if (isReadOnly) {
                return React.createElement(_richTexteditorReadOnly2.default, {
                    i18n: i18n.translations,
                    fieldValue: fieldValue
                });
            }

            return React.createElement(_richTexteditorWithPlugin2.default, {
                fieldName: fieldName,
                fieldValue: fieldValue
            });
        }
    }]);

    return InputRichTexteditor;
}(React.Component);

exports.default = InputRichTexteditor;

},{"../../../Resources/public/js/sections/i18n":102,"./rich-texteditor-read-only.jsx":28,"./rich-texteditor-with-plugin":29}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _linkedValue = require('../components/linked-value.js');

var _linkedValue2 = _interopRequireDefault(_linkedValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var jQueryPlugins = require('../../../Resources/public/js/modules/jquery/jquery-plugins').jQueryPlugins,
    $ = jQuery,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n;

var InputSearchableRelationNtoN = function (_LinkedValue) {
    _inherits(InputSearchableRelationNtoN, _LinkedValue);

    function InputSearchableRelationNtoN() {
        _classCallCheck(this, InputSearchableRelationNtoN);

        return _possibleConstructorReturn(this, (InputSearchableRelationNtoN.__proto__ || Object.getPrototypeOf(InputSearchableRelationNtoN)).apply(this, arguments));
    }

    _createClass(InputSearchableRelationNtoN, [{
        key: 'linkedChange',
        value: function linkedChange(event) {
            var selectedValues = [].concat(_toConsumableArray(event.target.options)).filter(function (option) {
                return option.selected;
            }).map(function (option) {
                return option.value;
            });

            this.setState({
                fieldValue: selectedValues
            });
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var isReadOnly = this.props.data.isReadOnly;


            jQueryPlugins.searchableSelect($(ReactDOM.findDOMNode(this)), isReadOnly);
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var isReadOnly = this.props.data.isReadOnly;


            jQueryPlugins.searchableSelectUpdate($(ReactDOM.findDOMNode(this)), isReadOnly);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                fieldValues = _props$data.fieldValues,
                isReadOnly = _props$data.isReadOnly;
            var fieldValue = this.state.fieldValue,
                options = [];


            fieldValues.forEach(function forEachFieldValue(optionValue) {
                options.push(optionValue);
            });

            if (!fieldValue) {
                fieldValue = [];
            }

            return React.createElement(
                'select',
                { name: fieldName, multiple: 'multiple', className: 'form-control',
                    disabled: isReadOnly, value: fieldValue, onChange: this.linkedChange.bind(this),
                    'data-placeholder': i18n.t('select_some_options') },
                options.map(function DropDownForEach(field) {
                    var id = field.id,
                        title = field.title;

                    return React.createElement(
                        'option',
                        { value: id, key: id },
                        title
                    );
                })
            );
        }
    }]);

    return InputSearchableRelationNtoN;
}(_linkedValue2.default);

exports.default = InputSearchableRelationNtoN;

},{"../../../Resources/public/js/modules/jquery/jquery-plugins":93,"../../../Resources/public/js/sections/i18n":102,"../components/linked-value.js":5}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputText = function (_React$Component) {
    _inherits(InputText, _React$Component);

    function InputText(props) {
        _classCallCheck(this, InputText);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputText.__proto__ || Object.getPrototypeOf(InputText)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputText, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'getInputType',
        value: function getInputType(fieldType) {
            if (/^(email|url|color|password)$/.test(fieldType)) {
                return fieldType;
            }

            if (/^(int|numeric)$/.test(fieldType)) {
                return 'number';
            }

            return 'text';
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                isReadOnly = _props$data.isReadOnly,
                fieldType = _props$data.fieldType,
                fieldValue = this.state.fieldValue;


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            return React.createElement('input', {
                className: 'form-control',
                name: fieldName,
                type: this.getInputType(fieldType),
                readOnly: isReadOnly,
                value: fieldValue,
                onChange: this.linkedChange.bind(this) });
        }
    }]);

    return InputText;
}(React.Component);

InputText.propTypes = {
    data: _propTypes2.default.shape({
        fieldName: _propTypes2.default.string,
        isReadOnly: _propTypes2.default.bool,
        fieldType: _propTypes2.default.string
    })
};

exports.default = InputText;

},{"./read-only.jsx":24,"prop-types":190}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputTextarea = function (_React$Component) {
    _inherits(InputTextarea, _React$Component);

    function InputTextarea(props) {
        _classCallCheck(this, InputTextarea);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputTextarea.__proto__ || Object.getPrototypeOf(InputTextarea)).call(this, props));

        _this.state = {
            fieldValue: fieldValue ? fieldValue : ''
        };
        return _this;
    }

    _createClass(InputTextarea, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var fieldValue = nextProps.data.fieldValue;


            this.setState({
                fieldValue: fieldValue ? fieldValue : ''
            });
        }
    }, {
        key: 'linkedChange',
        value: function linkedChange(event) {
            this.setState({
                fieldValue: event.target.value
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _props$data = this.props.data,
                fieldName = _props$data.fieldName,
                isReadOnly = _props$data.isReadOnly,
                fieldValue = this.state.fieldValue;


            if (isReadOnly) {
                return React.createElement(_readOnly2.default, { fieldValue: fieldValue });
            }

            return React.createElement('textarea', {
                className: 'form-control',
                name: fieldName,
                disabled: isReadOnly,
                value: fieldValue,
                onChange: this.linkedChange.bind(this) });
        }
    }]);

    return InputTextarea;
}(React.Component);

exports.default = InputTextarea;

},{"./read-only.jsx":24}],34:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory(require("prop-types"));else if (typeof define === 'function' && define.amd) define(["prop-types"], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["Dropzone"] = factory(require("prop-types"));else root["Dropzone"] = factory(root["prop-types"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_2__) {
  return (/******/function (modules) {
      // webpackBootstrap
      /******/ // The module cache
      /******/var installedModules = {};
      /******/
      /******/ // The require function
      /******/function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/if (installedModules[moduleId]) {
          /******/return installedModules[moduleId].exports;
          /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/var module = installedModules[moduleId] = {
          /******/i: moduleId,
          /******/l: false,
          /******/exports: {}
          /******/ };
        /******/
        /******/ // Execute the module function
        /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/return module.exports;
        /******/
      }
      /******/
      /******/
      /******/ // expose the modules object (__webpack_modules__)
      /******/__webpack_require__.m = modules;
      /******/
      /******/ // expose the module cache
      /******/__webpack_require__.c = installedModules;
      /******/
      /******/ // define getter function for harmony exports
      /******/__webpack_require__.d = function (exports, name, getter) {
        /******/if (!__webpack_require__.o(exports, name)) {
          /******/Object.defineProperty(exports, name, {
            /******/configurable: false,
            /******/enumerable: true,
            /******/get: getter
            /******/ });
          /******/
        }
        /******/
      };
      /******/
      /******/ // getDefaultExport function for compatibility with non-harmony modules
      /******/__webpack_require__.n = function (module) {
        /******/var getter = module && module.__esModule ?
        /******/function getDefault() {
          return module['default'];
        } :
        /******/function getModuleExports() {
          return module;
        };
        /******/__webpack_require__.d(getter, 'a', getter);
        /******/return getter;
        /******/
      };
      /******/
      /******/ // Object.prototype.hasOwnProperty.call
      /******/__webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/
      /******/ // __webpack_public_path__
      /******/__webpack_require__.p = "";
      /******/
      /******/ // Load entry module and return exports
      /******/return __webpack_require__(__webpack_require__.s = 0);
      /******/
    }(
    /************************************************************************/
    /******/[
    /* 0 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";
      /* WEBPACK VAR INJECTION */
      (function (process) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }return target;
        };

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        var _propTypes = __webpack_require__(2);

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _utils = __webpack_require__(3);

        var _styles = __webpack_require__(5);

        var _styles2 = _interopRequireDefault(_styles);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _objectWithoutProperties(obj, keys) {
          var target = {};for (var i in obj) {
            if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
          }return target;
        }

        function _toConsumableArray(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }return arr2;
          } else {
            return Array.from(arr);
          }
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
          }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        } /* eslint prefer-template: 0 */

        //import React from 'react'


        var Dropzone = function (_React$Component) {
          _inherits(Dropzone, _React$Component);

          function Dropzone(props, context) {
            _classCallCheck(this, Dropzone);

            var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this, props, context));

            _this.renderChildren = function (children, isDragActive, isDragAccept, isDragReject) {
              if (typeof children === 'function') {
                return children(_extends({}, _this.state, {
                  isDragActive: isDragActive,
                  isDragAccept: isDragAccept,
                  isDragReject: isDragReject
                }));
              }
              return children;
            };

            _this.composeHandlers = _this.composeHandlers.bind(_this);
            _this.onClick = _this.onClick.bind(_this);
            _this.onDocumentDrop = _this.onDocumentDrop.bind(_this);
            _this.onDragEnter = _this.onDragEnter.bind(_this);
            _this.onDragLeave = _this.onDragLeave.bind(_this);
            _this.onDragOver = _this.onDragOver.bind(_this);
            _this.onDragStart = _this.onDragStart.bind(_this);
            _this.onDrop = _this.onDrop.bind(_this);
            _this.onFileDialogCancel = _this.onFileDialogCancel.bind(_this);
            _this.onInputElementClick = _this.onInputElementClick.bind(_this);

            _this.setRef = _this.setRef.bind(_this);
            _this.setRefs = _this.setRefs.bind(_this);

            _this.isFileDialogActive = false;

            _this.state = {
              draggedFiles: [],
              acceptedFiles: [],
              rejectedFiles: []
            };
            return _this;
          }

          _createClass(Dropzone, [{
            key: 'componentDidMount',
            value: function componentDidMount() {
              var preventDropOnDocument = this.props.preventDropOnDocument;

              this.dragTargets = [];

              if (preventDropOnDocument) {
                document.addEventListener('dragover', _utils.onDocumentDragOver, false);
                document.addEventListener('drop', this.onDocumentDrop, false);
              }
              this.fileInputEl.addEventListener('click', this.onInputElementClick, false);
              // Tried implementing addEventListener, but didn't work out
              document.body.onfocus = this.onFileDialogCancel;
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              var preventDropOnDocument = this.props.preventDropOnDocument;

              if (preventDropOnDocument) {
                document.removeEventListener('dragover', _utils.onDocumentDragOver);
                document.removeEventListener('drop', this.onDocumentDrop);
              }
              this.fileInputEl.removeEventListener('click', this.onInputElementClick, false);
              // Can be replaced with removeEventListener, if addEventListener works
              document.body.onfocus = null;
            }
          }, {
            key: 'composeHandlers',
            value: function composeHandlers(handler) {
              if (this.props.disabled) {
                return null;
              }

              return handler;
            }
          }, {
            key: 'onDocumentDrop',
            value: function onDocumentDrop(evt) {
              if (this.node.contains(evt.target)) {
                // if we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
                return;
              }
              evt.preventDefault();
              this.dragTargets = [];
            }
          }, {
            key: 'onDragStart',
            value: function onDragStart(evt) {
              if (this.props.onDragStart) {
                this.props.onDragStart.call(this, evt);
              }
            }
          }, {
            key: 'onDragEnter',
            value: function onDragEnter(evt) {
              evt.preventDefault();

              // Count the dropzone and any children that are entered.
              if (this.dragTargets.indexOf(evt.target) === -1) {
                this.dragTargets.push(evt.target);
              }

              this.setState({
                isDragActive: true, // Do not rely on files for the drag state. It doesn't work in Safari.
                draggedFiles: (0, _utils.getDataTransferItems)(evt)
              });

              if (this.props.onDragEnter) {
                this.props.onDragEnter.call(this, evt);
              }
            }
          }, {
            key: 'onDragOver',
            value: function onDragOver(evt) {
              // eslint-disable-line class-methods-use-this
              evt.preventDefault();
              evt.stopPropagation();
              try {
                evt.dataTransfer.dropEffect = 'copy'; // eslint-disable-line no-param-reassign
              } catch (err) {
                // continue regardless of error
              }

              if (this.props.onDragOver) {
                this.props.onDragOver.call(this, evt);
              }
              return false;
            }
          }, {
            key: 'onDragLeave',
            value: function onDragLeave(evt) {
              var _this2 = this;

              evt.preventDefault();

              // Only deactivate once the dropzone and all children have been left.
              this.dragTargets = this.dragTargets.filter(function (el) {
                return el !== evt.target && _this2.node.contains(el);
              });
              if (this.dragTargets.length > 0) {
                return;
              }

              // Clear dragging files state
              this.setState({
                isDragActive: false,
                draggedFiles: []
              });

              if (this.props.onDragLeave) {
                this.props.onDragLeave.call(this, evt);
              }
            }
          }, {
            key: 'onDrop',
            value: function onDrop(evt) {
              var _this3 = this;

              var _props = this.props,
                  onDrop = _props.onDrop,
                  onDropAccepted = _props.onDropAccepted,
                  onDropRejected = _props.onDropRejected,
                  multiple = _props.multiple,
                  disablePreview = _props.disablePreview,
                  accept = _props.accept;

              var fileList = (0, _utils.getDataTransferItems)(evt);
              var acceptedFiles = [];
              var rejectedFiles = [];

              // Stop default browser behavior
              evt.preventDefault();

              // Reset the counter along with the drag on a drop.
              this.dragTargets = [];
              this.isFileDialogActive = false;

              fileList.forEach(function (file) {
                if (!disablePreview) {
                  try {
                    file.preview = window.URL.createObjectURL(file); // eslint-disable-line no-param-reassign
                  } catch (err) {
                    if (process.env.NODE_ENV !== 'production') {
                      console.error('Failed to generate preview for file', file, err); // eslint-disable-line no-console
                    }
                  }
                }

                if ((0, _utils.fileAccepted)(file, accept) && (0, _utils.fileMatchSize)(file, _this3.props.maxSize, _this3.props.minSize)) {
                  acceptedFiles.push(file);
                } else {
                  rejectedFiles.push(file);
                }
              });

              if (!multiple) {
                // if not in multi mode add any extra accepted files to rejected.
                // This will allow end users to easily ignore a multi file drop in "single" mode.
                rejectedFiles.push.apply(rejectedFiles, _toConsumableArray(acceptedFiles.splice(1)));
              }

              if (onDrop) {
                onDrop.call(this, acceptedFiles, rejectedFiles, evt);
              }

              if (rejectedFiles.length > 0 && onDropRejected) {
                onDropRejected.call(this, rejectedFiles, evt);
              }

              if (acceptedFiles.length > 0 && onDropAccepted) {
                onDropAccepted.call(this, acceptedFiles, evt);
              }

              // Clear files value
              this.draggedFiles = null;

              // Reset drag state
              this.setState({
                isDragActive: false,
                draggedFiles: [],
                acceptedFiles: acceptedFiles,
                rejectedFiles: rejectedFiles
              });
            }
          }, {
            key: 'onClick',
            value: function onClick(evt) {
              var _props2 = this.props,
                  onClick = _props2.onClick,
                  disableClick = _props2.disableClick;

              if (!disableClick) {
                evt.stopPropagation();

                if (onClick) {
                  onClick.call(this, evt);
                }

                // in IE11/Edge the file-browser dialog is blocking, ensure this is behind setTimeout
                // this is so react can handle state changes in the onClick prop above above
                // see: https://github.com/react-dropzone/react-dropzone/issues/450
                setTimeout(this.open.bind(this), 0);
              }
            }
          }, {
            key: 'onInputElementClick',
            value: function onInputElementClick(evt) {
              evt.stopPropagation();
              if (this.props.inputProps && this.props.inputProps.onClick) {
                this.props.inputProps.onClick();
              }
            }
          }, {
            key: 'onFileDialogCancel',
            value: function onFileDialogCancel() {
              // timeout will not recognize context of this method
              var onFileDialogCancel = this.props.onFileDialogCancel;
              var fileInputEl = this.fileInputEl;
              var isFileDialogActive = this.isFileDialogActive;
              // execute the timeout only if the onFileDialogCancel is defined and FileDialog
              // is opened in the browser

              if (onFileDialogCancel && isFileDialogActive) {
                setTimeout(function () {
                  // Returns an object as FileList
                  var FileList = fileInputEl.files;
                  if (!FileList.length) {
                    isFileDialogActive = false;
                    onFileDialogCancel();
                  }
                }, 300);
              }
            }
          }, {
            key: 'setRef',
            value: function setRef(ref) {
              this.node = ref;
            }
          }, {
            key: 'setRefs',
            value: function setRefs(ref) {
              this.fileInputEl = ref;
            }
            /**
             * Open system file upload dialog.
             *
             * @public
             */

          }, {
            key: 'open',
            value: function open() {
              this.isFileDialogActive = true;
              this.fileInputEl.value = null;
              this.fileInputEl.click();
            }
          }, {
            key: 'render',
            value: function render() {
              var _props3 = this.props,
                  accept = _props3.accept,
                  acceptClassName = _props3.acceptClassName,
                  activeClassName = _props3.activeClassName,
                  children = _props3.children,
                  disabled = _props3.disabled,
                  disabledClassName = _props3.disabledClassName,
                  inputProps = _props3.inputProps,
                  multiple = _props3.multiple,
                  name = _props3.name,
                  rejectClassName = _props3.rejectClassName,
                  rest = _objectWithoutProperties(_props3, ['accept', 'acceptClassName', 'activeClassName', 'children', 'disabled', 'disabledClassName', 'inputProps', 'multiple', 'name', 'rejectClassName']);

              var acceptStyle = rest.acceptStyle,
                  activeStyle = rest.activeStyle,
                  className = rest.className,
                  disabledStyle = rest.disabledStyle,
                  rejectStyle = rest.rejectStyle,
                  style = rest.style,
                  props = _objectWithoutProperties(rest, ['acceptStyle', 'activeStyle', 'className', 'disabledStyle', 'rejectStyle', 'style']);

              var _state = this.state,
                  isDragActive = _state.isDragActive,
                  draggedFiles = _state.draggedFiles;

              var filesCount = draggedFiles.length;
              var isMultipleAllowed = multiple || filesCount <= 1;
              var isDragAccept = filesCount > 0 && (0, _utils.allFilesAccepted)(draggedFiles, this.props.accept);
              var isDragReject = filesCount > 0 && (!isDragAccept || !isMultipleAllowed);
              className = className || '';
              var noStyles = !className && !style && !activeStyle && !acceptStyle && !rejectStyle && !disabledStyle;

              if (isDragActive && activeClassName) {
                className += ' ' + activeClassName;
              }
              if (isDragAccept && acceptClassName) {
                className += ' ' + acceptClassName;
              }
              if (isDragReject && rejectClassName) {
                className += ' ' + rejectClassName;
              }
              if (disabled && disabledClassName) {
                className += ' ' + disabledClassName;
              }

              if (noStyles) {
                style = _styles2.default.default;
                activeStyle = _styles2.default.active;
                acceptStyle = style.active;
                rejectStyle = _styles2.default.rejected;
                disabledStyle = _styles2.default.disabled;
              }

              var appliedStyle = _extends({}, style);
              if (activeStyle && isDragActive) {
                appliedStyle = _extends({}, style, activeStyle);
              }
              if (acceptStyle && isDragAccept) {
                appliedStyle = _extends({}, appliedStyle, acceptStyle);
              }
              if (rejectStyle && isDragReject) {
                appliedStyle = _extends({}, appliedStyle, rejectStyle);
              }
              if (disabledStyle && disabled) {
                appliedStyle = _extends({}, style, disabledStyle);
              }

              var inputAttributes = {
                accept: accept,
                disabled: disabled,
                type: 'file',
                style: { display: 'none' },
                multiple: _utils.supportMultiple && multiple,
                ref: this.setRefs,
                onChange: this.onDrop,
                autoComplete: 'off'
              };

              if (name && name.length) {
                inputAttributes.name = name;
              }

              // Remove custom properties before passing them to the wrapper div element
              var customProps = ['acceptedFiles', 'preventDropOnDocument', 'disablePreview', 'disableClick', 'activeClassName', 'acceptClassName', 'rejectClassName', 'disabledClassName', 'onDropAccepted', 'onDropRejected', 'onFileDialogCancel', 'maxSize', 'minSize'];
              var divProps = _extends({}, props);
              customProps.forEach(function (prop) {
                return delete divProps[prop];
              });

              return React.createElement('div', _extends({
                className: className,
                style: appliedStyle
              }, divProps /* expand user provided props first so event handlers are never overridden */, {
                onClick: this.composeHandlers(this.onClick),
                onDragStart: this.composeHandlers(this.onDragStart),
                onDragEnter: this.composeHandlers(this.onDragEnter),
                onDragOver: this.composeHandlers(this.onDragOver),
                onDragLeave: this.composeHandlers(this.onDragLeave),
                onDrop: this.composeHandlers(this.onDrop),
                ref: this.setRef,
                'aria-disabled': disabled
              }), this.renderChildren(children, isDragActive, isDragAccept, isDragReject), React.createElement('input', _extends({}, inputProps /* expand user provided inputProps first so inputAttributes override them */, inputAttributes)));
            }
          }]);

          return Dropzone;
        }(React.Component);

        exports.default = Dropzone;

        Dropzone.propTypes = {
          /**
           * Allow specific types of files. See https://github.com/okonet/attr-accept for more information.
           * Keep in mind that mime type determination is not reliable across platforms. CSV files,
           * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
           * Windows. In some cases there might not be a mime type set at all.
           * See: https://github.com/react-dropzone/react-dropzone/issues/276
           */
          accept: _propTypes2.default.string,

          /**
           * Contents of the dropzone
           */
          children: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),

          /**
           * Disallow clicking on the dropzone container to open file dialog
           */
          disableClick: _propTypes2.default.bool,

          /**
          * Enable/disable the dropzone entirely
          */
          disabled: _propTypes2.default.bool,

          /**
           * Enable/disable preview generation
           */
          disablePreview: _propTypes2.default.bool,

          /**
           * If false, allow dropped items to take over the current browser window
           */
          preventDropOnDocument: _propTypes2.default.bool,

          /**
           * Pass additional attributes to the `<input type="file"/>` tag
           */
          inputProps: _propTypes2.default.object,

          /**
           * Allow dropping multiple files
           */
          multiple: _propTypes2.default.bool,

          /**
           * `name` attribute for the input tag
           */
          name: _propTypes2.default.string,

          /**
           * Maximum file size
           */
          maxSize: _propTypes2.default.number,

          /**
           * Minimum file size
           */
          minSize: _propTypes2.default.number,

          /**
           * className
           */
          className: _propTypes2.default.string,

          /**
           * className for active state
           */
          activeClassName: _propTypes2.default.string,

          /**
           * className for accepted state
           */
          acceptClassName: _propTypes2.default.string,

          /**
           * className for rejected state
           */
          rejectClassName: _propTypes2.default.string,

          /**
           * className for disabled state
           */
          disabledClassName: _propTypes2.default.string,

          /**
           * CSS styles to apply
           */
          style: _propTypes2.default.object,

          /**
           * CSS styles to apply when drag is active
           */
          activeStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when drop will be accepted
           */
          acceptStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when drop will be rejected
           */
          rejectStyle: _propTypes2.default.object,

          /**
           * CSS styles to apply when dropzone is disabled
           */
          disabledStyle: _propTypes2.default.object,

          /**
           * onClick callback
           * @param {Event} event
           */
          onClick: _propTypes2.default.func,

          /**
           * onDrop callback
           */
          onDrop: _propTypes2.default.func,

          /**
           * onDropAccepted callback
           */
          onDropAccepted: _propTypes2.default.func,

          /**
           * onDropRejected callback
           */
          onDropRejected: _propTypes2.default.func,

          /**
           * onDragStart callback
           */
          onDragStart: _propTypes2.default.func,

          /**
           * onDragEnter callback
           */
          onDragEnter: _propTypes2.default.func,

          /**
           * onDragOver callback
           */
          onDragOver: _propTypes2.default.func,

          /**
           * onDragLeave callback
           */
          onDragLeave: _propTypes2.default.func,

          /**
           * Provide a callback on clicking the cancel button of the file dialog
           */
          onFileDialogCancel: _propTypes2.default.func
        };

        Dropzone.defaultProps = {
          preventDropOnDocument: true,
          disabled: false,
          disablePreview: false,
          disableClick: false,
          multiple: true,
          maxSize: Infinity,
          minSize: 0
        };
        module.exports = exports['default'];
        /* WEBPACK VAR INJECTION */
      }).call(exports, __webpack_require__(1));

      /***/
    },
    /* 1 */
    /***/function (module, exports) {

      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }

      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }

      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};

      function noop() {}

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) {
        return [];
      };

      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };

      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };

      /***/
    },
    /* 2 */
    /***/function (module, exports) {

      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

      /***/
    },
    /* 3 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.supportMultiple = undefined;
      exports.getDataTransferItems = getDataTransferItems;
      exports.fileAccepted = fileAccepted;
      exports.fileMatchSize = fileMatchSize;
      exports.allFilesAccepted = allFilesAccepted;
      exports.onDocumentDragOver = onDocumentDragOver;

      var _attrAccept = __webpack_require__(4);

      var _attrAccept2 = _interopRequireDefault(_attrAccept);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }

      var supportMultiple = exports.supportMultiple = typeof document !== 'undefined' && document && document.createElement ? 'multiple' in document.createElement('input') : true;

      function getDataTransferItems(event) {
        var dataTransferItemsList = [];
        if (event.dataTransfer) {
          var dt = event.dataTransfer;
          if (dt.files && dt.files.length) {
            dataTransferItemsList = dt.files;
          } else if (dt.items && dt.items.length) {
            // During the drag even the dataTransfer.files is null
            // but Chrome implements some drag store, which is accesible via dataTransfer.items
            dataTransferItemsList = dt.items;
          }
        } else if (event.target && event.target.files) {
          dataTransferItemsList = event.target.files;
        }
        // Convert from DataTransferItemsList to the native Array
        return Array.prototype.slice.call(dataTransferItemsList);
      }

      // Firefox versions prior to 53 return a bogus MIME type for every file drag, so dragovers with
      // that MIME type will always be accepted
      function fileAccepted(file, accept) {
        return file.type === 'application/x-moz-file' || (0, _attrAccept2.default)(file, accept);
      }

      function fileMatchSize(file, maxSize, minSize) {
        return file.size <= maxSize && file.size >= minSize;
      }

      function allFilesAccepted(files, accept) {
        return files.every(function (file) {
          return fileAccepted(file, accept);
        });
      }

      // allow the entire document to be a drag target
      function onDocumentDragOver(evt) {
        evt.preventDefault();
      }

      /***/
    },
    /* 4 */
    /***/function (module, exports) {

      module.exports = function (t) {
        function n(e) {
          if (r[e]) return r[e].exports;var o = r[e] = { exports: {}, id: e, loaded: !1 };return t[e].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports;
        }var r = {};return n.m = t, n.c = r, n.p = "", n(0);
      }([function (t, n, r) {
        "use strict";
        n.__esModule = !0, r(8), r(9), n["default"] = function (t, n) {
          if (t && n) {
            var r = function () {
              var r = Array.isArray(n) ? n : n.split(","),
                  e = t.name || "",
                  o = t.type || "",
                  i = o.replace(/\/.*$/, "");return { v: r.some(function (t) {
                  var n = t.trim();return "." === n.charAt(0) ? e.toLowerCase().endsWith(n.toLowerCase()) : /\/\*$/.test(n) ? i === n.replace(/\/.*$/, "") : o === n;
                }) };
            }();if ("object" == (typeof r === 'undefined' ? 'undefined' : _typeof(r))) return r.v;
          }return !0;
        }, t.exports = n["default"];
      }, function (t, n) {
        var r = t.exports = { version: "1.2.2" };"number" == typeof __e && (__e = r);
      }, function (t, n) {
        var r = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();"number" == typeof __g && (__g = r);
      }, function (t, n, r) {
        var e = r(2),
            o = r(1),
            i = r(4),
            u = r(19),
            c = "prototype",
            f = function f(t, n) {
          return function () {
            return t.apply(n, arguments);
          };
        },
            s = function s(t, n, r) {
          var a,
              p,
              l,
              y,
              d = t & s.G,
              h = t & s.P,
              v = d ? e : t & s.S ? e[n] || (e[n] = {}) : (e[n] || {})[c],
              x = d ? o : o[n] || (o[n] = {});d && (r = n);for (a in r) {
            p = !(t & s.F) && v && a in v, l = (p ? v : r)[a], y = t & s.B && p ? f(l, e) : h && "function" == typeof l ? f(Function.call, l) : l, v && !p && u(v, a, l), x[a] != l && i(x, a, y), h && ((x[c] || (x[c] = {}))[a] = l);
          }
        };e.core = o, s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, t.exports = s;
      }, function (t, n, r) {
        var e = r(5),
            o = r(18);t.exports = r(22) ? function (t, n, r) {
          return e.setDesc(t, n, o(1, r));
        } : function (t, n, r) {
          return t[n] = r, t;
        };
      }, function (t, n) {
        var r = Object;t.exports = { create: r.create, getProto: r.getPrototypeOf, isEnum: {}.propertyIsEnumerable, getDesc: r.getOwnPropertyDescriptor, setDesc: r.defineProperty, setDescs: r.defineProperties, getKeys: r.keys, getNames: r.getOwnPropertyNames, getSymbols: r.getOwnPropertySymbols, each: [].forEach };
      }, function (t, n) {
        var r = 0,
            e = Math.random();t.exports = function (t) {
          return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++r + e).toString(36));
        };
      }, function (t, n, r) {
        var e = r(20)("wks"),
            o = r(2).Symbol;t.exports = function (t) {
          return e[t] || (e[t] = o && o[t] || (o || r(6))("Symbol." + t));
        };
      }, function (t, n, r) {
        r(26), t.exports = r(1).Array.some;
      }, function (t, n, r) {
        r(25), t.exports = r(1).String.endsWith;
      }, function (t, n) {
        t.exports = function (t) {
          if ("function" != typeof t) throw TypeError(t + " is not a function!");return t;
        };
      }, function (t, n) {
        var r = {}.toString;t.exports = function (t) {
          return r.call(t).slice(8, -1);
        };
      }, function (t, n, r) {
        var e = r(10);t.exports = function (t, n, r) {
          if (e(t), void 0 === n) return t;switch (r) {case 1:
              return function (r) {
                return t.call(n, r);
              };case 2:
              return function (r, e) {
                return t.call(n, r, e);
              };case 3:
              return function (r, e, o) {
                return t.call(n, r, e, o);
              };}return function () {
            return t.apply(n, arguments);
          };
        };
      }, function (t, n) {
        t.exports = function (t) {
          if (void 0 == t) throw TypeError("Can't call method on  " + t);return t;
        };
      }, function (t, n, r) {
        t.exports = function (t) {
          var n = /./;try {
            "/./"[t](n);
          } catch (e) {
            try {
              return n[r(7)("match")] = !1, !"/./"[t](n);
            } catch (o) {}
          }return !0;
        };
      }, function (t, n) {
        t.exports = function (t) {
          try {
            return !!t();
          } catch (n) {
            return !0;
          }
        };
      }, function (t, n) {
        t.exports = function (t) {
          return "object" == (typeof t === 'undefined' ? 'undefined' : _typeof(t)) ? null !== t : "function" == typeof t;
        };
      }, function (t, n, r) {
        var e = r(16),
            o = r(11),
            i = r(7)("match");t.exports = function (t) {
          var n;return e(t) && (void 0 !== (n = t[i]) ? !!n : "RegExp" == o(t));
        };
      }, function (t, n) {
        t.exports = function (t, n) {
          return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: n };
        };
      }, function (t, n, r) {
        var e = r(2),
            o = r(4),
            i = r(6)("src"),
            u = "toString",
            c = Function[u],
            f = ("" + c).split(u);r(1).inspectSource = function (t) {
          return c.call(t);
        }, (t.exports = function (t, n, r, u) {
          "function" == typeof r && (o(r, i, t[n] ? "" + t[n] : f.join(String(n))), "name" in r || (r.name = n)), t === e ? t[n] = r : (u || delete t[n], o(t, n, r));
        })(Function.prototype, u, function () {
          return "function" == typeof this && this[i] || c.call(this);
        });
      }, function (t, n, r) {
        var e = r(2),
            o = "__core-js_shared__",
            i = e[o] || (e[o] = {});t.exports = function (t) {
          return i[t] || (i[t] = {});
        };
      }, function (t, n, r) {
        var e = r(17),
            o = r(13);t.exports = function (t, n, r) {
          if (e(n)) throw TypeError("String#" + r + " doesn't accept regex!");return String(o(t));
        };
      }, function (t, n, r) {
        t.exports = !r(15)(function () {
          return 7 != Object.defineProperty({}, "a", { get: function get() {
              return 7;
            } }).a;
        });
      }, function (t, n) {
        var r = Math.ceil,
            e = Math.floor;t.exports = function (t) {
          return isNaN(t = +t) ? 0 : (t > 0 ? e : r)(t);
        };
      }, function (t, n, r) {
        var e = r(23),
            o = Math.min;t.exports = function (t) {
          return t > 0 ? o(e(t), 9007199254740991) : 0;
        };
      }, function (t, n, r) {
        "use strict";
        var e = r(3),
            o = r(24),
            i = r(21),
            u = "endsWith",
            c = ""[u];e(e.P + e.F * r(14)(u), "String", { endsWith: function endsWith(t) {
            var n = i(this, t, u),
                r = arguments,
                e = r.length > 1 ? r[1] : void 0,
                f = o(n.length),
                s = void 0 === e ? f : Math.min(o(e), f),
                a = String(t);return c ? c.call(n, a, s) : n.slice(s - a.length, s) === a;
          } });
      }, function (t, n, r) {
        var e = r(5),
            o = r(3),
            i = r(1).Array || Array,
            u = {},
            c = function c(t, n) {
          e.each.call(t.split(","), function (t) {
            void 0 == n && t in i ? u[t] = i[t] : t in [] && (u[t] = r(12)(Function.call, [][t], n));
          });
        };c("pop,reverse,shift,keys,values,entries", 1), c("indexOf,every,some,forEach,map,filter,find,findIndex,includes", 3), c("join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill"), o(o.S, "Array", u);
      }]);

      /***/
    },
    /* 5 */
    /***/function (module, exports, __webpack_require__) {

      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = {
        rejected: {
          borderStyle: 'solid',
          borderColor: '#c66',
          backgroundColor: '#eee'
        },
        disabled: {
          opacity: 0.5
        },
        active: {
          borderStyle: 'solid',
          borderColor: '#6c6',
          backgroundColor: '#eee'
        },
        default: {
          width: 200,
          height: 200,
          borderWidth: 2,
          borderColor: '#666',
          borderStyle: 'dashed',
          borderRadius: 5
        }
      };
      module.exports = exports['default'];

      /***/
    }]
    /******/)
  );
});


},{"prop-types":190}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDropzone = require('./third-party/react-dropzone');

var _reactDropzone2 = _interopRequireDefault(_reactDropzone);

var _readOnly = require('./read-only.jsx');

var _readOnly2 = _interopRequireDefault(_readOnly);

var _uploadShowFile = require('./upload/upload-show-file.jsx');

var _uploadShowFile2 = _interopRequireDefault(_uploadShowFile);

var _superagent = require('superagent');

var _superagent2 = _interopRequireDefault(_superagent);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ajaxHelper = require('../../../Resources/public/js/helpers/ajax-helper').ajaxHelper,
    i18n = require('../../../Resources/public/js/sections/i18n').i18n,
    $ = jQuery;

var InputUpload = function (_React$Component) {
    _inherits(InputUpload, _React$Component);

    function InputUpload(props) {
        _classCallCheck(this, InputUpload);

        var fieldValue = props.data.fieldValue;

        var _this = _possibleConstructorReturn(this, (InputUpload.__proto__ || Object.getPrototypeOf(InputUpload)).call(this, props));

        _this.state = {
            files: fieldValue ? fieldValue.split(',') : [],
            loading: false
        };
        return _this;
    }

    _createClass(InputUpload, [{
        key: 'onDrop',
        value: function onDrop(acceptedFiles) {
            var _this2 = this;

            var uploadUrl = ajaxHelper.getUrl.apply(this.props.gcrudInstance, ['upload']),
                uploadRequest = _superagent2.default.post(uploadUrl),
                requestExtraHeaders = void 0,
                files = this.state.files;
            var maxUploadLimit = this.props.maxUploadLimit;


            this.setState({
                loading: true
            });

            requestExtraHeaders = $.ajaxSetup().headers;

            if (requestExtraHeaders !== undefined) {
                Object.keys(requestExtraHeaders).forEach(function foreachRequestHeaders(headerName) {
                    var headerValue = requestExtraHeaders[headerName];
                    uploadRequest.set(headerName, headerValue);
                });
            }

            if (maxUploadLimit > 1) {
                acceptedFiles.forEach(function (acceptedFile, numKey) {
                    uploadRequest.attach(_this2.props.data.fieldName + '[' + numKey + ']', acceptedFile);
                });
            } else {
                acceptedFiles.forEach(function (acceptedFile) {
                    uploadRequest.attach(_this2.props.data.fieldName, acceptedFile);
                });
            }

            uploadRequest.end(function uploadResponse(err, output) {
                var gcrudInstance = this.props.gcrudInstance,
                    jsonResponse = output.body;

                this.setState({
                    loading: false
                });
                if (err || jsonResponse === null) {
                    ajaxHelper.ajaxOnFail.apply(gcrudInstance, [output.text, err ? err.status : 'Not well JSON formatted response', 'error']);
                } else {

                    // Handled error
                    if (jsonResponse.status === 'failure') {
                        ajaxHelper.ajaxOnFail.apply(gcrudInstance, [jsonResponse.message, jsonResponse.status, 'error']);
                    }

                    if (jsonResponse.csrfToken) {
                        gcrudInstance.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    files.push(jsonResponse.uploadResult.filename);

                    this.setState({
                        files: files
                    });
                }
            }.bind(this));
        }
    }, {
        key: 'deleteOnClick',
        value: function deleteOnClick(filename) {
            var gcrudInstance = this.props.gcrudInstance;
            var deleteFileUrl = ajaxHelper.getUrl.apply(gcrudInstance, []),
                deleteFileRequest = _superagent2.default.post(deleteFileUrl),
                fieldName = this.props.data.fieldName,
                files = this.state.files,
                requestExtraHeaders = void 0,
                dataToSend = {
                action: 'delete-file',
                fieldName: fieldName,
                filename: filename
            };


            if (gcrudInstance.cachedInitialData.csrfToken) {
                dataToSend[gcrudInstance.cachedInitialData.csrfToken.inputName] = gcrudInstance.cachedInitialData.csrfToken.inputValue;
            }

            requestExtraHeaders = $.ajaxSetup().headers;

            if (requestExtraHeaders !== undefined) {
                Object.keys(requestExtraHeaders).forEach(function foreachRequestHeaders(headerName) {
                    var headerValue = requestExtraHeaders[headerName];
                    deleteFileRequest.set(headerName, headerValue);
                });
            }

            deleteFileRequest.type('form');
            deleteFileRequest.send(dataToSend);
            this.setState({
                loading: true
            });
            deleteFileRequest.end(function deleteFileRequestEnd(err, output) {
                var jsonResponse = output.body;

                if (err || jsonResponse === null) {
                    ajaxHelper.ajaxOnFail.apply(gcrudInstance, [output.text, err ? err.status : 'Not well JSON formatted response', 'error']);
                } else {
                    // Handled error
                    if (jsonResponse.status === 'failure') {
                        ajaxHelper.ajaxOnFail.apply(gcrudInstance, [jsonResponse.message, jsonResponse.status, 'error']);
                    }

                    if (jsonResponse.csrfToken) {
                        gcrudInstance.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    this.setState({
                        loading: false,
                        files: files.filter(function (file) {
                            return file !== filename;
                        })
                    });
                }
            }.bind(this));
        }
    }, {
        key: 'getTranslationFileAttach',
        value: function getTranslationFileAttach() {
            var splittedString = i18n.t('upload_attach_file').split('{browse_file}');

            if (splittedString.length <= 1) {
                return splittedString[0];
            }

            return React.createElement(
                'span',
                null,
                splittedString[0],
                ' ',
                React.createElement(
                    'a',
                    null,
                    i18n.t('browse_file')
                ),
                ' ',
                splittedString[1]
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var _state = this.state,
                loading = _state.loading,
                files = _state.files,
                _props = this.props,
                maxUploadLimit = _props.maxUploadLimit,
                _props$data = _props.data,
                fieldName = _props$data.fieldName,
                isReadOnly = _props$data.isReadOnly,
                options = _props$data.options,
                JSXarray = [];


            if (loading) {
                return React.createElement(
                    'div',
                    null,
                    React.createElement('i', { className: 'fa fa-refresh fa-spin' }),
                    ' Loading...'
                );
            }

            if (isReadOnly && files.length === 0) {
                return React.createElement(_readOnly2.default, { fieldValue: '' });
            }

            if (files.length < maxUploadLimit) {
                JSXarray.push(React.createElement(
                    'div',
                    { key: 'dropzone', style: { marginBottom: '5px' } },
                    React.createElement(
                        _reactDropzone2.default,
                        { style: { display: 'block' }, onDrop: this.onDrop.bind(this), multiple: maxUploadLimit > 1 },
                        React.createElement(
                            'div',
                            { className: 'gc-dropzone' },
                            React.createElement('i', { className: 'fa fa-cloud-upload' }),
                            '\xA0 ',
                            this.getTranslationFileAttach()
                        )
                    )
                ));
            }

            files.forEach(function (filename) {
                JSXarray.push(React.createElement(_uploadShowFile2.default, {
                    filePath: options.publicPath + '/' + filename,
                    filename: filename,
                    key: filename,
                    isReadOnly: isReadOnly,
                    onDelete: _this3.deleteOnClick.bind(_this3),
                    i18n: {
                        action_delete: i18n.t('action_delete')
                    }
                }));
            });

            JSXarray.push(React.createElement('input', { key: fieldName, name: fieldName, value: files.join(','), type: 'hidden' }));

            return JSXarray;
        }
    }]);

    return InputUpload;
}(React.Component);

InputUpload.propTypes = {
    maxUploadLimit: _propTypes2.default.number
};

exports.default = InputUpload;

},{"../../../Resources/public/js/helpers/ajax-helper":84,"../../../Resources/public/js/sections/i18n":102,"./read-only.jsx":24,"./third-party/react-dropzone":34,"./upload/upload-show-file.jsx":36,"prop-types":190,"superagent":219}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var UploadShowFile = function (_React$Component) {
    _inherits(UploadShowFile, _React$Component);

    function UploadShowFile() {
        _classCallCheck(this, UploadShowFile);

        return _possibleConstructorReturn(this, (UploadShowFile.__proto__ || Object.getPrototypeOf(UploadShowFile)).apply(this, arguments));
    }

    _createClass(UploadShowFile, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                filename = _props.filename,
                filePath = _props.filePath,
                isReadOnly = _props.isReadOnly,
                onDelete = _props.onDelete,
                i18n = _props.i18n;


            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "a",
                    { href: filePath, target: "_blank" },
                    /\.(jp(e)?g|gif|png|tiff)$/.test(filePath) ? React.createElement("img", { src: filePath, height: "50" }) : React.createElement(
                        "span",
                        null,
                        filename
                    )
                ),
                " \xA0",
                isReadOnly ? '' : React.createElement(
                    "button",
                    { onClick: function onClick() {
                            return onDelete(filename);
                        }, className: "btn btn-default" },
                    React.createElement("i", { className: "fa fa-trash-o" }),
                    "\xA0",
                    i18n.action_delete
                ),
                " \xA0"
            );
        }
    }]);

    return UploadShowFile;
}(React.Component);

UploadShowFile.propTypes = {
    filename: _propTypes2.default.string,
    filePath: _propTypes2.default.string,
    isReadOnly: _propTypes2.default.bool,
    fieldName: _propTypes2.default.string,
    onDelete: _propTypes2.default.func,
    i18n: _propTypes2.default.shape({
        action_delete: _propTypes2.default.string
    })
};

UploadShowFile.defaultProps = {
    i18n: {
        action_delete: 'Delete'
    }
};

exports.default = UploadShowFile;

},{"prop-types":190}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.jsx');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputUrl = function (_InputText) {
    _inherits(InputUrl, _InputText);

    function InputUrl() {
        _classCallCheck(this, InputUrl);

        return _possibleConstructorReturn(this, (InputUrl.__proto__ || Object.getPrototypeOf(InputUrl)).apply(this, arguments));
    }

    _createClass(InputUrl, [{
        key: 'render',
        value: function render() {
            var data = this.props.data,
                fieldName = this.props.data.fieldName;


            return React.createElement(_text2.default, { key: fieldName, data: data });
        }
    }]);

    return InputUrl;
}(_text2.default);

exports.default = InputUrl;

},{"./text.jsx":32}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitle = function (_React$Component) {
    _inherits(ModalTitle, _React$Component);

    function ModalTitle() {
        _classCallCheck(this, ModalTitle);

        return _possibleConstructorReturn(this, (ModalTitle.__proto__ || Object.getPrototypeOf(ModalTitle)).apply(this, arguments));
    }

    _createClass(ModalTitle, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                title = _props.title,
                ModalTitleWrapper = _props.ModalTitleWrapper;


            return React.createElement(ModalTitleWrapper, { title: title });
        }
    }]);

    return ModalTitle;
}(React.Component);

ModalTitle.propTypes = {
    title: _propTypes2.default.string,
    ModalTitleWrapper: _propTypes2.default.func
};

ModalTitle.defaultProps = {
    ModalTitleWrapper: function ModalTitleWrapper(props) {
        return React.createElement(
            React.Fragment,
            null,
            React.createElement(
                "button",
                {
                    type: "button",
                    className: "close",
                    "data-dismiss": "modal",
                    "aria-label": "Close"
                },
                React.createElement(
                    "span",
                    { "aria-hidden": "true" },
                    "\xD7"
                )
            ),
            React.createElement(
                "h4",
                { className: "modal-title" },
                props.title
            )
        );
    }
};

exports.default = ModalTitle;

},{"prop-types":190}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _visibleColumns = require('./visible-columns.jsx');

var _visibleColumns2 = _interopRequireDefault(_visibleColumns);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Settings = function (_React$Component) {
    _inherits(Settings, _React$Component);

    function Settings() {
        _classCallCheck(this, Settings);

        var _this = _possibleConstructorReturn(this, (Settings.__proto__ || Object.getPrototypeOf(Settings)).call(this));

        _this.setContainer = _this.setContainer.bind(_this);
        _this.state = {
            settingsOpen: false
        };
        return _this;
    }

    _createClass(Settings, [{
        key: 'toggleSettings',
        value: function toggleSettings() {
            this.setState({
                settingsOpen: !this.state.settingsOpen
            });
        }
    }, {
        key: 'setContainer',
        value: function setContainer(ref) {
            this.container = ref;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            document.addEventListener('click', function (e) {
                return _this2.clickOutside(e);
            }, true);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _this3 = this;

            document.removeEventListener('click', function (e) {
                return _this3.clickOutside(e);
            }, true);
        }
    }, {
        key: 'clickOutside',
        value: function clickOutside(event) {
            var settingsOpen = this.state.settingsOpen;


            if (settingsOpen && this.container && !this.container.contains(event.target)) {
                this.setState({
                    settingsOpen: false
                });
            }
        }
    }, {
        key: 'onRefreshCallback',
        value: function onRefreshCallback() {
            var onRefreshCallback = this.props.onRefreshCallback;


            if (onRefreshCallback) {
                onRefreshCallback();
            }
        }
    }, {
        key: 'onClearFilteringCallback',
        value: function onClearFilteringCallback() {
            var onClearFilteringCallback = this.props.onClearFilteringCallback;


            if (onClearFilteringCallback) {
                onClearFilteringCallback();
            }
        }
    }, {
        key: 'onClearCacheCallback',
        value: function onClearCacheCallback() {
            var onClearCacheCallback = this.props.onClearCacheCallback;


            if (onClearCacheCallback) {
                onClearCacheCallback();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var settingsOpen = this.state.settingsOpen,
                _props = this.props,
                i18n = _props.i18n,
                visibleColumnsCallbackOnChange = _props.visibleColumnsCallbackOnChange,
                columns = _props.columns,
                visibleColumns = _props.visibleColumns,
                gcrudInstance = _props.gcrudInstance,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                subMenuLeftDirection = _props.subMenuLeftDirection,
                buttons = [{
                hasSubMenu: true,
                subMenuLeftDirection: subMenuLeftDirection,
                icon: 'fa fa-list-alt',
                text: i18n.columns,
                key: 'columns',
                onClick: function onClick(e) {
                    return e.preventDefault();
                },
                subComponent: React.createElement(_visibleColumns2.default, {
                    callbackOnChange: visibleColumnsCallbackOnChange,
                    columns: columns,
                    gcrudInstance: gcrudInstance,
                    visibleColumns: visibleColumns
                })
            }, {
                icon: 'fa fa-refresh',
                text: i18n.refresh,
                key: 'refresh',
                onClick: function onClick(e) {
                    return _this4.onRefreshCallback(e);
                }

            }, {
                icon: 'fa fa-filter',
                text: i18n.clear_filtering,
                key: 'clear_filtering',
                onClick: function onClick(e) {
                    return _this4.onClearFilteringCallback(e);
                }

            }, {
                icon: 'fa fa-eraser',
                text: i18n.clear_cache,
                key: 'clear_cache',
                onClick: function onClick(e) {
                    return _this4.onClearCacheCallback(e);
                }
            }];


            return React.createElement(
                'div',
                { ref: this.setContainer, className: (0, _classnames2.default)('btn-group', {
                        open: settingsOpen
                    }) },
                React.createElement(
                    GroupPrimaryButton,
                    { type: 'button', onClick: function onClick() {
                            return _this4.toggleSettings();
                        } },
                    React.createElement('span', { className: 'fa fa-gear' }),
                    '\xA0',
                    i18n.settings,
                    '\xA0',
                    React.createElement('span', { className: 'caret' })
                ),
                React.createElement(GroupButtonsList, {
                    subMenuLeftDirection: subMenuLeftDirection,
                    buttons: buttons.map(function (button) {
                        return {
                            subMenuLeftDirection: button.subMenuLeftDirection,
                            hasSubMenu: button.hasSubMenu,
                            icon: button.icon,
                            text: button.text,
                            key: button.key,
                            onClick: function onClick(event) {
                                if (button.onClick) {
                                    event.preventDefault();
                                    button.onClick(event);
                                }
                            },
                            subComponent: button.subComponent
                        };
                    }) })
            );
        }
    }]);

    return Settings;
}(React.Component);

Settings.propTypes = {
    onRefreshCallback: _propTypes2.default.func,
    onClearFilteringCallback: _propTypes2.default.func,
    onClearCacheCallback: _propTypes2.default.func,
    columns: _propTypes2.default.array,
    gcrudInstance: _propTypes2.default.object,
    visibleColumns: _propTypes2.default.array,
    visibleColumnsCallbackOnChange: _propTypes2.default.func,
    i18n: _propTypes2.default.shape({
        settings: _propTypes2.default.string,
        columns: _propTypes2.default.string,
        refresh: _propTypes2.default.string,
        clear_filtering: _propTypes2.default.string,
        clear_cache: _propTypes2.default.string
    }),
    GroupPrimaryButton: _propTypes2.default.func,
    subMenuLeftDirection: _propTypes2.default.bool
};

Settings.defaultProps = {
    GroupPrimaryButton: function GroupPrimaryButton(props) {
        return React.createElement(
            'button',
            props,
            props.children
        );
    },
    GroupButtonsList: function GroupButtonsList(props) {
        return React.createElement(
            'ul',
            { className: 'dropdown-menu' },
            props.buttons.map(function (button) {
                return React.createElement(
                    'li',
                    { key: button.key, className: (0, _classnames2.default)({
                            'dropdown-submenu': button.hasSubMenu,
                            'left-direction': button.hasSubMenu && button.subMenuLeftDirection
                        }) },
                    React.createElement(
                        'a',
                        {
                            href: button.href ? button.href : '',
                            onClick: button.onClick,
                            target: button.target
                        },
                        button.icon && React.createElement('i', { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    ),
                    button.subComponent && React.createElement(
                        'ul',
                        { className: 'dropdown-menu' },
                        button.subComponent
                    )
                );
            })
        );
    }
};

exports.default = Settings;

},{"./visible-columns.jsx":40,"classnames":124,"prop-types":190}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VisibleColumns = function (_React$Component) {
    _inherits(VisibleColumns, _React$Component);

    function VisibleColumns(props) {
        _classCallCheck(this, VisibleColumns);

        var _this = _possibleConstructorReturn(this, (VisibleColumns.__proto__ || Object.getPrototypeOf(VisibleColumns)).call(this, props));

        var checkedColumns = {},
            visibleColumns = _this.props.visibleColumns;


        _this.props.columns.forEach(function (column) {
            checkedColumns[column.columnName] = visibleColumns.indexOf(column.columnName) > -1;
        });

        _this.state = {
            checkedColumns: checkedColumns
        };
        return _this;
    }

    _createClass(VisibleColumns, [{
        key: 'onCheckboxChange',
        value: function onCheckboxChange(event) {
            var checkedColumns = this.state.checkedColumns,
                visibleColumns = [];

            checkedColumns[event.target.getAttribute('data-field-name')] = event.target.checked;

            if (!this.hasAtLeastOneChecked(checkedColumns)) {
                checkedColumns[event.target.getAttribute('data-field-name')] = true;
            }

            this.setState({
                checkedColumns: checkedColumns
            });

            Object.keys(checkedColumns).forEach(function (columnName) {
                if (checkedColumns[columnName]) {
                    visibleColumns.push(columnName);
                }
            });

            this.props.callbackOnChange.apply(this.props.gcrudInstance, [visibleColumns]);
        }
    }, {
        key: 'hasAtLeastOneChecked',
        value: function hasAtLeastOneChecked(checkedColumns) {
            var atLeastOneChecked = false;

            Object.keys(checkedColumns).forEach(function (columnName) {
                if (checkedColumns[columnName]) {
                    atLeastOneChecked = true;
                }
            });

            return atLeastOneChecked;
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var columns = this.props.columns,
                checkedColumns = this.state.checkedColumns,
                columnsCheckboxes = columns.map(function (column) {
                return React.createElement(
                    'li',
                    { className: 'dropdown-item', key: column.columnName },
                    React.createElement(
                        'a',
                        null,
                        React.createElement(
                            'label',
                            null,
                            React.createElement('input', { type: 'checkbox', 'data-field-name': column.columnName, onChange: _this2.onCheckboxChange.bind(_this2), checked: checkedColumns[column.columnName] }),
                            '\xA0 ',
                            column.displayAs
                        )
                    )
                );
            });


            return columnsCheckboxes;
        }
    }]);

    return VisibleColumns;
}(React.Component);

VisibleColumns.propTypes = {
    columns: _propTypes2.default.array,
    visibleColumns: _propTypes2.default.array,
    gcrudInstance: _propTypes2.default.object,
    callbackOnChange: _propTypes2.default.func
};

exports.default = VisibleColumns;

},{"prop-types":190}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BasicOperator = function (_React$Component) {
    _inherits(BasicOperator, _React$Component);

    function BasicOperator(props) {
        _classCallCheck(this, BasicOperator);

        return _possibleConstructorReturn(this, (BasicOperator.__proto__ || Object.getPrototypeOf(BasicOperator)).call(this, props));
    }

    _createClass(BasicOperator, [{
        key: 'render',
        value: function render() {
            var i18n = {
                basic_operator: 'Basic Operator',
                and_statement: 'AND',
                or_statement: 'OR'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return React.createElement(
                'div',
                { className: 'row form-group' },
                React.createElement(
                    'label',
                    { className: 'col-md-3 control-label' },
                    i18n.basic_operator,
                    ' :'
                ),
                React.createElement(
                    'div',
                    { className: 'col-md-3' },
                    React.createElement(
                        'select',
                        { name: 'basic_operator', className: 'form-control' },
                        React.createElement(
                            'option',
                            { value: 'AND' },
                            i18n.and_statement
                        ),
                        React.createElement(
                            'option',
                            { value: 'OR' },
                            i18n.or_statement
                        )
                    )
                )
            );
        }
    }]);

    return BasicOperator;
}(React.Component);

exports.default = BasicOperator;

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputDate = function (_React$Component) {
    _inherits(InputDate, _React$Component);

    function InputDate(props) {
        _classCallCheck(this, InputDate);

        return _possibleConstructorReturn(this, (InputDate.__proto__ || Object.getPrototypeOf(InputDate)).call(this, props));
    }

    _createClass(InputDate, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                inputValue = _props.inputValue,
                fieldIndex = _props.fieldIndex;


            return React.createElement('input', {
                required: true,
                className: 'form-control',
                name: 'extended_search[' + fieldIndex + '][value]',
                type: 'text', value: inputValue
            });
        }
    }]);

    return InputDate;
}(React.Component);

exports.default = InputDate;


InputDate.propTypes = {
    fieldIndex: _propTypes2.default.number,
    inputValue: _propTypes2.default.string,
    inputValueOnChange: _propTypes2.default.func
};

},{"prop-types":190}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelectDropdown = function (_React$Component) {
    _inherits(InputSelectDropdown, _React$Component);

    function InputSelectDropdown(props) {
        _classCallCheck(this, InputSelectDropdown);

        return _possibleConstructorReturn(this, (InputSelectDropdown.__proto__ || Object.getPrototypeOf(InputSelectDropdown)).call(this, props));
    }

    _createClass(InputSelectDropdown, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;

            var optionsArray = [];

            Object.keys(permittedValues).forEach(function (itemId) {
                var itemDisplay = permittedValues[itemId];
                optionsArray.push(React.createElement(
                    'option',
                    { value: itemId, key: itemId },
                    itemDisplay
                ));
            });

            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                optionsArray
            );
        }
    }]);

    return InputSelectDropdown;
}(React.Component);

exports.default = InputSelectDropdown;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelectRelational = function (_React$Component) {
    _inherits(InputSelectRelational, _React$Component);

    function InputSelectRelational(props) {
        _classCallCheck(this, InputSelectRelational);

        return _possibleConstructorReturn(this, (InputSelectRelational.__proto__ || Object.getPrototypeOf(InputSelectRelational)).call(this, props));
    }

    _createClass(InputSelectRelational, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;


            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                permittedValues.map(function (item) {
                    return React.createElement(
                        'option',
                        { value: item.id, key: item.id },
                        item.title
                    );
                })
            );
        }
    }]);

    return InputSelectRelational;
}(React.Component);

exports.default = InputSelectRelational;

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InputSelect = function (_React$Component) {
    _inherits(InputSelect, _React$Component);

    function InputSelect(props) {
        _classCallCheck(this, InputSelect);

        return _possibleConstructorReturn(this, (InputSelect.__proto__ || Object.getPrototypeOf(InputSelect)).call(this, props));
    }

    _createClass(InputSelect, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var onComponentMount = this.props.onComponentMount;


            if (onComponentMount) {
                onComponentMount.apply(this);
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            var onComponentUpdate = this.props.onComponentUpdate;


            if (onComponentUpdate) {
                onComponentUpdate.apply(this);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                permittedValues = _props.permittedValues,
                fieldIndex = _props.fieldIndex;


            return React.createElement(
                'select',
                { className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]' },
                permittedValues.map(function (item) {
                    return React.createElement(
                        'option',
                        { value: item, key: item },
                        item
                    );
                })
            );
        }
    }]);

    return InputSelect;
}(React.Component);

exports.default = InputSelect;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _equal_not_equal = require('../select-options/equal_not_equal');

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchCheckboxBoolean = function (_React$Component) {
    _inherits(SearchCheckboxBoolean, _React$Component);

    function SearchCheckboxBoolean(props) {
        _classCallCheck(this, SearchCheckboxBoolean);

        var _this = _possibleConstructorReturn(this, (SearchCheckboxBoolean.__proto__ || Object.getPrototypeOf(SearchCheckboxBoolean)).call(this, props));

        _this.state = {
            comparisonValue: 'equals',
            isChecked: true
        };
        return _this;
    }

    _createClass(SearchCheckboxBoolean, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange() {
            var isChecked = this.state.isChecked;


            this.setState({
                isChecked: !isChecked
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                isChecked = _state.isChecked,
                comparisonValue = _state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', { type: 'checkbox', checked: isChecked, onChange: this.inputValueOnChange.bind(this), style: { marginTop: 12 } }),
                    React.createElement('input', { name: 'extended_search[' + fieldIndex + '][value]', type: 'hidden', value: isChecked ? '1' : '0' })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchCheckboxBoolean;
}(React.Component);

exports.default = SearchCheckboxBoolean;


SearchCheckboxBoolean.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchCheckboxBoolean.defaultProps = {
    isMobile: false
};

},{"../filter-select":54,"../select-options/equal_not_equal":58,"prop-types":190}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = require('../select-options/comparison');

var _comparison2 = _interopRequireDefault(_comparison);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _date = require('../field-input/date');

var _date2 = _interopRequireDefault(_date);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchDate = function (_React$Component) {
    _inherits(SearchDate, _React$Component);

    function SearchDate(props) {
        _classCallCheck(this, SearchDate);

        var _this = _possibleConstructorReturn(this, (SearchDate.__proto__ || Object.getPrototypeOf(SearchDate)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchDate, [{
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _comparison2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement(_date2.default, {
                        i18n: i18n,
                        fieldIndex: fieldIndex,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchDate;
}(React.Component);

SearchDate.propTypes = {
    fieldIndex: _propTypes2.default.number,
    onComponentMount: _propTypes2.default.func,
    onComponentUpdate: _propTypes2.default.func,
    isMobile: _propTypes2.default.bool
};

SearchDate.defaultProps = {
    isMobile: false
};

exports.default = SearchDate;

},{"../field-input/date":42,"../filter-select":54,"../select-options/comparison":57,"prop-types":190}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectDropdown = require("../field-input/select-dropdown");

var _selectDropdown2 = _interopRequireDefault(_selectDropdown);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchDropdown = function (_React$Component) {
    _inherits(SearchDropdown, _React$Component);

    function SearchDropdown(props) {
        _classCallCheck(this, SearchDropdown);

        var _this = _possibleConstructorReturn(this, (SearchDropdown.__proto__ || Object.getPrototypeOf(SearchDropdown)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchDropdown, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0,
                optionsArray = [];

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            Object.keys(permittedValues).forEach(function (itemId) {
                var itemDisplay = permittedValues[itemId];
                optionsArray.push(React.createElement(
                    "option",
                    { value: itemId, key: itemId },
                    itemDisplay
                ));
            });

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectDropdown2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchDropdown;
}(React.Component);

exports.default = SearchDropdown;


SearchDropdown.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.object,
    isMobile: _propTypes2.default.isMobile
};

SearchDropdown.defaultProps = {
    isMobile: false
};

},{"../field-input/select-dropdown":43,"../filter-select":54,"../select-options/equal_not_equal":58,"prop-types":190}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _select = require("../field-input/select");

var _select2 = _interopRequireDefault(_select);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchEnum = function (_React$Component) {
    _inherits(SearchEnum, _React$Component);

    function SearchEnum(props) {
        _classCallCheck(this, SearchEnum);

        var _this = _possibleConstructorReturn(this, (SearchEnum.__proto__ || Object.getPrototypeOf(SearchEnum)).call(this, props));

        _this.state = {
            comparisonValue: 'contains'
        };
        return _this;
    }

    _createClass(SearchEnum, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_select2.default, {
                        permittedValues: permittedValues,
                        fieldIndex: fieldIndex,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchEnum;
}(React.Component);

exports.default = SearchEnum;


SearchEnum.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchEnum.defaultProps = {
    isMobile: false
};

},{"../field-input/select":45,"../filter-select":54,"../select-options/equal_not_equal":58,"prop-types":190}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _comparison = require('../select-options/comparison');

var _comparison2 = _interopRequireDefault(_comparison);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchNumeric = function (_React$Component) {
    _inherits(SearchNumeric, _React$Component);

    function SearchNumeric(props) {
        _classCallCheck(this, SearchNumeric);

        var _this = _possibleConstructorReturn(this, (SearchNumeric.__proto__ || Object.getPrototypeOf(SearchNumeric)).call(this, props));

        _this.state = {
            comparisonValue: 'equals',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchNumeric, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange(event) {
            this.setState({
                inputValue: event.target.value
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                comparisonValue = _state.comparisonValue,
                inputValue = _state.inputValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _comparison2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '0',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', { required: true, className: 'form-control', name: 'extended_search[' + fieldIndex + '][value]', type: 'number', value: inputValue, onChange: this.inputValueOnChange.bind(this) })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchNumeric;
}(React.Component);

exports.default = SearchNumeric;


SearchNumeric.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchNumeric.defaultProps = {
    isMobile: false
};

},{"../filter-select":54,"../select-options/comparison":57,"prop-types":190}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _has_or_not = require("../select-options/has_or_not");

var _has_or_not2 = _interopRequireDefault(_has_or_not);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectRelational = require("../field-input/select-relational");

var _selectRelational2 = _interopRequireDefault(_selectRelational);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchRelationalNtoN = function (_React$Component) {
    _inherits(SearchRelationalNtoN, _React$Component);

    function SearchRelationalNtoN(props) {
        _classCallCheck(this, SearchRelationalNtoN);

        var _this = _possibleConstructorReturn(this, (SearchRelationalNtoN.__proto__ || Object.getPrototypeOf(SearchRelationalNtoN)).call(this, props));

        _this.state = {
            comparisonValue: 'has'
        };
        return _this;
    }

    _createClass(SearchRelationalNtoN, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _has_or_not2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectRelational2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchRelationalNtoN;
}(React.Component);

exports.default = SearchRelationalNtoN;


SearchRelationalNtoN.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchRelationalNtoN.defaultProps = {
    isMobile: false
};

},{"../field-input/select-relational":44,"../filter-select":54,"../select-options/has_or_not":59,"prop-types":190}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require("../filter-select");

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _selectRelational = require("../field-input/select-relational");

var _selectRelational2 = _interopRequireDefault(_selectRelational);

var _equal_not_equal = require("../select-options/equal_not_equal");

var _equal_not_equal2 = _interopRequireDefault(_equal_not_equal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchRelational = function (_React$Component) {
    _inherits(SearchRelational, _React$Component);

    function SearchRelational(props) {
        _classCallCheck(this, SearchRelational);

        var _this = _possibleConstructorReturn(this, (SearchRelational.__proto__ || Object.getPrototypeOf(SearchRelational)).call(this, props));

        _this.state = {
            comparisonValue: 'has'
        };
        return _this;
    }

    _createClass(SearchRelational, [{
        key: "comparisonOnChange",
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: "render",
        value: function render() {
            var comparisonValue = this.state.comparisonValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                permittedValues = _props.permittedValues,
                onComponentMount = _props.onComponentMount,
                onComponentUpdate = _props.onComponentUpdate,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _equal_not_equal2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: "0",
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    "div",
                    { key: "2", className: "col-md-8" },
                    React.createElement(_selectRelational2.default, {
                        fieldIndex: fieldIndex,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchRelational;
}(React.Component);

exports.default = SearchRelational;


SearchRelational.propTypes = {
    fieldIndex: _propTypes2.default.number,
    permittedValues: _propTypes2.default.array,
    isMobile: _propTypes2.default.bool
};

SearchRelational.defaultProps = {
    isMobile: false
};

},{"../field-input/select-relational":44,"../filter-select":54,"../select-options/equal_not_equal":58,"prop-types":190}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _filterSelect = require('../filter-select');

var _filterSelect2 = _interopRequireDefault(_filterSelect);

var _text = require('../select-options/text');

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SearchText = function (_React$Component) {
    _inherits(SearchText, _React$Component);

    function SearchText(props) {
        _classCallCheck(this, SearchText);

        var _this = _possibleConstructorReturn(this, (SearchText.__proto__ || Object.getPrototypeOf(SearchText)).call(this, props));

        _this.state = {
            comparisonValue: 'contains',
            inputValue: ''
        };
        return _this;
    }

    _createClass(SearchText, [{
        key: 'inputValueOnChange',
        value: function inputValueOnChange(event) {
            this.setState({
                inputValue: event.target.value
            });
        }
    }, {
        key: 'comparisonOnChange',
        value: function comparisonOnChange(comparisonValue) {
            this.setState({
                comparisonValue: comparisonValue
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                comparisonValue = _state.comparisonValue,
                inputValue = _state.inputValue,
                _props = this.props,
                fieldIndex = _props.fieldIndex,
                i18n = _props.i18n,
                isMobile = _props.isMobile;

            var JsxArray = void 0;

            JsxArray = [React.createElement(_filterSelect2.default, {
                i18n: i18n,
                fieldIndex: fieldIndex,
                SelectOptions: _text2.default,
                onChangeCallback: this.comparisonOnChange.bind(this),
                key: '1',
                isMobile: isMobile
            })];

            if (comparisonValue !== 'is_empty' && comparisonValue !== 'is_not_empty') {
                JsxArray.push(React.createElement(
                    'div',
                    { key: '2', className: 'col-md-8' },
                    React.createElement('input', {
                        required: true,
                        className: 'form-control',
                        name: 'extended_search[' + fieldIndex + '][value]',
                        type: 'text',
                        value: inputValue,
                        onChange: this.inputValueOnChange.bind(this)
                    })
                ));
            }

            return JsxArray;
        }
    }]);

    return SearchText;
}(React.Component);

exports.default = SearchText;


SearchText.propTypes = {
    fieldIndex: _propTypes2.default.number,
    isMobile: _propTypes2.default.bool
};

SearchText.defaultProps = {
    isMobile: false
};

},{"../filter-select":54,"../select-options/text":60,"prop-types":190}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FilterSelect = function (_React$Component) {
    _inherits(FilterSelect, _React$Component);

    function FilterSelect(props) {
        _classCallCheck(this, FilterSelect);

        var _this = _possibleConstructorReturn(this, (FilterSelect.__proto__ || Object.getPrototypeOf(FilterSelect)).call(this, props));

        _this.state = {
            comparisonValue: ''
        };
        return _this;
    }

    _createClass(FilterSelect, [{
        key: 'selectOnChange',
        value: function selectOnChange(event) {
            var comparisonValue = event.target.value,
                onChangeCallback = this.props.onChangeCallback;


            this.setState({
                comparisonValue: comparisonValue
            });

            onChangeCallback(comparisonValue);
        }
    }, {
        key: 'render',
        value: function render() {
            var _props = this.props,
                fieldIndex = _props.fieldIndex,
                SelectOptions = _props.SelectOptions,
                i18n = _props.i18n,
                isMobile = _props.isMobile,
                comparisonValue = this.state.comparisonValue;


            return React.createElement(
                'div',
                { className: (0, _classnames2.default)('col-md-4', {
                        'b10': isMobile
                    }) },
                React.createElement(
                    'select',
                    { className: 'form-control', name: 'extended_search[' + fieldIndex + '][filter]', value: comparisonValue, onChange: this.selectOnChange.bind(this) },
                    React.createElement(SelectOptions, { i18n: i18n })
                )
            );
        }
    }]);

    return FilterSelect;
}(React.Component);

exports.default = FilterSelect;


FilterSelect.propTypes = {
    fieldIndex: _propTypes2.default.number,
    SelectOptions: _propTypes2.default.func,
    onChangeCallback: _propTypes2.default.func,
    isMobile: _propTypes2.default.bool
};

FilterSelect.defaultProps = {
    isMobile: false
};

},{"classnames":124,"prop-types":190}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _basicOperator = require('./basic-operator.js');

var _basicOperator2 = _interopRequireDefault(_basicOperator);

var _multipleSearch = require('./multiple-search.js');

var _multipleSearch2 = _interopRequireDefault(_multipleSearch);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Filtering = function (_React$Component) {
    _inherits(Filtering, _React$Component);

    function Filtering(props) {
        _classCallCheck(this, Filtering);

        var _this = _possibleConstructorReturn(this, (Filtering.__proto__ || Object.getPrototypeOf(Filtering)).call(this, props));

        _this.state = {
            indexes: [0]
        };
        return _this;
    }

    _createClass(Filtering, [{
        key: 'addMoreFilters',
        value: function addMoreFilters() {
            var indexes = this.state.indexes;

            // the last index is always the bigger one so add +1

            indexes.push(indexes[indexes.length - 1] + 1);

            this.setState({
                indexes: indexes
            });
        }
    }, {
        key: 'removeFilter',
        value: function removeFilter(fieldIndex) {
            var indexes = this.state.indexes;


            indexes = indexes.filter(function (index) {
                return index !== fieldIndex;
            });

            this.setState({
                indexes: indexes
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var indexes = this.state.indexes,
                _props = this.props,
                fields = _props.fields,
                onSubmitCallback = _props.onSubmitCallback,
                onInputMount = _props.onInputMount,
                ModalTitle = _props.ModalTitle,
                screenSize = _props.screenSize,
                indexesLength = indexes.length;

            var JSXarray = void 0,
                i18n = {
                basic_operator: 'Basic Operator',
                and_statement: 'AND',
                or_statement: 'OR',
                filtering: 'Filtering',
                filter: 'Filter',
                cancel_filtering: 'Cancel',
                add_more: 'Add more',
                remove_filter: 'Remove Filter'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            JSXarray = indexes.map(function (index) {
                return React.createElement(_multipleSearch2.default, {
                    i18n: i18n,
                    fields: fields,
                    fieldIndex: index,
                    key: index,
                    hasRemoveButton: indexesLength > 1,
                    onDeleteCallback: _this2.removeFilter.bind(_this2),
                    onInputMount: onInputMount,
                    screenSize: screenSize
                });
            });

            return React.createElement(
                'div',
                { className: 'modal-dialog gc-modal-dialog' },
                React.createElement(
                    'div',
                    { className: 'modal-content' },
                    React.createElement(
                        'form',
                        { method: 'post', className: 'form-horizontal', onSubmit: onSubmitCallback.bind(this) },
                        React.createElement(
                            'div',
                            { className: 'modal-header' },
                            React.createElement(ModalTitle, { title: i18n.filtering })
                        ),
                        React.createElement(
                            'div',
                            { className: 'modal-body delete-modal' },
                            React.createElement(_basicOperator2.default, { i18n: i18n }),
                            JSXarray,
                            React.createElement(
                                'div',
                                { className: 'gc-filtering-row' },
                                React.createElement(
                                    'button',
                                    {
                                        type: 'button',
                                        className: 'btn btn-default btn-outline-dark',
                                        onClick: this.addMoreFilters.bind(this) },
                                    React.createElement('em', { className: 'fa fa-plus' }),
                                    '\xA0',
                                    i18n.add_more
                                )
                            )
                        ),
                        React.createElement(
                            'div',
                            { className: 'modal-footer' },
                            React.createElement(
                                'button',
                                { type: 'button', className: 'btn btn-default btn-outline-dark', 'data-dismiss': 'modal' },
                                i18n.cancel_filtering
                            ),
                            React.createElement(
                                'button',
                                { type: 'submit', className: 'btn btn-success delete-multiple-confirmation-button' },
                                i18n.filter
                            )
                        )
                    )
                )
            );
        }
    }]);

    return Filtering;
}(React.Component);

exports.default = Filtering;


Filtering.propTypes = {
    fields: _propTypes2.default.array,
    onSubmitCallback: _propTypes2.default.func,
    onInputMount: _propTypes2.default.object,
    ModalTitle: _propTypes2.default.func,
    screenSize: _propTypes2.default.string
};

Filtering.defaultProps = {
    ModalTitle: function ModalTitle(props) {
        return React.createElement(
            React.Fragment,
            null,
            React.createElement(
                'button',
                {
                    type: 'button',
                    className: 'close',
                    'data-dismiss': 'modal',
                    'aria-label': 'Close'
                },
                React.createElement(
                    'span',
                    { 'aria-hidden': 'true' },
                    '\xD7'
                )
            ),
            React.createElement(
                'h4',
                { className: 'modal-title' },
                props.title
            )
        );
    },
    screenSize: 'l'
};

},{"./basic-operator.js":41,"./multiple-search.js":56,"prop-types":190}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require("./field-types/text");

var _text2 = _interopRequireDefault(_text);

var _date = require("./field-types/date");

var _date2 = _interopRequireDefault(_date);

var _numeric = require("./field-types/numeric");

var _numeric2 = _interopRequireDefault(_numeric);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _checkbox_boolean = require("./field-types/checkbox_boolean");

var _checkbox_boolean2 = _interopRequireDefault(_checkbox_boolean);

var _enum = require("./field-types/enum");

var _enum2 = _interopRequireDefault(_enum);

var _dropdown = require("./field-types/dropdown");

var _dropdown2 = _interopRequireDefault(_dropdown);

var _relational = require("./field-types/relational");

var _relational2 = _interopRequireDefault(_relational);

var _relationalNN = require("./field-types/relational-n-n");

var _relationalNN2 = _interopRequireDefault(_relationalNN);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MultipleSearch = function (_React$Component) {
    _inherits(MultipleSearch, _React$Component);

    function MultipleSearch(props) {
        _classCallCheck(this, MultipleSearch);

        var firstFieldsKey = props.fields.find(function (__item, key) {
            return key === 0;
        }),
            fieldName = firstFieldsKey.fieldName,
            type = firstFieldsKey.type,
            permittedValues = firstFieldsKey.permittedValues;

        var _this = _possibleConstructorReturn(this, (MultipleSearch.__proto__ || Object.getPrototypeOf(MultipleSearch)).call(this, props));

        _this.state = {
            selectedValue: fieldName,
            selectedType: type,
            permittedValues: permittedValues
        };
        return _this;
    }

    _createClass(MultipleSearch, [{
        key: "onChangeSelect",
        value: function onChangeSelect(event) {
            var selectedField = this.props.fields.find(function (field) {
                return field.fieldName === event.target.value;
            }),
                fieldName = selectedField.fieldName,
                type = selectedField.type,
                permittedValues = selectedField.permittedValues;


            this.setState({
                selectedValue: fieldName,
                selectedType: type,
                permittedValues: permittedValues
            });
        }
    }, {
        key: "onDeleteClick",
        value: function onDeleteClick() {
            var _props = this.props,
                fieldIndex = _props.fieldIndex,
                onDeleteCallback = _props.onDeleteCallback;


            onDeleteCallback(fieldIndex);
        }
    }, {
        key: "render",
        value: function render() {
            var _state = this.state,
                selectedValue = _state.selectedValue,
                selectedType = _state.selectedType,
                permittedValues = _state.permittedValues,
                _props2 = this.props,
                fieldIndex = _props2.fieldIndex,
                fields = _props2.fields,
                hasRemoveButton = _props2.hasRemoveButton,
                onInputMount = _props2.onInputMount,
                screenSize = _props2.screenSize,
                evenOrOdd = fieldIndex % 2 === 0 ? 'even' : 'odd',
                isMobile = screenSize === 's' || screenSize === 'xs';

            var searchInput = void 0,
                onComponentMount = void 0,
                onComponentUpdate = void 0,
                i18n = {
                remove_filter: 'Remove Filter'
            };

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            if (onInputMount && onInputMount[selectedType]) {
                onComponentMount = onInputMount[selectedType].onMount;
                onComponentUpdate = onInputMount[selectedType].onUpdate;
            }

            switch (selectedType) {
                case 'date':
                case 'datetime':
                case 'timestamp':
                    searchInput = React.createElement(_date2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'int':
                case 'numeric':
                    searchInput = React.createElement(_numeric2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'checkbox_boolean':
                    searchInput = React.createElement(_checkbox_boolean2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'relational_n_n':
                case 'native_relational_n_n':
                    searchInput = React.createElement(_relationalNN2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'relational':
                case 'relational_native':
                    searchInput = React.createElement(_relational2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'multiselect_native':
                case 'multiselect_searchable':
                case 'dropdown':
                case 'dropdown_search':
                    searchInput = React.createElement(_dropdown2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                case 'enum_searchable':
                case 'enum':
                    searchInput = React.createElement(_enum2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        permittedValues: permittedValues,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        isMobile: isMobile
                    });
                    break;

                default:
                    searchInput = React.createElement(_text2.default, {
                        fieldIndex: fieldIndex,
                        i18n: i18n,
                        onComponentMount: onComponentMount,
                        onComponentUpdate: onComponentUpdate,
                        screenSize: screenSize,
                        isMobile: isMobile
                    });
                    break;
            }

            return React.createElement(
                "div",
                { className: 'row gc-filtering-row ' + evenOrOdd },
                hasRemoveButton ? React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('col-md-1', {
                            'b10': isMobile
                        }) },
                    React.createElement(
                        "button",
                        {
                            type: "button",
                            className: (0, _classnames2.default)('btn', 'btn-default', 'btn-outline-dark', 'btn-block'),
                            onClick: this.onDeleteClick.bind(this),
                            title: i18n.remove_filter },
                        React.createElement("em", { className: "fa fa-trash-o" }),
                        isMobile && React.createElement(
                            React.Fragment,
                            null,
                            "\xA0 ",
                            i18n.remove_filter
                        )
                    )
                ) : '',
                React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('col-md-3', {
                            'b10': isMobile
                        }) },
                    React.createElement(
                        "select",
                        { className: "form-control", name: 'extended_search[' + fieldIndex + '][name]',
                            onChange: this.onChangeSelect.bind(this), value: selectedValue },
                        fields.map(function (field) {
                            return React.createElement(
                                "option",
                                { value: field.fieldName,
                                    key: field.fieldName },
                                field.displayAs
                            );
                        })
                    )
                ),
                React.createElement(
                    "div",
                    { className: (0, _classnames2.default)('row', {
                            'col-md-8': hasRemoveButton,
                            'col-md-9': !hasRemoveButton,
                            'b10': isMobile
                        }) },
                    searchInput
                )
            );
        }
    }]);

    return MultipleSearch;
}(React.Component);

MultipleSearch.propTypes = {
    fieldIndex: _propTypes2.default.number,
    fields: _propTypes2.default.array,
    hasRemoveButton: _propTypes2.default.bool,
    onDeleteCallback: _propTypes2.default.func,
    screenSize: _propTypes2.default.string
};

MultipleSearch.defaultProps = {
    screenSize: 'l'
};

exports.default = MultipleSearch;

},{"./field-types/checkbox_boolean":46,"./field-types/date":47,"./field-types/dropdown":48,"./field-types/enum":49,"./field-types/numeric":50,"./field-types/relational":52,"./field-types/relational-n-n":51,"./field-types/text":53,"classnames":124,"prop-types":190}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nComparison = require('./translations/i18n-comparison');

var _i18nComparison2 = _interopRequireDefault(_i18nComparison);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ComparisonSelectOptions = function (_React$Component) {
    _inherits(ComparisonSelectOptions, _React$Component);

    function ComparisonSelectOptions() {
        _classCallCheck(this, ComparisonSelectOptions);

        return _possibleConstructorReturn(this, (ComparisonSelectOptions.__proto__ || Object.getPrototypeOf(ComparisonSelectOptions)).apply(this, arguments));
    }

    _createClass(ComparisonSelectOptions, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nComparison2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            console.log(i18n);

            return [React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'greater_than', value: 'greater_than' },
                i18n.comparison_greater_than
            ), React.createElement(
                'option',
                { key: 'less_than', value: 'less_than' },
                i18n.comparison_less_than
            ), React.createElement(
                'option',
                { key: 'greater_than_or_equal', value: 'greater_than_or_equal' },
                i18n.comparison_greater_than_or_equal
            ), React.createElement(
                'option',
                { key: 'less_than_or_equal', value: 'less_than_or_equal' },
                i18n.comparison_less_than_or_equal
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return ComparisonSelectOptions;
}(React.Component);

ComparisonSelectOptions.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = ComparisonSelectOptions;

},{"./translations/i18n-comparison":61,"prop-types":190}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nEqualNotEqual = require('./translations/i18n-equal-not-equal');

var _i18nEqualNotEqual2 = _interopRequireDefault(_i18nEqualNotEqual);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectOptionsEqualNotEqual = function (_React$Component) {
    _inherits(SelectOptionsEqualNotEqual, _React$Component);

    function SelectOptionsEqualNotEqual() {
        _classCallCheck(this, SelectOptionsEqualNotEqual);

        return _possibleConstructorReturn(this, (SelectOptionsEqualNotEqual.__proto__ || Object.getPrototypeOf(SelectOptionsEqualNotEqual)).apply(this, arguments));
    }

    _createClass(SelectOptionsEqualNotEqual, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nEqualNotEqual2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return SelectOptionsEqualNotEqual;
}(React.Component);

SelectOptionsEqualNotEqual.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = SelectOptionsEqualNotEqual;

},{"./translations/i18n-equal-not-equal":62,"prop-types":190}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nHasOrNot = require('./translations/i18n-has-or-not');

var _i18nHasOrNot2 = _interopRequireDefault(_i18nHasOrNot);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SelectOptionsHasOrNot = function (_React$Component) {
    _inherits(SelectOptionsHasOrNot, _React$Component);

    function SelectOptionsHasOrNot() {
        _classCallCheck(this, SelectOptionsHasOrNot);

        return _possibleConstructorReturn(this, (SelectOptionsHasOrNot.__proto__ || Object.getPrototypeOf(SelectOptionsHasOrNot)).apply(this, arguments));
    }

    _createClass(SelectOptionsHasOrNot, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nHasOrNot2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'has', value: 'has' },
                i18n.comparison_has
            ), React.createElement(
                'option',
                { key: 'does_not_have', value: 'does_not_have' },
                i18n.comparison_does_not_have
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return SelectOptionsHasOrNot;
}(React.Component);

SelectOptionsHasOrNot.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = SelectOptionsHasOrNot;

},{"./translations/i18n-has-or-not":63,"prop-types":190}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _i18nText = require('./translations/i18n-text');

var _i18nText2 = _interopRequireDefault(_i18nText);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TextSelectOptions = function (_React$Component) {
    _inherits(TextSelectOptions, _React$Component);

    function TextSelectOptions() {
        _classCallCheck(this, TextSelectOptions);

        return _possibleConstructorReturn(this, (TextSelectOptions.__proto__ || Object.getPrototypeOf(TextSelectOptions)).apply(this, arguments));
    }

    _createClass(TextSelectOptions, [{
        key: 'render',
        value: function render() {
            var i18n = _i18nText2.default;

            if (this.props.i18n) {
                i18n = Object.assign({}, i18n, this.props.i18n);
            }

            return [React.createElement(
                'option',
                { key: 'contains', value: 'contains' },
                i18n.comparison_contains
            ), React.createElement(
                'option',
                { key: 'starts_with', value: 'starts_with' },
                i18n.comparison_starts_with
            ), React.createElement(
                'option',
                { key: 'ends_with', value: 'ends_with' },
                i18n.comparison_ends_with
            ), React.createElement(
                'option',
                { key: 'equals', value: 'equals' },
                i18n.comparison_equals
            ), React.createElement(
                'option',
                { key: 'not_equals', value: 'not_equals' },
                i18n.comparison_not_equals
            ), React.createElement(
                'option',
                { key: 'is_empty', value: 'is_empty' },
                i18n.comparison_is_empty
            ), React.createElement(
                'option',
                { key: 'is_not_empty', value: 'is_not_empty' },
                i18n.comparison_is_not_empty
            )];
        }
    }]);

    return TextSelectOptions;
}(React.Component);

TextSelectOptions.propTypes = {
    i18n: _propTypes2.default.object
};

exports.default = TextSelectOptions;

},{"./translations/i18n-text":64,"prop-types":190}],61:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_greater_than: 'greater than',
    comparison_less_than: 'less than',
    comparison_greater_than_or_equal: 'greater than or equal',
    comparison_less_than_or_equal: 'less than or equal',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_has: 'has',
    comparison_does_not_have: 'does not have',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    comparison_contains: 'contains',
    comparison_starts_with: 'starts with',
    comparison_ends_with: 'ends with',
    comparison_equals: 'equals',
    comparison_not_equals: 'not equals',
    comparison_is_empty: 'is empty',
    comparison_is_not_empty: 'is not empty'
};

},{}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultGroupButton = function (_React$Component) {
    _inherits(DefaultGroupButton, _React$Component);

    function DefaultGroupButton() {
        _classCallCheck(this, DefaultGroupButton);

        var _this = _possibleConstructorReturn(this, (DefaultGroupButton.__proto__ || Object.getPrototypeOf(DefaultGroupButton)).call(this));

        _this.setContainer = _this.setContainer.bind(_this);
        _this.state = {
            settingsOpen: false
        };
        return _this;
    }

    _createClass(DefaultGroupButton, [{
        key: 'toggleSettings',
        value: function toggleSettings() {
            this.setState({
                settingsOpen: !this.state.settingsOpen
            });
        }
    }, {
        key: 'setContainer',
        value: function setContainer(ref) {
            this.container = ref;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            document.addEventListener('click', function (e) {
                return _this2.clickOutside(e);
            }, true);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var _this3 = this;

            document.removeEventListener('click', function (e) {
                return _this3.clickOutside(e);
            }, true);
        }
    }, {
        key: 'clickOutside',
        value: function clickOutside(event) {
            var settingsOpen = this.state.settingsOpen;


            if (settingsOpen && this.container && !this.container.contains(event.target)) {
                this.setState({
                    settingsOpen: false
                });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this4 = this;

            var settingsOpen = this.state.settingsOpen,
                _props = this.props,
                buttons = _props.buttons,
                maxButtons = _props.maxButtons,
                i18n = _props.i18n,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;


            return React.createElement(
                'div',
                {
                    ref: this.setContainer,
                    className: (0, _classnames2.default)('btn-group', {
                        open: settingsOpen
                    }),
                    role: 'group'
                },
                React.createElement(
                    GroupPrimaryButton,
                    { type: 'button', onClick: function onClick(e) {
                            return _this4.toggleSettings();
                        } },
                    maxButtons === 1 ? i18n.actions : i18n.more,
                    '\xA0',
                    React.createElement('span', { className: 'caret' })
                ),
                React.createElement(GroupButtonsList, { buttons: buttons.map(function (button) {
                        return {
                            href: button.url ? button.url : '',
                            target: button.newTab ? '_blank' : '',
                            icon: button.icon,
                            text: button.text,
                            key: button.key,
                            onClick: function onClick(e) {
                                if (button.onClick) {
                                    e.preventDefault();
                                    button.onClick(button.primaryKeyValue);
                                }
                            }
                        };
                    }) })
            );
        }
    }]);

    return DefaultGroupButton;
}(React.Component);

DefaultGroupButton.propTypes = {
    buttons: _propTypes2.default.array,
    maxButtons: _propTypes2.default.number,
    i18n: (0, _propTypes.shape)({
        actions: _propTypes2.default.string,
        more: _propTypes2.default.string
    })
};

DefaultGroupButton.defaultProps = {
    i18n: {
        actions: 'Actions',
        more: 'More'
    },
    GroupPrimaryButton: function GroupPrimaryButton(props) {
        return React.createElement(
            'button',
            props,
            props.children
        );
    },
    GroupButtonsList: function GroupButtonsList(props) {
        return React.createElement(
            'ul',
            { className: 'dropdown-menu' },
            props.buttons.map(function (button) {
                return React.createElement(
                    'li',
                    { key: button.key, className: (0, _classnames2.default)({ 'dropdown-submenu': button.hasSubMenu }) },
                    React.createElement(
                        'a',
                        {
                            href: button.href,
                            onClick: button.onClick,
                            target: button.target
                        },
                        button.icon && React.createElement('i', { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    )
                );
            })
        );
    }
};

exports.default = DefaultGroupButton;

},{"classnames":124,"prop-types":190}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DefaultLinkButton = function (_React$PureComponent) {
    _inherits(DefaultLinkButton, _React$PureComponent);

    function DefaultLinkButton() {
        _classCallCheck(this, DefaultLinkButton);

        return _possibleConstructorReturn(this, (DefaultLinkButton.__proto__ || Object.getPrototypeOf(DefaultLinkButton)).apply(this, arguments));
    }

    _createClass(DefaultLinkButton, [{
        key: 'onClickCallback',
        value: function onClickCallback(event) {
            var _props = this.props,
                onClick = _props.onClick,
                primaryKeyValue = _props.primaryKeyValue;


            if (onClick) {
                event.preventDefault();
                onClick(primaryKeyValue);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                icon = _props2.icon,
                url = _props2.url,
                text = _props2.text,
                rightMargin = _props2.rightMargin,
                newTab = _props2.newTab,
                LinkButtonWrapper = _props2.LinkButtonWrapper;


            return React.createElement(
                LinkButtonWrapper,
                {
                    classNames: { 'r5': rightMargin },
                    href: url ? url : '',
                    role: 'button',
                    onClick: function onClick(e) {
                        return _this2.onClickCallback(e);
                    },
                    target: newTab ? '_blank' : ''
                },
                icon && React.createElement('i', { className: icon }),
                text && React.createElement(
                    'span',
                    null,
                    '\xA0',
                    text
                )
            );
        }
    }]);

    return DefaultLinkButton;
}(React.PureComponent);

;

DefaultLinkButton.propTypes = {
    icon: _propTypes2.default.string,
    url: _propTypes2.default.string,
    text: _propTypes2.default.string,
    rightMargin: _propTypes2.default.bool,
    onClick: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string,
    newTab: _propTypes2.default.bool,
    LinkButtonWrapper: _propTypes2.default.func
};

DefaultLinkButton.defaultProps = {
    LinkButtonWrapper: function LinkButtonWrapper(props) {
        return React.createElement(
            'a',
            props,
            props.children
        );
    }
};

exports.default = DefaultLinkButton;

},{"classnames":124,"prop-types":190}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _groupButtons = require('./wrappers/bootstrap-v3/group-buttons.jsx');

var _groupButtons2 = _interopRequireDefault(_groupButtons);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _datagridCheckbox = require('./datagrid-checkbox.jsx');

var _datagridCheckbox2 = _interopRequireDefault(_datagridCheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridActionsColumn = function (_React$Component) {
    _inherits(DatagridActionsColumn, _React$Component);

    function DatagridActionsColumn() {
        _classCallCheck(this, DatagridActionsColumn);

        return _possibleConstructorReturn(this, (DatagridActionsColumn.__proto__ || Object.getPrototypeOf(DatagridActionsColumn)).apply(this, arguments));
    }

    _createClass(DatagridActionsColumn, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                actionButtons = _props.actionButtons,
                backendActionButtons = _props.backendActionButtons,
                _props$options = _props.options,
                hasEdit = _props$options.hasEdit,
                hasRead = _props$options.hasRead,
                hasClone = _props$options.hasClone,
                hasDelete = _props$options.hasDelete,
                hasActionButtons = _props$options.hasActionButtons,
                deleteMultiple = _props$options.deleteMultiple,
                onEditClick = _props.onEditClick,
                onReadClick = _props.onReadClick,
                onCloneClick = _props.onCloneClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                screenSize = _props.screenSize,
                rowSelected = _props.rowSelected,
                toggleSelectRow = _props.toggleSelectRow,
                primaryKeyValue = _props.primaryKeyValue,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;

            var buttons = [];

            if (hasEdit) {
                buttons.push({
                    key: 'gc-edit',
                    url: '#/' + urlUniqueHash + 'edit/' + primaryKeyValue,
                    icon: 'fa fa-pencil',
                    text: i18n.edit,
                    onClick: onEditClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasRead) {
                buttons.push({
                    key: 'gc-read',
                    url: '#/' + urlUniqueHash + 'read/' + primaryKeyValue,
                    icon: 'fa fa-eye',
                    text: i18n.view,
                    onClick: onReadClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasClone) {
                buttons.push({
                    key: 'gc-clone',
                    url: '#/' + urlUniqueHash + 'clone/' + primaryKeyValue,
                    icon: 'fa fa-copy',
                    text: i18n.clone,
                    onClick: onCloneClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            if (hasActionButtons && actionButtons) {
                actionButtons.forEach(function (button) {
                    buttons.push({
                        key: button.label,
                        icon: button.iconCssClass,
                        text: button.label,
                        onClick: button.onClick,
                        newTab: false,
                        primaryKeyValue: primaryKeyValue
                    });
                });
            }

            if (hasActionButtons && backendActionButtons) {
                backendActionButtons.forEach(function (button) {
                    buttons.push({
                        key: button.label,
                        icon: button.iconCssClass,
                        text: button.label,
                        newTab: button.newTab,
                        url: button.url,
                        primaryKeyValue: primaryKeyValue
                    });
                });
            }

            if (hasDelete) {
                buttons.push({
                    key: 'gc-delete',
                    icon: 'fa fa-trash-o',
                    text: i18n.action_delete,
                    onClick: onDeleteClick,
                    newTab: false,
                    primaryKeyValue: primaryKeyValue
                });
            }

            return React.createElement(
                'td',
                { className: 'gc-actions' },
                deleteMultiple && screenSize !== 'xs' && screenSize !== 's' && React.createElement(_datagridCheckbox2.default, {
                    rowSelected: rowSelected,
                    toggleSelectRow: toggleSelectRow,
                    onRowCheckboxClick: onRowCheckboxClick,
                    primaryKeyValue: primaryKeyValue
                }),
                React.createElement(_groupButtons2.default, {
                    buttons: buttons,
                    screenSize: screenSize,
                    i18n: i18n,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                })
            );
        }
    }]);

    return DatagridActionsColumn;
}(React.Component);

DatagridActionsColumn.propTypes = {
    actionButtons: _propTypes2.default.array,
    backendActionButtons: _propTypes2.default.array,
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    screenSize: _propTypes2.default.string,
    rowSelected: _propTypes2.default.bool,
    toggleSelectRow: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string,
    i18n: _propTypes2.default.shape({
        edit: _propTypes2.default.string,
        view: _propTypes2.default.string,
        action_delete: _propTypes2.default.string,
        actions: _propTypes2.default.string,
        more: _propTypes2.default.string,
        clone: _propTypes2.default.string
    }),
    LinkButtonWrapper: _propTypes2.default.func,
    GroupButtonsList: _propTypes2.default.func
};

DatagridActionsColumn.defaultProps = {
    urlUniqueHash: ''
};

exports.default = DatagridActionsColumn;

},{"./datagrid-checkbox.jsx":68,"./wrappers/bootstrap-v3/group-buttons.jsx":73,"prop-types":190}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridCheckbox = function (_React$Component) {
    _inherits(DatagridCheckbox, _React$Component);

    function DatagridCheckbox() {
        _classCallCheck(this, DatagridCheckbox);

        return _possibleConstructorReturn(this, (DatagridCheckbox.__proto__ || Object.getPrototypeOf(DatagridCheckbox)).apply(this, arguments));
    }

    _createClass(DatagridCheckbox, [{
        key: "onCheckboxClick",
        value: function onCheckboxClick(event) {
            var _props = this.props,
                toggleSelectRow = _props.toggleSelectRow,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                primaryKeyValue = _props.primaryKeyValue;


            toggleSelectRow(primaryKeyValue);
            onRowCheckboxClick(event, primaryKeyValue);
        }
    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                rowSelected = _props2.rowSelected,
                primaryKeyValue = _props2.primaryKeyValue;


            return React.createElement("input", {
                checked: rowSelected,
                onClick: function onClick(e) {
                    return _this2.onCheckboxClick(e);
                },
                type: "checkbox",
                className: "gc-select-row",
                "data-id": primaryKeyValue
            });
        }
    }]);

    return DatagridCheckbox;
}(React.Component);

DatagridCheckbox.propTypes = {
    rowSelected: _propTypes2.default.bool,
    toggleSelectRow: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    primaryKeyValue: _propTypes2.default.string
};

exports.default = DatagridCheckbox;

},{"prop-types":190}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DatagridRow$propType;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _datagridActionsColumn = require('./datagrid-actions-column.jsx');

var _datagridActionsColumn2 = _interopRequireDefault(_datagridActionsColumn);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridRow = function (_React$Component) {
    _inherits(DatagridRow, _React$Component);

    function DatagridRow() {
        _classCallCheck(this, DatagridRow);

        return _possibleConstructorReturn(this, (DatagridRow.__proto__ || Object.getPrototypeOf(DatagridRow)).apply(this, arguments));
    }

    _createClass(DatagridRow, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                columnsData = _props.data.columnsData,
                options = _props.options,
                hasActionButtons = _props.options.hasActionButtons,
                onEditClick = _props.onEditClick,
                onCloneClick = _props.onCloneClick,
                onReadClick = _props.onReadClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                actionButtons = _props.actionButtons,
                backendActionButtons = _props.backendActionButtons,
                screenSize = _props.screenSize,
                orderBy = _props.orderBy,
                i18n = _props.i18n,
                primaryKeyValue = _props.primaryKeyValue,
                toggleSelectRow = _props.toggleSelectRow,
                rowSelected = _props.rowSelected,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList;


            var columnData = [];

            columnsData.forEach(function (column) {

                columnData.push(React.createElement(
                    'td',
                    {
                        className: (0, _classnames2.default)({
                            'active': orderBy === column.name,
                            'table-active': orderBy === column.name
                        }, 'gc-data-container'),
                        key: column.name
                    },
                    !column.value && React.createElement(
                        'span',
                        null,
                        '\xA0'
                    ),
                    column.value && !column.isHtml && React.createElement(
                        'div',
                        { className: 'gc-data-container-text' },
                        column.value
                    ),
                    column.value && column.isHtml && React.createElement('div', { className: 'gc-data-container-text', dangerouslySetInnerHTML: { __html: column.value } })
                ));
            });

            return React.createElement(
                'tr',
                {
                    className: (0, _classnames2.default)({
                        'warning': rowSelected
                    }),
                    'data-id': primaryKeyValue
                },
                hasActionButtons && React.createElement(_datagridActionsColumn2.default, {
                    options: options,
                    actionButtons: actionButtons,
                    backendActionButtons: backendActionButtons,
                    onEditClick: onEditClick,
                    onCloneClick: onCloneClick,
                    onReadClick: onReadClick,
                    onDeleteClick: onDeleteClick,
                    onRowCheckboxClick: onRowCheckboxClick,
                    urlUniqueHash: urlUniqueHash,
                    screenSize: screenSize,
                    toggleSelectRow: toggleSelectRow,
                    rowSelected: rowSelected,
                    i18n: i18n,
                    primaryKeyValue: primaryKeyValue,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                }),
                columnData
            );
        }
    }]);

    return DatagridRow;
}(React.Component);

DatagridRow.propTypes = (_DatagridRow$propType = {
    data: (0, _propTypes.shape)({
        columnsData: _propTypes2.default.array
    }),
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    actionButtons: _propTypes2.default.array,
    backendActionButtons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    primaryKeyValue: _propTypes2.default.string,
    toggleSelectRow: _propTypes2.default.func,
    rowSelected: _propTypes2.default.bool,
    LinkButtonWrapper: _propTypes2.default.func
}, _defineProperty(_DatagridRow$propType, 'LinkButtonWrapper', _propTypes2.default.func), _defineProperty(_DatagridRow$propType, 'GroupButtonsList', _propTypes2.default.func), _DatagridRow$propType);

exports.default = DatagridRow;

},{"./datagrid-actions-column.jsx":67,"classnames":124,"prop-types":190}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _datagridRow = require('./datagrid-row.jsx');

var _datagridRow2 = _interopRequireDefault(_datagridRow);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DatagridTbody = function (_React$Component) {
    _inherits(DatagridTbody, _React$Component);

    function DatagridTbody(props) {
        _classCallCheck(this, DatagridTbody);

        var _this = _possibleConstructorReturn(this, (DatagridTbody.__proto__ || Object.getPrototypeOf(DatagridTbody)).call(this, props));

        _this.state = {
            selectedIds: []
        };
        return _this;
    }

    _createClass(DatagridTbody, [{
        key: 'toggleSelectRow',
        value: function toggleSelectRow(id) {
            var selectedIds = this.state.selectedIds;


            if (selectedIds.indexOf(id) > -1) {
                selectedIds = selectedIds.filter(function (selectedId) {
                    return selectedId !== id;
                });
            } else {
                selectedIds.push(id);
            }

            this.setState({
                selectedIds: selectedIds
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props = this.props,
                rows = _props.rows,
                options = _props.options,
                orderBy = _props.orderBy,
                columns = _props.columns,
                onEditClick = _props.onEditClick,
                onCloneClick = _props.onCloneClick,
                onReadClick = _props.onReadClick,
                onDeleteClick = _props.onDeleteClick,
                onRowCheckboxClick = _props.onRowCheckboxClick,
                urlUniqueHash = _props.urlUniqueHash,
                actionButtons = _props.actionButtons,
                screenSize = _props.screenSize,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                selectedIds = this.state.selectedIds;


            return rows.map(function (row, key) {
                return React.createElement(_datagridRow2.default, {
                    columns: columns,
                    options: options,
                    data: row,
                    orderBy: orderBy,
                    key: key,
                    onEditClick: onEditClick,
                    onReadClick: onReadClick,
                    onCloneClick: onCloneClick,
                    onDeleteClick: onDeleteClick,
                    onRowCheckboxClick: onRowCheckboxClick,
                    urlUniqueHash: urlUniqueHash,
                    actionButtons: actionButtons,
                    backendActionButtons: row.backendActionButtons,
                    screenSize: screenSize,
                    toggleSelectRow: function toggleSelectRow(id) {
                        return _this2.toggleSelectRow(id);
                    },
                    i18n: i18n,
                    primaryKeyValue: row.primaryKeyValue,
                    rowSelected: selectedIds.indexOf(row.primaryKeyValue) > -1,
                    LinkButtonWrapper: LinkButtonWrapper,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                });
            });
        }
    }]);

    return DatagridTbody;
}(React.Component);

DatagridTbody.propTypes = {
    rows: _propTypes2.default.array,
    options: (0, _propTypes.shape)({
        deleteMultiple: _propTypes2.default.bool,
        hasEdit: _propTypes2.default.bool,
        hasClone: _propTypes2.default.bool,
        hasDelete: _propTypes2.default.bool,
        hasRead: _propTypes2.default.bool,
        hasActionButtons: _propTypes2.default.bool
    }),
    orderBy: _propTypes2.default.string,
    columns: _propTypes2.default.array,
    onEditClick: _propTypes2.default.func,
    onCloneClick: _propTypes2.default.func,
    onReadClick: _propTypes2.default.func,
    onDeleteClick: _propTypes2.default.func,
    onRowCheckboxClick: _propTypes2.default.func,
    urlUniqueHash: _propTypes2.default.string,
    actionButtons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    LinkButtonWrapper: _propTypes2.default.func,
    GroupPrimaryButton: _propTypes2.default.func,
    GroupButtonsList: _propTypes2.default.func
};

exports.default = DatagridTbody;

},{"./datagrid-row.jsx":69,"prop-types":190}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRowWrapper = function (_React$Component) {
    _inherits(FieldRowWrapper, _React$Component);

    function FieldRowWrapper() {
        _classCallCheck(this, FieldRowWrapper);

        return _possibleConstructorReturn(this, (FieldRowWrapper.__proto__ || Object.getPrototypeOf(FieldRowWrapper)).apply(this, arguments));
    }

    _createClass(FieldRowWrapper, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                isRequired = _props.isRequired,
                displayAs = _props.displayAs,
                FieldInput = _props.FieldInput,
                data = _props.data,
                gcrudInstance = _props.gcrudInstance,
                fetchData = _props.fetchData,
                i18n = _props.i18n,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate;


            return React.createElement(
                "div",
                { className: "form-group" },
                React.createElement(
                    "label",
                    { className: "col-sm-3 control-label" },
                    isRequired ? '*' : '',
                    displayAs
                ),
                React.createElement(
                    "div",
                    { className: "col-sm-9" },
                    React.createElement(FieldInput, {
                        data: data,
                        gcrudInstance: gcrudInstance,
                        fetchData: fetchData,
                        i18n: i18n,
                        relationalOnComponentDidMount: relationalOnComponentDidMount,
                        relationalOnComponentDidUpdate: relationalOnComponentDidUpdate
                    })
                )
            );
        }
    }]);

    return FieldRowWrapper;
}(React.Component);

FieldRowWrapper.propTypes = {
    isRequired: _propTypes2.default.bool,
    displayAs: _propTypes2.default.string,
    FieldInput: _propTypes2.default.func,
    data: _propTypes2.default.object,
    gcrudInstance: _propTypes2.default.object,
    i18n: _propTypes2.default.object,
    relationalOnComponentDidMount: _propTypes2.default.func,
    relationalOnComponentDidUpdate: _propTypes2.default.func
};

exports.default = FieldRowWrapper;

},{"prop-types":190}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtonsList = function (_React$Component) {
    _inherits(GroupButtonsList, _React$Component);

    function GroupButtonsList() {
        _classCallCheck(this, GroupButtonsList);

        return _possibleConstructorReturn(this, (GroupButtonsList.__proto__ || Object.getPrototypeOf(GroupButtonsList)).apply(this, arguments));
    }

    _createClass(GroupButtonsList, [{
        key: "render",
        value: function render() {
            var buttons = this.props.buttons;


            return React.createElement(
                "ul",
                { className: "dropdown-menu" },
                buttons.map(function (button) {
                    return React.createElement(
                        "li",
                        _defineProperty({
                            className: "dropdown-item",
                            key: button.key
                        }, "className", (0, _classnames2.default)({
                            'dropdown-submenu': button.hasSubMenu,
                            'left-direction': button.hasSubMenu && button.subMenuLeftDirection
                        })),
                        React.createElement(
                            "a",
                            {
                                href: button.href ? button.href : '',
                                onClick: button.onClick,
                                target: button.target
                            },
                            button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                            button.text
                        ),
                        button.subComponent && React.createElement(
                            "ul",
                            { className: "dropdown-menu" },
                            button.subComponent
                        )
                    );
                })
            );
        }
    }]);

    return GroupButtonsList;
}(React.Component);

GroupButtonsList.propTypes = {
    buttons: _propTypes2.default.array
};

exports.default = GroupButtonsList;

},{"classnames":124,"prop-types":190}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _defaultLinkButton = require("../../buttons/default-link-button.jsx");

var _defaultLinkButton2 = _interopRequireDefault(_defaultLinkButton);

var _defaultGroupButton = require("../../buttons/default-group-button.jsx");

var _defaultGroupButton2 = _interopRequireDefault(_defaultGroupButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtons = function (_React$Component) {
    _inherits(GroupButtons, _React$Component);

    function GroupButtons() {
        _classCallCheck(this, GroupButtons);

        return _possibleConstructorReturn(this, (GroupButtons.__proto__ || Object.getPrototypeOf(GroupButtons)).apply(this, arguments));
    }

    _createClass(GroupButtons, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                buttons = _props.buttons,
                screenSize = _props.screenSize,
                i18n = _props.i18n,
                LinkButtonWrapper = _props.LinkButtonWrapper,
                GroupPrimaryButton = _props.GroupPrimaryButton,
                GroupButtonsList = _props.GroupButtonsList,
                maxButtons = screenSize === 'xs' || screenSize === 's' ? 1 : 2,
                buttonMap = function buttonMap(button) {
                return React.createElement(_defaultLinkButton2.default, {
                    key: button.key,
                    url: button.url,
                    icon: button.icon,
                    text: button.text,
                    newTab: button.newTab,
                    rightMargin: true,
                    primaryKeyValue: button.primaryKeyValue,
                    onClick: button.onClick,
                    LinkButtonWrapper: LinkButtonWrapper
                });
            };

            if (!buttons || buttons.length === 0) {
                return null;
            }

            if (buttons.length <= maxButtons) {
                return buttons.map(buttonMap);
            }

            return React.createElement(
                "span",
                null,
                buttons.filter(function (__button, key) {
                    return key < maxButtons - 1;
                }).map(buttonMap),
                React.createElement(_defaultGroupButton2.default, {
                    buttons: buttons.filter(function (__button, key) {
                        return key >= maxButtons - 1;
                    }),
                    maxButtons: maxButtons,
                    i18n: i18n,
                    GroupPrimaryButton: GroupPrimaryButton,
                    GroupButtonsList: GroupButtonsList
                })
            );
        }
    }]);

    return GroupButtons;
}(React.Component);

GroupButtons.propTypes = {
    buttons: _propTypes2.default.array,
    screenSize: _propTypes2.default.string,
    i18n: _propTypes2.default.object,
    GroupButtonsList: _propTypes2.default.func,
    LinkButtonWrapper: _propTypes2.default.func
};

exports.default = GroupButtons;

},{"../../buttons/default-group-button.jsx":65,"../../buttons/default-link-button.jsx":66,"prop-types":190}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupPrimaryButton = function (_React$Component) {
  _inherits(GroupPrimaryButton, _React$Component);

  function GroupPrimaryButton() {
    _classCallCheck(this, GroupPrimaryButton);

    return _possibleConstructorReturn(this, (GroupPrimaryButton.__proto__ || Object.getPrototypeOf(GroupPrimaryButton)).apply(this, arguments));
  }

  _createClass(GroupPrimaryButton, [{
    key: "render",
    value: function render() {
      var props = this.props;


      return React.createElement(
        "button",
        _extends({ type: "button", className: "btn btn-default dropdown-toggle" }, props),
        props.children
      );
    }
  }]);

  return GroupPrimaryButton;
}(React.Component);

exports.default = GroupPrimaryButton;

},{}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkButtonWrapper = function (_React$Component) {
  _inherits(LinkButtonWrapper, _React$Component);

  function LinkButtonWrapper() {
    _classCallCheck(this, LinkButtonWrapper);

    return _possibleConstructorReturn(this, (LinkButtonWrapper.__proto__ || Object.getPrototypeOf(LinkButtonWrapper)).apply(this, arguments));
  }

  _createClass(LinkButtonWrapper, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          classNames = _props.classNames,
          href = _props.href,
          role = _props.role,
          onClick = _props.onClick,
          target = _props.target;


      return React.createElement(
        'a',
        {
          className: (0, _classnames2.default)('btn', 'btn-default', classNames),
          href: href,
          role: role,
          onClick: onClick,
          target: target
        },
        children
      );
    }
  }]);

  return LinkButtonWrapper;
}(React.Component);

exports.default = LinkButtonWrapper;

},{"classnames":124}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitleWrapper = function (_React$Component) {
    _inherits(ModalTitleWrapper, _React$Component);

    function ModalTitleWrapper() {
        _classCallCheck(this, ModalTitleWrapper);

        return _possibleConstructorReturn(this, (ModalTitleWrapper.__proto__ || Object.getPrototypeOf(ModalTitleWrapper)).apply(this, arguments));
    }

    _createClass(ModalTitleWrapper, [{
        key: "render",
        value: function render() {
            var title = this.props.title;


            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "button",
                    {
                        type: "button",
                        className: "close",
                        "data-dismiss": "modal",
                        "aria-label": "Close"
                    },
                    React.createElement(
                        "span",
                        { "aria-hidden": "true" },
                        "\xD7"
                    )
                ),
                React.createElement(
                    "h4",
                    { className: "modal-title" },
                    title
                )
            );
        }
    }]);

    return ModalTitleWrapper;
}(React.Component);

ModalTitleWrapper.propTypes = {
    title: _propTypes2.default.string
};

exports.default = ModalTitleWrapper;

},{"prop-types":190}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FieldRowWrapper = function (_React$Component) {
    _inherits(FieldRowWrapper, _React$Component);

    function FieldRowWrapper() {
        _classCallCheck(this, FieldRowWrapper);

        return _possibleConstructorReturn(this, (FieldRowWrapper.__proto__ || Object.getPrototypeOf(FieldRowWrapper)).apply(this, arguments));
    }

    _createClass(FieldRowWrapper, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                isRequired = _props.isRequired,
                displayAs = _props.displayAs,
                FieldInput = _props.FieldInput,
                data = _props.data,
                gcrudInstance = _props.gcrudInstance,
                fetchData = _props.fetchData,
                i18n = _props.i18n,
                relationalOnComponentDidMount = _props.relationalOnComponentDidMount,
                relationalOnComponentDidUpdate = _props.relationalOnComponentDidUpdate;


            return React.createElement(
                "div",
                { className: "form-group row" },
                React.createElement(
                    "label",
                    { className: "col-sm-3 col-form-label" },
                    isRequired ? '*' : '',
                    displayAs
                ),
                React.createElement(
                    "div",
                    { className: "col-sm-9" },
                    React.createElement(FieldInput, {
                        data: data,
                        gcrudInstance: gcrudInstance,
                        fetchData: fetchData,
                        i18n: i18n,
                        relationalOnComponentDidMount: relationalOnComponentDidMount,
                        relationalOnComponentDidUpdate: relationalOnComponentDidUpdate
                    })
                )
            );
        }
    }]);

    return FieldRowWrapper;
}(React.Component);

FieldRowWrapper.propTypes = {
    isRequired: _propTypes2.default.bool,
    displayAs: _propTypes2.default.string,
    FieldInput: _propTypes2.default.func,
    data: _propTypes2.default.object,
    gcrudInstance: _propTypes2.default.object,
    i18n: _propTypes2.default.object,
    relationalOnComponentDidMount: _propTypes2.default.func,
    relationalOnComponentDidUpdate: _propTypes2.default.func
};

exports.default = FieldRowWrapper;

},{"prop-types":190}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require("classnames");

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupButtonsList = function (_React$Component) {
    _inherits(GroupButtonsList, _React$Component);

    function GroupButtonsList() {
        _classCallCheck(this, GroupButtonsList);

        return _possibleConstructorReturn(this, (GroupButtonsList.__proto__ || Object.getPrototypeOf(GroupButtonsList)).apply(this, arguments));
    }

    _createClass(GroupButtonsList, [{
        key: "render",
        value: function render() {
            var buttons = this.props.buttons;


            return React.createElement(
                "div",
                { className: "dropdown-menu" },
                buttons.map(function (button) {
                    return !button.hasSubMenu ? React.createElement(
                        "a",
                        {
                            key: button.key,
                            href: button.href,
                            onClick: button.onClick,
                            target: button.target,
                            className: "dropdown-item"
                        },
                        button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text
                    ) : React.createElement(
                        "div",
                        {
                            key: button.key,
                            className: (0, _classnames2.default)('dropdown-item', 'dropdown-submenu', 'dropdown-submenu-item', {
                                'left-direction': button.subMenuLeftDirection
                            })
                        },
                        button.icon && React.createElement("i", { className: (0, _classnames2.default)(button.icon, 'gc-button-icon') }),
                        button.text,
                        button.subComponent && React.createElement(
                            "ul",
                            { className: "dropdown-menu" },
                            button.subComponent
                        )
                    );
                })
            );
        }
    }]);

    return GroupButtonsList;
}(React.Component);

GroupButtonsList.propTypes = {
    buttons: _propTypes2.default.array
};

exports.default = GroupButtonsList;

},{"classnames":124,"prop-types":190}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GroupPrimaryButton = function (_React$Component) {
  _inherits(GroupPrimaryButton, _React$Component);

  function GroupPrimaryButton() {
    _classCallCheck(this, GroupPrimaryButton);

    return _possibleConstructorReturn(this, (GroupPrimaryButton.__proto__ || Object.getPrototypeOf(GroupPrimaryButton)).apply(this, arguments));
  }

  _createClass(GroupPrimaryButton, [{
    key: "render",
    value: function render() {
      var props = this.props;


      return React.createElement(
        "button",
        _extends({ type: "button", className: "btn btn-outline-dark dropdown-toggle" }, props),
        props.children
      );
    }
  }]);

  return GroupPrimaryButton;
}(React.Component);

exports.default = GroupPrimaryButton;

},{}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LinkButtonWrapper = function (_React$Component) {
    _inherits(LinkButtonWrapper, _React$Component);

    function LinkButtonWrapper() {
        _classCallCheck(this, LinkButtonWrapper);

        return _possibleConstructorReturn(this, (LinkButtonWrapper.__proto__ || Object.getPrototypeOf(LinkButtonWrapper)).apply(this, arguments));
    }

    _createClass(LinkButtonWrapper, [{
        key: 'render',
        value: function render() {
            var _props = this.props,
                children = _props.children,
                classNames = _props.classNames,
                href = _props.href,
                role = _props.role,
                onClick = _props.onClick,
                target = _props.target;


            return React.createElement(
                'a',
                {
                    className: (0, _classnames2.default)('btn', 'btn-outline-dark', classNames),
                    href: href,
                    role: role,
                    onClick: onClick,
                    target: target
                },
                children
            );
        }
    }]);

    return LinkButtonWrapper;
}(React.Component);

exports.default = LinkButtonWrapper;

},{"classnames":124}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalTitleWrapper = function (_React$Component) {
    _inherits(ModalTitleWrapper, _React$Component);

    function ModalTitleWrapper() {
        _classCallCheck(this, ModalTitleWrapper);

        return _possibleConstructorReturn(this, (ModalTitleWrapper.__proto__ || Object.getPrototypeOf(ModalTitleWrapper)).apply(this, arguments));
    }

    _createClass(ModalTitleWrapper, [{
        key: "render",
        value: function render() {
            var title = this.props.title;


            return React.createElement(
                React.Fragment,
                null,
                React.createElement(
                    "h4",
                    { className: "modal-title" },
                    title
                ),
                React.createElement(
                    "button",
                    {
                        type: "button",
                        className: "close",
                        "data-dismiss": "modal",
                        "aria-label": "Close"
                    },
                    React.createElement(
                        "span",
                        { "aria-hidden": "true" },
                        "\xD7"
                    )
                )
            );
        }
    }]);

    return ModalTitleWrapper;
}(React.Component);

ModalTitleWrapper.propTypes = {
    title: _propTypes2.default.string
};

exports.default = ModalTitleWrapper;

},{"prop-types":190}],82:[function(require,module,exports){
'use strict';

var _perPageDropdown = require('../modules/react/jsx/datagrid/footer/per-page-dropdown.jsx');

var _perPageDropdown2 = _interopRequireDefault(_perPageDropdown);

var _filtering = require('../../../../React-Components/gce-react-datagrid-filtering/filtering');

var _filtering2 = _interopRequireDefault(_filtering);

var _datagridTbody = require('../../../../React-Components/gce-react-datagrid/datagrid-tbody.jsx');

var _datagridTbody2 = _interopRequireDefault(_datagridTbody);

var _settings = require('../../../../React-Components/gce-datagrid-settings/gce-datagrid-settings/settings.jsx');

var _settings2 = _interopRequireDefault(_settings);

var _groupPrimaryButton = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-primary-button.jsx');

var _groupPrimaryButton2 = _interopRequireDefault(_groupPrimaryButton);

var _groupButtonsList = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-buttons-list.jsx');

var _groupButtonsList2 = _interopRequireDefault(_groupButtonsList);

var _linkButtonWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/link-button-wrapper.jsx');

var _linkButtonWrapper2 = _interopRequireDefault(_linkButtonWrapper);

var _fieldRowWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/field-row-wrapper');

var _fieldRowWrapper2 = _interopRequireDefault(_fieldRowWrapper);

var _modalTitleWrapper = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/modal-title-wrapper');

var _modalTitleWrapper2 = _interopRequireDefault(_modalTitleWrapper);

var _groupPrimaryButton3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-primary-button.jsx');

var _groupPrimaryButton4 = _interopRequireDefault(_groupPrimaryButton3);

var _groupButtonsList3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-buttons-list.jsx');

var _groupButtonsList4 = _interopRequireDefault(_groupButtonsList3);

var _linkButtonWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/link-button-wrapper.jsx');

var _linkButtonWrapper4 = _interopRequireDefault(_linkButtonWrapper3);

var _fieldRowWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/field-row-wrapper');

var _fieldRowWrapper4 = _interopRequireDefault(_fieldRowWrapper3);

var _modalTitleWrapper3 = require('../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/modal-title-wrapper');

var _modalTitleWrapper4 = _interopRequireDefault(_modalTitleWrapper3);

var _title = require('../../../../React-Components/gce-crud-forms/modal/title.jsx');

var _title2 = _interopRequireDefault(_title);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-line no-unused-vars


// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
var Handlebars = require('../libraries/HandlebarsExtended').Handlebars,
    _ = require('underscore'),
    $ = jQuery,
    jQueryPlugins = require('../modules/jquery/jquery-plugins').jQueryPlugins,
    Constants = require('../sections/constants').Constants,
    ajaxHelper = require('../helpers/ajax-helper').ajaxHelper,
    i18n = require('../sections/i18n').i18n,
    localStorageHelper = require('../helpers/local-storage-helper').localStorageHelper,
    Grid = require('./../sections/datagrid/datagrid.grid.js').Grid,
    OperationAdd = require('./../sections/operations/add.js').OperationAdd,
    OperationEdit = require('./../sections/operations/edit.js').OperationEdit,
    OperationClone = require('./../sections/operations/clone.js').OperationClone,
    OperationRead = require('./../sections/operations/read.js').OperationRead,
    OperationDelete = require('./../sections/operations/delete.js').OperationDelete,
    OperationsCommon = require('./../sections/operations/common.js').OperationsCommon,
    Column = require('../sections/datagrid/column').Column,
    DatagridColumns = require('../sections/datagrid/datagrid.columns').DatagridColumns,
    DatagridPaging = require('../sections/datagrid/datagrid.paging').DatagridPaging,
    DatagridHeaderActions = require('./../sections/datagrid/datagrid.header-actions.js').DatagridHeaderActions,
    DatagridSearch = require('./../sections/datagrid/datagrid.search.js').DatagridSearch,
    Router = require('../sections/routes/router').Router,

/**
 * This is the basic Object that does all the functionality for GroceryCrud
 *
 * @class GroceryCrud
 * @param {jQuery} gcrud_container
 * @param Object settings
 * @constructor
 */
GroceryCrud = function GroceryCrud(gcrud_container, settings) {

    /**
     *
     * @type {jQuery}
     */
    this.$gc = gcrud_container;
    this.settings = settings;
}; // eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars
// eslint-disable-line no-unused-vars


if ($.fn !== undefined) {
    require('../jquery-plugins/printThis');
    require('../jquery-plugins/transition');
    require('../jquery-plugins/modal');
    require('../jquery-plugins/chosen.jquery');
    require('../libraries/jquery-ui-timepicker');
}

//GroceryCrud public variables
GroceryCrud.prototype.insertFields = [];
GroceryCrud.prototype.url = '';
GroceryCrud.prototype.indexedColumns = {};
GroceryCrud.prototype.hasActions = '';
GroceryCrud.prototype.enumFields = [];
GroceryCrud.prototype.enumFieldsData = [];
GroceryCrud.prototype.dropdownFields = [];
GroceryCrud.prototype.dropdownFieldsData = [];
GroceryCrud.prototype.checkboxBooleanFields = [];
GroceryCrud.prototype.checkboxBooleanFieldsData = [];

GroceryCrud.prototype.relationNtoNFields = {};
GroceryCrud.prototype.relationNtoNData = {};
GroceryCrud.prototype.multipleSelectFields = {};
GroceryCrud.prototype.multipleSelectData = {};
GroceryCrud.prototype.texteditorFields = {};
GroceryCrud.prototype.callbackColumnFields = {};

GroceryCrud.prototype.components = {
    GroupPrimaryButton: null,
    GroupButtonsList: null,
    LinkButtonWrapper: null,
    FieldRowWrapper: null,
    ModalTitleWrapper: null
};

GroceryCrud.prototype.relationFields = [];
GroceryCrud.prototype.relationData = {};
GroceryCrud.prototype.uploadFields = [];
GroceryCrud.prototype.uploadFieldsData = {};
GroceryCrud.prototype.dateFields = [];
GroceryCrud.prototype.datetimeFields = [];
GroceryCrud.prototype.dateFormatter = null;
GroceryCrud.prototype.updateFields = [];
GroceryCrud.prototype.readFields = [];
GroceryCrud.prototype.cloneFields = [];
GroceryCrud.prototype.columns = [];
GroceryCrud.prototype.visibleColumns = [];
GroceryCrud.prototype.search_timer = null;
GroceryCrud.prototype.cachedInitialData = null;
GroceryCrud.prototype.primaryKeyField = null;
GroceryCrud.prototype.jsonData = {};
GroceryCrud.prototype.rowsData = null;
GroceryCrud.prototype.uniqueId = null;
GroceryCrud.prototype.dateFormat = null;
GroceryCrud.prototype.datagridStore = null;
GroceryCrud.prototype.hashEvent = null;
GroceryCrud.prototype.stringVariables = {
    subject: 'Record',
    subjectPlural: ''
};

GroceryCrud.prototype.init = function init() {
    this.getInitData();
};

GroceryCrud.prototype.componentsInit = function componentsInit() {
    if (this.cachedInitialData.config.skin === 'bootstrap-v4') {
        this.components.GroupButtonsList = _groupButtonsList4.default;
        this.components.GroupPrimaryButton = _groupPrimaryButton4.default;
        this.components.LinkButtonWrapper = _linkButtonWrapper4.default;
        this.components.FieldRowWrapper = _fieldRowWrapper4.default;
        this.components.ModalTitleWrapper = _modalTitleWrapper4.default;
    } else {
        this.components.GroupButtonsList = _groupButtonsList2.default;
        this.components.GroupPrimaryButton = _groupPrimaryButton2.default;
        this.components.LinkButtonWrapper = _linkButtonWrapper2.default;
        this.components.FieldRowWrapper = _fieldRowWrapper2.default;
        this.components.ModalTitleWrapper = _modalTitleWrapper2.default;
    }
};

GroceryCrud.prototype.initFacade = function initFacade() {
    Router.setRoutes.apply(this);
    this.componentsInit();
    this.datagridInit();

    jQueryPlugins.init();

    OperationAdd.listenerAddButton.apply(this);
    OperationsCommon.listenerSubmitForm.apply(this);
    OperationDelete.listenerDeleteSingleModal.apply(this);
    OperationDelete.listenerDeleteMultiple.apply(this);
    OperationDelete.listenerDeleteMultipleModal.apply(this);
    OperationsCommon.initReduxStore.apply(this);

    DatagridSearch.listenerSearchButton.apply(this);
    Grid.listenerColumnWithOrdering.apply(this);
    Grid.listenerPagingButtons.apply(this);
    DatagridHeaderActions.listenerPrintButton.apply(this);
    this.listenerPerPage();

    this.listenerOnScreenResize();

    this.initializeFieldTypesData();

    Column.initCachedData.apply(this);

    // All these MUST be after the initializeFieldTypesData and initCachedData
    DatagridColumns.setVisibleColumns.apply(this);
    this.renderSettingsButton.apply(this);
    this.enableFilteringComponent.apply(this);

    this.initializingData();

    Router.init.apply(this);
};

GroceryCrud.prototype.listenerOnScreenResize = function listenerOnScreenResize() {
    var resizerTimeout = null; // eslint-disable-line no-unused-vars
    if (window) {
        window.addEventListener('resize', function onWindowResize() {
            if (resizerTimeout !== null) {
                clearTimeout(resizerTimeout);
            }

            resizerTimeout = setTimeout(function windowResizeTimeout() {
                resizerTimeout = null;

                if (this.rowsData !== null) {
                    this.renderDatagridBody(this.rowsData);
                }

                this.enableFilteringComponent();
            }.bind(this), 250);
        }.bind(this));
    }
};

GroceryCrud.prototype._filteringOnSubmitCallback = function _filteringOnSubmitCallback(event) {
    var dataToSend = ajaxHelper.getMultilayerPostDataFromForm.apply(this, [$(event.target)]),
        hiddenFieldsHtml = '',
        numberOfFilters = 0;
    var per_page = Grid.getPerPage.apply(this),
        order_by = Grid.getOrderBy.apply(this),
        sorting = Grid.getSorting.apply(this);

    _.each(dataToSend, function foreachDataToSend(fieldValue, fieldName) {
        var className = /^extended_search/.test(fieldName) ? 'gc-extended-search-input' : '';

        if (/^extended_search\[\d+\]\[name\]$/.test(fieldName)) {
            numberOfFilters++;
        }

        hiddenFieldsHtml += '<input type="hidden" name="' + fieldName + '" value="' + fieldValue + '" class="' + className + '" />';
    });

    $('.gc-hidden-search-inputs').html(hiddenFieldsHtml);

    if (this.cachedInitialData.csrfToken) {
        dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
    }

    dataToSend.action = 'datagrid';
    dataToSend.page = '1';
    dataToSend.per_page = per_page;
    dataToSend.order_by = order_by;
    dataToSend.sorting = sorting;

    this.$gc.find('.page-number-input').val('1');
    this.$gc.find('.page-number-hidden').val('1');

    event.preventDefault();
    this.$gc.find('.gc-filtering-modal').gc_modal('hide');

    this.sendPostRequest({
        url: this.$gc.data('url'),
        dataToSend: dataToSend,
        successCallback: function successCallback(jsonResponse) {
            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            this.renderDatagrid(jsonResponse);
            this.createDatagrid(jsonResponse);
            Grid.updateGridDetails.apply(this, [jsonResponse]);
            DatagridColumns.triggerColumnsRender.apply(this);
            this.$gc.find('.gc-filter-button').addClass('btn-success').removeClass('btn-outline-dark');
            this.$gc.find('.gc-remove-filter-container').removeClass('hidden');
            this.$gc.find('.gc-filter-text').addClass('hidden');
            this.$gc.find('.gc-filter-counter').removeClass('hidden');
            this.$gc.find('.gc-filter-counter-number').html(numberOfFilters.toString());

            if (numberOfFilters === 1) {
                this.$gc.find('.gc-filter-counter-text').removeClass('hidden');
                this.$gc.find('.gc-filter-counter-text-plural').addClass('hidden');
            } else {
                this.$gc.find('.gc-filter-counter-text').addClass('hidden');
                this.$gc.find('.gc-filter-counter-text-plural').removeClass('hidden');
            }
        }.bind(this)
    });
};

GroceryCrud.prototype.enableFilteringComponent = function enableFilteringComponent() {
    var _this = this;

    var gcInstance = this,
        searchableSelect = {
        onMount: function onSearchableMount() {
            setTimeout(function timeOutforSearchableSelect() {
                $(ReactDOM.findDOMNode(this)).chosen({
                    allow_single_deselect: true
                });
            }.bind(this), 500);
        },
        onUpdate: function onSearchableUpdate() {
            $(ReactDOM.findDOMNode(this)).trigger('chosen:updated');
        }
    },
        inputDatetime = {
        onMount: function onDateMount() {
            $(ReactDOM.findDOMNode(this)).datetimepicker({
                dateFormat: gcInstance.dateFormat
            });
        }
    },
        inputDate = {
        onMount: function onDateMount() {
            $(ReactDOM.findDOMNode(this)).datepicker({
                dateFormat: gcInstance.dateFormat
            });
        }
    };
    if (!this.settings.datagridSearchAllInput) {
        ReactDOM.render(React.createElement(_filtering2.default, {
            ModalTitle: function ModalTitle(props) {
                return React.createElement(_title2.default, {
                    ModalTitleWrapper: _this.components.ModalTitleWrapper,
                    title: props.title
                });
            },
            i18n: {
                basic_operator: i18n.t('filtering_operator'),
                and_statement: i18n.t('filtering_and_statement'),
                or_statement: i18n.t('filtering_or_statement'),
                filtering: i18n.t('filtering_text'),
                filter: i18n.t('filtering_filter_text'),
                cancel_filtering: i18n.t('filtering_cancel'),
                add_more: i18n.t('filtering_add_more'),
                remove_filter: i18n.t('filtering_remove_filter'),
                comparison_contains: i18n.t('filtering_contains'),
                comparison_starts_with: i18n.t('filtering_starts_with'),
                comparison_ends_with: i18n.t('filtering_ends_with'),
                comparison_equals: i18n.t('filtering_equals'),
                comparison_not_equals: i18n.t('filtering_not_equals'),
                comparison_is_empty: i18n.t('filtering_is_empty'),
                comparison_is_not_empty: i18n.t('filtering_is_not_empty'),
                comparison_greater_than: i18n.t('filtering_greater_than'),
                comparison_less_than: i18n.t('filtering_less_than'),
                comparison_greater_than_or_equal: i18n.t('filtering_greater_than_or_equal'),
                comparison_less_than_or_equal: i18n.t('filtering_less_than_or_equal'),
                comparison_has: i18n.t('filtering_has'),
                comparison_does_not_have: i18n.t('filtering_does_not_have')
            },
            screenSize: this.getScreenWidth(),
            fields: this.getFieldsForFiltering.apply(this),
            onSubmitCallback: this._filteringOnSubmitCallback.bind(this),
            onInputMount: {
                date: inputDate,
                datetime: inputDatetime,
                timestamp: inputDatetime,
                enum_searchable: searchableSelect,
                dropdown_search: searchableSelect,
                relational: searchableSelect,
                relational_n_n: searchableSelect
            }
        }), this.$gc.find('.gc-filtering-container')[0]);
    }
};

GroceryCrud.prototype.renderSettingsButton = function renderVisibleColumnsCheckboxes() {
    var _this2 = this;

    var refreshCallback = function refreshCallback() {
        Grid.searchAndOrderingTrigger.apply(_this2);
    },
        subMenuLeftDirection = !this.cachedInitialData.operations.exportData || !this.cachedInitialData.operations.print,
        clearFilteringCallback = function clearFilteringCallback() {
        _this2.$gc.find('.gc-searchable-input').val('');
        _this2.$gc.find('.gc-searchable-select').val('');
        _this2.$gc.find('.gc-searchable-checkbox').prop('checked', false);
        _this2.$gc.find('.gc-search-input').val('').blur();
        _this2.$gc.find('.gc-hidden-search-inputs').html('');

        Grid.searchAndOrderingTrigger.apply(_this2);
    },
        clearCacheCallback = function clearCacheCallback() {
        localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + _this2.uniqueId);
        localStorageHelper.removeLocalStorageItem('gcrudVisibleColumns_' + _this2.uniqueId);
        localStorageHelper.removeLocalStorageItem('gcrudPreferences');
    },
        visibleColumnsCallback = function visibleColumnsCallback(visibleColumns) {
        var filteredVisibleColumns = DatagridColumns.filterVisibleColumns.apply(_this2, [visibleColumns]);
        DatagridColumns.triggerColumnsRender.apply(_this2, [filteredVisibleColumns]);
        DatagridColumns.setCacheForVisibleColumns.apply(_this2, [visibleColumns]);
        _this2.createDatagrid();
    },
        _components = this.components,
        GroupPrimaryButton = _components.GroupPrimaryButton,
        GroupButtonsList = _components.GroupButtonsList;


    ReactDOM.render(React.createElement(_settings2.default, {
        subMenuLeftDirection: subMenuLeftDirection,
        onRefreshCallback: refreshCallback,
        onClearFilteringCallback: clearFilteringCallback,
        onClearCacheCallback: clearCacheCallback,
        columns: this.columns,
        visibleColumns: this.visibleColumns,
        gcrudInstance: this,
        visibleColumnsCallbackOnChange: visibleColumnsCallback,
        i18n: this.cachedInitialData.i18n,
        GroupPrimaryButton: GroupPrimaryButton,
        GroupButtonsList: GroupButtonsList
    }), this.$gc.find('.gc-settings-button-container')[0]);
};

GroceryCrud.prototype.renderDatagrid = function rerenderDatagrid(data) {
    if (data !== undefined) {
        this.jsonData = data;
    }
};

GroceryCrud.prototype.getInitData = function getInitData() {


    this.uniqueId = this.$gc.data('unique-id');
    this.url = this.$gc.data('url');

    this.sendGetRequest({
        url: this.$gc.data('url'),
        dataToSend: {
            action: Constants.ACTION_INIT_DATA
        },
        successCallback: function successCallback(jsonResponse) {

            this.setInitVariables(jsonResponse);
            this.cachedInitialData = jsonResponse;

            this.initFacade();
        }.bind(this)
    });
};

GroceryCrud.prototype.dynamicTranslation = function dynamicTranslation(i18nStrings) {
    var pagingSubString;

    i18nStrings.confirm_delete_multiple = i18n.format(i18nStrings.confirm_delete_multiple, {
        items_amount: '<span class="gc-delete-count"></span>'
    });

    i18nStrings.paging_displaying = i18n.format(i18nStrings.paging_displaying, {
        start: '<span class="paging-starts">1</span>',
        end: '<span class="paging-ends">10</span>',
        results: '<span class="current-total-results"></span>'
    });

    pagingSubString = i18nStrings.paging_show_entries.match(/(.*)+\{paging\}(.*)+/);
    i18nStrings.paging_show_entries = {
        first: pagingSubString !== null ? pagingSubString[1] : '',
        second: pagingSubString !== null ? pagingSubString[2] : ''
    };

    i18nStrings.paging_filtered_from = i18n.format(i18nStrings.paging_filtered_from, {
        total_results: '<span class="full-total"></span>'
    });
};

// GC-195: Automatically render the submenu to the left if there is not enough space.
GroceryCrud.prototype.subMenuOverflowCheck = function subMenuOverflowCheck() {
    var settingsButtonOffset = this.$gc.find('.gc-settings-button').offset();
    if (settingsButtonOffset && settingsButtonOffset.left + 160 + 180 > $(window).width()) {
        this.$gc.find('.gc-settings-button').next().find('.dropdown-submenu').addClass('left-direction');
    }
};

GroceryCrud.prototype.datagridInit = function datagridInit() {
    var i18nStrings = this.cachedInitialData.i18n,
        initData = this.cachedInitialData;

    this.dynamicTranslation(i18nStrings);

    this.stringVariables.isBootstrapV4 = this.cachedInitialData.config.skin === 'bootstrap-v4';
    this.stringVariables.addUrl = '#/' + this.hashEvent.addItem;
    this.stringVariables.operationAddEnabled = initData.operations.add;
    this.stringVariables.operationExportEnabled = initData.operations.exportData;
    this.stringVariables.operationPrintEnabled = initData.operations.print;

    this.$gc.find(Constants.SELECTOR_SEARCH_ROW).append(this.handlebarsTemplate('.gc-header-actions-operations', {
        isBootstrapV4: this.stringVariables.isBootstrapV4,
        deleteMultiple: initData.operations.deleteMultiple,
        hasActionButtons: this.datagridHasActions.apply(this),
        i18n: i18nStrings
    }));

    this.$gc.find('.footer-tools').append(this.handlebarsTemplate('.gc-footer-template', {
        i18n: i18nStrings,
        isBootstrapV4: this.stringVariables.isBootstrapV4
    }));

    this.$gc.find(Constants.SELECTOR_DATAGRID_CONTAINER).prepend(this.handlebarsTemplate(Constants.HANDLEBARS_TEMPLATE_CAPTION_TITLE, {
        subject: this.cachedInitialData.subject.subject_single,
        subjectPlural: this.cachedInitialData.subject.subject_plural
    }));

    this.$gc.find(Constants.SELECTOR_HEADER_TOOLS).prepend(this.handlebarsTemplate(Constants.HANDLEBARS_ADD_BUTTON, {
        operationAddEnabled: this.stringVariables.operationAddEnabled,
        addUrl: this.stringVariables.addUrl,
        addItemString: i18n.format(i18nStrings.add_item, {
            subject: this.cachedInitialData.subject.subject_single
        })
    }));

    this.$gc.find('.gc-export-button-container').html(this.handlebarsTemplate(Constants.HANDLEBARS_EXPORT_BUTTON, {
        operationExportEnabled: this.stringVariables.operationExportEnabled,
        i18n: i18nStrings
    }));

    this.$gc.find('.gc-print-button-container').html(this.handlebarsTemplate(Constants.HANDLEBARS_PRINT_BUTTON, {
        operationPrintEnabled: this.stringVariables.operationPrintEnabled,
        i18n: i18nStrings
    }));

    this.$gc.find('.gc-search-filter-button-container').html(this.handlebarsTemplate('.search-button-template', {
        i18n: i18nStrings,
        searchAllButton: this.settings.datagridSearchAllInput
    }));

    this.subMenuOverflowCheck.apply(this);

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_INSERT_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_DELETE_SINGLE_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.prepend(this.handlebarsTemplate(Constants.HANDLEBARS_DELETE_MUTLIPLE_MODAL, {
        i18n: i18nStrings
    }));

    this.$gc.find('.paging-entries-container').prepend(this.handlebarsTemplate('.paging-entries-template', {
        i18n: i18nStrings
    }));

    // After the paging is rendered we will also need to add the pagingComponent
    ReactDOM.render(React.createElement(_perPageDropdown2.default, { defaultPerPage: initData.paging.defaultPerPage, pagingOptions: initData.paging.pagingOptions }), this.$gc.find('.per-page-container')[0]);

    this.$gc.find('.displaying-paging-container').prepend(this.handlebarsTemplate('.displaying-paging-template', {
        i18n: i18nStrings
    }));

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.error_generic_title
    }), this.$gc.find('.gc-error-modal').find('.modal-header')[0]);

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.action_delete
    }), this.$gc.find('.delete-single-confirmation').find('.modal-header')[0]);

    ReactDOM.render(React.createElement(_title2.default, {
        ModalTitleWrapper: this.components.ModalTitleWrapper,
        title: i18nStrings.action_delete
    }), this.$gc.find('.gc-delete-multiple-confirmation').find('.modal-header')[0]);

    i18n.init(i18nStrings);
};

GroceryCrud.prototype.getFieldsForFiltering = function getFieldsForFiltering() {
    var fields = [],
        indexedColumns = {};
    var _cachedInitialData = this.cachedInitialData,
        fieldTypesColumns = _cachedInitialData.fieldTypesColumns,
        columns = _cachedInitialData.columns;


    columns.forEach(function (column) {
        indexedColumns[column.name] = column.displayAs;
    });

    Object.keys(fieldTypesColumns).forEach(function forEachFieldTypesColumns(fieldName) {
        if (indexedColumns[fieldName]) {
            fields.push({
                fieldName: fieldName,
                type: fieldTypesColumns[fieldName].dataType,
                displayAs: indexedColumns[fieldName],
                permittedValues: fieldTypesColumns[fieldName].permittedValues
            });
        }
    });

    return fields;
};

/**
 *
 * @param {String} selector
 * @returns {jQuery}
 */
GroceryCrud.prototype.find = function find(selector) {
    return this.$gc.find(selector);
};

GroceryCrud.prototype.setInitVariables = function setInitVariables(data) {
    this.columns = [];

    _.each(data.columns, function foreachColumns(column) {
        this.columns.push({
            columnName: column.name,
            displayAs: column.displayAs
        });

        this.indexedColumns[column.name] = column.displayAs;
    }.bind(this));
};

GroceryCrud.prototype.sendGetRequest = function sendGetRequest(options) {
    options.url = !_.isUndefined(options.url) ? options.url : this.$gc.data('url');

    return ajaxHelper.sendGetRequest.apply(this, [options]);
};

GroceryCrud.prototype.sendPostRequest = function sendPostRequest(options) {
    options.url = !_.isUndefined(options.url) ? options.url : this.$gc.data('url');

    return ajaxHelper.sendPostRequest.apply(this, [options]);
};

GroceryCrud.prototype.handlebarsTemplate = function handlebarsTemplate(stringSelector, templateObject) {

    var handlebarsTemplateCompiled = Handlebars.compile(this.$gc.find(stringSelector).html());

    return handlebarsTemplateCompiled(templateObject);
};

GroceryCrud.prototype.datagridHasActions = function datagridHasActions() {
    return this.cachedInitialData.operations.deleteSingle || this.cachedInitialData.operations.edit || this.cachedInitialData.operations.read || this.cachedInitialData.operations.actionButtons || this.settings.actionButtons.length > 0;
};

GroceryCrud.prototype.initializeFieldTypesData = function initializeFieldTypesData() {
    var fieldTypesAddForm = {},
        fieldTypesEditForm = {},
        fieldTypesCloneForm = {},
        fieldTypesReadForm = {},
        fieldTypesColumns = {};

    _.each(this.cachedInitialData.fieldTypes, function fieldTypesForEarch(fieldTypeObject, fieldName) {
        fieldTypesAddForm[fieldName] = fieldTypeObject;
        fieldTypesEditForm[fieldName] = fieldTypeObject;
        fieldTypesCloneForm[fieldName] = fieldTypeObject;
        fieldTypesReadForm[fieldName] = fieldTypeObject;
        fieldTypesColumns[fieldName] = fieldTypeObject;
    });

    // overriding the field types
    _.each(this.cachedInitialData.fieldTypesAddForm, function fieldTypesAddFormForEach(fieldTypeObject, fieldName) {
        fieldTypesAddForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesEditForm, function fieldTypesEditFormForEach(fieldTypeObject, fieldName) {
        fieldTypesEditForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesCloneForm, function fieldTypesCloneFormForEach(fieldTypeObject, fieldName) {
        fieldTypesCloneForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesReadForm, function fieldTypesReadFormForEach(fieldTypeObject, fieldName) {
        fieldTypesReadForm[fieldName] = fieldTypeObject;
    });

    _.each(this.cachedInitialData.fieldTypesColumns, function fieldTypesColumnsForEach(fieldTypeObject, fieldName) {
        fieldTypesColumns[fieldName] = fieldTypeObject;
    });

    this.cachedInitialData.fieldTypesAddForm = fieldTypesAddForm;
    this.cachedInitialData.fieldTypesEditForm = fieldTypesEditForm;
    this.cachedInitialData.fieldTypesCloneForm = fieldTypesCloneForm;
    this.cachedInitialData.fieldTypesReadForm = fieldTypesReadForm;
    this.cachedInitialData.fieldTypesColumns = fieldTypesColumns;

    switch (this.cachedInitialData.config.dateFormat) {
        case 'uk-date':
            this.dateFormat = 'dd/mm/yy';
            break;

        case 'us-date':
            this.dateFormat = 'mm/dd/yy';
            break;

        case 'sql-date':
            this.dateFormat = 'yy-mm-dd';
            break;
    }
};

/**
 * Having the first call into the backend in order to fill our datagrid with some data
 */
GroceryCrud.prototype.initializingData = function initializingData() {
    var dataToSend = {},
        cachedData,
        cachedPreferences,
        column_title,
        $columnToOrder,
        readOnlyAddFields = {},
        readOnlyEditFields = {},
        readOnlyCloneFields = {};

    Grid.setExportUrl.apply(this);
    dataToSend.action = Constants.ACTION_DATAGRID;

    if (this.cachedInitialData.csrfToken) {
        dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
    }

    this.hasActions = this.datagridHasActions.apply(this);

    _.each(this.cachedInitialData.readOnlyAddFields, function readOnlyAddFieldsForEarch(field) {
        readOnlyAddFields[field] = true;
    });
    this.cachedInitialData.readOnlyAddFields = readOnlyAddFields;

    _.each(this.cachedInitialData.readOnlyCloneFields, function readOnlyCloneFieldsForEarch(field) {
        readOnlyCloneFields[field] = true;
    });
    this.cachedInitialData.readOnlyCloneFields = readOnlyCloneFields;

    _.each(this.cachedInitialData.readOnlyEditFields, function readOnlyEditFieldsForEarch(field) {
        readOnlyEditFields[field] = true;
    });
    this.cachedInitialData.readOnlyEditFields = readOnlyEditFields;

    cachedData = localStorageHelper.getLocalStorageItem('gcrudInitialData_' + this.uniqueId);
    cachedPreferences = localStorageHelper.getLocalStorageItem('gcrudPreferences');

    if (cachedData) {
        cachedData = JSON.parse(cachedData);
        dataToSend.order_by = cachedData.order_by;
        dataToSend.sorting = cachedData.sorting;

        if (cachedPreferences) {
            cachedPreferences = JSON.parse(cachedPreferences);
            dataToSend.per_page = cachedPreferences.per_page;
            this.$gc.find('.per_page').val(dataToSend.per_page);
        }

        $columnToOrder = this.$gc.find('.column-with-ordering[data-order-by="' + dataToSend.order_by + '"]');
        column_title = $columnToOrder.addClass('active table-active ordering-' + dataToSend.sorting).text();

        if (dataToSend.order_by && dataToSend.sorting) {
            this.$gc.find('.gc-order-by-hidden').val(dataToSend.order_by);
            this.$gc.find('.gc-sorting-hidden').val(dataToSend.sorting);
        }

        column_title = $.trim(column_title);

        $columnToOrder.html('<div>' + column_title + '</div>');
    }

    this.sendPostRequest({
        url: this.$gc.data('url'),
        dataToSend: dataToSend,
        successCallback: function successCallback(jsonResponse) {
            var columnIndex, pagingEnds;

            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            this.$gc.find('.current-total-results').html(jsonResponse.filtered_total);
            this.$gc.find('.full-total').html(jsonResponse.filtered_total);
            this.createDatagrid(jsonResponse);

            if (dataToSend.sorting !== undefined) {
                columnIndex = $columnToOrder.index() + 1;
                $columnToOrder.closest('.grocery-crud-table').find('thead tr td:nth-child(' + columnIndex + ')').addClass('active table-active');
            }

            if (jsonResponse.csrfToken) {
                this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
            }

            pagingEnds = dataToSend.per_page > jsonResponse.filtered_total ? jsonResponse.filtered_total : dataToSend.per_page;

            this.$gc.find('.paging-ends').html(pagingEnds);
            DatagridPaging.pagingCalculations.apply(this);
        }.bind(this),
        errorCallback: function datagridErrorCallback() {
            localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + this.uniqueId);
        }.bind(this)
    });
};

GroceryCrud.prototype.transformRowsData = function transformRowsData(result) {
    var rows = [];

    _.each(result.data, function eachData(dataObject) {
        rows.push(Column.getRowsData.apply(this, [dataObject]));
    }.bind(this));

    return rows;
};

/**
 * Get the tbody from the response with HandleBars template
 * */
GroceryCrud.prototype.getTableBodyFromResponse = function getTableBodyFromResponse(result) {
    var row_html = this.$gc.find(Constants.HANDLEBARS_TEMPLATE_ROW).html(),
        row_template = Handlebars.compile(row_html),
        rows = this.transformRowsData(result);

    return row_template({ rows: rows });
};

GroceryCrud.prototype.onEditClick = function onEditClick(primaryKeyValue) {
    OperationEdit.onEditClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onCloneClick = function onCloneClick(primaryKeyValue) {
    OperationClone.onCloneClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onReadClick = function onReadClick(primaryKeyValue) {
    OperationRead.onReadClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.onDeleteClick = function onDeleteClick(primaryKeyValue) {
    OperationDelete.onDeleteClick.apply(this, [primaryKeyValue]);
};

GroceryCrud.prototype.createDatagrid = function createDatagrid(data) {
    if (data !== undefined) {
        this.jsonData = data;
    }

    this.rowsData = this.transformRowsData(this.jsonData);

    this.renderDatagridBody.apply(this, [this.rowsData]);

    /*this.listenerActionKeys();
    OperationDelete.listenerSelectRow.apply(this);
    Grid.activateOrderingRows.apply(this);*/
};

GroceryCrud.prototype.getScreenWidth = function getScreenWidth() {
    if (window && window.matchMedia) {

        if (window.matchMedia('(max-width: 576px)').matches) {
            return 'xs';
        }

        if (window.matchMedia('(max-width: 768px)').matches) {
            return 's';
        }
    }

    return 'l';
};

GroceryCrud.prototype.renderDatagridBody = function renderDatagridBody(rows) {
    var _cachedInitialData$op = this.cachedInitialData.operations,
        edit = _cachedInitialData$op.edit,
        read = _cachedInitialData$op.read,
        deleteSingle = _cachedInitialData$op.deleteSingle,
        deleteMultiple = _cachedInitialData$op.deleteMultiple,
        clone = _cachedInitialData$op.clone,
        _components2 = this.components,
        GroupPrimaryButton = _components2.GroupPrimaryButton,
        GroupButtonsList = _components2.GroupButtonsList,
        LinkButtonWrapper = _components2.LinkButtonWrapper;


    ReactDOM.render(React.createElement(_datagridTbody2.default, {
        rows: rows,
        options: {
            deleteMultiple: deleteMultiple,
            hasEdit: edit,
            hasClone: clone,
            hasDelete: deleteSingle,
            hasRead: read,
            hasActionButtons: this.hasActions
        },
        urlUniqueHash: this.hashEvent.urlUniqueHash,
        orderBy: Grid.getOrderBy.apply(this),
        columns: this.columns,
        onEditClick: this.onEditClick.bind(this),
        onCloneClick: this.onCloneClick.bind(this),
        onRowCheckboxClick: this.hideShowDeleteButton.bind(this),
        onReadClick: this.onReadClick.bind(this),
        onDeleteClick: this.onDeleteClick.bind(this),
        actionButtons: this.settings.actionButtons,
        screenSize: this.getScreenWidth(),
        i18n: this.cachedInitialData.i18n,
        LinkButtonWrapper: LinkButtonWrapper,
        GroupPrimaryButton: GroupPrimaryButton,
        GroupButtonsList: GroupButtonsList
    }), this.$gc.find('.gc-tbody')[0]);
};

GroceryCrud.prototype.listenerActionKeys = function listenerActionKeys() {
    this.$gc.find('.gc-action').click(function clickActionButton(event) {
        var $currentButton = $(event.currentTarget),
            primaryKeyValue = $currentButton.data('primary-key-value'),
            actionButtonKey = $currentButton.data('action-key');

        /* actionButtons Data is looking like this
             {
             iconCssClass: 'fa fa-smile-o',
             label: 'Smiley',
             onClick: function smileyCallback() {}
             }
         */
        this.settings.actionButtons[actionButtonKey].actionCallback.apply(this, [$currentButton, primaryKeyValue, this]);
    }.bind(this));
};

GroceryCrud.prototype.clearFilteringCache = function clearFilteringCache() {
    var $searchAllInput = this.$gc.find('.search-button > input.gc-search-input');

    this.$gc.find(Constants.SELECTOR_HIDDEN_PAGE_NUMBER).val('1');
    this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val('1');
    this.$gc.find('.grocery-crud-table tr:first').find(Constants.SELECTOR_ACTIVE).removeClass('active table-active ordering-desc ordering-asc');
    this.$gc.find('thead').find('td.active').removeClass('active table-active');
    this.$gc.find('thead .value-not-empty').removeClass('value-not-empty').val('');

    if ($searchAllInput.val() !== '') {
        $searchAllInput.val('').trigger('blur');
    }

    Grid.searchAndOrderingTrigger.apply(this);
};

GroceryCrud.prototype.appendSearchClearButtons = function appendSearchClearButtons() {
    var datagrid_object = this;

    this.$gc.find('.clear-search').remove();

    this.$gc.find(Constants.SELECTOR_SEARCH_FIELD_INPUT).each(function forEachSearchableInput() {
        $(this).removeClass('value-not-empty');
        if ($(this).val() === '') {
            return true;
        }
        $(this).addClass('value-not-empty');
        $(this).after('<i class="fa fa-times clear-search"></i>');

        datagrid_object.$gc.find('.clear-search').click(function clearSearch() {
            $(this).closest('td').find('.gc-searchable-input').val('').trigger('keyup');
        });
    });
};

GroceryCrud.prototype.listenerPerPage = function listenerPerPage() {
    this.$gc.find('.' + Constants.CLASS_PER_PAGE).change(function perPageOnChange() {
        this.$gc.find('.page-number-hidden').val('1');
        Grid.searchAndOrderingTrigger.apply(this);
    }.bind(this));
};

GroceryCrud.prototype.clearFilteringListener = function clearFilteringListener($settingsContainer) {
    $settingsContainer.find('.clear-filtering').click(function clearFilteringClickButton() {
        this.clearFilteringCache();
    }.bind(this));
};

GroceryCrud.prototype.hideShowDeleteButton = function hideShowDeleteButton() {

    if (this.$gc.find('.gc-select-row:checked').length > 0) {
        this.$gc.find('.delete-selected-button').removeClass('hidden');
    } else {
        this.$gc.find('.delete-selected-button').addClass('hidden');
    }
};

exports.GroceryCrud = GroceryCrud;

},{"../../../../React-Components/gce-crud-forms/modal/title.jsx":38,"../../../../React-Components/gce-datagrid-settings/gce-datagrid-settings/settings.jsx":39,"../../../../React-Components/gce-react-datagrid-filtering/filtering":55,"../../../../React-Components/gce-react-datagrid/datagrid-tbody.jsx":70,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/field-row-wrapper":71,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-buttons-list.jsx":72,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/group-primary-button.jsx":74,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/link-button-wrapper.jsx":75,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v3/modal-title-wrapper":76,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/field-row-wrapper":77,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-buttons-list.jsx":78,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/group-primary-button.jsx":79,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/link-button-wrapper.jsx":80,"../../../../React-Components/gce-react-datagrid/wrappers/bootstrap-v4/modal-title-wrapper":81,"../helpers/ajax-helper":84,"../helpers/local-storage-helper":85,"../jquery-plugins/chosen.jquery":86,"../jquery-plugins/modal":87,"../jquery-plugins/printThis":88,"../jquery-plugins/transition":89,"../libraries/HandlebarsExtended":90,"../libraries/jquery-ui-timepicker":91,"../modules/jquery/jquery-plugins":93,"../modules/react/jsx/datagrid/footer/per-page-dropdown.jsx":94,"../sections/constants":95,"../sections/datagrid/column":96,"../sections/datagrid/datagrid.columns":97,"../sections/datagrid/datagrid.paging":100,"../sections/i18n":102,"../sections/routes/router":110,"./../sections/datagrid/datagrid.grid.js":98,"./../sections/datagrid/datagrid.header-actions.js":99,"./../sections/datagrid/datagrid.search.js":101,"./../sections/operations/add.js":103,"./../sections/operations/clone.js":104,"./../sections/operations/common.js":105,"./../sections/operations/delete.js":106,"./../sections/operations/edit.js":107,"./../sections/operations/read.js":108,"underscore":225}],83:[function(require,module,exports){
'use strict';

var GroceryCrud = require('./grocery-crud').GroceryCrud,
    $ = jQuery;

$.fn.groceryCrud = function jQueryFnDatagrid(options) {
    var settings = $.extend({
        actionButtons: [],
        hashEvents: true,
        datagridSearchAllInput: false
    }, options);

    this.each(function forEachDatagrid() {
        new GroceryCrud($(this), settings).init();
    });

    return this;
};

},{"./grocery-crud":82}],84:[function(require,module,exports){
'use strict';

var $ = jQuery,
    _ = require('underscore'),
    Constants = require('../sections/constants').Constants,
    ajaxHelper = Object.create({
    setLoading: function setLoading() {
        this.$gc.find('.loading-opacity').css('width', this.$gc.width() + 15 + 'px').css('height', this.$gc.height() + 'px').removeClass('hidden');
    },
    unsetLoading: function unsetLoading() {
        this.$gc.find('.loading-opacity').addClass('hidden').css('width', '0px').css('height', '0px');
    },
    sendGetRequest: function sendGetRequest(options) {
        return ajaxHelper.sendAjaxRequest.apply(this, [options, 'get']);
    },
    sendPostRequest: function sendPostRequest(options) {
        return ajaxHelper.sendAjaxRequest.apply(this, [options, 'post']);
    },
    ajaxOnFail: function ajaxOnFail(errorAsString, textStatus, errorThrown) {
        ajaxHelper.unsetLoading.apply(this);
        this.$gc.find('.gc-error-modal').find('.gc-error-body').html(this.handlebarsTemplate('.gc-modal-error-text-template', {
            textStatus: textStatus,
            errorThrown: errorThrown,
            errorAsString: errorAsString
        }));

        if (/\<(html|script|body|style|link)\>/i.test(errorAsString)) {
            this.$gc.find('.gc-error-html-preview-button').addClass('hidden');
        } else {
            this.$gc.find('.gc-error-html-preview-button').removeClass('hidden');

            this.$gc.find('.gc-error-html-preview-button').click(function errorHTMLPreviewClick() {
                this.$gc.find('.gc-code-error-response').addClass('hidden');
                this.$gc.find('.gc-error-message-html').removeClass('hidden');
                this.$gc.find('.gc-error-message-html').html(errorAsString);
                this.$gc.find('.gc-error-html-preview-button').addClass('hidden');
            }.bind(this));
        }

        this.$gc.find('.gc-error-modal').gc_modal({
            backdrop: false
        });
    },
    sendAjaxRequest: function sendAjaxRequest(options, requestMethod) {
        return $.ajax({
            beforeSend: ajaxHelper.setLoading.bind(this),
            data: options.dataToSend,
            method: requestMethod,
            dataType: 'json',
            url: options.url
        }).done(function ajaxCallDone(data) {
            ajaxHelper.unsetLoading.apply(this);

            if (data.status === Constants.RESPONSE.FAILURE) {
                ajaxHelper.showErrorModal.apply(this, [data.message]);
            } else {
                options.successCallback(data);
            }
        }.bind(this)).fail(function ajaxOnFail(jqXHR, textStatus, errorThrown) {
            var errorAsString = jqXHR.responseText;

            ajaxHelper.ajaxOnFail.apply(this, [errorAsString, textStatus, errorThrown]);

            if (options.errorCallback !== undefined) {
                options.errorCallback(errorAsString);
            }
        }.bind(this));
    },
    showErrorModal: function showErrorModal(errorMessage) {
        this.$gc.find('.gc-error-modal').find('.gc-error-body').html(errorMessage);

        this.$gc.find('.gc-error-modal').gc_modal({
            backdrop: false
        });
    },
    getUrl: function getUrl(action, data_to_send) {
        var url = this.url;

        if (action) {
            url += /\?/.test(url) ? '&' : '?';
            url += 'action=' + action;
        }

        if (data_to_send === undefined) {
            return url;
        }

        _.each(data_to_send, function forEachDataToSend(_field_value, _field_name) {
            if (_field_value instanceof Array) {
                _.each(_field_value, function forEachFields(_array_value) {
                    url += '&' + _field_name + '[]=' + _array_value;
                });
            } else if (_field_value instanceof Object) {
                _.each(_field_value, function forEachFields(objectFieldValue, objectFieldName) {
                    url += '&' + _field_name + '[' + objectFieldName + ']=' + objectFieldValue;
                });
            } else {
                url += '&' + _field_name + '=' + (_.isUndefined(_field_value) ? '' : _field_value);
            }
        });

        return url;
    },
    getPostDataFromForm: function getPostDataFromForm($jqueryForm) {
        var postData = {};
        _.each($jqueryForm.serializeArray(), function eachFormFields(field) {
            var dataType = this.cachedInitialData.fieldTypes[field.name].dataType;
            if (dataType === 'relational_n_n' || dataType === 'native_relational_n_n') {
                if (postData[field.name] === undefined) {
                    postData[field.name] = [field.value];
                } else {
                    postData[field.name].push(field.value);
                }
            } else {
                postData[field.name] = field.value;
            }
        }.bind(this));

        return postData;
    },
    getMultilayerPostDataFromForm: function getMultilayerPostDataFromForm($jqueryForm) {
        var postData = {};
        var formData = $jqueryForm.serializeArray();

        formData.forEach(function foreachFormData(item) {
            postData[item.name] = item.value;
        });

        return postData;
    }
});

exports.ajaxHelper = ajaxHelper;

},{"../sections/constants":95,"underscore":225}],85:[function(require,module,exports){
'use strict';

var localStorageHelper = Object.create({

    // By default this is empty as some browsers doesn't support localStorage cache
    setLocalStorageItem: function setLocalStorageItem(__item, __value) {},

    // By default this is empty as some browsers doesn't support localStorage cache
    removeLocalStorageItem: function removeLocalStorageItem(__item) {},

    // By default this is empty as some browsers doesn't support localStorage cache
    getLocalStorageItem: function getLocalStorageItem(__item) {
        return null;
    },

    // The below function is copied from the modernizr local storage support
    browserSupportsLocalStorage: function browserSupportsLocalStorage() {
        var mod = 'modernizr';
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch (e) {
            return false;
        }
    },

    // Changing the default empty values of the functions to support local storage. The below function
    // is called only once for optimizing reasons
    setLocalStorageCache: function setLocalStorageCache() {
        if (this.browserSupportsLocalStorage()) {
            //if browser is supporting local storage overrides the empty functions
            this.setLocalStorageItem = function setLocalStorageItem(item, value) {
                localStorage.setItem(item, value);
            };
            this.removeLocalStorageItem = function removeLocalStorageItem(item) {
                localStorage.removeItem(item);
            };
            this.getLocalStorageItem = function getLocalStorageItem(item) {
                return localStorage.getItem(item);
            };
        }
    }
});

localStorageHelper.setLocalStorageCache();

exports.localStorageHelper = localStorageHelper;

},{}],86:[function(require,module,exports){
"use strict";

/*!
Chosen, a Select Box Enhancer for jQuery and Prototype
by Patrick Filler for Harvest, http://getharvest.com

Version 1.6.2
Full source at https://github.com/harvesthq/chosen
Copyright (c) 2011-2016 Harvest http://getharvest.com

MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
This file is generated by `grunt build`, do not edit it by hand.
*/

(function () {
  var $,
      AbstractChosen,
      Chosen,
      SelectParser,
      _ref,
      __hasProp = {}.hasOwnProperty,
      __extends = function __extends(child, parent) {
    for (var key in parent) {
      if (__hasProp.call(parent, key)) child[key] = parent[key];
    }function ctor() {
      this.constructor = child;
    }ctor.prototype = parent.prototype;child.prototype = new ctor();child.__super__ = parent.prototype;return child;
  };

  SelectParser = function () {
    function SelectParser() {
      this.options_index = 0;
      this.parsed = [];
    }

    SelectParser.prototype.add_node = function (child) {
      if (child.nodeName.toUpperCase() === "OPTGROUP") {
        return this.add_group(child);
      } else {
        return this.add_option(child);
      }
    };

    SelectParser.prototype.add_group = function (group) {
      var group_position, option, _i, _len, _ref, _results;
      group_position = this.parsed.length;
      this.parsed.push({
        array_index: group_position,
        group: true,
        label: this.escapeExpression(group.label),
        title: group.title ? group.title : void 0,
        children: 0,
        disabled: group.disabled,
        classes: group.className
      });
      _ref = group.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        _results.push(this.add_option(option, group_position, group.disabled));
      }
      return _results;
    };

    SelectParser.prototype.add_option = function (option, group_position, group_disabled) {
      if (option.nodeName.toUpperCase() === "OPTION") {
        if (option.text !== "") {
          if (group_position != null) {
            this.parsed[group_position].children += 1;
          }
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            value: option.value,
            text: option.text,
            html: option.innerHTML,
            title: option.title ? option.title : void 0,
            selected: option.selected,
            disabled: group_disabled === true ? group_disabled : option.disabled,
            group_array_index: group_position,
            group_label: group_position != null ? this.parsed[group_position].label : null,
            classes: option.className,
            style: option.style.cssText
          });
        } else {
          this.parsed.push({
            array_index: this.parsed.length,
            options_index: this.options_index,
            empty: true
          });
        }
        return this.options_index += 1;
      }
    };

    SelectParser.prototype.escapeExpression = function (text) {
      var map, unsafe_chars;
      if (text == null || text === false) {
        return "";
      }
      if (!/[\&\<\>\"\'\`]/.test(text)) {
        return text;
      }
      map = {
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
      };
      unsafe_chars = /&(?!\w+;)|[\<\>\"\'\`]/g;
      return text.replace(unsafe_chars, function (chr) {
        return map[chr] || "&amp;";
      });
    };

    return SelectParser;
  }();

  SelectParser.select_to_array = function (select) {
    var child, parser, _i, _len, _ref;
    parser = new SelectParser();
    _ref = select.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      parser.add_node(child);
    }
    return parser.parsed;
  };

  AbstractChosen = function () {
    function AbstractChosen(form_field, options) {
      this.form_field = form_field;
      this.options = options != null ? options : {};
      if (!AbstractChosen.browser_is_supported()) {
        return;
      }
      this.is_multiple = this.form_field.multiple;
      this.set_default_text();
      this.set_default_values();
      this.setup();
      this.set_up_html();
      this.register_observers();
      this.on_ready();
    }

    AbstractChosen.prototype.set_default_values = function () {
      var _this = this;
      this.click_test_action = function (evt) {
        return _this.test_active_click(evt);
      };
      this.activate_action = function (evt) {
        return _this.activate_field(evt);
      };
      this.active_field = false;
      this.mouse_on_container = false;
      this.results_showing = false;
      this.result_highlighted = null;
      this.allow_single_deselect = this.options.allow_single_deselect != null && this.form_field.options[0] != null && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
      this.disable_search_threshold = this.options.disable_search_threshold || 0;
      this.disable_search = this.options.disable_search || false;
      this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
      this.group_search = this.options.group_search != null ? this.options.group_search : true;
      this.search_contains = this.options.search_contains || false;
      this.single_backstroke_delete = this.options.single_backstroke_delete != null ? this.options.single_backstroke_delete : true;
      this.max_selected_options = this.options.max_selected_options || Infinity;
      this.inherit_select_classes = this.options.inherit_select_classes || false;
      this.display_selected_options = this.options.display_selected_options != null ? this.options.display_selected_options : true;
      this.display_disabled_options = this.options.display_disabled_options != null ? this.options.display_disabled_options : true;
      this.include_group_label_in_selected = this.options.include_group_label_in_selected || false;
      this.max_shown_results = this.options.max_shown_results || Number.POSITIVE_INFINITY;
      return this.case_sensitive_search = this.options.case_sensitive_search || false;
    };

    AbstractChosen.prototype.set_default_text = function () {
      if (this.form_field.getAttribute("data-placeholder")) {
        this.default_text = this.form_field.getAttribute("data-placeholder");
      } else if (this.is_multiple) {
        this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
      } else {
        this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
      }
      return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
    };

    AbstractChosen.prototype.choice_label = function (item) {
      if (this.include_group_label_in_selected && item.group_label != null) {
        return "<b class='group-name'>" + item.group_label + "</b>" + item.html;
      } else {
        return item.html;
      }
    };

    AbstractChosen.prototype.mouse_enter = function () {
      return this.mouse_on_container = true;
    };

    AbstractChosen.prototype.mouse_leave = function () {
      return this.mouse_on_container = false;
    };

    AbstractChosen.prototype.input_focus = function (evt) {
      var _this = this;
      if (this.is_multiple) {
        if (!this.active_field) {
          return setTimeout(function () {
            return _this.container_mousedown();
          }, 50);
        }
      } else {
        if (!this.active_field) {
          return this.activate_field();
        }
      }
    };

    AbstractChosen.prototype.input_blur = function (evt) {
      var _this = this;
      if (!this.mouse_on_container) {
        this.active_field = false;
        return setTimeout(function () {
          return _this.blur_test();
        }, 100);
      }
    };

    AbstractChosen.prototype.results_option_build = function (options) {
      var content, data, data_content, shown_results, _i, _len, _ref;
      content = '';
      shown_results = 0;
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        data = _ref[_i];
        data_content = '';
        if (data.group) {
          data_content = this.result_add_group(data);
        } else {
          data_content = this.result_add_option(data);
        }
        if (data_content !== '') {
          shown_results++;
          content += data_content;
        }
        if (options != null ? options.first : void 0) {
          if (data.selected && this.is_multiple) {
            this.choice_build(data);
          } else if (data.selected && !this.is_multiple) {
            this.single_set_selected_text(this.choice_label(data));
          }
        }
        if (shown_results >= this.max_shown_results) {
          break;
        }
      }
      return content;
    };

    AbstractChosen.prototype.result_add_option = function (option) {
      var classes, option_el;
      if (!option.search_match) {
        return '';
      }
      if (!this.include_option_in_results(option)) {
        return '';
      }
      classes = [];
      if (!option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("active-result");
      }
      if (option.disabled && !(option.selected && this.is_multiple)) {
        classes.push("disabled-result");
      }
      if (option.selected) {
        classes.push("result-selected");
      }
      if (option.group_array_index != null) {
        classes.push("group-option");
      }
      if (option.classes !== "") {
        classes.push(option.classes);
      }
      option_el = document.createElement("li");
      option_el.className = classes.join(" ");
      option_el.style.cssText = option.style;
      option_el.setAttribute("data-option-array-index", option.array_index);
      option_el.innerHTML = option.search_text;
      if (option.title) {
        option_el.title = option.title;
      }
      return this.outerHTML(option_el);
    };

    AbstractChosen.prototype.result_add_group = function (group) {
      var classes, group_el;
      if (!(group.search_match || group.group_match)) {
        return '';
      }
      if (!(group.active_options > 0)) {
        return '';
      }
      classes = [];
      classes.push("group-result");
      if (group.classes) {
        classes.push(group.classes);
      }
      group_el = document.createElement("li");
      group_el.className = classes.join(" ");
      group_el.innerHTML = group.search_text;
      if (group.title) {
        group_el.title = group.title;
      }
      return this.outerHTML(group_el);
    };

    AbstractChosen.prototype.results_update_field = function () {
      this.set_default_text();
      if (!this.is_multiple) {
        this.results_reset_cleanup();
      }
      this.result_clear_highlight();
      this.results_build();
      if (this.results_showing) {
        return this.winnow_results();
      }
    };

    AbstractChosen.prototype.reset_single_select_options = function () {
      var result, _i, _len, _ref, _results;
      _ref = this.results_data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.selected) {
          _results.push(result.selected = false);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    AbstractChosen.prototype.results_toggle = function () {
      if (this.results_showing) {
        return this.results_hide();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.results_search = function (evt) {
      if (this.results_showing) {
        return this.winnow_results();
      } else {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.winnow_results = function () {
      var escapedSearchText, option, regex, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;
      this.no_results_clear();
      results = 0;
      searchText = this.get_search_text();
      escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      zregex = new RegExp(escapedSearchText, 'i');
      regex = this.get_search_regex(escapedSearchText);
      _ref = this.results_data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        option.search_match = false;
        results_group = null;
        if (this.include_option_in_results(option)) {
          if (option.group) {
            option.group_match = false;
            option.active_options = 0;
          }
          if (option.group_array_index != null && this.results_data[option.group_array_index]) {
            results_group = this.results_data[option.group_array_index];
            if (results_group.active_options === 0 && results_group.search_match) {
              results += 1;
            }
            results_group.active_options += 1;
          }
          option.search_text = option.group ? option.label : option.html;
          if (!(option.group && !this.group_search)) {
            option.search_match = this.search_string_match(option.search_text, regex);
            if (option.search_match && !option.group) {
              results += 1;
            }
            if (option.search_match) {
              if (searchText.length) {
                startpos = option.search_text.search(zregex);
                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
              }
              if (results_group != null) {
                results_group.group_match = true;
              }
            } else if (option.group_array_index != null && this.results_data[option.group_array_index].search_match) {
              option.search_match = true;
            }
          }
        }
      }
      this.result_clear_highlight();
      if (results < 1 && searchText.length) {
        this.update_results_content("");
        return this.no_results(searchText);
      } else {
        this.update_results_content(this.results_option_build());
        return this.winnow_results_set_highlight();
      }
    };

    AbstractChosen.prototype.get_search_regex = function (escaped_search_string) {
      var regex_anchor, regex_flag;
      regex_anchor = this.search_contains ? "" : "^";
      regex_flag = this.case_sensitive_search ? "" : "i";
      return new RegExp(regex_anchor + escaped_search_string, regex_flag);
    };

    AbstractChosen.prototype.search_string_match = function (search_string, regex) {
      var part, parts, _i, _len;
      if (regex.test(search_string)) {
        return true;
      } else if (this.enable_split_word_search && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
        parts = search_string.replace(/\[|\]/g, "").split(" ");
        if (parts.length) {
          for (_i = 0, _len = parts.length; _i < _len; _i++) {
            part = parts[_i];
            if (regex.test(part)) {
              return true;
            }
          }
        }
      }
    };

    AbstractChosen.prototype.choices_count = function () {
      var option, _i, _len, _ref;
      if (this.selected_option_count != null) {
        return this.selected_option_count;
      }
      this.selected_option_count = 0;
      _ref = this.form_field.options;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        option = _ref[_i];
        if (option.selected) {
          this.selected_option_count += 1;
        }
      }
      return this.selected_option_count;
    };

    AbstractChosen.prototype.choices_click = function (evt) {
      evt.preventDefault();
      if (!(this.results_showing || this.is_disabled)) {
        return this.results_show();
      }
    };

    AbstractChosen.prototype.keyup_checker = function (evt) {
      var stroke, _ref;
      stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
      this.search_field_scale();
      switch (stroke) {
        case 8:
          if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
            return this.keydown_backstroke();
          } else if (!this.pending_backstroke) {
            this.result_clear_highlight();
            return this.results_search();
          }
          break;
        case 13:
          evt.preventDefault();
          if (this.results_showing) {
            return this.result_select(evt);
          }
          break;
        case 27:
          if (this.results_showing) {
            this.results_hide();
          }
          return true;
        case 9:
        case 38:
        case 40:
        case 16:
        case 91:
        case 17:
        case 18:
          break;
        default:
          return this.results_search();
      }
    };

    AbstractChosen.prototype.clipboard_event_checker = function (evt) {
      var _this = this;
      return setTimeout(function () {
        return _this.results_search();
      }, 50);
    };

    AbstractChosen.prototype.container_width = function () {
      if (this.options.width != null) {
        return this.options.width;
      } else {
        return "" + this.form_field.offsetWidth + "px";
      }
    };

    AbstractChosen.prototype.include_option_in_results = function (option) {
      if (this.is_multiple && !this.display_selected_options && option.selected) {
        return false;
      }
      if (!this.display_disabled_options && option.disabled) {
        return false;
      }
      if (option.empty) {
        return false;
      }
      return true;
    };

    AbstractChosen.prototype.search_results_touchstart = function (evt) {
      this.touch_started = true;
      return this.search_results_mouseover(evt);
    };

    AbstractChosen.prototype.search_results_touchmove = function (evt) {
      this.touch_started = false;
      return this.search_results_mouseout(evt);
    };

    AbstractChosen.prototype.search_results_touchend = function (evt) {
      if (this.touch_started) {
        return this.search_results_mouseup(evt);
      }
    };

    AbstractChosen.prototype.outerHTML = function (element) {
      var tmp;
      if (element.outerHTML) {
        return element.outerHTML;
      }
      tmp = document.createElement("div");
      tmp.appendChild(element);
      return tmp.innerHTML;
    };

    AbstractChosen.browser_is_supported = function () {
      if ("Microsoft Internet Explorer" === window.navigator.appName) {
        return document.documentMode >= 8;
      }
      if (/iP(od|hone)/i.test(window.navigator.userAgent) || /IEMobile/i.test(window.navigator.userAgent) || /Windows Phone/i.test(window.navigator.userAgent) || /BlackBerry/i.test(window.navigator.userAgent) || /BB10/i.test(window.navigator.userAgent) || /Android.*Mobile/i.test(window.navigator.userAgent)) {
        return false;
      }
      return true;
    };

    AbstractChosen.default_multiple_text = "Select Some Options";

    AbstractChosen.default_single_text = "Select an Option";

    AbstractChosen.default_no_result_text = "No results match";

    return AbstractChosen;
  }();

  $ = jQuery;

  $.fn.extend({
    chosen: function chosen(options) {
      if (!AbstractChosen.browser_is_supported()) {
        return this;
      }
      return this.each(function (input_field) {
        var $this, chosen;
        $this = $(this);
        chosen = $this.data('chosen');
        if (options === 'destroy') {
          if (chosen instanceof Chosen) {
            chosen.destroy();
          }
          return;
        }
        if (!(chosen instanceof Chosen)) {
          $this.data('chosen', new Chosen(this, options));
        }
      });
    }
  });

  Chosen = function (_super) {
    __extends(Chosen, _super);

    function Chosen() {
      _ref = Chosen.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Chosen.prototype.setup = function () {
      this.form_field_jq = $(this.form_field);
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.is_rtl = this.form_field_jq.hasClass("chosen-rtl");
    };

    Chosen.prototype.set_up_html = function () {
      var container_classes, container_props;
      container_classes = ["chosen-container"];
      container_classes.push("chosen-container-" + (this.is_multiple ? "multi" : "single"));
      if (this.inherit_select_classes && this.form_field.className) {
        container_classes.push(this.form_field.className);
      }
      if (this.is_rtl) {
        container_classes.push("chosen-rtl");
      }
      container_props = {
        'class': container_classes.join(' '),
        'style': "width: " + this.container_width() + ";",
        'title': this.form_field.title
      };
      if (this.form_field.id.length) {
        container_props.id = this.form_field.id.replace(/[^\w]/g, '_') + "_chosen";
      }
      this.container = $("<div />", container_props);
      if (this.is_multiple) {
        this.container.html('<ul class="chosen-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chosen-drop"><ul class="chosen-results"></ul></div>');
      } else {
        this.container.html('<a class="chosen-single chosen-default"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chosen-drop"><div class="chosen-search"><input type="text" autocomplete="off" /></div><ul class="chosen-results"></ul></div>');
      }
      this.form_field_jq.hide().after(this.container);
      this.dropdown = this.container.find('div.chosen-drop').first();
      this.search_field = this.container.find('input').first();
      this.search_results = this.container.find('ul.chosen-results').first();
      this.search_field_scale();
      this.search_no_results = this.container.find('li.no-results').first();
      if (this.is_multiple) {
        this.search_choices = this.container.find('ul.chosen-choices').first();
        this.search_container = this.container.find('li.search-field').first();
      } else {
        this.search_container = this.container.find('div.chosen-search').first();
        this.selected_item = this.container.find('.chosen-single').first();
      }
      this.results_build();
      this.set_tab_index();
      return this.set_label_behavior();
    };

    Chosen.prototype.on_ready = function () {
      return this.form_field_jq.trigger("chosen:ready", {
        chosen: this
      });
    };

    Chosen.prototype.register_observers = function () {
      var _this = this;
      this.container.bind('touchstart.chosen', function (evt) {
        _this.container_mousedown(evt);
        return evt.preventDefault();
      });
      this.container.bind('touchend.chosen', function (evt) {
        _this.container_mouseup(evt);
        return evt.preventDefault();
      });
      this.container.bind('mousedown.chosen', function (evt) {
        _this.container_mousedown(evt);
      });
      this.container.bind('mouseup.chosen', function (evt) {
        _this.container_mouseup(evt);
      });
      this.container.bind('mouseenter.chosen', function (evt) {
        _this.mouse_enter(evt);
      });
      this.container.bind('mouseleave.chosen', function (evt) {
        _this.mouse_leave(evt);
      });
      this.search_results.bind('mouseup.chosen', function (evt) {
        _this.search_results_mouseup(evt);
      });
      this.search_results.bind('mouseover.chosen', function (evt) {
        _this.search_results_mouseover(evt);
      });
      this.search_results.bind('mouseout.chosen', function (evt) {
        _this.search_results_mouseout(evt);
      });
      this.search_results.bind('mousewheel.chosen DOMMouseScroll.chosen', function (evt) {
        _this.search_results_mousewheel(evt);
      });
      this.search_results.bind('touchstart.chosen', function (evt) {
        _this.search_results_touchstart(evt);
      });
      this.search_results.bind('touchmove.chosen', function (evt) {
        _this.search_results_touchmove(evt);
      });
      this.search_results.bind('touchend.chosen', function (evt) {
        _this.search_results_touchend(evt);
      });
      this.form_field_jq.bind("chosen:updated.chosen", function (evt) {
        _this.results_update_field(evt);
      });
      this.form_field_jq.bind("chosen:activate.chosen", function (evt) {
        _this.activate_field(evt);
      });
      this.form_field_jq.bind("chosen:open.chosen", function (evt) {
        _this.container_mousedown(evt);
      });
      this.form_field_jq.bind("chosen:close.chosen", function (evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('blur.chosen', function (evt) {
        _this.input_blur(evt);
      });
      this.search_field.bind('keyup.chosen', function (evt) {
        _this.keyup_checker(evt);
      });
      this.search_field.bind('keydown.chosen', function (evt) {
        _this.keydown_checker(evt);
      });
      this.search_field.bind('focus.chosen', function (evt) {
        _this.input_focus(evt);
      });
      this.search_field.bind('cut.chosen', function (evt) {
        _this.clipboard_event_checker(evt);
      });
      this.search_field.bind('paste.chosen', function (evt) {
        _this.clipboard_event_checker(evt);
      });
      if (this.is_multiple) {
        return this.search_choices.bind('click.chosen', function (evt) {
          _this.choices_click(evt);
        });
      } else {
        return this.container.bind('click.chosen', function (evt) {
          evt.preventDefault();
        });
      }
    };

    Chosen.prototype.destroy = function () {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      if (this.search_field[0].tabIndex) {
        this.form_field_jq[0].tabIndex = this.search_field[0].tabIndex;
      }
      this.container.remove();
      this.form_field_jq.removeData('chosen');
      return this.form_field_jq.show();
    };

    Chosen.prototype.search_field_disabled = function () {
      this.is_disabled = this.form_field_jq[0].disabled;
      if (this.is_disabled) {
        this.container.addClass('chosen-disabled');
        this.search_field[0].disabled = true;
        if (!this.is_multiple) {
          this.selected_item.unbind("focus.chosen", this.activate_action);
        }
        return this.close_field();
      } else {
        this.container.removeClass('chosen-disabled');
        this.search_field[0].disabled = false;
        if (!this.is_multiple) {
          return this.selected_item.bind("focus.chosen", this.activate_action);
        }
      }
    };

    Chosen.prototype.container_mousedown = function (evt) {
      if (!this.is_disabled) {
        if (evt && evt.type === "mousedown" && !this.results_showing) {
          evt.preventDefault();
        }
        if (!(evt != null && $(evt.target).hasClass("search-choice-close"))) {
          if (!this.active_field) {
            if (this.is_multiple) {
              this.search_field.val("");
            }
            $(this.container[0].ownerDocument).bind('click.chosen', this.click_test_action);
            this.results_show();
          } else if (!this.is_multiple && evt && ($(evt.target)[0] === this.selected_item[0] || $(evt.target).parents("a.chosen-single").length)) {
            evt.preventDefault();
            this.results_toggle();
          }
          return this.activate_field();
        }
      }
    };

    Chosen.prototype.container_mouseup = function (evt) {
      if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
        return this.results_reset(evt);
      }
    };

    Chosen.prototype.search_results_mousewheel = function (evt) {
      var delta;
      if (evt.originalEvent) {
        delta = evt.originalEvent.deltaY || -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
      }
      if (delta != null) {
        evt.preventDefault();
        if (evt.type === 'DOMMouseScroll') {
          delta = delta * 40;
        }
        return this.search_results.scrollTop(delta + this.search_results.scrollTop());
      }
    };

    Chosen.prototype.blur_test = function (evt) {
      if (!this.active_field && this.container.hasClass("chosen-container-active")) {
        return this.close_field();
      }
    };

    Chosen.prototype.close_field = function () {
      $(this.container[0].ownerDocument).unbind("click.chosen", this.click_test_action);
      this.active_field = false;
      this.results_hide();
      this.container.removeClass("chosen-container-active");
      this.clear_backstroke();
      this.show_search_field_default();
      return this.search_field_scale();
    };

    Chosen.prototype.activate_field = function () {
      this.container.addClass("chosen-container-active");
      this.active_field = true;
      this.search_field.val(this.search_field.val());
      return this.search_field.focus();
    };

    Chosen.prototype.test_active_click = function (evt) {
      var active_container;
      active_container = $(evt.target).closest('.chosen-container');
      if (active_container.length && this.container[0] === active_container[0]) {
        return this.active_field = true;
      } else {
        return this.close_field();
      }
    };

    Chosen.prototype.results_build = function () {
      this.parsing = true;
      this.selected_option_count = null;
      this.results_data = SelectParser.select_to_array(this.form_field);
      if (this.is_multiple) {
        this.search_choices.find("li.search-choice").remove();
      } else if (!this.is_multiple) {
        this.single_set_selected_text();
        if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
          this.search_field[0].readOnly = true;
          this.container.addClass("chosen-container-single-nosearch");
        } else {
          this.search_field[0].readOnly = false;
          this.container.removeClass("chosen-container-single-nosearch");
        }
      }
      this.update_results_content(this.results_option_build({
        first: true
      }));
      this.search_field_disabled();
      this.show_search_field_default();
      this.search_field_scale();
      return this.parsing = false;
    };

    Chosen.prototype.result_do_highlight = function (el) {
      var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
      if (el.length) {
        this.result_clear_highlight();
        this.result_highlight = el;
        this.result_highlight.addClass("highlighted");
        maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
        visible_top = this.search_results.scrollTop();
        visible_bottom = maxHeight + visible_top;
        high_top = this.result_highlight.position().top + this.search_results.scrollTop();
        high_bottom = high_top + this.result_highlight.outerHeight();
        if (high_bottom >= visible_bottom) {
          return this.search_results.scrollTop(high_bottom - maxHeight > 0 ? high_bottom - maxHeight : 0);
        } else if (high_top < visible_top) {
          return this.search_results.scrollTop(high_top);
        }
      }
    };

    Chosen.prototype.result_clear_highlight = function () {
      if (this.result_highlight) {
        this.result_highlight.removeClass("highlighted");
      }
      return this.result_highlight = null;
    };

    Chosen.prototype.results_show = function () {
      if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
        this.form_field_jq.trigger("chosen:maxselected", {
          chosen: this
        });
        return false;
      }
      this.container.addClass("chosen-with-drop");
      this.results_showing = true;
      this.search_field.focus();
      this.search_field.val(this.search_field.val());
      this.winnow_results();
      return this.form_field_jq.trigger("chosen:showing_dropdown", {
        chosen: this
      });
    };

    Chosen.prototype.update_results_content = function (content) {
      return this.search_results.html(content);
    };

    Chosen.prototype.results_hide = function () {
      if (this.results_showing) {
        this.result_clear_highlight();
        this.container.removeClass("chosen-with-drop");
        this.form_field_jq.trigger("chosen:hiding_dropdown", {
          chosen: this
        });
      }
      return this.results_showing = false;
    };

    Chosen.prototype.set_tab_index = function (el) {
      var ti;
      if (this.form_field.tabIndex) {
        ti = this.form_field.tabIndex;
        this.form_field.tabIndex = -1;
        return this.search_field[0].tabIndex = ti;
      }
    };

    Chosen.prototype.set_label_behavior = function () {
      var _this = this;
      this.form_field_label = this.form_field_jq.parents("label");
      if (!this.form_field_label.length && this.form_field.id.length) {
        this.form_field_label = $("label[for='" + this.form_field.id + "']");
      }
      if (this.form_field_label.length > 0) {
        return this.form_field_label.bind('click.chosen', function (evt) {
          if (_this.is_multiple) {
            return _this.container_mousedown(evt);
          } else {
            return _this.activate_field();
          }
        });
      }
    };

    Chosen.prototype.show_search_field_default = function () {
      if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
        this.search_field.val(this.default_text);
        return this.search_field.addClass("default");
      } else {
        this.search_field.val("");
        return this.search_field.removeClass("default");
      }
    };

    Chosen.prototype.search_results_mouseup = function (evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target.length) {
        this.result_highlight = target;
        this.result_select(evt);
        return this.search_field.focus();
      }
    };

    Chosen.prototype.search_results_mouseover = function (evt) {
      var target;
      target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
      if (target) {
        return this.result_do_highlight(target);
      }
    };

    Chosen.prototype.search_results_mouseout = function (evt) {
      if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
        return this.result_clear_highlight();
      }
    };

    Chosen.prototype.choice_build = function (item) {
      var choice,
          close_link,
          _this = this;
      choice = $('<li />', {
        "class": "search-choice"
      }).html("<span>" + this.choice_label(item) + "</span>");
      if (item.disabled) {
        choice.addClass('search-choice-disabled');
      } else {
        close_link = $('<a />', {
          "class": 'search-choice-close',
          'data-option-array-index': item.array_index
        });
        close_link.bind('click.chosen', function (evt) {
          return _this.choice_destroy_link_click(evt);
        });
        choice.append(close_link);
      }
      return this.search_container.before(choice);
    };

    Chosen.prototype.choice_destroy_link_click = function (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      if (!this.is_disabled) {
        return this.choice_destroy($(evt.target));
      }
    };

    Chosen.prototype.choice_destroy = function (link) {
      if (this.result_deselect(link[0].getAttribute("data-option-array-index"))) {
        this.show_search_field_default();
        if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
          this.results_hide();
        }
        link.parents('li').first().remove();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.results_reset = function () {
      this.reset_single_select_options();
      this.form_field.options[0].selected = true;
      this.single_set_selected_text();
      this.show_search_field_default();
      this.results_reset_cleanup();
      this.form_field_jq.trigger("change");
      if (this.active_field) {
        return this.results_hide();
      }
    };

    Chosen.prototype.results_reset_cleanup = function () {
      this.current_selectedIndex = this.form_field.selectedIndex;
      return this.selected_item.find("abbr").remove();
    };

    Chosen.prototype.result_select = function (evt) {
      var high, item;
      if (this.result_highlight) {
        high = this.result_highlight;
        this.result_clear_highlight();
        if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
          this.form_field_jq.trigger("chosen:maxselected", {
            chosen: this
          });
          return false;
        }
        if (this.is_multiple) {
          high.removeClass("active-result");
        } else {
          this.reset_single_select_options();
        }
        high.addClass("result-selected");
        item = this.results_data[high[0].getAttribute("data-option-array-index")];
        item.selected = true;
        this.form_field.options[item.options_index].selected = true;
        this.selected_option_count = null;
        if (this.is_multiple) {
          this.choice_build(item);
        } else {
          this.single_set_selected_text(this.choice_label(item));
        }
        if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
          this.results_hide();
        }
        this.show_search_field_default();
        if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
          this.form_field_jq.trigger("change", {
            'selected': this.form_field.options[item.options_index].value
          });
        }
        this.current_selectedIndex = this.form_field.selectedIndex;
        evt.preventDefault();
        return this.search_field_scale();
      }
    };

    Chosen.prototype.single_set_selected_text = function (text) {
      if (text == null) {
        text = this.default_text;
      }
      if (text === this.default_text) {
        this.selected_item.addClass("chosen-default");
      } else {
        this.single_deselect_control_build();
        this.selected_item.removeClass("chosen-default");
      }
      return this.selected_item.find("span").html(text);
    };

    Chosen.prototype.result_deselect = function (pos) {
      var result_data;
      result_data = this.results_data[pos];
      if (!this.form_field.options[result_data.options_index].disabled) {
        result_data.selected = false;
        this.form_field.options[result_data.options_index].selected = false;
        this.selected_option_count = null;
        this.result_clear_highlight();
        if (this.results_showing) {
          this.winnow_results();
        }
        this.form_field_jq.trigger("change", {
          deselected: this.form_field.options[result_data.options_index].value
        });
        this.search_field_scale();
        return true;
      } else {
        return false;
      }
    };

    Chosen.prototype.single_deselect_control_build = function () {
      if (!this.allow_single_deselect) {
        return;
      }
      if (!this.selected_item.find("abbr").length) {
        this.selected_item.find("span").first().after("<abbr class=\"search-choice-close\"></abbr>");
      }
      return this.selected_item.addClass("chosen-single-with-deselect");
    };

    Chosen.prototype.get_search_text = function () {
      return $('<div/>').text($.trim(this.search_field.val())).html();
    };

    Chosen.prototype.winnow_results_set_highlight = function () {
      var do_high, selected_results;
      selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
      do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
      if (do_high != null) {
        return this.result_do_highlight(do_high);
      }
    };

    Chosen.prototype.no_results = function (terms) {
      var no_results_html;
      no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
      no_results_html.find("span").first().html(terms);
      this.search_results.append(no_results_html);
      return this.form_field_jq.trigger("chosen:no_results", {
        chosen: this
      });
    };

    Chosen.prototype.no_results_clear = function () {
      return this.search_results.find(".no-results").remove();
    };

    Chosen.prototype.keydown_arrow = function () {
      var next_sib;
      if (this.results_showing && this.result_highlight) {
        next_sib = this.result_highlight.nextAll("li.active-result").first();
        if (next_sib) {
          return this.result_do_highlight(next_sib);
        }
      } else {
        return this.results_show();
      }
    };

    Chosen.prototype.keyup_arrow = function () {
      var prev_sibs;
      if (!this.results_showing && !this.is_multiple) {
        return this.results_show();
      } else if (this.result_highlight) {
        prev_sibs = this.result_highlight.prevAll("li.active-result");
        if (prev_sibs.length) {
          return this.result_do_highlight(prev_sibs.first());
        } else {
          if (this.choices_count() > 0) {
            this.results_hide();
          }
          return this.result_clear_highlight();
        }
      }
    };

    Chosen.prototype.keydown_backstroke = function () {
      var next_available_destroy;
      if (this.pending_backstroke) {
        this.choice_destroy(this.pending_backstroke.find("a").first());
        return this.clear_backstroke();
      } else {
        next_available_destroy = this.search_container.siblings("li.search-choice").last();
        if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
          this.pending_backstroke = next_available_destroy;
          if (this.single_backstroke_delete) {
            return this.keydown_backstroke();
          } else {
            return this.pending_backstroke.addClass("search-choice-focus");
          }
        }
      }
    };

    Chosen.prototype.clear_backstroke = function () {
      if (this.pending_backstroke) {
        this.pending_backstroke.removeClass("search-choice-focus");
      }
      return this.pending_backstroke = null;
    };

    Chosen.prototype.keydown_checker = function (evt) {
      var stroke, _ref1;
      stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
      this.search_field_scale();
      if (stroke !== 8 && this.pending_backstroke) {
        this.clear_backstroke();
      }
      switch (stroke) {
        case 8:
          this.backstroke_length = this.search_field.val().length;
          break;
        case 9:
          if (this.results_showing && !this.is_multiple) {
            this.result_select(evt);
          }
          this.mouse_on_container = false;
          break;
        case 13:
          if (this.results_showing) {
            evt.preventDefault();
          }
          break;
        case 32:
          if (this.disable_search) {
            evt.preventDefault();
          }
          break;
        case 38:
          evt.preventDefault();
          this.keyup_arrow();
          break;
        case 40:
          evt.preventDefault();
          this.keydown_arrow();
          break;
      }
    };

    Chosen.prototype.search_field_scale = function () {
      var div, f_width, h, style, style_block, styles, w, _i, _len;
      if (this.is_multiple) {
        h = 0;
        w = 0;
        style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
        styles = ['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing'];
        for (_i = 0, _len = styles.length; _i < _len; _i++) {
          style = styles[_i];
          style_block += style + ":" + this.search_field.css(style) + ";";
        }
        div = $('<div />', {
          'style': style_block
        });
        div.text(this.search_field.val());
        $('body').append(div);
        w = div.width() + 25;
        div.remove();
        f_width = this.container.outerWidth();
        if (w > f_width - 10) {
          w = f_width - 10;
        }
        return this.search_field.css({
          'width': w + 'px'
        });
      }
    };

    return Chosen;
  }(AbstractChosen);
}).call(undefined);

},{}],87:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* ========================================================================
 * Bootstrap: modal.js v3.3.6
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var GC_Modal = function GC_Modal(element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;

    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };

  GC_Modal.VERSION = '3.3.6';

  GC_Modal.TRANSITION_DURATION = 300;
  GC_Modal.BACKDROP_TRANSITION_DURATION = 150;

  GC_Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };

  GC_Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  GC_Modal.prototype.show = function (_relatedTarget) {
    var that = this,
        e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget }),
        maxHeight = Math.max(250, $(window).height() - 200),
        minHeight = 250;

    this.$element.trigger(e);

    if (this.isShown || e.isDefaultPrevented()) return;

    this.isShown = true;

    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');

    this.$element.find('.modal-body').css('min-height', minHeight + 'px').css('max-height', maxHeight + 'px');

    this.escape();
    this.resize();

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);

      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.removeClass('gc-visible-but-hidden');
      that.$element.addClass('in').addClass('show').css('display', 'block');

      that.enforceFocus();

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

      transition ? that.$dialog // wait for modal to slide in
      .one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(GC_Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };

  GC_Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();

    e = $.Event('hide.bs.modal');

    this.$element.trigger(e);

    if (!this.isShown || e.isDefaultPrevented()) return;

    this.isShown = false;

    this.escape();
    this.resize();

    $(document).off('focusin.bs.modal');

    this.$element.removeClass('in').removeClass('show').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal').css('display', 'none');

    this.$dialog.off('mousedown.dismiss.bs.modal');

    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideGC_Modal, this)).emulateTransitionEnd(GC_Modal.TRANSITION_DURATION) : this.hideGC_Modal();
  };

  GC_Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal') // guard against infinite focus loop
    .on('focusin.bs.modal', $.proxy(function (e) {
      if (this.$element[0] !== e.target && !this.$element.has(e.target).length && !$(e.target.parentNode).hasClass('cke_dialog_ui_input_select') && !$(e.target.parentNode).hasClass('cke_dialog_ui_input_text')) {
        this.$element.trigger('focus');
      }
    }, this));
  };

  GC_Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };

  GC_Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };

  GC_Modal.prototype.hideGC_Modal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };

  GC_Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  GC_Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;

      this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }
        if (e.target !== e.currentTarget) return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));

      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass('in').addClass('show').css('display', 'block');

      if (!callback) return;

      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(GC_Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in').removeClass('show').css('display', 'none');

      var callbackRemove = function callbackRemove() {
        that.removeBackdrop();
        callback && callback();
      };
      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(GC_Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  };

  // these following methods are used to handle overflowing modals

  GC_Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  GC_Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };

  GC_Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };

  GC_Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;
    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  GC_Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
  };

  GC_Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
  };

  GC_Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  };

  // MODAL PLUGIN DEFINITION
  // =======================

  function GC_Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, GC_Modal.DEFAULTS, $this.data(), (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);

      if (!data) $this.data('bs.modal', data = new GC_Modal(this, options));
      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
    });
  }

  $.fn.gc_modal = GC_Plugin;
  $.fn.gc_modal.Constructor = GC_Modal;

  // MODAL DATA-API
  // ==============

  if (typeof document !== 'undefined') {

    $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
      var $this = $(this);
      var href = $this.attr('href');
      var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
      var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

      if ($this.is('a')) e.preventDefault();

      $target.one('show.bs.modal', function (showEvent) {
        if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
        $target.one('hidden.bs.modal', function () {
          $this.is(':visible') && $this.trigger('focus');
        });
      });
      GC_Plugin.call($target, option, this);
    });

    $(window).resize(function () {
      var maxHeight = Math.max(250, $(window).height() - 200),
          minHeight = 250;
      $('.gc-container').find('.modal-body').css('max-height', maxHeight + 'px').css('min-height', minHeight + 'px');
    });
  }
}(jQuery);

},{}],88:[function(require,module,exports){
"use strict";

/*
 * printThis v1.5
 * @desc Printing plug-in for jQuery
 * @author Jason Day
 *
 * Resources (based on) :
 *              jPrintArea: http://plugins.jquery.com/project/jPrintArea
 *              jqPrint: https://github.com/permanenttourist/jquery.jqprint
 *              Ben Nadal: http://www.bennadel.com/blog/1591-Ask-Ben-Print-Part-Of-A-Web-Page-With-jQuery.htm
 *
 * Licensed under the MIT licence:
 *              http://www.opensource.org/licenses/mit-license.php
 *
 * (c) Jason Day 2015
 *
 * Usage:
 *
 *  $("#mySelector").printThis({
 *      debug: false,               * show the iframe for debugging
 *      importCSS: true,            * import page CSS
 *      importStyle: false,         * import style tags
 *      printContainer: true,       * grab outer container as well as the contents of the selector
 *      loadCSS: "path/to/my.css",  * path to additional css file - us an array [] for multiple
 *      pageTitle: "",              * add title to print page
 *      removeInline: false,        * remove all inline styles from print elements
 *      printDelay: 333,            * variable print delay
 *      header: null,               * prefix to html
 *      formValues: true            * preserve input/form values
 *  });
 *
 * Notes:
 *  - the loadCSS will load additional css (with or without @media print) into the iframe, adjusting layout
 */
(function ($) {

    var opt;
    $.fn.printThis = function (options) {
        opt = $.extend({}, $.fn.printThis.defaults, options);
        var $element = this instanceof jQuery ? this : $(this);

        var strFrameName = "printThis-" + new Date().getTime();

        if (window.location.hostname !== document.domain && navigator.userAgent.match(/msie/i)) {
            // Ugly IE hacks due to IE not inheriting document.domain from parent
            // checks if document.domain is set by comparing the host name against document.domain
            var iframeSrc = "javascript:document.write(\"<head><script>document.domain=\\\"" + document.domain + "\\\";</script></head><body></body>\")";
            var printI = document.createElement('iframe');
            printI.name = "printIframe";
            printI.id = strFrameName;
            printI.className = "MSIE";
            document.body.appendChild(printI);
            printI.src = iframeSrc;
        } else {
            // other browsers inherit document.domain, and IE works if document.domain is not explicitly set
            var $frame = $("<iframe id='" + strFrameName + "' name='printIframe' />");
            $frame.appendTo("body");
        }

        var $iframe = $("#" + strFrameName);

        // show frame if in debug mode
        if (!opt.debug) $iframe.css({
            position: "absolute",
            width: "0px",
            height: "0px",
            left: "-600px",
            top: "-600px"
        });

        // $iframe.ready() and $iframe.load were inconsistent between browsers
        setTimeout(function () {

            // Add doctype to fix the style difference between printing and render
            function setDocType($iframe, doctype) {
                var win, doc;
                win = $iframe.get(0);
                win = win.contentWindow || win.contentDocument || win;
                doc = win.document || win.contentDocument || win;
                doc.open();
                doc.write(doctype);
                doc.close();
            }
            if (opt.doctypeString) {
                setDocType($iframe, opt.doctypeString);
            }

            var $doc = $iframe.contents(),
                $head = $doc.find("head"),
                $body = $doc.find("body");

            // add base tag to ensure elements use the parent domain
            $head.append('<base href="' + document.location.protocol + '//' + document.location.host + '">');

            // import page stylesheets
            if (opt.importCSS) $("link[rel=stylesheet]").each(function () {
                var href = $(this).attr("href");
                if (href) {
                    var media = $(this).attr("media") || "all";
                    $head.append("<link type='text/css' rel='stylesheet' href='" + href + "' media='" + media + "'>");
                }
            });

            // import style tags
            if (opt.importStyle) $("style").each(function () {
                $(this).clone().appendTo($head);
                //$head.append($(this));
            });

            //add title of the page
            if (opt.pageTitle) $head.append("<title>" + opt.pageTitle + "</title>");

            // import additional stylesheet(s)
            if (opt.loadCSS) {
                if ($.isArray(opt.loadCSS)) {
                    jQuery.each(opt.loadCSS, function (index, value) {
                        $head.append("<link type='text/css' rel='stylesheet' href='" + this + "'>");
                    });
                } else {
                    $head.append("<link type='text/css' rel='stylesheet' href='" + opt.loadCSS + "'>");
                }
            }

            // print header
            if (opt.header) $body.append(opt.header);

            // grab $.selector as container
            if (opt.printContainer) $body.append($element.outer());

            // otherwise just print interior elements of container
            else $element.each(function () {
                    $body.append($(this).html());
                });

            // capture form/field values
            if (opt.formValues) {
                // loop through inputs
                var $input = $element.find('input');
                if ($input.length) {
                    $input.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $checker = $this.is(':checkbox') || $this.is(':radio'),
                            $iframeInput = $doc.find('input[name="' + $name + '"]'),
                            $value = $this.val();

                        //order matters here
                        if (!$checker) {
                            $iframeInput.val($value);
                        } else if ($this.is(':checked')) {
                            if ($this.is(':checkbox')) {
                                $iframeInput.attr('checked', 'checked');
                            } else if ($this.is(':radio')) {
                                $doc.find('input[name="' + $name + '"][value=' + $value + ']').attr('checked', 'checked');
                            }
                        }
                    });
                }

                //loop through selects
                var $select = $element.find('select');
                if ($select.length) {
                    $select.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $value = $this.val();
                        $doc.find('select[name="' + $name + '"]').val($value);
                    });
                }

                //loop through textareas
                var $textarea = $element.find('textarea');
                if ($textarea.length) {
                    $textarea.each(function () {
                        var $this = $(this),
                            $name = $(this).attr('name'),
                            $value = $this.val();
                        $doc.find('textarea[name="' + $name + '"]').val($value);
                    });
                }
            } // end capture form/field values

            // remove inline styles
            if (opt.removeInline) {
                // $.removeAttr available jQuery 1.7+
                if ($.isFunction($.removeAttr)) {
                    $doc.find("body *").removeAttr("style");
                } else {
                    $doc.find("body *").attr("style", "");
                }
            }

            setTimeout(function () {
                if ($iframe.hasClass("MSIE")) {
                    // check if the iframe was created with the ugly hack
                    // and perform another ugly hack out of neccessity
                    window.frames["printIframe"].focus();
                    $head.append("<script>  window.print(); </script>");
                } else {
                    // proper method
                    if (document.queryCommandSupported("print")) {
                        $iframe[0].contentWindow.document.execCommand("print", false, null);
                    } else {
                        $iframe[0].contentWindow.focus();
                        $iframe[0].contentWindow.print();
                    }
                }

                //remove iframe after print
                if (!opt.debug) {
                    setTimeout(function () {
                        $iframe.remove();
                    }, 1000);
                }
            }, opt.printDelay);
        }, 333);
    };

    // defaults
    $.fn.printThis.defaults = {
        debug: false, // show the iframe for debugging
        importCSS: true, // import parent page css
        importStyle: false, // import style tags
        printContainer: true, // print outer container/$.selector
        loadCSS: "", // load an additional css file - load multiple stylesheets with an array []
        pageTitle: "", // add title to print page
        removeInline: false, // remove all inline styles
        printDelay: 333, // variable print delay
        header: null, // prefix to html
        formValues: true, // preserve input/form values
        doctypeString: '<!DOCTYPE html>' // html doctype
    };
})(jQuery);

// $.selector container
jQuery.fn.outer = function () {
    return $($("<div></div>").html(this.clone())).html();
};

},{}],89:[function(require,module,exports){
'use strict';

/* ========================================================================
 * Bootstrap: transition.js v3.3.5
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

+function ($) {
    'use strict';

    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================

    function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd otransitionend',
            transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return { end: transEndEventNames[name] };
            }
        }

        return false; // explicit for ie8 (  ._.)
    }

    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
            called = true;
        });
        var callback = function callback() {
            if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
    };

    $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function handle(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        };
    });
}(jQuery);

},{}],90:[function(require,module,exports){
'use strict';

var Handlebars = require('handlebars');

Handlebars.registerHelper('ifCond', function (v1, operator, v2, options) {

    switch (operator) {
        case '==':
            return v1 == v2 ? options.fn(this) : options.inverse(this);
        case '===':
            return v1 === v2 ? options.fn(this) : options.inverse(this);
        case '<':
            return v1 < v2 ? options.fn(this) : options.inverse(this);
        case '<=':
            return v1 <= v2 ? options.fn(this) : options.inverse(this);
        case '>':
            return v1 > v2 ? options.fn(this) : options.inverse(this);
        case '>=':
            return v1 >= v2 ? options.fn(this) : options.inverse(this);
        case '&&':
            return v1 && v2 ? options.fn(this) : options.inverse(this);
        case '||':
            return v1 || v2 ? options.fn(this) : options.inverse(this);
        default:
            return options.inverse(this);
    }
});

exports.Handlebars = Handlebars;

},{"handlebars":160}],91:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! jQuery Timepicker Addon - v1.6.3 - 2016-04-20
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2016 Trent Richardson; Licensed MIT */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(['jquery', 'jquery-ui'], factory);
	} else {
		factory(jQuery);
	}
})(function ($) {

	/*
 * Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
 */
	$.ui = $.ui || {};
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
 * Extend jQueryUI, get it started with our version number
 */
	$.extend($.ui, {
		timepicker: {
			version: "1.6.3"
		}
	});

	/*
 * Timepicker manager.
 * Use the singleton instance of this class, $.timepicker, to interact with the time picker.
 * Settings for (groups of) time pickers are maintained in an instance object,
 * allowing multiple different settings on the same page.
 */
	var Timepicker = function Timepicker() {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			timeOnlyShowDate: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			maxTime: null,
			minTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			altRedirectFocus: true,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			oneLine: false,
			defaultValue: null,
			parse: 'strict',
			afterInject: null
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		maxTime: null,
		minTime: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/*
  * Override the default settings for all instances of the time picker.
  * @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
  * @return {Object} the manager object
  */
		setDefaults: function setDefaults(settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
  * Create a new Timepicker instance
  */
		_newInst: function _newInst($input, opts) {
			var tp_inst = new Timepicker(),
			    inlineSettings = {},
			    fns = {},
			    overrides,
			    i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function beforeShow(input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function onChangeMonthYear(year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					// tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function onClose(dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || this._defaults[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(tp_inst._defaults.timeFormat + (tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') + (tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof tp_inst._defaults.controlType === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof $.ui.slider === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
					tp_inst.control = tp_inst._defaults.controlType;
				}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length,
			    tzi = 0,
			    tzv = null;
			if (tzl > 0 && _typeof(timezoneList[0]) !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) : new Date().getTimezoneOffset() * -1;
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin : tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin : tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin : tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin : tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin : tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField);
				if (tp_inst._defaults.altRedirectFocus === true) {
					tp_inst.$altInput.css({
						cursor: 'pointer'
					}).focus(function () {
						$input.trigger("focus");
					});
				}
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
  * add our sliders to the calendar
  */
		_addTimePicker: function _addTimePicker(dp_inst) {
			var currDT = $.trim(this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val());

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
			this._afterInject();
		},

		/*
  * parse the time string from input value or _setTime
  */
		_parseTime: function _parseTime(timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
  * Handle callback option after injecting timepicker
  */
		_afterInject: function _afterInject() {
			var o = this.inst.settings;
			if ($.isFunction(o.afterInject)) {
				o.afterInject.call(this);
			}
		},

		/*
  * generate and inject html for timepicker into ui datepicker
  */
		_injectTimePicker: function _injectTimePicker() {
			var $dp = this.inst.dpDiv,
			    o = this.inst.settings,
			    tp_inst = this,
			    litem = '',
			    uitem = '',
			    show = null,
			    max = {},
			    gridSize = {},
			    size = null,
			    i = 0,
			    l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' ui_tpicker_unit_hide',
				    html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + (o.oneLine && o.controlType === 'select' ? ' ui-timepicker-oneLine' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label' + (o.showTime ? '' : noDisplay) + '">' + o.timeText + '</dt>' + '<dd class="ui_tpicker_time ' + (o.showTime ? '' : noDisplay) + '"><input class="ui_tpicker_time_input" ' + (o.timeInput ? '' : 'disabled') + '/></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt(o[litem + 'Max'] - (o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem], 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label' + (show ? '' : noDisplay) + '">' + o[litem + 'Text'] + '</dt>' + '<dd class="ui_tpicker_' + litem + (show ? '' : noDisplay) + '"><div class="ui_tpicker_' + litem + '_slider' + (show ? '' : noDisplay) + '"></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', { hour: h }, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						} else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + (m < 10 ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}

				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label' + (showTz ? '' : noDisplay) + '">' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone' + (showTz ? '' : noDisplay) + '"></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}

				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : size / (-2 * gridSize[litem]) + "%",
							marginRight: o.isRTL ? size / (-2 * gridSize[litem]) + "%" : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
							var $t = $(this),
							    h = $t.html(),
							    n = parseInt(h.replace(/[^0-9]/g), 10),
							    ap = h.replace(/[^apm]/ig),
							    f = $t.data('for'); // loses scope, so we use data-for

							if (f === 'hour') {
								if (ap.indexOf('p') !== -1 && n < 12) {
									n += 12;
								} else {
									if (ap.indexOf('a') !== -1 && n === 12) {
										n = 0;
									}
								}
							}

							tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

							tp_inst._onTimeChange();
							tp_inst._onSelectHandler();
						}).css({
							cursor: 'pointer',
							width: 100 / gridSize[litem] + '%',
							textAlign: 'center',
							overflow: 'hidden'
						});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) {
					return $("<option />").val((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.value : val).text((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === "object" ? val.label : val);
				}));
				if (typeof this.timezone !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof this.hour !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
					tp_inst._afterInject();
				});
				// End timezone options

				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time_input');
				this.$timeObj.change(function () {
					var timeFormat = tp_inst.inst.settings.timeFormat;
					var parsedTime = $.datepicker.parseTime(timeFormat, this.value);
					var update = new Date();
					if (parsedTime) {
						update.setHours(parsedTime.hour);
						update.setMinutes(parsedTime.minute);
						update.setSeconds(parsedTime.second);
						$.datepicker._setTime(tp_inst.inst, update);
					} else {
						this.value = tp_inst.formattedTime;
						this.blur();
					}
				});

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
					    rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;

					setTimeout(function () {
						// fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
									    oldWidth = $g.outerWidth(),
									    oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
									    newWidth = oldWidth - sliderAccessWidth,
									    newMarginLeft = oldMarginLeft * newWidth / oldWidth + '%',
									    css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
  * This function tries to limit the ability to go outside the
  * min/max date range
  */
		_limitMinMaxDateTime: function _limitMinMaxDateTime(dp_inst, adjustSliders) {
			var o = this._defaults,
			    dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
				    minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
				    maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (dp_inst.settings.minTime !== null) {
				var tempMinTime = new Date("01/01/1970 " + dp_inst.settings.minTime);
				if (this.hour < tempMinTime.getHours()) {
					this.hour = this._defaults.hourMin = tempMinTime.getHours();
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else if (this.hour === tempMinTime.getHours() && this.minute < tempMinTime.getMinutes()) {
					this.minute = this._defaults.minuteMin = tempMinTime.getMinutes();
				} else {
					if (this._defaults.hourMin < tempMinTime.getHours()) {
						this._defaults.hourMin = tempMinTime.getHours();
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else if (this._defaults.hourMin === tempMinTime.getHours() === this.hour && this._defaults.minuteMin < tempMinTime.getMinutes()) {
						this._defaults.minuteMin = tempMinTime.getMinutes();
					} else {
						this._defaults.minuteMin = 0;
					}
				}
			}

			if (dp_inst.settings.maxTime !== null) {
				var tempMaxTime = new Date("01/01/1970 " + dp_inst.settings.maxTime);
				if (this.hour > tempMaxTime.getHours()) {
					this.hour = this._defaults.hourMax = tempMaxTime.getHours();
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else if (this.hour === tempMaxTime.getHours() && this.minute > tempMaxTime.getMinutes()) {
					this.minute = this._defaults.minuteMax = tempMaxTime.getMinutes();
				} else {
					if (this._defaults.hourMax > tempMaxTime.getHours()) {
						this._defaults.hourMax = tempMaxTime.getHours();
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else if (this._defaults.hourMax === tempMaxTime.getHours() === this.hour && this._defaults.minuteMax > tempMaxTime.getMinutes()) {
						this._defaults.minuteMax = tempMaxTime.getMinutes();
					} else {
						this._defaults.minuteMax = 59;
					}
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10),
				    minMax = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10),
				    secMax = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10),
				    millisecMax = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10),
				    microsecMax = parseInt(this._defaults.microsecMax - (this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec, 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax, step: this._defaults.stepHour });
					this.control.value(this, this.hour_slider, 'hour', this.hour - this.hour % this._defaults.stepHour);
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax, step: this._defaults.stepMinute });
					this.control.value(this, this.minute_slider, 'minute', this.minute - this.minute % this._defaults.stepMinute);
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax, step: this._defaults.stepSecond });
					this.control.value(this, this.second_slider, 'second', this.second - this.second % this._defaults.stepSecond);
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax, step: this._defaults.stepMillisec });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - this.millisec % this._defaults.stepMillisec);
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax, step: this._defaults.stepMicrosec });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - this.microsec % this._defaults.stepMicrosec);
				}
			}
		},

		/*
  * when a slider moves, set the internal time...
  * on time change is also called when the time is updated in the text field
  */
		_onTimeChange: function _onTimeChange() {
			if (!this._defaults.showTimepicker) {
				return;
			}
			var hour = this.hour_slider ? this.control.value(this, this.hour_slider, 'hour') : false,
			    minute = this.minute_slider ? this.control.value(this, this.minute_slider, 'minute') : false,
			    second = this.second_slider ? this.control.value(this, this.second_slider, 'second') : false,
			    millisec = this.millisec_slider ? this.control.value(this, this.millisec_slider, 'millisec') : false,
			    microsec = this.microsec_slider ? this.control.value(this, this.microsec_slider, 'microsec') : false,
			    timezone = this.timezone_select ? this.timezone_select.val() : false,
			    o = this._defaults,
			    pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
			    pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if ((typeof hour === 'undefined' ? 'undefined' : _typeof(hour)) === 'object') {
				hour = false;
			}
			if ((typeof minute === 'undefined' ? 'undefined' : _typeof(minute)) === 'object') {
				minute = false;
			}
			if ((typeof second === 'undefined' ? 'undefined' : _typeof(second)) === 'object') {
				second = false;
			}
			if ((typeof millisec === 'undefined' ? 'undefined' : _typeof(millisec)) === 'object') {
				millisec = false;
			}
			if ((typeof microsec === 'undefined' ? 'undefined' : _typeof(microsec)) === 'object') {
				microsec = false;
			}
			if ((typeof timezone === 'undefined' ? 'undefined' : _typeof(timezone)) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}
			if (timezone !== false) {
				timezone = timezone.toString();
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = hour !== parseInt(this.hour, 10) || // sliders should all be numeric
			minute !== parseInt(this.minute, 10) || second !== parseInt(this.second, 10) || millisec !== parseInt(this.millisec, 10) || microsec !== parseInt(this.microsec, 10) || this.ampm.length > 0 && hour < 12 !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1) || this.timezone !== null && timezone !== this.timezone.toString() // could be numeric or "EST" format, so use toString()
			;

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.val(this.formattedTime + pickerTimeSuffix);
				} else {
					this.$timeObj.val($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
				if (this.$timeObj[0].setSelectionRange) {
					var sPos = this.$timeObj[0].selectionStart;
					var ePos = this.$timeObj[0].selectionEnd;
					this.$timeObj[0].setSelectionRange(sPos, ePos);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
				//this.$input.focus(); // may automatically open the picker on setDate
			}
		},

		/*
  * call custom onSelect.
  * bind to sliders slidestop, and grid click.
  */
		_onSelectHandler: function _onSelectHandler() {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
  * update our input with the new date time..
  */
		_updateDateTime: function _updateDateTime(dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = dp_inst.currentYear > 0 ? new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay),
			    dt = $.datepicker._daylightSavingAdjust(dtTmp),

			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
			//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
			dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
			    formatCfg = $.datepicker._getFormatConfig(dp_inst),
			    timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, dt === null ? new Date() : dt, formatCfg);
			var formattedDateTime = this.formattedDate;

			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVal === "") {
				dp_inst.currentYear = dp_inst.selectedYear;
				dp_inst.currentMonth = dp_inst.selectedMonth;
				dp_inst.currentDay = dp_inst.selectedDay;
			}

			/*
   * remove following lines to force every changes in date picker to change the input value
   * Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker.
   * If the user manually empty the value in the input field, the date picker will never change selected value.
   */
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === false) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable) || this._defaults.timeOnly === true && this._defaults.timeOnlyShowDate === true) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
				    altSeparator = this._defaults.altSeparator !== null ? this._defaults.altSeparator : this._defaults.separator,
				    altTimeSuffix = this._defaults.altTimeSuffix !== null ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;

				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, dt === null ? new Date() : dt, formatCfg);
					} else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat !== null) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				} else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function _onFocus() {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
				    tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
  * Small abstraction to control types
  * We can add more, just be sure to follow the pattern: create, options, value
  */
		_controls: {
			// slider methods
			slider: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function slide(event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function stop(event, ui) {
							tp_inst._onSelectHandler();
						}
					});
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof opts === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min,
						    max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof opts === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function value(tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function create(tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select ui-state-default ui-corner-all" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
					    format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), { hour: i }, tp_inst._defaults);
						} else if (unit === 'millisec' || unit === 'microsec' || i >= 10) {
							sel += i;
						} else {
							sel += '0' + i.toString();
						}
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
						tp_inst._afterInject();
					});

					return obj;
				},
				options: function options(tp_inst, obj, unit, opts, val) {
					var o = {},
					    $t = obj.children('select');
					if (typeof opts === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;
					} else {
						o = opts;
					}
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min >= 0 ? o.min : $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function value(tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			} // end _controls

		} });

	$.fn.extend({
		/*
  * shorthand just to use timepicker.
  */
		timepicker: function timepicker(o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if ((typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
  * extend timepicker to datepicker
  */
		datetimepicker: function datetimepicker(o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof o === 'string') {
				if (o === 'getDate' || o === 'option' && tmp_args.length === 2 && typeof tmp_args[1] === 'string') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
 * Public Utility to parse date and time
 */
	$.datepicker = $.datepicker || {};
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
 * Public utility to parse time
 */
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
		    iso8601 = timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1;

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function strictParse(f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function getPatternAmpm(amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function getFormatPositions(timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
				    orders = {
					h: -1,
					m: -1,
					s: -1,
					l: -1,
					c: -1,
					t: -1,
					z: -1
				};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
				var ml = match.length;
				switch (match.charAt(0).toLowerCase()) {
					case 'h':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'm':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 's':
						return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
					case 'l':
						return '(\\d?\\d?\\d)';
					case 'c':
						return '(\\d?\\d?\\d)';
					case 'z':
						return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
					case 't':
						return getPatternAmpm(o.amNames, o.pmNames);
					default:
						// literal escaped in quotes
						return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) {
							return "\\" + m;
						}) + ')?';
				}
			}).replace(/\s/g, '\\s?') + o.timeSuffix + '$',
			    order = getFormatPositions(f),
			    ampm = '',
			    treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), $.map(o.amNames, function (x, i) {
							return x.toUpperCase();
						})) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}

				return resTime;
			}
			return false;
		}; // end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function looseParse(f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			} catch (err) {
				try {
					return strictParse(f, s, o);
				} catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}
			}
			return false;
		}; // end looseParse

		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
  * Public utility to format the time
  * @param {string} format format of the time
  * @param {Object} time Object not a Date for timezones
  * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
  * @returns {string} the formatted time
  */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
		    ampmName = options.amNames[0],
		    hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
				case 'HH':
					return ('0' + hour).slice(-2);
				case 'H':
					return hour;
				case 'hh':
					return ('0' + convert24to12(hour)).slice(-2);
				case 'h':
					return convert24to12(hour);
				case 'mm':
					return ('0' + time.minute).slice(-2);
				case 'm':
					return time.minute;
				case 'ss':
					return ('0' + time.second).slice(-2);
				case 's':
					return time.second;
				case 'l':
					return ('00' + time.millisec).slice(-3);
				case 'c':
					return ('00' + time.microsec).slice(-3);
				case 'z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
				case 'Z':
					return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
				case 'T':
					return ampmName.charAt(0).toUpperCase();
				case 'TT':
					return ampmName.toUpperCase();
				case 't':
					return ampmName.charAt(0).toLowerCase();
				case 'tt':
					return ampmName.toLowerCase();
				default:
					return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
 * the bad hack :/ override datepicker so it doesn't close on select
 // inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
 */
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
		    tp_inst = this._get(inst, 'timepicker'),
		    was_inline;

		if (tp_inst && inst.settings.showTimepicker) {
			tp_inst._limitMinMaxDateTime(inst, true);
			was_inline = inst.inline;
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = was_inline;
			inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
 * second bad hack :/ override datepicker so it triggers an event when changing the input field
 * and does not redraw the datepicker on every selectDate event
 */
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof inst.stay_open !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
 * third bad hack :/ override datepicker so it allows spaces and colon in the input field
 */
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
				    tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
				    dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
				    datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, '').replace(/TT/g, ampm ? 'APM' : '').replace(/Tt/g, ampm ? 'AaPpMm' : '').replace(/tT/g, ampm ? 'AaPpMm' : '').replace(/T/g, ampm ? 'AP' : '').replace(/tt/g, ampm ? 'apm' : '').replace(/t/g, ampm ? 'ap' : '') + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tz ? tp_inst._defaults.timezoneList.join('') : '') + tp_inst._defaults.amNames.join('') + tp_inst._defaults.pmNames.join('') + dateChars,
				    chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1;
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
 * Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
 * Update any alternate field to synchronise with the main field.
 */
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) {
				// update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
				    date = this._getDate(inst),
				    formatCfg = $.datepicker._getFormatConfig(inst),
				    altFormattedDateTime = '',
				    altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator,
				    altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
				    altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;

				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					} else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(inst.input.val() ? altFormattedDateTime : "");
			}
		} else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
 * Override key up event to sync manual input changes.
 */
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
		    tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && inst.input.val() !== inst.lastVal) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
 * override "Today" button to also grab the time and set it to input field.
 */
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]);
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		if (!tp_inst) {
			return;
		}

		var tzoffset = $.timepicker.timezoneOffsetNumber(tp_inst.timezone);
		var now = new Date();
		now.setMinutes(now.getMinutes() + now.getTimezoneOffset() + parseInt(tzoffset, 10));
		this._setTime(inst, now);
		this._setDate(inst, now);
		tp_inst._onSelectHandler();
	};

	/*
 * Disable & enable the Time in the datetimepicker
 */
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create our own set time function
 */
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times..
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
 * Create new public method to set only time, callable as $().datepicker('setTime', date)
 */
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}
	};

	/*
 * override setDate() to allow setting time too within Date object
 */
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, _date) {
		var inst = this._getInst(target);
		var date = _date;
		if (!inst) {
			return;
		}

		if (typeof _date === 'string') {
			date = new Date(_date);
			if (!date.getTime()) {
				this._base_setDateDatepicker.apply(this, arguments);
				date = $(target).datepicker('getDate');
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}

		// This is important if you are using the timezone option, javascript's Date
		// object will only return the timezone offset for the current locale, so we
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst && tp_date) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()), tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, $.timepicker.timezoneOffsetString(-tp_date.getTimezoneOffset()), tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
 * override getDate() to allow getting time too within Date object
 */
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);

			var currDT = null;

			if (tp_inst.$altInput && tp_inst._defaults.altFieldTimeOnly) {
				currDT = tp_inst.$input.val() + ' ' + tp_inst.$altInput.val();
			} else if (tp_inst.$input.get(0).tagName !== 'INPUT' && tp_inst.$altInput) {
				/**
     * in case the datetimepicker has been applied to a non-input tag for inline UI,
     * and the user has not configured the plugin to display only time in altInput,
     * pick current date time from the altInput (and hope for the best, for now, until "ER1" is applied)
     *
     * @todo ER1. Since altInput can have a totally difference format, convert it to standard format by reading input format from "altFormat" and "altTimeFormat" option values
     */
				currDT = tp_inst.$altInput.val();
			} else {
				currDT = tp_inst.$input.val();
			}

			if (date && tp_inst._parseTime(currDT, !inst.settings.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date
				// object will only return the timezone offset for the current locale, so we
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone, $.timepicker.timezoneOffsetString(-date.getTimezoneOffset()));
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
 * override parseDate() because UI 1.8.14 throws an error about "Extra characters"
 * An option in datapicker to ignore extra format characters would be nicer.
 */
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
 * override formatDate to set date with time to the input
 */
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
 * override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
 */
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
		    name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
			    max = null,
			    onselect = null,
			    overrides = tp_inst._defaults.evnts,
			    fns = {},
			    prop,
			    ret,
			    oldVal,
			    $target;
			if (typeof name === 'string') {
				// if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof value === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
				//if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) {
						name_clone = $.extend({}, name);
					}
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) {
				return;
			}
			if (min) {
				//if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) {
				//if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}

			// Datepicker will override our date when we call _base_optionDatepicker when
			// calling minDate/maxDate, so we will first grab the value, call
			// _base_optionDatepicker, then set our value back.
			if (min || max) {
				$target = $(target);
				oldVal = $target.datetimepicker('getDate');
				ret = this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
				$target.datetimepicker('setDate', oldVal);
				return ret;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};

	/*
 * jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
 * it will return false for all objects
 */
	var isEmptyObject = function isEmptyObject(obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
 * jQuery extend now ignores nulls!
 */
	var extendRemove = function extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
 * Determine by the time format which units are supported
 * Returns an object of booleans for each unit
 */
	var detectSupport = function detectSupport(timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(),
		    // removes literals
		isIn = function isIn(f, t) {
			// does the format contain the token?
			return f.indexOf(t) !== -1 ? true : false;
		};
		return {
			hour: isIn(tf, 'h'),
			minute: isIn(tf, 'm'),
			second: isIn(tf, 's'),
			millisec: isIn(tf, 'l'),
			microsec: isIn(tf, 'c'),
			timezone: isIn(tf, 'z'),
			ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
			iso8601: isIn(timeFormat, 'Z')
		};
	};

	/*
 * Converts 24 hour format into 12 hour
 * Returns 12 hour without leading 0
 */
	var convert24to12 = function convert24to12(hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function computeEffectiveSetting(settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
 * Splits datetime string into date and time substrings.
 * Throws exception when date can't be parsed
 * Returns {dateString: dateString, timeString: timeString}
 */
	var splitDateTime = function splitDateTime(dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
		    format = computeEffectiveSetting(timeSettings, 'timeFormat'),
		    timeParts = format.split(separator),
		    // how many occurrences of separator may be in our format?
		timePartsLen = timeParts.length,
		    allParts = dateTimeString.split(separator),
		    allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
 * Internal function to parse datetime interval
 * Returns: {date: Date, timeObj: Object}, where
 *   date - parsed date without time (type Date)
 *   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
 */
	var parseDateTimeInternal = function parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date, parts, parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
 * Internal function to set timezone_select to the local timezone
 */
	var selectLocalTimezone = function selectLocalTimezone(tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
 * Create a Singleton Instance
 */
	$.timepicker = new Timepicker();

	/**
  * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
  * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
  * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
  * @return {string}
  */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
		    minutes = off % 60,
		    hours = (off - minutes) / 60,
		    iso = iso8601 ? ':' : '',
		    tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);

		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
  * Get the number in minutes that represents a timezone string
  * @param  {string} tzString formatted like "+0500", "-1245", "Z"
  * @return {number} the offset minutes or the original string if it doesn't match expectations
  */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') {
			// if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) {
			// possibly a user defined tz, so just give it back
			return parseInt(tzString, 10);
		}

		return (normalized.substr(0, 1) === '-' ? -1 : 1) * ( // plus or minus
		parseInt(normalized.substr(1, 2), 10) * 60 + // hours (converted to minutes)
		parseInt(normalized.substr(3, 2), 10)); // minutes
	};

	/**
  * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
  * @param  {Date} date
  * @param  {string} fromTimezone formatted like "+0500", "-1245"
  * @param  {string} toTimezone formatted like "+0500", "-1245"
  * @return {Date}
  */
	$.timepicker.timezoneAdjust = function (date, fromTimezone, toTimezone) {
		var fromTz = $.timepicker.timezoneOffsetNumber(fromTimezone);
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -fromTz - -toTz);
		}
		return date;
	};

	/**
  * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * n.b. The input value must be correctly formatted (reformatting is not supported)
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the timepicker() call
  * @return {jQuery}
  */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
  * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @return {jQuery}
  */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
  * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
  * Calls `method` on the `startTime` and `endTime` elements, and configures them to
  * enforce date range limits.
  * @param  {string} method Can be used to specify the type of picker to be added
  * @param  {Element} startTime
  * @param  {Element} endTime
  * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
  *   a boolean value that can be used to reformat the input values to the `dateFormat`.
  * @return {jQuery}
  */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {}, // options for start picker
			end: {} // options for end picker
		}, options);

		// for the mean time this fixes an issue with calling getDate with timepicker()
		var timeOnly = false;
		if (method === 'timepicker') {
			timeOnly = true;
			method = 'datetimepicker';
		}

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
			    enddt = endTime[method]('getDate'),
			    changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
				    maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) {
					// minInterval check
					endTime[method]('setDate', minDate);
				} else if (options.maxInterval > 0 && maxDate < enddt) {
					// max interval check
					endTime[method]('setDate', maxDate);
				} else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}

			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			timeOnly: timeOnly,
			onClose: function onClose(dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function onSelect(selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);

		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');

		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
  * Log error or data to the console during error or debugging
  * @param  {Object} err pass any type object to log to the console during error or debugging
  * @return {void}
  */
	$.timepicker.log = function () {
		// Older IE (9, maybe 10) throw error on accessing `window.console.log.apply`, so check first.
		if (window.console && window.console.log && window.console.log.apply) {
			window.console.log.apply(window.console, Array.prototype.slice.call(arguments));
		}
	};

	/*
  * Add util object to allow access to private methods for testability.
  */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
 * Microsecond support
 */
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () {
			return this.microseconds;
		};
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
 * Keep up with the version
 */
	$.timepicker.version = "1.6.3";
});

},{}],92:[function(require,module,exports){
'use strict';

require('../datagrid/jquery.gcrud.datagrid.js');
jQuery(document).ready(function GroceryCRUDOnDocumentReady() {
    jQuery('.gc-container').groceryCrud();
});

},{"../datagrid/jquery.gcrud.datagrid.js":83}],93:[function(require,module,exports){
'use strict';

var $ = jQuery,
    i18n = require('../../sections/i18n').i18n,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    jQueryPlugins = Object.create({
    init: function jQueryPluginsInit() {
        $.datepicker.setDefaults({
            constrainInput: false,
            showButtonPanel: true,
            changeMonth: true,
            changeYear: true,
            closeText: i18n.t('calendar_close_text'),
            prevText: i18n.t('calendar_prev_text'),
            nextText: i18n.t('calendar_next_text'),
            currentText: i18n.t('calendar_current_text'),
            monthNames: i18n.t('calendar_month_names'),
            monthNamesShort: i18n.t('calendar_month_names_short'),
            dayNames: i18n.t('calendar_day_names'),
            dayNamesShort: i18n.t('calendar_day_names_short'),
            dayNamesMin: i18n.t('calendar_day_names_min'),
            weekHeader: i18n.t('calendar_week_header')
        });

        $.timepicker.setDefaults({
            timeFormat: 'HH:mm:ss',
            timeText: i18n.t('time_text'),
            hourText: i18n.t('time_hour_text'),
            minuteText: i18n.t('time_minute_text'),
            secondText: i18n.t('time_second_text')
        });
    },
    datepicker: function datepicker($selector, gcInstance) {
        $selector.datepicker({
            dateFormat: gcInstance !== undefined ? gcInstance.dateFormat : 'yy-mm-dd'
        });
    },
    datetimepicker: function datetimepicker($selector, gcInstance) {
        $selector.datetimepicker({
            dateFormat: gcInstance !== undefined ? gcInstance.dateFormat : 'yy-mm-dd'
        });
    },
    texteditor: function texteditor($selector) {
        $selector.ckeditor();
    },
    updateTexteditor: function texteditor(fieldName, fieldValue) {
        if (typeof CKEDITOR.instances[fieldName] !== 'undefined') {
            CKEDITOR.instances[fieldName].setData(fieldValue);
        }
    },
    destroyTexteditor: function destroyTexteditor(fieldName) {
        if (typeof CKEDITOR.instances[fieldName] !== 'undefined') {
            CKEDITOR.instances[fieldName].destroy();
        }
    },
    searchableSelect: function searchableSelect($selector) {
        var isReadOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var myReactComponent = arguments[2];

        $selector.chosen('destroy');

        // Timeout as jquery Chosen is dynamically checking for select width
        setTimeout(function timeOutforSearchableSelect() {
            // Removing hidden class in order to calculate the width with chosen
            if (isReadOnly) {
                $selector.removeClass('hidden');
            }
            $selector.chosen({
                allow_single_deselect: true
            }).change(function onChosenChange() {
                if (myReactComponent) {
                    myReactComponent.linkedChange({
                        target: {
                            value: $(this).val()
                        }
                    });
                }
            });

            if (isReadOnly) {
                // Put back the hidden class for read Only
                $selector.addClass('hidden');
                $selector.next().addClass('hidden');
            } else {
                $selector.next().removeClass('hidden');
            }
        }, 1000);
    },
    searchableSelectUpdate: function searchableSelectUpdate($selector, isReadOnly) {
        if (isReadOnly) {
            $selector.next().addClass('hidden');
        } else {
            $selector.trigger('chosen:updated');
            $selector.next().removeClass('hidden');
        }
    },
    searchableAjaxSelect: function searchableAjaxSelect($selector, gcInstance) {

        setTimeout(function timeOutSearchableAjaxSelect() {
            $selector.select2({
                ajax: {
                    url: ajaxHelper.getUrl.apply(gcInstance, ['ajax-search']),
                    dataType: 'json',
                    method: 'post',
                    delay: 250,
                    data: function getDataParameters(params) {
                        return {
                            search_value: params.term,
                            field_name: 'country',
                            page: params.page
                        };
                    },
                    processResults: function ajaxProcessResults(data, params) {
                        params.page = params.page || 1;
                        return {
                            results: data.items,
                            pagination: {
                                more: params.page * 30 < data.total_count
                            }
                        };
                    },
                    cache: true
                },
                allowClear: true,
                placeholder: 'Select an option',
                escapeMarkup: function escapeMarkupMakeItWork(markup) {
                    return markup;
                },
                minimumInputLength: 1,
                templateResult: function templateResult(item) {
                    return item.title || '';
                },
                templateSelection: function templateSelection(item) {
                    return item.title || '';
                }
            });
            $selector.select2({
                data: [{
                    id: '',
                    title: ''
                }, {
                    id: 'GR',
                    title: 'Greece'
                }]
            });
        }, 1000);
    },
    searchableAjaxSelectUpdate: function searchableAjaxSelectUpdate($selector) {
        $selector.trigger('change');
    }
});

exports.jQueryPlugins = jQueryPlugins;

},{"../../helpers/ajax-helper":84,"../../sections/i18n":102}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PerPageDropdown = function (_React$Component) {
    _inherits(PerPageDropdown, _React$Component);

    function PerPageDropdown() {
        _classCallCheck(this, PerPageDropdown);

        return _possibleConstructorReturn(this, (PerPageDropdown.__proto__ || Object.getPrototypeOf(PerPageDropdown)).apply(this, arguments));
    }

    _createClass(PerPageDropdown, [{
        key: "render",
        value: function render() {
            var _props = this.props,
                defaultPerPage = _props.defaultPerPage,
                pagingOptions = _props.pagingOptions;


            return React.createElement(
                "select",
                { name: "per_page", className: "per_page form-control", defaultValue: defaultPerPage },
                pagingOptions.map(function PerPageDropDownForEach(fieldValue) {
                    return React.createElement(
                        "option",
                        { value: fieldValue, key: fieldValue },
                        fieldValue
                    );
                })
            );
        }
    }]);

    return PerPageDropdown;
}(React.Component);

exports.default = PerPageDropdown;

},{}],95:[function(require,module,exports){
'use strict';

var Constants = {
    PAGING: {
        CLASS_PER_PAGE: 'per_page'
    },

    RESPONSE: {
        SUCCESS: 'success',
        FAILURE: 'failure'
    },

    FIELD_TYPE_RELATION: 'relational',
    FIELD_TYPE_RELATION_NATIVE: 'relational_native',
    FIELD_TYPE_RELATION_N_TO_N: 'relational_n_n',
    FIELD_TYPE_DEPENDED_RELATION: 'depended_relational',
    FIELD_TYPE_NATIVE_RELATION_N_TO_N: 'native_relational_n_n',
    FIELD_TYPE_DATE: 'date',
    FIELD_TYPE_DATETIME: 'datetime',
    FIELD_TYPE_TIMESTAMP: 'timestamp',
    SELECTOR_STRING_VARIABLES: '.string-variables',
    SELECTOR_GRID_TABLE: '.grocery-crud-table',
    SELECTOR_PAGE_NUMBER_INPUT: '.page-number-input',
    SELECTOR_HIDDEN_PAGE_NUMBER: '.page-number-hidden',
    SELECTOR_ACTIVE: '.active',
    SELECTOR_VISIBLE_COLUMN_CHECKBOX: 'input[type=checkbox]',
    SELECTOR_DATAGRID_CONTAINER: '.gc-grid-container',
    SELECTOR_HEADER_TOOLS: '.header-tools',
    SELECTOR_SETTINGS: '.gc-settings-container',
    SELECTOR_MODAL_FORM: '.gc-form-operation-modal',
    SELECTOR_MODAL_ADD_FORM_CONTAINER: '.gc-insert-modal',
    SELECTOR_MODAL_EDIT_FORM_CONTAINER: '.gc-update-modal',
    SELECTOR_MODAL_READ_FORM_CONTAINER: '.gc-read-modal',
    SELECTOR_SEARCH_ROW: '.gc-search-row',

    SELECTOR_SEARCH_FIELD_INPUT: '.gc-searchable-input',

    SELECTOR_FORM: 'form',
    SELECTOR_COLUMNS_TR: '.header-columns',

    CLASS_DISABLED: 'disabled',
    CLASS_COLUMN_ON_HOVER: 'bg-info',
    CLASS_PAGING_PREVIOUS: 'paging-previous',
    CLASS_PAGING_NEXT: 'paging-next',
    CLASS_PAGING_FIRST: 'paging-first',
    CLASS_PAGING_LAST: 'paging-last',
    CLASS_PER_PAGE: 'per_page',

    ACTION_DATAGRID: 'datagrid',
    ACTION_PRINT: 'print',
    ACTION_ADD_FORM: 'add-form',
    ACTION_EDIT_FORM: 'edit-form',
    ACTION_CLONE_FORM: 'clone-form',
    ACTION_READ_FORM: 'read-form',
    ACTION_INSERT: 'insert',
    ACTION_CLONE: 'clone',
    ACTION_UPDATE: 'update',
    ACTION_READ: 'read',
    ACTION_REMOVE_ONE: 'remove-one',
    ACTION_REMOVE_MULTIPLE: 'remove-multiple',
    ACTION_INIT_DATA: 'initial',

    SELECTOR_BUTTON_ADD: '.button-add',

    FIELD_NAME_ACTION: 'action',

    HANDLEBARS_TEMPLATE_ROW: '.gc-table-row',
    HANDLEBARS_TEMPLATE_HEADER_COLUMNS: '.gc-table-header-columns',
    HANDLEBARS_TEMPLATE_CAPTION_TITLE: '.gc-table-title-caption',
    HANDLEBARS_ADD_BUTTON: '.gc-add-button',
    HANDLEBARS_ACTIONS_TITLE: '.gc-header-actions-title',
    HANDLEBARS_EXPORT_BUTTON: '.gc-export-button',
    HANDLEBARS_PRINT_BUTTON: '.gc-print-button',
    HANDLEBARS_INSERT_MODAL: '.gc-insert-modal-template',
    HANDLEBARS_READ_MODAL: '.gc-read-modal-template',
    HANDLEBARS_READ_FIELD_ROW: '.gc-read-field-row',
    HANDLEBARS_ERROR: '.gc-error',
    HANDLEBARS_SETTINGS_BUTTONS: '.gc-settings-buttons-template',
    HANDLEBARS_DELETE_SINGLE_MODAL: '.gc-confirm-delete-single',
    HANDLEBARS_DELETE_MUTLIPLE_MODAL: '.gc-confirm-delete-multiple',
    HANDLEBARS_PRINT_CONTAINER: '.gc-print-template',
    HANDLEBARS_PRINT_HEADER: '.gc-print-header',

    SELECTOR_PAGING_PREVIOUS: '.paging-previous',
    SELECTOR_PAGING_NEXT: '.paging-next',
    SELECTOR_PAGING_FIRST: '.paging-first',
    SELECTOR_PAGING_LAST: '.paging-last',

    CANCEL_BUTTON: '.gc-cancel-button',

    SELECTOR_DELETE_BUTTON: '.gc-delete-single',
    SELECTOR_DELETE_CONFIRMATION_BUTTON: '.delete-single-confirmation-button',
    SELECTOR_DELETE_FORM_MODAL: '.delete-single-confirmation',

    SELECTOR_MULTIPLE_DELETE_FORM_MODAL: '.gc-delete-multiple-confirmation',
    SELECTOR_MULTIPLE_DELETE_CONFIRMATION_BUTTON: '.delete-multiple-confirmation-button',

    SELECTOR_DELETE_CHECKBOX: 'input.gc-select-row',
    SELECTOR_DELETE_CHECKBOX_CHECKED: 'input.gc-select-row:checked',

    SELECTOR_EDIT_BUTTON: '.gc-edit-button',
    SELECTOR_READ_BUTTON: '.gc-read-button',

    SELECTOR_MODAL_BODY: '.modal-body',

    SELECTOR_TYPE_DATE_INPUT: '.gc-date',
    SELECTOR_TYPE_DATETIME_INPUT: '.gc-datetime'
};

exports.Constants = Constants;

},{}],96:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RelationNtoN = require('../types/relation-n-n').RelationNtoN,
    Relation = require('../types/relation').Relation,
    Enum = require('../types/enum').Enum,
    Dropdown = require('../types/dropdown').Dropdown,
    MultipleSelect = require('../types/multiple-select').MultipleSelect,
    CheckboxBoolean = require('../types/checkbox-boolean').CheckboxBoolean,
    DateAndTime = require('../types/date-and-time').DateAndTime,
    Upload = require('../types/upload').Upload,
    Texteditor = require('../types/texteditor').Texteditor,
    CallbackColumn = require('../types/callback-column').CallbackColumn,
    Column = Object.create({
    initCachedData: function initCachedData() {
        RelationNtoN.initData.apply(this);
        Relation.initData.apply(this);
        Enum.initData.apply(this);
        DateAndTime.initData.apply(this);
        Upload.initData.apply(this);
        Dropdown.initData.apply(this);
        CheckboxBoolean.initData.apply(this);
        MultipleSelect.initData.apply(this);
        Texteditor.initData.apply(this);
        CallbackColumn.initData.apply(this);
    },
    getRowsData: function getRowsData(dataObject) {
        var rowData = {};

        rowData.backendActionButtons = dataObject.grocery_crud_extras.actionButtons;
        rowData.primaryKeyValue = dataObject.grocery_crud_extras.primaryKeyValue;

        rowData.columnsData = [];
        _underscore2.default.each(this.visibleColumns, function eachVisibleColumns(columnName) {
            var rowValue = dataObject[columnName],
                isHtml = false;
            if (rowValue === null || rowValue === undefined) {
                rowValue = '';
            }
            if (RelationNtoN.isNtoN.apply(this, [columnName])) {
                rowValue = RelationNtoN.transformData.apply(this, [columnName, rowValue]);
            } else if (Upload.isUploadType.apply(this, [columnName])) {
                rowValue = Upload.formatUpload.apply(this, [columnName, rowValue]);
                isHtml = true;
            } else if (Dropdown.isDropdown.apply(this, [columnName])) {
                rowValue = Dropdown.formatValue.apply(this, [columnName, rowValue]);
            } else if (CheckboxBoolean.isCheckboxBoolean.apply(this, [columnName])) {
                rowValue = CheckboxBoolean.formatValue.apply(this, [rowValue]);
                isHtml = true;
            } else if (Relation.isRelational.apply(this, [columnName])) {
                rowValue = Relation.transformData.apply(this, [columnName, rowValue]);
            } else if (MultipleSelect.isThisType.apply(this, [columnName])) {
                rowValue = MultipleSelect.transformData.apply(this, [columnName, rowValue]);
            } else if (Texteditor.isThisType.apply(this, [columnName])) {
                isHtml = true;
            } else if (CallbackColumn.isThisType.apply(this, [columnName])) {
                isHtml = true;
            }

            rowData.columnsData.push({
                name: columnName,
                value: rowValue,
                isHtml: isHtml
            });
        }.bind(this));

        return rowData;
    }
});

exports.Column = Column;

},{"../types/callback-column":111,"../types/checkbox-boolean":112,"../types/date-and-time":113,"../types/dropdown":114,"../types/enum":115,"../types/multiple-select":116,"../types/relation":118,"../types/relation-n-n":117,"../types/texteditor":119,"../types/upload":120,"underscore":225}],97:[function(require,module,exports){
'use strict';

var Grid = require('./datagrid.grid.js').Grid,
    jQueryPlugins = require('../../modules/jquery/jquery-plugins').jQueryPlugins,
    localStorageHelper = require('../../helpers/local-storage-helper').localStorageHelper,
    Handlebars = require('handlebars'),
    Constants = require('../constants').Constants,
    DatagridColumns = Object.create({
    setVisibleColumns: function setVisibleColumns() {
        var visibleColumnsCache = void 0,
            visibleColumns = void 0;

        visibleColumnsCache = DatagridColumns.getCacheForVisibleColumns.apply(this);

        if (visibleColumnsCache) {
            // @todo: Handle JSON.parse
            visibleColumnsCache = JSON.parse(visibleColumnsCache);
        }

        if (visibleColumnsCache) {
            visibleColumns = DatagridColumns.filterVisibleColumns.apply(this, [visibleColumnsCache]);

            // In case we don't have any visible columns then add all the columns as checked
            if (visibleColumns.length === 0) {
                visibleColumns = this.columns;
            }
        } else {
            visibleColumns = this.columns;
        }

        DatagridColumns.triggerColumnsRender.apply(this, [visibleColumns]);
    },
    filterVisibleColumns: function filterVisibleColumns(visibleColumns) {
        var filteredVisibleColumns = this.columns.filter(function (column) {
            return visibleColumns.indexOf(column.columnName) > -1;
        });

        if (filteredVisibleColumns.length === 0) {
            filteredVisibleColumns = this.columns;
        }

        return filteredVisibleColumns;
    },
    templateObjectFieldTypes: function templateObjectFieldTypes(column) {
        var field = void 0,
            isEnum = void 0,
            isDate = void 0,
            isDatetime = void 0,
            isDropdown = void 0,
            isRelational = void 0,
            isNtoNRelational = void 0,
            isSearchable = void 0,
            isAjaxSearchable = void 0,
            isBoolean = void 0;

        field = this.cachedInitialData.fieldTypes[column.columnName];

        if (field === undefined) {
            throw new Error('Can\'t find column name: "' + column.columnName + '" in fieldTypes. ' + 'This is usually an error that you will see when you\'ve added a field name that doesn\'t exist ' + 'in the database.');
        }

        isEnum = field.dataType === 'enum' || field.dataType === 'enum_searchable';
        isDate = field.dataType === 'date';
        isDatetime = field.dataType === 'datetime' || field.dataType === 'timestamp';
        isDropdown = field.dataType === 'dropdown' || field.dataType === 'dropdown_search' || field.dataType === 'multiselect_searchable' || field.dataType === 'multiselect_native';
        isRelational = field.dataType === 'relational' || field.dataType === 'relational_native' || field.dataType === 'depended_relational';
        isNtoNRelational = field.dataType === 'relational_n_n' || field.dataType === 'native_relational_n_n';
        isSearchable = field.dataType === 'relational_n_n' || field.dataType === 'relational' || field.dataType === 'depended_relational' && field.options.dependedFrom.length === 0;
        isAjaxSearchable = field.dataType === 'depended_relational' && field.options.dependedFrom.length > 0;
        isBoolean = field.dataType === 'checkbox_boolean';

        return {
            column_name: column.columnName,
            display_name: column.displayAs,
            columnInfo: field,
            isEnum: isEnum,
            isDropdown: isDropdown,
            isRelational: isRelational,
            isNtoNRelational: isNtoNRelational,
            isDate: isDate,
            isDatetime: isDatetime,
            isSearchable: isSearchable,
            isAjaxSearchable: isAjaxSearchable,
            isBoolean: isBoolean,
            knownField: isEnum || isDropdown || isRelational || isNtoNRelational || isDate || isDatetime || isBoolean,
            hasOrdering: !isRelational && !isNtoNRelational && !isDropdown
        };
    },
    triggerColumnsRender: function triggerColumnsRender(visibleColumnsRaw) {
        var columnsTemplate = void 0,
            templateObject = void 0,
            searchColumnsTemplate = void 0,
            i18nStrings = this.cachedInitialData.i18n,
            visibleColumns = void 0;

        Handlebars.registerHelper('ifCond', function (v1, v2, options) {
            if (v1 === v2) {
                return options.fn(this);
            }
            return options.inverse(this);
        });

        Handlebars.registerHelper('ifNot', function (v1, v2, options) {
            if (v1 !== v2) {
                return options.fn(this);
            }
            return options.inverse(this);
        });

        templateObject = {
            table_columns: [],
            i18n: i18nStrings,
            hasActions: this.datagridHasActions.apply(this),
            searchByColumn: !Grid.hasExtendedSearch.apply(this)
        };

        if (visibleColumnsRaw) {
            visibleColumns = visibleColumnsRaw;
        } else if (this.visibleColumns.length > 0) {
            visibleColumns = DatagridColumns.filterVisibleColumns.apply(this, [this.visibleColumns]);
        } else {
            throw new Error('Unexpected error!');
        }

        templateObject.table_columns = visibleColumns.map(DatagridColumns.templateObjectFieldTypes.bind(this));
        this.visibleColumns = visibleColumns.map(function (column) {
            return column.columnName;
        });

        columnsTemplate = Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_TEMPLATE_HEADER_COLUMNS).html());
        searchColumnsTemplate = Handlebars.compile(this.$gc.find('.gc-search-columns').html(), {
            i18n: i18nStrings
        });

        this.$gc.find('.gc-search-column').remove();
        this.$gc.find(Constants.SELECTOR_COLUMNS_TR).html(columnsTemplate(templateObject));
        this.$gc.find('.gc-search-row').append(searchColumnsTemplate(templateObject));

        if (this.$gc.find('.gc-searchable-date').length > 0) {
            jQueryPlugins.datepicker(this.$gc.find('.gc-searchable-date'), this);
        }
        if (this.$gc.find('.gc-searchable-datetime').length > 0) {
            jQueryPlugins.datetimepicker(this.$gc.find('.gc-searchable-datetime'), this);
        }
        if (this.$gc.find('.gc-with-search-plugin').length > 0) {
            jQueryPlugins.searchableSelect(this.$gc.find('.gc-with-search-plugin'));
        }

        Grid.activateOrderingColumn.apply(this);
        Grid.activateOrderingRows.apply(this);

        Grid.listenerColumnWithOrdering.apply(this);
        Grid.listenerSearchInput.apply(this);
    },
    setCacheForVisibleColumns: function setCacheForVisibleColumns(visibleColumns) {
        localStorageHelper.setLocalStorageItem('gcrudVisibleColumns_' + this.uniqueId, JSON.stringify(visibleColumns));
    },
    getCacheForVisibleColumns: function getCacheForVisibleColumns() {
        return localStorageHelper.getLocalStorageItem('gcrudVisibleColumns_' + this.uniqueId);
    }
});

exports.DatagridColumns = DatagridColumns;

},{"../../helpers/local-storage-helper":85,"../../modules/jquery/jquery-plugins":93,"../constants":95,"./datagrid.grid.js":98,"handlebars":160}],98:[function(require,module,exports){
'use strict';

var $ = jQuery,
    localStorageHelper = require('../../helpers/local-storage-helper').localStorageHelper,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    DatagridPaging = require('./datagrid.paging').DatagridPaging,
    Constants = require('../constants').Constants,
    Grid = Object.create({
    searchAndOrderingTrigger: function searchAndOrderingTrigger(highlightRowId) {
        var datagrid_object = this,
            gcrud_container = datagrid_object.$gc,
            ajax_list_url = gcrud_container.data('url');
        var dataToSend = void 0;

        DatagridPaging.pagingCalculations.apply(this);

        dataToSend = Grid.getDataToSend.apply(this);

        localStorageHelper.setLocalStorageItem('gcrudInitialData_' + this.uniqueId, JSON.stringify({
            order_by: dataToSend.order_by,
            sorting: dataToSend.sorting
        }));

        localStorageHelper.setLocalStorageItem('gcrudPreferences', JSON.stringify({
            per_page: dataToSend.per_page
        }));

        Grid.setExportUrl.apply(this, [dataToSend]);
        dataToSend.action = 'datagrid';

        if (this.cachedInitialData.csrfToken) {
            dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
        }

        this.sendPostRequest({
            url: ajax_list_url,
            dataToSend: dataToSend,
            successCallback: function ajaxSuccessCallback(jsonResponse) {
                if (jsonResponse.csrfToken) {
                    this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                }

                this.createDatagrid(jsonResponse);
                Grid.updateGridDetails.apply(this, [jsonResponse, highlightRowId]);
            }.bind(this),
            errorCallback: function datagridErrorCallback() {
                localStorageHelper.removeLocalStorageItem('gcrudInitialData_' + this.uniqueId);
            }.bind(this)
        });
    },
    setExportUrl: function setExportUrl(data_to_send) {
        this.$gc.find('.gc-export').attr('href', ajaxHelper.getUrl.apply(this, ['export', data_to_send]));
    },
    getSearchData: function getSearchData() {
        var $search_all_input = this.$gc.find('.search-button > input.gc-search-input');

        var search_fields = [],
            search_texts = [],
            search = {};

        this.$gc.find('.gc-search-row').find('.gc-searchable-input,.gc-searchable-select').each(function forEachSearchableInput() {
            var searchValue = $(this).val();

            if (searchValue !== '') {
                search_fields.push($(this).attr('name'));
                search_texts.push(searchValue);
            }
        });

        this.$gc.find('.gc-search-row').find('input.gc-searchable-checkbox').each(function forEachSearchableInput() {
            if ($(this).is(':checked')) {
                search_fields.push($(this).attr('name'));
                search_texts.push('1');
            }
        });

        if (search_fields.length > 0 && $search_all_input.length > 0) {
            $search_all_input.val('');
            $search_all_input.trigger('blur');
        }

        if ($search_all_input.length > 0 && $search_all_input.val() !== '') {
            //Let's take advantage that JavaScript is not strong type!
            search_fields = '';
            search_texts = $search_all_input.val();
            search._gcrud_search_all = $search_all_input.val();
        } else {
            search_fields.forEach(function forEachSearchFields(searchfieldName, searchIndex) {
                search[searchfieldName] = search_texts[searchIndex];
            });
        }

        return search;
    },
    getOrderBy: function getOrderBy() {
        var order_by = this.$gc.find('.gc-order-by-hidden').val();

        if (order_by) {
            return order_by;
        }

        return this.$gc.find('.column-with-ordering.active:first').data('order-by');
    },
    getSorting: function getSorting() {
        var $columnWithOrdering = void 0,
            sorting = this.$gc.find('.gc-sorting-hidden').val();

        if (sorting) {
            return sorting;
        }

        $columnWithOrdering = this.$gc.find('.column-with-ordering.active:first');

        if ($columnWithOrdering.hasClass('ordering-desc')) {
            sorting = 'desc';
        } else if ($columnWithOrdering.hasClass('ordering-asc')) {
            sorting = 'asc';
        }

        return sorting;
    },
    getPerPage: function getPerPage() {
        return this.$gc.find('.per_page').val();
    },
    getPage: function getPage() {
        return this.$gc.find('input[name="page_number"]').val();
    },
    getBasicOperator: function getBasicOperator() {
        var $inputBasicOperator = this.$gc.find('.gc-hidden-search-inputs').find('input[name="basic_operator"]');

        if ($inputBasicOperator.length > 0) {
            return $inputBasicOperator.val();
        }

        return null;
    },
    getExtendedSearch: function getExtendedSearch() {
        var $searchInputs = this.$gc.find('.gc-hidden-search-inputs').find('.gc-extended-search-input');
        var searchInputs = {};

        if ($searchInputs.length === 0) {
            return null;
        }

        $searchInputs.each(function forEachSearchInputs() {
            searchInputs[$(this).attr('name')] = $(this).val();
        });

        return searchInputs;
    },
    hasExtendedSearch: function hasExtendedSearch() {
        return this.$gc.find('.gc-hidden-search-inputs').find('.gc-extended-search-input').length > 0;
    },
    getDataToSend: function getDataToSend() {
        var page = Grid.getPage.apply(this),
            per_page = Grid.getPerPage.apply(this),
            order_by = Grid.getOrderBy.apply(this),
            sorting = Grid.getSorting.apply(this),
            search = Grid.getSearchData.apply(this),
            basic_operator = Grid.getBasicOperator.apply(this),
            extended_search = Grid.getExtendedSearch.apply(this);

        return {
            page: page,
            per_page: per_page,
            order_by: order_by,
            sorting: sorting,
            search: search,
            basic_operator: basic_operator,
            extended_search: extended_search
        };
    },
    activateOrderingRows: function activateOrderingRows() {
        var $active_column = this.$gc.find('.column-with-ordering.active:first'),
            columnIndex = $active_column.index() + 1;

        if ($active_column.length > 0) {
            this.$gc.find('.grocery-crud-table').find('thead tr td:nth-child(' + columnIndex + ')').addClass('active table-active');
        }
    },
    updateGridDetails: function updateGridDetails(jsonResponse, highlightRowId) {
        var per_page_value = this.$gc.find('.per_page').val();
        var paging_ends = void 0;

        this.$gc.find('.select-all-none').prop('checked', false);
        this.$gc.find('.current-total-results').html(jsonResponse.filtered_total);

        if (jsonResponse.filtered_total > 10) {
            paging_ends = parseInt(this.$gc.find('input[name="page_number"]').val(), 10) * per_page_value;

            if (paging_ends > jsonResponse.filtered_total) {
                paging_ends = jsonResponse.filtered_total;
            }
            this.$gc.find('.paging-ends').html(paging_ends);
        } else {
            this.$gc.find('.paging-ends').html(jsonResponse.filtered_total);
        }

        if (jsonResponse.csrfToken) {
            this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
        }

        this.$gc.find('.paging-starts').html((parseInt(this.$gc.find('input[name="page_number"]').val(), 10) - 1) * per_page_value + 1);

        Grid.activateOrderingRows.apply(this);

        if (jsonResponse.filtered_total < parseInt(this.$gc.find('.full-total').html(), 10)) {
            this.$gc.find('.full-total-container').removeClass('hidden');
        } else {
            this.$gc.find('.full-total-container').addClass('hidden');
        }

        this.appendSearchClearButtons();
        DatagridPaging.pagingCalculations.apply(this);
        this.hideShowDeleteButton();
        if (highlightRowId) {
            this.$gc.find('tr[data-id=' + highlightRowId + ']').addClass('flash animated');
            setTimeout(function timeoutRemoveFlashing() {
                this.$gc.find('tr[data-id=' + highlightRowId + ']').removeClass('flash animated');
            }.bind(this), 1000);
        }
    },
    listenerPagingButtons: function listenerPagingButtons() {
        var datagrid_object = this,
            selectors_for_all_buttons = Constants.SELECTOR_PAGING_PREVIOUS + ', ' + Constants.SELECTOR_PAGING_NEXT + ', ' + Constants.SELECTOR_PAGING_FIRST + ',' + Constants.SELECTOR_PAGING_LAST,
            page_number_input_hidden = datagrid_object.$gc.find('.page-number-hidden');

        this.$gc.find(selectors_for_all_buttons).click(function forEachButtonsSelectors(event) {
            event.preventDefault();

            //If it is disabled then do nothing!
            if ($(this).hasClass(Constants.CLASS_DISABLED)) {
                return;
            }

            if ($(this).hasClass(Constants.CLASS_PAGING_PREVIOUS)) {
                page_number_input_hidden.val(parseInt(page_number_input_hidden.val(), 10) - 1);
            } else if ($(this).hasClass(Constants.CLASS_PAGING_NEXT)) {
                page_number_input_hidden.val(parseInt(page_number_input_hidden.val(), 10) + 1);
            } else if ($(this).hasClass(Constants.CLASS_PAGING_FIRST)) {
                page_number_input_hidden.val('1');
            } else if ($(this).hasClass(Constants.CLASS_PAGING_LAST)) {
                page_number_input_hidden.val(DatagridPaging.getMaxPaging.apply(datagrid_object));
            }
            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });

        this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).change(function pageNumberInputOnChange() {
            if (!isNaN(parseInt($(this).val(), 10))) {
                page_number_input_hidden.val(parseInt($(this).val(), 10));
            } else {
                page_number_input_hidden.val('1');
            }

            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });
    },
    activateOrderingColumn: function activateOrderingColumn() {
        var order_by = this.$gc.find('.gc-order-by-hidden').val(),
            sorting = this.$gc.find('.gc-sorting-hidden').val();
        if (order_by && sorting) {
            this.$gc.find('.column-with-ordering[data-order-by="' + order_by + '"]').addClass('active table-active');
            this.$gc.find('.column-with-ordering[data-order-by="' + order_by + '"]').addClass('ordering-' + sorting);
        }
    },
    listenerColumnWithOrdering: function listenerColumnWithOrdering() {
        var datagrid_object = this;

        this.$gc.find('.column-with-ordering').click(function onColumnOrderingClick() {
            var gcrud_container = $(this).closest('.gc-container'),
                $table = $(this).closest('.grocery-crud-table'),
                sorting = void 0;

            $table.find('thead').find('th.active, td.active').removeClass('active table-active');

            $(this).parent().find('.column-with-ordering').each(function foreachColumnsWithOrdering() {
                $(this).html('<div>' + $.trim($(this).text()) + '</div>');
            });

            $(this).addClass('active table-active');

            if ($(this).hasClass('ordering-asc')) {
                $table.find('th').removeClass('ordering-desc').removeClass('ordering-asc');
                $(this).addClass('ordering-desc').removeClass('ordering-asc');
                sorting = 'desc';
            } else {
                $table.find('th').removeClass('ordering-desc').removeClass('ordering-asc');
                $(this).addClass('ordering-asc').removeClass('ordering-desc');
                sorting = 'asc';
            }

            gcrud_container.find('input[name="page_number"]').val('1');

            gcrud_container.find('.gc-order-by-hidden').val($(this).data('order-by'));
            gcrud_container.find('.gc-sorting-hidden').val(sorting);

            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });
    },
    listenerSearchInput: function listenerSearchInput() {
        var datagrid_object = this;

        this.$gc.find('.gc-searchable-input').on('keyup change', function onChangeSearchInput(event) {
            //If the key is Enter or empty, then don't wait! Just start searching...
            var timerTimeout = event.keyCode === 9 || event.keyCode === 13 || $(this).val() === '' ? 1 : 1000;

            if (datagrid_object.search_timer !== null) {
                clearTimeout(datagrid_object.search_timer);
            }
            datagrid_object.search_timer = setTimeout(function searchTimerTimeoutCallback() {
                datagrid_object.$gc.find('.page-number-hidden').val('1');
                Grid.searchAndOrderingTrigger.apply(datagrid_object);
            }, timerTimeout);
        });

        this.$gc.find('.gc-searchable-select,.gc-searchable-checkbox').change(function onChangeSearchInput() {
            this.$gc.find('.page-number-hidden').val('1');
            Grid.searchAndOrderingTrigger.apply(this);
        }.bind(this));

        this.$gc.find('.gc-date-operator').change(function onChangeSearchInput() {
            Grid.searchAndOrderingTrigger.apply(this);
        }.bind(this));
    }
});

Grid.CLASS_PER_PAGE = 'per_page';

exports.Grid = Grid;

},{"../../helpers/ajax-helper":84,"../../helpers/local-storage-helper":85,"../constants":95,"./datagrid.paging":100}],99:[function(require,module,exports){
'use strict';

var $ = jQuery,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    Handlebars = require('handlebars'),
    _ = require('underscore'),
    Constants = require('../constants').Constants,
    Grid = require('./datagrid.grid').Grid,
    DatagridHeaderActions = Object.create({
    listenerPrintButton: function listenerPrintButton() {
        var printContainerHtml = Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_PRINT_CONTAINER).html())();

        this.$gc.find('.gc-print').click(function printButtonOnClick(event) {
            var dataToSend = Grid.getDataToSend.apply(this);

            event.preventDefault();

            this.sendGetRequest({
                url: ajaxHelper.getUrl.apply(this, [DatagridHeaderActions.ACTION_PRINT, dataToSend]),
                successCallback: function successCallback(jsonResponse) {
                    var $printContainer = $(printContainerHtml);

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    $printContainer.find('thead').html(DatagridHeaderActions.getPrintTableHeader.apply(this));

                    $printContainer.find('tbody').html(this.getTableBodyFromResponse(jsonResponse)).closest('#table-container').printThis();
                }.bind(this)
            });
        }.bind(this));
    },
    getPrintTableHeader: function getPrintTableHeader() {
        var headerColumns = [];
        _.each(this.visibleColumns, function eachVisibleColumns(columnName) {
            headerColumns.push({
                name: columnName,
                displayAs: this.indexedColumns[columnName]
            });
        }.bind(this));

        return Handlebars.compile(this.$gc.find(Constants.HANDLEBARS_PRINT_HEADER).html())({
            headerColumns: headerColumns
        });
    }
});

DatagridHeaderActions.ACTION_PRINT = 'print';

exports.DatagridHeaderActions = DatagridHeaderActions;

},{"../../helpers/ajax-helper":84,"../constants":95,"./datagrid.grid":98,"handlebars":160,"underscore":225}],100:[function(require,module,exports){
'use strict';

var $ = jQuery,
    Constants = require('../constants').Constants,
    DatagridPaging = Object.create({
    getMaxPaging: function getMaxPaging() {
        var total_results = parseInt(this.$gc.find('.current-total-results').html(), 10),
            per_page = parseInt(this.$gc.find('.' + Constants.CLASS_PER_PAGE).val(), 10),
            max_paging = total_results === 0 ? 1 : Math.ceil(total_results / per_page);

        return max_paging;
    },
    pagingCalculations: function pagingCalculations() {
        var page_number_value = parseInt(this.$gc.find('.page-number-hidden').val(), 10),
            max_paging = DatagridPaging.getMaxPaging.apply(this);

        if (page_number_value <= 0) {
            page_number_value = 1;
            this.$gc.find('.page-number-hidden').val('1');
            this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val('1');
        }

        if (page_number_value === 1) {
            this.$gc.find('.paging-first').addClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-previous').addClass(Constants.CLASS_DISABLED);
        } else {
            this.$gc.find('.paging-first').removeClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-previous').removeClass(Constants.CLASS_DISABLED);
        }

        if (page_number_value + 1 > max_paging) {
            this.$gc.find('.paging-last').addClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-next').addClass(Constants.CLASS_DISABLED);
        } else {
            this.$gc.find('.paging-last').removeClass(Constants.CLASS_DISABLED);
            this.$gc.find('.paging-next').removeClass(Constants.CLASS_DISABLED);
        }

        this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val(page_number_value);

        if (page_number_value > max_paging) {
            this.$gc.find('.page-number-hidden').val(max_paging);
            this.$gc.find(Constants.SELECTOR_PAGE_NUMBER_INPUT).val(max_paging);
        }
    }
});

exports.DatagridPaging = DatagridPaging;

},{"../constants":95}],101:[function(require,module,exports){
'use strict';

var $ = jQuery,
    Grid = require('./datagrid.grid.js').Grid,
    DatagridColumns = require('./datagrid.columns').DatagridColumns,
    DatagridSearch = Object.create({
    listenerSearchButton: function listenerSearchButton() {
        var datagrid_object = this;

        if (this.settings.datagridSearchAllInput) {
            DatagridSearch.searchAllButton.apply(this);
        } else {
            this.$gc.find('.gc-filter-button').click(function searchButtonOnClick(event) {
                event.preventDefault();
                this.$gc.find('.gc-filtering-modal').gc_modal({
                    backdrop: true
                });
            }.bind(this));

            this.$gc.find('.gc-remove-filter-button').click(function removeFiltersButtonOnClick(event) {
                event.preventDefault();
                this.$gc.find('.gc-hidden-search-inputs').html('');
                DatagridColumns.triggerColumnsRender.apply(this);
                Grid.searchAndOrderingTrigger.apply(this);
                this.$gc.find('.gc-remove-filter-container').addClass('hidden');
                this.$gc.find('.gc-filter-button').removeClass('btn-success').addClass('btn-outline-dark');
                this.$gc.find('.gc-filter-text').removeClass('hidden');
                this.$gc.find('.gc-filter-counter').addClass('hidden');
            }.bind(this));
        }

        this.$gc.find('.search-button>input.gc-search-input').change(function searchInputOnChange() {
            datagrid_object.$gc.find('.search-button .clear-all-search').remove();

            if ($(this).val() !== '') {
                $(this).after('<i class="fa fa-times clear-all-search"></i>');

                datagrid_object.$gc.find('.search-button .clear-all-search').click(function searchClearAllOnClick() {
                    datagrid_object.$gc.find('.search-button>input.gc-search-input').val('').trigger('change');
                });
            }

            datagrid_object.$gc.find('.page-number-hidden').val('1');
            datagrid_object.$gc.find('.gc-searchable-input').val('');
            Grid.searchAndOrderingTrigger.apply(datagrid_object);
        });

        this.$gc.find('.search-button>input.gc-search-input').blur(function searchInputOnBlur() {
            var search_button = $(this).closest('.search-button');

            if ($(this).val() === '' && search_button.hasClass('search-button-big')) {
                //Make sure that we are blur :)
                datagrid_object.$gc.find('.search-button .clear-all-search').remove();
                $(this).removeClass('gc-search-input-big');
                search_button.removeClass('search-button-big');
                search_button.removeClass('btn-default').addClass('btn-primary');
            }
        });
    },
    searchAllButton: function searchAllButton() {
        this.$gc.find('.search-button').click(function searchButtonOnClick(event) {
            var $search_button = $(this);

            event.preventDefault();

            $search_button.removeClass('btn-primary').addClass('btn-default');
            $search_button.find('input.gc-search-input').addClass('gc-search-input-big');

            setTimeout(function timeoutCallback() {
                $search_button.find('input.gc-search-input').focus();
            }, 400);

            $(this).addClass('search-button-big');
        });
    }
});

exports.DatagridSearch = DatagridSearch;

},{"./datagrid.columns":97,"./datagrid.grid.js":98}],102:[function(require,module,exports){
'use strict';

var _ = require('underscore'),
    i18n = Object.create({
    translations: {},
    init: function initI18n(i18nVariables) {
        this.translations = i18nVariables;
    },
    t: function t(translation) {
        if (this.translations[translation]) {
            return this.translations[translation];
        }
        return translation;
    },
    format: function format(strRaw, args) {
        var str = strRaw;
        if (!args && !args.length) {
            return str;
        }
        _.each(args, function eachArgs(arg, argName) {
            str = str.replace(RegExp('\\{' + argName + '\\}', 'gi'), arg);
        });
        return str;
    }
});

exports.i18n = i18n;

},{"underscore":225}],103:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationAdd = Object.create({
    actionAdd: function eventAdd() {
        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_ADD_FORM,
            fieldsListName: 'insertFields',
            fieldList: 'addFields',
            readOnlyFields: 'readOnlyAddFields',
            cache: true,
            callbackAfterRender: OperationAdd.callbackAfterModal.bind(this)
        }]);
    },
    callbackAfterModal: function callbackAfterModal() {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find('input, textarea').first().focus();
    },
    listenerAddButton: function listenerAddButton() {

        OperationsCommon.hideModalOnClose.apply(this, [Constants.SELECTOR_MODAL_FORM]);
        // GC-174: Ugly workaround to also have an event to add an empty hash on error close
        OperationsCommon.hideModalOnClose.apply(this, ['.gc-error-modal']);

        this.$gc.find(Constants.SELECTOR_BUTTON_ADD).click(function addButtonClick(event) {
            event.preventDefault();

            if (this.settings.hashEvents) {
                hasher.setHash(this.hashEvent.addItem);
            } else {
                OperationAdd.actionAdd.apply(this);
            }
        }.bind(this));
    }
});

exports.OperationAdd = OperationAdd;

},{"../constants":95,"./common":105,"hasher":172}],104:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationClone = Object.create({
    actionClone: function eventEdit(primaryKeyValue) {

        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_CLONE_FORM,
            fieldsListName: 'cloneFields',
            fieldList: 'cloneFields',
            fieldTypes: 'fieldTypesCloneForm',
            readOnlyFields: 'readOnlyCloneFields',
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onCloneClick: function onCloneClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.cloneItem + '/' + primaryKeyValue);
        } else {
            OperationClone.actionClone.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationClone = OperationClone;

},{"../constants":95,"./common":105,"hasher":172}],105:[function(require,module,exports){
'use strict';

var _fieldList = require('../../../../../React-Components/gce-crud-forms/field-list.jsx');

var _fieldList2 = _interopRequireDefault(_fieldList);

var _title = require('../../../../../React-Components/gce-crud-forms/modal/title.jsx');

var _title2 = _interopRequireDefault(_title);

var _fieldInput = require('../../../../../React-Components/gce-crud-forms/field-input.jsx');

var _fieldInput2 = _interopRequireDefault(_fieldInput);

var _redux = require('redux');

var _reducer = require('./reducer.js');

var _reducer2 = _interopRequireDefault(_reducer);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var $ = jQuery,
    ajaxHelper = require('../../helpers/ajax-helper').ajaxHelper,
    Grid = require('./../datagrid/datagrid.grid.js').Grid,
    jQueryPlugins = require('../../modules/jquery/jquery-plugins').jQueryPlugins,
    i18n = require('./../i18n').i18n,
    hasher = require('hasher'),
    Constants = require('../constants').Constants,
    OperationsCommon = Object.create({
    getFormDomContainer: function getFormDomContainer() {
        if (this.$formDomContainer === undefined) {
            this.$formDomContainer = this.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_MODAL_BODY)[0];
        }
        return this.$formDomContainer;
    },
    getModalTitleDom: function getModalTitleDom() {
        if (this.$modalTitleDom === undefined) {
            this.$modalTitleDom = this.find(Constants.SELECTOR_MODAL_FORM).find('.modal-header')[0];
        }
        return this.$modalTitleDom;
    },
    operationDispatch: function operationDispatch(optionsRaw) {
        var options = _underscore2.default.extend({
            action: Constants.ACTION_ADD_FORM,
            fieldsListName: 'insertFields',
            fieldList: 'addFields',
            fieldTypes: 'fieldTypesAddForm',
            primaryKeyValue: null,
            cache: false,
            readOnlyFields: null,
            isReadOnly: false,
            callbackAfterRender: function callbackAfterRender() {
                return;
            }
        }, optionsRaw);

        if (options.cache && this[options.fieldsListName].length > 0) {
            OperationsCommon.showModal.apply(this, [options]);
        } else {
            OperationsCommon.collectDataAndDispatch.apply(this, [options]);
        }
    },
    displayAs: function displayAs(fieldName, fieldList) {
        return _underscore2.default.find(fieldList, function (column) {
            return column.name === fieldName;
        });
    },
    collectDataAndDispatch: function collectData(options) {
        var dataToSend = {
            action: options.action
        };

        if (options.primaryKeyValue !== null) {
            dataToSend.pk_value = options.primaryKeyValue;
        }

        this.sendGetRequest({
            url: this.$gc.data('url'),
            dataToSend: dataToSend,
            successCallback: function successCallback(jsonResponse) {
                var fieldList = this.cachedInitialData[options.fieldList],
                    readOnlyFieldList = options.readOnlyFields !== null ? this.cachedInitialData[options.readOnlyFields] : {};

                this[options.fieldsListName] = [];

                if (jsonResponse.csrfToken) {
                    this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                }

                _underscore2.default.each(fieldList, function jsonResponseForEach(field) {
                    var fieldName = field.name,
                        fieldType = this.cachedInitialData[options.fieldTypes][fieldName];

                    if (fieldType === undefined) {
                        throw new Error('Can\'t find field name: "' + fieldName + '" in fieldTypes. ' + 'This is usually an error that you will see when you\'ve added a field name that doesn\'t exist ' + 'in the database.');
                    }

                    this[options.fieldsListName].push({
                        fieldName: fieldName,
                        displayAs: OperationsCommon.displayAs.apply(this, [fieldName, fieldList]).displayAs,
                        fieldValue: jsonResponse.data[fieldName],
                        fieldType: this.cachedInitialData[options.fieldTypes][fieldName].dataType,
                        fieldValues: this.cachedInitialData[options.fieldTypes][fieldName].permittedValues,
                        defaultValue: this.cachedInitialData[options.fieldTypes][fieldName].defaultValue,
                        showDefaultValue: options.action === 'add-form',
                        isNullable: this.cachedInitialData[options.fieldTypes][fieldName].isNullable,
                        isRequired: this.cachedInitialData[options.fieldTypes][fieldName].isRequired,
                        isReadOnly: readOnlyFieldList[fieldName] || options.isReadOnly || this.cachedInitialData[options.fieldTypes][fieldName].isReadOnly,
                        options: this.cachedInitialData[options.fieldTypes][fieldName].options ? this.cachedInitialData[options.fieldTypes][fieldName].options : null
                    });
                }.bind(this));

                OperationsCommon.showModal.apply(this, [options]);
            }.bind(this)
        });
    },
    showModal: function showModal(options) {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).data('action', options.action);

        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).data('primary-key-value', options.primaryKeyValue !== null ? options.primaryKeyValue : '');

        this.store.dispatch({
            type: options.action,
            fields: this[options.fieldsListName]
        });

        this.$gc.find(Constants.SELECTOR_MODAL_FORM).gc_modal({
            backdrop: false
        });

        if (options.action === 'read-form') {
            this.$gc.find('.options-on-save').hide();
            this.$gc.find('.save-changes').hide();
        } else {
            this.$gc.find('.options-on-save').show();
            this.$gc.find('.save-changes').show();
        }

        options.callbackAfterRender();
    },
    getTitle: function getTitle(titleType) {
        var subjectSingle = this.cachedInitialData.subject.subject_single;

        switch (titleType) {
            case Constants.ACTION_ADD_FORM:
                return i18n.format(i18n.t('add_item'), {
                    subject: subjectSingle
                });
            case Constants.ACTION_EDIT_FORM:
                return i18n.format(i18n.t('edit_item'), {
                    subject: subjectSingle
                });

            case Constants.ACTION_READ_FORM:
                return i18n.format(i18n.t('view_item'), {
                    subject: subjectSingle
                });

            case Constants.ACTION_CLONE_FORM:
                return i18n.format(i18n.t('add_item'), {
                    subject: subjectSingle
                });

            default:
                return titleType;
        }
    },
    initReduxStore: function initReduxStore() {
        this.store = (0, _redux.createStore)(_reducer2.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
        this.renderFieldList = function renderFieldList() {
            var _this = this;

            var currentState = this.store.getState(),
                title = OperationsCommon.getTitle.apply(this, [currentState.type]),
                _components = this.components,
                FieldRowWrapper = _components.FieldRowWrapper,
                ModalTitleWrapper = _components.ModalTitleWrapper;


            ReactDOM.render(React.createElement(_title2.default, {
                title: title,
                ModalTitleWrapper: ModalTitleWrapper
            }), OperationsCommon.getModalTitleDom.apply(this));
            ReactDOM.render(React.createElement(_fieldList2.default, {
                relationalOnComponentDidMount: function relationalOnComponentDidMount(componentDomElement, options) {
                    jQueryPlugins.searchableSelect($(componentDomElement).find('select'), options.isReadOnly, this);
                },
                relationalOnComponentDidUpdate: function relationalOnComponentDidUpdate(componentDomElement, options) {
                    jQueryPlugins.searchableSelectUpdate($(componentDomElement).find('select'), options.isReadOnly);
                },
                i18n: i18n.translations,
                fields: currentState.fields,
                gcrudInstance: this,
                fetchData: function fetchData(fieldName, fieldValue) {
                    return new Promise(function (resolve) {
                        ajaxHelper.sendAjaxRequest.apply(this, [{
                            dataToSend: {
                                action: 'depended-relation',
                                field_name: fieldName,
                                search_value: fieldValue
                            },
                            url: this.$gc.data('url'),
                            successCallback: function successCallback(data) {
                                resolve(data.items);
                            }
                        }, 'get']);
                    }.bind(_this));
                },
                FieldInputComponent: _fieldInput2.default,
                FieldRowWrapper: FieldRowWrapper
            }), OperationsCommon.getFormDomContainer.apply(this));
        }.bind(this);
        this.store.subscribe(this.renderFieldList);
    },
    hideModalOnClose: function hideModalOnClose(selectorString) {
        this.$gc.find(selectorString).on('hidden.bs.modal', function onModalHideOnClose() {
            if (this.settings.hashEvents) {
                hasher.setHash('!');
            }
        }.bind(this));
    },
    listenerSubmitForm: function listenerInsertForm() {
        this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM).submit(function SubmitAddForm(event) {
            var dataToSend = void 0;
            var currentAction = $(event.currentTarget).data('action');

            event.preventDefault();

            dataToSend = {
                data: ajaxHelper.getPostDataFromForm.apply(this, [this.$gc.find(Constants.SELECTOR_MODAL_FORM).find(Constants.SELECTOR_FORM)])
            };

            if (currentAction === Constants.ACTION_ADD_FORM) {
                dataToSend.action = Constants.ACTION_INSERT;
            } else if (currentAction === Constants.ACTION_EDIT_FORM) {
                dataToSend.action = Constants.ACTION_UPDATE;
                dataToSend.pk_value = $(event.currentTarget).data('primary-key-value');
            } else if (currentAction === Constants.ACTION_CLONE_FORM) {
                dataToSend.action = Constants.ACTION_CLONE;
            }

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                url: this.$gc.data('url'),
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    var rowToHighlight = void 0,
                        errors = void 0;

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === 'success') {
                        rowToHighlight = dataToSend.action === Constants.ACTION_INSERT ? jsonResponse.insertId : dataToSend.pk_value;
                        if (this.$gc.find('.close-modal-on-save').is(':checked')) {
                            this.$gc.find(Constants.SELECTOR_MODAL_FORM).gc_modal('hide');
                        }
                        Grid.searchAndOrderingTrigger.apply(this, [rowToHighlight]);
                    } else if (jsonResponse.status === 'error') {
                        errors = [];
                        _underscore2.default.each(jsonResponse.errors, function forEachErrors(error) {
                            errors = _underscore2.default.union(errors, error);
                        });

                        this.$gc.find('.gc-error-modal').find('.gc-error-body').html('- ' + errors.join('<br/>- '));

                        this.$gc.find('.gc-error-modal').gc_modal({
                            backdrop: true
                        });
                    }
                }.bind(this)
            });
        }.bind(this));
    }
});

exports.OperationsCommon = OperationsCommon;

},{"../../../../../React-Components/gce-crud-forms/field-input.jsx":6,"../../../../../React-Components/gce-crud-forms/field-list.jsx":7,"../../../../../React-Components/gce-crud-forms/modal/title.jsx":38,"../../helpers/ajax-helper":84,"../../modules/jquery/jquery-plugins":93,"../constants":95,"./../datagrid/datagrid.grid.js":98,"./../i18n":102,"./reducer.js":109,"hasher":172,"redux":216,"underscore":225}],106:[function(require,module,exports){
'use strict';

var $ = jQuery,
    _ = require('underscore'),
    Grid = require('./../datagrid/datagrid.grid.js').Grid,
    Constants = require('../constants').Constants,
    OperationsCommon = require('./common').OperationsCommon,
    hasher = require('hasher'),
    OperationDelete = Object.create({
    actionDelete: function actionDelete(primaryKeyValue) {
        var confirmationTable;
        this.$gc.find(Constants.SELECTOR_DELETE_CONFIRMATION_BUTTON).data('delete-id', primaryKeyValue);

        confirmationTable = OperationDelete.confirmationTable.apply(this, [[primaryKeyValue]]);

        this.$gc.find('.delete-single-confirmation').find('.content-to-delete').html(confirmationTable);

        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).gc_modal();
        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).find(Constants.CANCEL_BUTTON).focus();
    },
    listenerDeleteMultiple: function listenerDeleteMultiple() {
        //Select All/None
        this.$gc.find('.select-all-none').click(function selectAllNoneOnClick(event) {
            if ($(event.currentTarget).is(':checked')) {
                this.$gc.find('.gc-select-row').each(function forEachSelectRow() {
                    $(this).prop('checked', true).closest('tr').addClass('warning');
                });
            } else {
                this.$gc.find('.gc-select-row').each(function forEachSelectRow() {
                    $(this).prop('checked', false).closest('tr').removeClass('warning');
                });
            }

            this.hideShowDeleteButton();
        }.bind(this));

        this.$gc.find('.delete-selected-button').click(function deleteSelectedButtonOnClick(event) {
            var multipleIds = OperationDelete.getMultipleDeleteIds.apply(this),
                confirmationTable;

            this.$gc.find('.gc-delete-count').html(multipleIds.length);

            confirmationTable = OperationDelete.confirmationTable.apply(this, [multipleIds]);

            this.$gc.find('.gc-delete-multiple-confirmation').find('.content-to-delete').html(confirmationTable);

            this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_FORM_MODAL).gc_modal();

            event.preventDefault();
        }.bind(this));
    },
    confirmationTable: function confirmationTable(dataIds) {
        var $table = this.$gc.find('.grocery-crud-table'),
            $headerTr = $table.find('.header-columns').clone(),
            tableOutput,
            dataRows = '';

        _.each(dataIds, function foreachDataIds(dataId) {
            var $tr = $table.find('tr[data-id="' + dataId + '"]').clone();
            if ($tr.length === 0) {
                return false;
            }
            $tr.find('td.gc-row-checkbox').remove();
            $tr.find('td.gc-actions').remove();
            $tr.find('td').removeClass();
            dataRows += '<tr>' + $tr.html() + '</tr>';
        });

        $headerTr.find('.header-actions').remove();
        $headerTr.find('th>i').remove();
        $headerTr.find('th').removeClass();

        tableOutput = '<table class="table table-bordered table-hover">';
        tableOutput += '<tr>' + $headerTr.html() + '</tr>';
        tableOutput += dataRows;
        tableOutput += '</table>';

        return tableOutput;
    },
    onDeleteClick: function onDeleteClick(primaryKeyValue) {
        OperationDelete.actionDelete.apply(this, [primaryKeyValue]);
    },
    listenerDeleteSingleModal: function listenerDeleteSingleModal() {
        this.$gc.find(Constants.SELECTOR_DELETE_CONFIRMATION_BUTTON).click(function deleteConfirmationClick(event) {
            var dataToSend = {
                primaryKeyValue: $(event.currentTarget).data('delete-id'),
                action: Constants.ACTION_REMOVE_ONE
            };

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                url: this.$gc.data('url'),
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    var $fullTotal, total;

                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === Constants.RESPONSE.SUCCESS) {
                        $fullTotal = this.$gc.find('.full-total');
                        this.$gc.find(Constants.SELECTOR_DELETE_FORM_MODAL).gc_modal('hide');

                        total = parseInt($fullTotal.text(), 10) - 1;
                        if (total < 0) {
                            total = 0;
                        }

                        $fullTotal.html('' + total);

                        setTimeout(function searchAndOrderingTimeout() {
                            Grid.searchAndOrderingTrigger.apply(this);
                        }.bind(this), 200);
                    }
                }.bind(this)
            });
        }.bind(this));
    },
    listenerDeleteMultipleModal: function listenerDeleteSingleModal() {
        this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_CONFIRMATION_BUTTON).click(function deleteMultipleConfirmationClick() {
            var dataToSend = {
                primaryKeys: OperationDelete.getMultipleDeleteIds.apply(this),
                action: Constants.ACTION_REMOVE_MULTIPLE
            },
                idsToDelete = dataToSend.primaryKeys.length;

            if (this.cachedInitialData.csrfToken) {
                dataToSend[this.cachedInitialData.csrfToken.inputName] = this.cachedInitialData.csrfToken.inputValue;
            }

            this.sendPostRequest({
                dataToSend: dataToSend,
                successCallback: function successCallback(jsonResponse) {
                    if (jsonResponse.csrfToken) {
                        this.cachedInitialData.csrfToken = jsonResponse.csrfToken;
                    }

                    if (jsonResponse.status === 'success') {
                        this.$gc.find(Constants.SELECTOR_MULTIPLE_DELETE_FORM_MODAL).gc_modal('hide');
                        this.$gc.find('.full-total').html(parseInt(this.$gc.find('.full-total').text(), 10) - idsToDelete);
                        Grid.searchAndOrderingTrigger.apply(this);
                    }
                }.bind(this)
            });
        }.bind(this));
    },
    getMultipleDeleteIds: function getMultipleDeleteIds() {
        var deleteIds = [];

        this.$gc.find(Constants.SELECTOR_DELETE_CHECKBOX_CHECKED).each(function forEachGetMultipleIds() {
            deleteIds.push($(this).data('id'));
        });

        return deleteIds;
    },
    listenerSelectRow: function listenerSelectRow() {
        var datagrid_object = this;

        datagrid_object.$gc.find('.gc-select-row').click(function selectRowOnClick() {
            if ($(this).is(':checked')) {
                $(this).closest('tr').addClass('warning');
            } else {
                $(this).closest('tr').removeClass('warning');
            }

            datagrid_object.hideShowDeleteButton();
        });
    }
});

exports.OperationDelete = OperationDelete;

},{"../constants":95,"./../datagrid/datagrid.grid.js":98,"./common":105,"hasher":172,"underscore":225}],107:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationEdit = Object.create({
    actionEdit: function eventEdit(primaryKeyValue) {

        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_EDIT_FORM,
            fieldsListName: 'updateFields',
            fieldList: 'editFields',
            fieldTypes: 'fieldTypesEditForm',
            readOnlyFields: 'readOnlyEditFields',
            cache: false,
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onEditClick: function onEditClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.editItem + '/' + primaryKeyValue);
        } else {
            OperationEdit.actionEdit.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationEdit = OperationEdit;

},{"../constants":95,"./common":105,"hasher":172}],108:[function(require,module,exports){
'use strict';

var Constants = require('../constants').Constants,
    hasher = require('hasher'),
    OperationsCommon = require('./common').OperationsCommon,
    OperationRead = Object.create({
    actionRead: function actionRead(primaryKeyValue) {
        OperationsCommon.operationDispatch.apply(this, [{
            action: Constants.ACTION_READ_FORM,
            fieldsListName: 'readFields',
            fieldList: 'readFields',
            fieldTypes: 'fieldTypesReadForm',
            cache: false,
            isReadOnly: true,
            primaryKeyValue: primaryKeyValue
        }]);
    },
    onReadClick: function onReadClick(primaryKeyValue) {
        if (this.settings.hashEvents) {
            hasher.setHash(this.hashEvent.readItem + '/' + primaryKeyValue);
        } else {
            OperationRead.actionRead.apply(this, [primaryKeyValue]);
        }
    }
});

exports.OperationRead = OperationRead;

},{"../constants":95,"./common":105,"hasher":172}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var action = arguments[1];

    if (!state) {
        return {
            type: action.type,
            fields: []
        };
    }

    return action;
};

},{}],110:[function(require,module,exports){
'use strict';

var hasher = require('hasher'),
    thisIncrease = 0,
    crossroads = require('crossroads'),
    OperationAdd = require('../operations/add').OperationAdd,
    OperationEdit = require('../operations/edit').OperationEdit,
    OperationClone = require('../operations/clone').OperationClone,
    OperationRead = require('../operations/read').OperationRead,
    Router = {
    setRoutes: function setRoutes() {
        var startingString = '';

        if (thisIncrease > 0) {
            startingString = thisIncrease + '/';
        }

        this.hashEvent = {};
        this.hashEvent.addItem = startingString + 'add';
        this.hashEvent.editItem = startingString + 'edit';
        this.hashEvent.cloneItem = startingString + 'clone';
        this.hashEvent.readItem = startingString + 'read';
        this.hashEvent.deleteItem = startingString + 'delete';
        this.hashEvent.urlUniqueHash = startingString;
    },
    init: function init() {
        var parseHash = function parseHash(newHash) {
            crossroads.parse(newHash);
        };

        // This line is in order to call the route as many times as we want!
        crossroads.ignoreState = true;

        if (this.settings.hashEvents) {
            crossroads.addRoute(this.hashEvent.addItem, function operationAddRoute() {
                OperationAdd.actionAdd.apply(this);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.editItem + '/{primaryKeyValue}', function operationEditRoute(primaryKeyValue) {
                OperationEdit.actionEdit.apply(this, [primaryKeyValue]);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.cloneItem + '/{primaryKeyValue}', function operationCloneRoute(primaryKeyValue) {
                OperationClone.actionClone.apply(this, [primaryKeyValue]);
            }.bind(this));

            crossroads.addRoute(this.hashEvent.readItem + '/{primaryKeyValue}', function operationReadRoute(primaryKeyValue) {
                OperationRead.actionRead.apply(this, [primaryKeyValue]);
            }.bind(this));
        }

        if (thisIncrease === 0) {
            hasher.initialized.add(parseHash);
            hasher.changed.add(parseHash);

            // start listening for history changes
            hasher.init();
        }

        thisIncrease++;
    }
};

exports.Router = Object.create(Router);

},{"../operations/add":103,"../operations/clone":104,"../operations/edit":107,"../operations/read":108,"crossroads":126,"hasher":172}],111:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CallbackColumn = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'callback_column') {
                this.callbackColumnFields[fieldName] = true;
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.callbackColumnFields[fieldName];
    }
});

exports.CallbackColumn = CallbackColumn;

},{"underscore":225}],112:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CheckboxBoolean = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'checkbox_boolean') {
                this.checkboxBooleanFields.push(fieldName);
                this.checkboxBooleanFieldsData[fieldName] = {};

                this.checkboxBooleanFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isCheckboxBoolean: function isCheckboxBoolean(fieldName) {
        if (this.checkboxBooleanFields.length === 0) {
            return false;
        }

        if (this.checkboxBooleanFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    formatValue: function formatValue(fieldValue) {
        if (fieldValue === '1') {
            return '<i class="fa fa-check"></i>';
        }

        return '';
    }
});

exports.CheckboxBoolean = CheckboxBoolean;

},{"underscore":225}],113:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    DateAndTime = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_DATE) {
                this.dateFields.push(fieldName);
            } else if (/^(datetime|timestamp)$/i.test(fieldData.dataType)) {
                this.datetimeFields.push(fieldName);
            }
        }.bind(this));
    },
    getFormatter: function getFormatter() {
        if (this.dateFormatter === null) {

            if (typeof Intl !== 'undefined') {
                this.dateFormatter = new Intl.DateTimeFormat(DateAndTime.getLocale());
            } else {
                this.dateFormatter = {
                    format: function format(myDate) {
                        return myDate.toLocaleDateString();
                    }
                };
            }
        }

        return this.dateFormatter;
    },
    formatDateLocale: function formatDateLocale(rawDate) {
        var myDate, formatter;

        if (rawDate === '0000-00-00') {
            return '';
        }

        myDate = new Date(rawDate);
        formatter = DateAndTime.getFormatter.apply(this);

        if (!DateAndTime.isValidDate(myDate)) {
            return '';
        }

        return formatter.format(myDate);
    },
    formatDatetimeLocale: function formatDatetimeLocale(rawDate) {
        var myDate, formatter;

        if (rawDate === '0000-00-00 00:00:00') {
            return '';
        }

        myDate = new Date(rawDate);
        formatter = DateAndTime.getFormatter.apply(this);

        if (!DateAndTime.isValidDate(myDate)) {
            return '';
        }

        return formatter.format(myDate) + ' ' + myDate.toLocaleTimeString();
    },
    getLocale: function getLocale() {
        if (navigator.languages !== undefined) {
            return navigator.languages[0];
        }

        return navigator.language;
    },
    isValidDate: function isValidDate(myDate) {
        if (Object.prototype.toString.call(myDate) === '[object Date]') {
            return !isNaN(myDate.getTime());
        }

        return false;
    },
    isDatetime: function isNtoN(fieldName) {
        if (this.datetimeFields.length === 0) {
            return false;
        }

        return this.datetimeFields.indexOf(fieldName) > -1;
    },
    isDate: function isNtoN(fieldName) {
        if (this.dateFields.length === 0) {
            return false;
        }

        return this.dateFields.indexOf(fieldName) > -1;
    }
});

exports.DateAndTime = DateAndTime;

},{"../constants":95,"underscore":225}],114:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Dropdown = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (/^dropdown(_search)?$/.test(fieldData.dataType)) {
                this.dropdownFields.push(fieldName);
                this.dropdownFieldsData[fieldName] = {};

                this.dropdownFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isDropdown: function isDropdown(fieldName) {
        if (this.dropdownFields.length === 0) {
            return false;
        }

        if (this.dropdownFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    formatValue: function formatValue(fieldName, fieldValue) {
        var data;

        if (!fieldValue) {
            return '';
        }

        data = this.dropdownFieldsData[fieldName];

        if (!_underscore2.default.isUndefined(data[fieldValue])) {
            return data[fieldValue];
        }

        return fieldValue;
    }
});

exports.Dropdown = Dropdown;

},{"underscore":225}],115:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Enum = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'enum') {
                this.enumFields.push(fieldName);
                this.enumFieldsData[fieldName] = {};

                this.enumFieldsData[fieldName] = fieldData.permittedValues;
            }
        }.bind(this));
    },
    isEnum: function isEnum(fieldName) {
        if (this.enumFields.length === 0) {
            return false;
        }

        if (this.enumFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    }
});

exports.Enum = Enum;

},{"underscore":225}],116:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MultipleSelect = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'multiselect_searchable' || fieldData.dataType === 'multiselect_native') {

                this.multipleSelectFields[fieldName] = true;
                this.multipleSelectData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(dataLabel, dataIndex) {
                    this.multipleSelectData[fieldName][dataIndex] = dataLabel;
                }.bind(this));
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.multipleSelectFields[fieldName];
    },
    transformData: function transformData(fieldName, fieldData) {
        var finalString = void 0,
            finalArray = [];
        _underscore2.default.each(fieldData.split(','), function foreachTransformData(dataValue) {
            if (this.multipleSelectData[fieldName][dataValue] !== undefined) {
                finalArray.push(this.multipleSelectData[fieldName][dataValue]);
            }
        }.bind(this));

        finalString = finalArray.join(',');

        return finalString;
    }
});

exports.MultipleSelect = MultipleSelect;

},{"underscore":225}],117:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    RelationNtoN = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_RELATION_N_TO_N || fieldData.dataType === Constants.FIELD_TYPE_NATIVE_RELATION_N_TO_N || fieldData.dataType === Constants.FIELD_TYPE_SEARCHABLE_N_TO_N) {

                this.relationNtoNFields[fieldName] = true;
                this.relationNtoNData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(data) {
                    this.relationNtoNData[fieldName][data.id] = data.title;
                }.bind(this));
            }
        }.bind(this));
    },
    isNtoN: function isNtoN(fieldName) {
        return this.relationNtoNFields[fieldName];
    },
    transformData: function transformData(fieldName, fieldData) {
        var finalString = '';
        _underscore2.default.each(fieldData, function foreachTransformData(dataValue) {
            if (this.relationNtoNData[fieldName][dataValue] !== undefined) {
                finalString += this.relationNtoNData[fieldName][dataValue] + ', ';
            }
        }.bind(this));

        if (finalString.length > 1) {
            finalString = finalString.substr(0, finalString.length - 2);
        }

        return finalString;
    }
});

exports.RelationNtoN = RelationNtoN;

},{"../constants":95,"underscore":225}],118:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Constants = require('../constants').Constants,
    Relation = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === Constants.FIELD_TYPE_RELATION || fieldData.dataType === Constants.FIELD_TYPE_RELATION_NATIVE || fieldData.dataType === Constants.FIELD_TYPE_DEPENDED_RELATION && fieldData.options.dependedFrom.length === 0) {
                this.relationFields.push(fieldName);
                this.relationData[fieldName] = {};

                _underscore2.default.each(fieldData.permittedValues, function foreachData(data) {
                    this.relationData[fieldName][data.id] = data.title;
                }.bind(this));
            }
        }.bind(this));
    },
    isRelational: function isRelational(fieldName) {
        if (this.relationFields.length === 0) {
            return false;
        }

        if (this.relationFields.indexOf(fieldName) > -1) {
            return true;
        }

        return false;
    },
    transformData: function transformData(fieldName, fieldData) {
        if (this.relationData[fieldName][fieldData] !== undefined) {
            return this.relationData[fieldName][fieldData];
        }

        return fieldData;
    }
});

exports.Relation = Relation;

},{"../constants":95,"underscore":225}],119:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Texteditor = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'texteditor') {
                this.texteditorFields[fieldName] = true;
            }
        }.bind(this));
    },
    isThisType: function isThisType(fieldName) {
        return this.texteditorFields[fieldName];
    }
});

exports.Texteditor = Texteditor;

},{"underscore":225}],120:[function(require,module,exports){
'use strict';

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Upload = Object.create({
    initData: function initData() {
        _underscore2.default.each(this.cachedInitialData.fieldTypesColumns, function fieldTypes(fieldData, fieldName) {
            if (fieldData.dataType === 'upload') {
                this.uploadFields.push(fieldName);

                this.uploadFieldsData[fieldName] = fieldData.options;
            }
        }.bind(this));
    },
    isUploadType: function isUploadType(fieldName) {
        if (this.uploadFields.length === 0) {
            return false;
        }

        return this.uploadFields.indexOf(fieldName) > -1;
    },
    formatUpload: function formatUpload(fieldName, fieldValue) {
        var url;

        if (!fieldValue) {
            return '';
        }

        url = this.uploadFieldsData[fieldName].publicPath + '/' + fieldValue;

        return '<a href="' + url + '" target="_blank">' + fieldValue + '</a>';
    }
});

exports.Upload = Upload;

},{"underscore":225}],121:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules/amdefine/amdefine.js")

},{"_process":186,"path":123}],122:[function(require,module,exports){

},{}],123:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":186}],124:[function(require,module,exports){
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],125:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],126:[function(require,module,exports){
/** @license
 * crossroads <http://millermedeiros.github.com/crossroads.js/>
 * Author: Miller Medeiros | MIT License
 * v0.12.2 (2015/07/31 18:37)
 */

(function () {
var factory = function (signals) {

    var crossroads,
        _hasOptionalGroupBug,
        UNDEF;

    // Helpers -----------
    //====================

    // IE 7-8 capture optional groups as empty strings while other browsers
    // capture as `undefined`
    _hasOptionalGroupBug = (/t(.+)?/).exec('t')[1] === '';

    function arrayIndexOf(arr, val) {
        if (arr.indexOf) {
            return arr.indexOf(val);
        } else {
            //Array.indexOf doesn't work on IE 6-7
            var n = arr.length;
            while (n--) {
                if (arr[n] === val) {
                    return n;
                }
            }
            return -1;
        }
    }

    function arrayRemove(arr, item) {
        var i = arrayIndexOf(arr, item);
        if (i !== -1) {
            arr.splice(i, 1);
        }
    }

    function isKind(val, kind) {
        return '[object '+ kind +']' === Object.prototype.toString.call(val);
    }

    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }

    function isArray(val) {
        return isKind(val, 'Array');
    }

    function isFunction(val) {
        return typeof val === 'function';
    }

    //borrowed from AMD-utils
    function typecastValue(val) {
        var r;
        if (val === null || val === 'null') {
            r = null;
        } else if (val === 'true') {
            r = true;
        } else if (val === 'false') {
            r = false;
        } else if (val === UNDEF || val === 'undefined') {
            r = UNDEF;
        } else if (val === '' || isNaN(val)) {
            //isNaN('') returns false
            r = val;
        } else {
            //parseFloat(null || '') returns NaN
            r = parseFloat(val);
        }
        return r;
    }

    function typecastArrayValues(values) {
        var n = values.length,
            result = [];
        while (n--) {
            result[n] = typecastValue(values[n]);
        }
        return result;
    }

    // borrowed from MOUT
    function decodeQueryString(queryStr, shouldTypecast) {
        var queryArr = (queryStr || '').replace('?', '').split('&'),
            reg = /([^=]+)=(.+)/,
            i = -1,
            obj = {},
            equalIndex, cur, pValue, pName;

        while ((cur = queryArr[++i])) {
            equalIndex = cur.indexOf('=');
            pName = cur.substring(0, equalIndex);
            pValue = decodeURIComponent(cur.substring(equalIndex + 1));
            if (shouldTypecast !== false) {
                pValue = typecastValue(pValue);
            }
            if (pName in obj){
                if(isArray(obj[pName])){
                    obj[pName].push(pValue);
                } else {
                    obj[pName] = [obj[pName], pValue];
                }
            } else {
                obj[pName] = pValue;
           }
        }
        return obj;
    }


    // Crossroads --------
    //====================

    /**
     * @constructor
     */
    function Crossroads() {
        this.bypassed = new signals.Signal();
        this.routed = new signals.Signal();
        this._routes = [];
        this._prevRoutes = [];
        this._piped = [];
        this.resetState();
    }

    Crossroads.prototype = {

        greedy : false,

        greedyEnabled : true,

        ignoreCase : true,

        ignoreState : false,

        shouldTypecast : false,

        normalizeFn : null,

        resetState : function(){
            this._prevRoutes.length = 0;
            this._prevMatchedRequest = null;
            this._prevBypassedRequest = null;
        },

        create : function () {
            return new Crossroads();
        },

        addRoute : function (pattern, callback, priority) {
            var route = new Route(pattern, callback, priority, this);
            this._sortedInsert(route);
            return route;
        },

        removeRoute : function (route) {
            arrayRemove(this._routes, route);
            route._destroy();
        },

        removeAllRoutes : function () {
            var n = this.getNumRoutes();
            while (n--) {
                this._routes[n]._destroy();
            }
            this._routes.length = 0;
        },

        parse : function (request, defaultArgs) {
            request = request || '';
            defaultArgs = defaultArgs || [];

            // should only care about different requests if ignoreState isn't true
            if ( !this.ignoreState &&
                (request === this._prevMatchedRequest ||
                 request === this._prevBypassedRequest) ) {
                return;
            }

            var routes = this._getMatchedRoutes(request),
                i = 0,
                n = routes.length,
                cur;

            if (n) {
                this._prevMatchedRequest = request;

                this._notifyPrevRoutes(routes, request);
                this._prevRoutes = routes;
                //should be incremental loop, execute routes in order
                while (i < n) {
                    cur = routes[i];
                    cur.route.matched.dispatch.apply(cur.route.matched, defaultArgs.concat(cur.params));
                    cur.isFirst = !i;
                    this.routed.dispatch.apply(this.routed, defaultArgs.concat([request, cur]));
                    i += 1;
                }
            } else {
                this._prevBypassedRequest = request;
                this.bypassed.dispatch.apply(this.bypassed, defaultArgs.concat([request]));
            }

            this._pipeParse(request, defaultArgs);
        },

        _notifyPrevRoutes : function(matchedRoutes, request) {
            var i = 0, prev;
            while (prev = this._prevRoutes[i++]) {
                //check if switched exist since route may be disposed
                if(prev.route.switched && this._didSwitch(prev.route, matchedRoutes)) {
                    prev.route.switched.dispatch(request);
                }
            }
        },

        _didSwitch : function (route, matchedRoutes){
            var matched,
                i = 0;
            while (matched = matchedRoutes[i++]) {
                // only dispatch switched if it is going to a different route
                if (matched.route === route) {
                    return false;
                }
            }
            return true;
        },

        _pipeParse : function(request, defaultArgs) {
            var i = 0, route;
            while (route = this._piped[i++]) {
                route.parse(request, defaultArgs);
            }
        },

        getNumRoutes : function () {
            return this._routes.length;
        },

        _sortedInsert : function (route) {
            //simplified insertion sort
            var routes = this._routes,
                n = routes.length;
            do { --n; } while (routes[n] && route._priority <= routes[n]._priority);
            routes.splice(n+1, 0, route);
        },

        _getMatchedRoutes : function (request) {
            var res = [],
                routes = this._routes,
                n = routes.length,
                route;
            //should be decrement loop since higher priorities are added at the end of array
            while (route = routes[--n]) {
                if ((!res.length || this.greedy || route.greedy) && route.match(request)) {
                    res.push({
                        route : route,
                        params : route._getParamsArray(request)
                    });
                }
                if (!this.greedyEnabled && res.length) {
                    break;
                }
            }
            return res;
        },

        pipe : function (otherRouter) {
            this._piped.push(otherRouter);
        },

        unpipe : function (otherRouter) {
            arrayRemove(this._piped, otherRouter);
        },

        toString : function () {
            return '[crossroads numRoutes:'+ this.getNumRoutes() +']';
        }
    };

    //"static" instance
    crossroads = new Crossroads();
    crossroads.VERSION = '0.12.2';

    crossroads.NORM_AS_ARRAY = function (req, vals) {
        return [vals.vals_];
    };

    crossroads.NORM_AS_OBJECT = function (req, vals) {
        return [vals];
    };


    // Route --------------
    //=====================

    /**
     * @constructor
     */
    function Route(pattern, callback, priority, router) {
        var isRegexPattern = isRegExp(pattern),
            patternLexer = router.patternLexer;
        this._router = router;
        this._pattern = pattern;
        this._paramsIds = isRegexPattern? null : patternLexer.getParamIds(pattern);
        this._optionalParamsIds = isRegexPattern? null : patternLexer.getOptionalParamsIds(pattern);
        this._matchRegexp = isRegexPattern? pattern : patternLexer.compilePattern(pattern, router.ignoreCase);
        this.matched = new signals.Signal();
        this.switched = new signals.Signal();
        if (callback) {
            this.matched.add(callback);
        }
        this._priority = priority || 0;
    }

    Route.prototype = {

        greedy : false,

        rules : void(0),

        match : function (request) {
            request = request || '';
            return this._matchRegexp.test(request) && this._validateParams(request); //validate params even if regexp because of `request_` rule.
        },

        _validateParams : function (request) {
            var rules = this.rules,
                values = this._getParamsObject(request),
                key;
            for (key in rules) {
                // normalize_ isn't a validation rule... (#39)
                if(key !== 'normalize_' && rules.hasOwnProperty(key) && ! this._isValidParam(request, key, values)){
                    return false;
                }
            }
            return true;
        },

        _isValidParam : function (request, prop, values) {
            var validationRule = this.rules[prop],
                val = values[prop],
                isValid = false,
                isQuery = (prop.indexOf('?') === 0);

            if (val == null && this._optionalParamsIds && arrayIndexOf(this._optionalParamsIds, prop) !== -1) {
                isValid = true;
            }
            else if (isRegExp(validationRule)) {
                if (isQuery) {
                    val = values[prop +'_']; //use raw string
                }
                isValid = validationRule.test(val);
            }
            else if (isArray(validationRule)) {
                if (isQuery) {
                    val = values[prop +'_']; //use raw string
                }
                isValid = this._isValidArrayRule(validationRule, val);
            }
            else if (isFunction(validationRule)) {
                isValid = validationRule(val, request, values);
            }

            return isValid; //fail silently if validationRule is from an unsupported type
        },

        _isValidArrayRule : function (arr, val) {
            if (! this._router.ignoreCase) {
                return arrayIndexOf(arr, val) !== -1;
            }

            if (typeof val === 'string') {
                val = val.toLowerCase();
            }

            var n = arr.length,
                item,
                compareVal;

            while (n--) {
                item = arr[n];
                compareVal = (typeof item === 'string')? item.toLowerCase() : item;
                if (compareVal === val) {
                    return true;
                }
            }
            return false;
        },

        _getParamsObject : function (request) {
            var shouldTypecast = this._router.shouldTypecast,
                values = this._router.patternLexer.getParamValues(request, this._matchRegexp, shouldTypecast),
                o = {},
                n = values.length,
                param, val;
            while (n--) {
                val = values[n];
                if (this._paramsIds) {
                    param = this._paramsIds[n];
                    if (param.indexOf('?') === 0 && val) {
                        //make a copy of the original string so array and
                        //RegExp validation can be applied properly
                        o[param +'_'] = val;
                        //update vals_ array as well since it will be used
                        //during dispatch
                        val = decodeQueryString(val, shouldTypecast);
                        values[n] = val;
                    }
                    // IE will capture optional groups as empty strings while other
                    // browsers will capture `undefined` so normalize behavior.
                    // see: #gh-58, #gh-59, #gh-60
                    if ( _hasOptionalGroupBug && val === '' && arrayIndexOf(this._optionalParamsIds, param) !== -1 ) {
                        val = void(0);
                        values[n] = val;
                    }
                    o[param] = val;
                }
                //alias to paths and for RegExp pattern
                o[n] = val;
            }
            o.request_ = shouldTypecast? typecastValue(request) : request;
            o.vals_ = values;
            return o;
        },

        _getParamsArray : function (request) {
            var norm = this.rules? this.rules.normalize_ : null,
                params;
            norm = norm || this._router.normalizeFn; // default normalize
            if (norm && isFunction(norm)) {
                params = norm(request, this._getParamsObject(request));
            } else {
                params = this._getParamsObject(request).vals_;
            }
            return params;
        },

        interpolate : function(replacements) {
            var str = this._router.patternLexer.interpolate(this._pattern, replacements);
            if (! this._validateParams(str) ) {
                throw new Error('Generated string doesn\'t validate against `Route.rules`.');
            }
            return str;
        },

        dispose : function () {
            this._router.removeRoute(this);
        },

        _destroy : function () {
            this.matched.dispose();
            this.switched.dispose();
            this.matched = this.switched = this._pattern = this._matchRegexp = null;
        },

        toString : function () {
            return '[Route pattern:"'+ this._pattern +'", numListeners:'+ this.matched.getNumListeners() +']';
        }

    };



    // Pattern Lexer ------
    //=====================

    Crossroads.prototype.patternLexer = (function () {

        var
            //match chars that should be escaped on string regexp
            ESCAPE_CHARS_REGEXP = /[\\.+*?\^$\[\](){}\/'#]/g,

            //trailing slashes (begin/end of string)
            LOOSE_SLASHES_REGEXP = /^\/|\/$/g,
            LEGACY_SLASHES_REGEXP = /\/$/g,

            //params - everything between `{ }` or `: :`
            PARAMS_REGEXP = /(?:\{|:)([^}:]+)(?:\}|:)/g,

            //used to save params during compile (avoid escaping things that
            //shouldn't be escaped).
            TOKENS = {
                'OS' : {
                    //optional slashes
                    //slash between `::` or `}:` or `\w:` or `:{?` or `}{?` or `\w{?`
                    rgx : /([:}]|\w(?=\/))\/?(:|(?:\{\?))/g,
                    save : '$1{{id}}$2',
                    res : '\\/?'
                },
                'RS' : {
                    //required slashes
                    //used to insert slash between `:{` and `}{`
                    rgx : /([:}])\/?(\{)/g,
                    save : '$1{{id}}$2',
                    res : '\\/'
                },
                'RQ' : {
                    //required query string - everything in between `{? }`
                    rgx : /\{\?([^}]+)\}/g,
                    //everything from `?` till `#` or end of string
                    res : '\\?([^#]+)'
                },
                'OQ' : {
                    //optional query string - everything in between `:? :`
                    rgx : /:\?([^:]+):/g,
                    //everything from `?` till `#` or end of string
                    res : '(?:\\?([^#]*))?'
                },
                'OR' : {
                    //optional rest - everything in between `: *:`
                    rgx : /:([^:]+)\*:/g,
                    res : '(.*)?' // optional group to avoid passing empty string as captured
                },
                'RR' : {
                    //rest param - everything in between `{ *}`
                    rgx : /\{([^}]+)\*\}/g,
                    res : '(.+)'
                },
                // required/optional params should come after rest segments
                'RP' : {
                    //required params - everything between `{ }`
                    rgx : /\{([^}]+)\}/g,
                    res : '([^\\/?]+)'
                },
                'OP' : {
                    //optional params - everything between `: :`
                    rgx : /:([^:]+):/g,
                    res : '([^\\/?]+)?\/?'
                }
            },

            LOOSE_SLASH = 1,
            STRICT_SLASH = 2,
            LEGACY_SLASH = 3,

            _slashMode = LOOSE_SLASH;


        function precompileTokens(){
            var key, cur;
            for (key in TOKENS) {
                if (TOKENS.hasOwnProperty(key)) {
                    cur = TOKENS[key];
                    cur.id = '__CR_'+ key +'__';
                    cur.save = ('save' in cur)? cur.save.replace('{{id}}', cur.id) : cur.id;
                    cur.rRestore = new RegExp(cur.id, 'g');
                }
            }
        }
        precompileTokens();


        function captureVals(regex, pattern) {
            var vals = [], match;
            // very important to reset lastIndex since RegExp can have "g" flag
            // and multiple runs might affect the result, specially if matching
            // same string multiple times on IE 7-8
            regex.lastIndex = 0;
            while (match = regex.exec(pattern)) {
                vals.push(match[1]);
            }
            return vals;
        }

        function getParamIds(pattern) {
            return captureVals(PARAMS_REGEXP, pattern);
        }

        function getOptionalParamsIds(pattern) {
            return captureVals(TOKENS.OP.rgx, pattern);
        }

        function compilePattern(pattern, ignoreCase) {
            pattern = pattern || '';

            if(pattern){
                if (_slashMode === LOOSE_SLASH) {
                    pattern = pattern.replace(LOOSE_SLASHES_REGEXP, '');
                }
                else if (_slashMode === LEGACY_SLASH) {
                    pattern = pattern.replace(LEGACY_SLASHES_REGEXP, '');
                }

                //save tokens
                pattern = replaceTokens(pattern, 'rgx', 'save');
                //regexp escape
                pattern = pattern.replace(ESCAPE_CHARS_REGEXP, '\\$&');
                //restore tokens
                pattern = replaceTokens(pattern, 'rRestore', 'res');

                if (_slashMode === LOOSE_SLASH) {
                    pattern = '\\/?'+ pattern;
                }
            }

            if (_slashMode !== STRICT_SLASH) {
                //single slash is treated as empty and end slash is optional
                pattern += '\\/?';
            }
            return new RegExp('^'+ pattern + '$', ignoreCase? 'i' : '');
        }

        function replaceTokens(pattern, regexpName, replaceName) {
            var cur, key;
            for (key in TOKENS) {
                if (TOKENS.hasOwnProperty(key)) {
                    cur = TOKENS[key];
                    pattern = pattern.replace(cur[regexpName], cur[replaceName]);
                }
            }
            return pattern;
        }

        function getParamValues(request, regexp, shouldTypecast) {
            var vals = regexp.exec(request);
            if (vals) {
                vals.shift();
                if (shouldTypecast) {
                    vals = typecastArrayValues(vals);
                }
            }
            return vals;
        }

        function interpolate(pattern, replacements) {
            // default to an empty object because pattern might have just
            // optional arguments
            replacements = replacements || {};
            if (typeof pattern !== 'string') {
                throw new Error('Route pattern should be a string.');
            }

            var replaceFn = function(match, prop){
                    var val;
                    prop = (prop.substr(0, 1) === '?')? prop.substr(1) : prop;
                    if (replacements[prop] != null) {
                        if (typeof replacements[prop] === 'object') {
                            var queryParts = [], rep;
                            for(var key in replacements[prop]) {
                                rep = replacements[prop][key];
                                if (isArray(rep)) {
                                    for (var k in rep) {
                                        if ( key.slice(-2) == '[]' ) {
                                            queryParts.push(encodeURI(key.slice(0, -2)) + '[]=' + encodeURI(rep[k]));
                                        } else {
                                            queryParts.push(encodeURI(key + '=' + rep[k]));
                                        }
                                    }
                                }
                                else {
                                    queryParts.push(encodeURI(key + '=' + rep));
                                }
                            }
                            val = '?' + queryParts.join('&');
                        } else {
                            // make sure value is a string see #gh-54
                            val = String(replacements[prop]);
                        }

                        if (match.indexOf('*') === -1 && val.indexOf('/') !== -1) {
                            throw new Error('Invalid value "'+ val +'" for segment "'+ match +'".');
                        }
                    }
                    else if (match.indexOf('{') !== -1) {
                        throw new Error('The segment '+ match +' is required.');
                    }
                    else {
                        val = '';
                    }
                    return val;
                };

            if (! TOKENS.OS.trail) {
                TOKENS.OS.trail = new RegExp('(?:'+ TOKENS.OS.id +')+$');
            }

            return pattern
                        .replace(TOKENS.OS.rgx, TOKENS.OS.save)
                        .replace(PARAMS_REGEXP, replaceFn)
                        .replace(TOKENS.OS.trail, '') // remove trailing
                        .replace(TOKENS.OS.rRestore, '/'); // add slash between segments
        }

        //API
        return {
            strict : function(){
                _slashMode = STRICT_SLASH;
            },
            loose : function(){
                _slashMode = LOOSE_SLASH;
            },
            legacy : function(){
                _slashMode = LEGACY_SLASH;
            },
            getParamIds : getParamIds,
            getOptionalParamsIds : getOptionalParamsIds,
            getParamValues : getParamValues,
            compilePattern : compilePattern,
            interpolate : interpolate
        };

    }());


    return crossroads;
};

if (typeof define === 'function' && define.amd) {
    define(['signals'], factory);
} else if (typeof module !== 'undefined' && module.exports) { //Node
    module.exports = factory(require('signals'));
} else {
    /*jshint sub:true */
    window['crossroads'] = factory(window['signals']);
}

}());


},{"signals":218}],127:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],128:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyObject = {};

if ("production" !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
},{}],129:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if ("production" !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],130:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
},{"./emptyFunction":127}],131:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _handlebarsRuntime = require('./handlebars.runtime');

var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

// Compiler imports

var _handlebarsCompilerAst = require('./handlebars/compiler/ast');

var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

var _handlebarsCompilerBase = require('./handlebars/compiler/base');

var _handlebarsCompilerCompiler = require('./handlebars/compiler/compiler');

var _handlebarsCompilerJavascriptCompiler = require('./handlebars/compiler/javascript-compiler');

var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

var _handlebarsCompilerVisitor = require('./handlebars/compiler/visitor');

var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

var _create = _handlebarsRuntime2['default'].create;
function create() {
  var hb = _create();

  hb.compile = function (input, options) {
    return _handlebarsCompilerCompiler.compile(input, options, hb);
  };
  hb.precompile = function (input, options) {
    return _handlebarsCompilerCompiler.precompile(input, options, hb);
  };

  hb.AST = _handlebarsCompilerAst2['default'];
  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
  hb.Parser = _handlebarsCompilerBase.parser;
  hb.parse = _handlebarsCompilerBase.parse;

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst.Visitor = _handlebarsCompilerVisitor2['default'];

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars.runtime":132,"./handlebars/compiler/ast":134,"./handlebars/compiler/base":135,"./handlebars/compiler/compiler":137,"./handlebars/compiler/javascript-compiler":139,"./handlebars/compiler/visitor":142,"./handlebars/no-conflict":156}],132:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":133,"./handlebars/exception":146,"./handlebars/no-conflict":156,"./handlebars/runtime":157,"./handlebars/safe-string":158,"./handlebars/utils":159}],133:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.11';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":144,"./exception":146,"./helpers":147,"./logger":155,"./utils":159}],134:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var AST = {
  // Public API used to evaluate derived attributes regarding AST nodes
  helpers: {
    // a mustache is definitely a helper if:
    // * it is an eligible helper, and
    // * it has at least one parameter or hash segment
    helperExpression: function helperExpression(node) {
      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
    },

    scopedId: function scopedId(path) {
      return (/^\.|this\b/.test(path.original)
      );
    },

    // an ID is simple if it only has one part, and that part is not
    // `..` or `this`.
    simpleId: function simpleId(path) {
      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
    }
  }
};

// Must be exported as an object rather than the root of the module as the jison lexer
// must modify the object to operate properly.
exports['default'] = AST;
module.exports = exports['default'];


},{}],135:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.parse = parse;
// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _parser = require('./parser');

var _parser2 = _interopRequireDefault(_parser);

var _whitespaceControl = require('./whitespace-control');

var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

var _utils = require('../utils');

exports.parser = _parser2['default'];

var yy = {};
_utils.extend(yy, Helpers);

function parse(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var strip = new _whitespaceControl2['default'](options);
  return strip.accept(_parser2['default'].parse(input));
}


},{"../utils":159,"./helpers":138,"./parser":140,"./whitespace-control":143}],136:[function(require,module,exports){
/* global define */
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

var SourceNode = undefined;

try {
  /* istanbul ignore next */
  if (typeof define !== 'function' || !define.amd) {
    // We don't support this in AMD environments. For these environments, we asusme that
    // they are running on the browser and thus have no need for the source-map library.
    var SourceMap = require('source-map');
    SourceNode = SourceMap.SourceNode;
  }
} catch (err) {}
/* NOP */

/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
if (!SourceNode) {
  SourceNode = function (line, column, srcFile, chunks) {
    this.src = '';
    if (chunks) {
      this.add(chunks);
    }
  };
  /* istanbul ignore next */
  SourceNode.prototype = {
    add: function add(chunks) {
      if (_utils.isArray(chunks)) {
        chunks = chunks.join('');
      }
      this.src += chunks;
    },
    prepend: function prepend(chunks) {
      if (_utils.isArray(chunks)) {
        chunks = chunks.join('');
      }
      this.src = chunks + this.src;
    },
    toStringWithSourceMap: function toStringWithSourceMap() {
      return { code: this.toString() };
    },
    toString: function toString() {
      return this.src;
    }
  };
}

function castChunk(chunk, codeGen, loc) {
  if (_utils.isArray(chunk)) {
    var ret = [];

    for (var i = 0, len = chunk.length; i < len; i++) {
      ret.push(codeGen.wrap(chunk[i], loc));
    }
    return ret;
  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
    // Handle primitives that the SourceNode will throw up on
    return chunk + '';
  }
  return chunk;
}

function CodeGen(srcFile) {
  this.srcFile = srcFile;
  this.source = [];
}

CodeGen.prototype = {
  isEmpty: function isEmpty() {
    return !this.source.length;
  },
  prepend: function prepend(source, loc) {
    this.source.unshift(this.wrap(source, loc));
  },
  push: function push(source, loc) {
    this.source.push(this.wrap(source, loc));
  },

  merge: function merge() {
    var source = this.empty();
    this.each(function (line) {
      source.add(['  ', line, '\n']);
    });
    return source;
  },

  each: function each(iter) {
    for (var i = 0, len = this.source.length; i < len; i++) {
      iter(this.source[i]);
    }
  },

  empty: function empty() {
    var loc = this.currentLocation || { start: {} };
    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
  },
  wrap: function wrap(chunk) {
    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

    if (chunk instanceof SourceNode) {
      return chunk;
    }

    chunk = castChunk(chunk, this, loc);

    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
  },

  functionCall: function functionCall(fn, type, params) {
    params = this.generateList(params);
    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
  },

  quotedString: function quotedString(str) {
    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
    .replace(/\u2029/g, '\\u2029') + '"';
  },

  objectLiteral: function objectLiteral(obj) {
    var pairs = [];

    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        var value = castChunk(obj[key], this);
        if (value !== 'undefined') {
          pairs.push([this.quotedString(key), ':', value]);
        }
      }
    }

    var ret = this.generateList(pairs);
    ret.prepend('{');
    ret.add('}');
    return ret;
  },

  generateList: function generateList(entries) {
    var ret = this.empty();

    for (var i = 0, len = entries.length; i < len; i++) {
      if (i) {
        ret.add(',');
      }

      ret.add(castChunk(entries[i], this));
    }

    return ret;
  },

  generateArray: function generateArray(entries) {
    var ret = this.generateList(entries);
    ret.prepend('[');
    ret.add(']');

    return ret;
  }
};

exports['default'] = CodeGen;
module.exports = exports['default'];


},{"../utils":159,"source-map":161}],137:[function(require,module,exports){
/* eslint-disable new-cap */

'use strict';

exports.__esModule = true;
exports.Compiler = Compiler;
exports.precompile = precompile;
exports.compile = compile;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

var _utils = require('../utils');

var _ast = require('./ast');

var _ast2 = _interopRequireDefault(_ast);

var slice = [].slice;

function Compiler() {}

// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = {
  compiler: Compiler,

  equals: function equals(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
        return false;
      }
    }

    // We know that length is the same between the two arrays because they are directly tied
    // to the opcode behavior above.
    len = this.children.length;
    for (var i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }

    return true;
  },

  guid: 0,

  compile: function compile(program, options) {
    this.sourceNode = [];
    this.opcodes = [];
    this.children = [];
    this.options = options;
    this.stringParams = options.stringParams;
    this.trackIds = options.trackIds;

    options.blockParams = options.blockParams || [];

    // These changes will propagate to the other compiler components
    var knownHelpers = options.knownHelpers;
    options.knownHelpers = {
      'helperMissing': true,
      'blockHelperMissing': true,
      'each': true,
      'if': true,
      'unless': true,
      'with': true,
      'log': true,
      'lookup': true
    };
    if (knownHelpers) {
      for (var _name in knownHelpers) {
        /* istanbul ignore else */
        if (_name in knownHelpers) {
          this.options.knownHelpers[_name] = knownHelpers[_name];
        }
      }
    }

    return this.accept(program);
  },

  compileProgram: function compileProgram(program) {
    var childCompiler = new this.compiler(),
        // eslint-disable-line new-cap
    result = childCompiler.compile(program, this.options),
        guid = this.guid++;

    this.usePartial = this.usePartial || result.usePartial;

    this.children[guid] = result;
    this.useDepths = this.useDepths || result.useDepths;

    return guid;
  },

  accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
      throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
  },

  Program: function Program(program) {
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
      this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
  },

  BlockStatement: function BlockStatement(block) {
    transformLiteralToPath(block);

    var program = block.program,
        inverse = block.inverse;

    program = program && this.compileProgram(program);
    inverse = inverse && this.compileProgram(inverse);

    var type = this.classifySexpr(block);

    if (type === 'helper') {
      this.helperSexpr(block, program, inverse);
    } else if (type === 'simple') {
      this.simpleSexpr(block);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue', block.path.original);
    } else {
      this.ambiguousSexpr(block, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }

    this.opcode('append');
  },

  DecoratorBlock: function DecoratorBlock(decorator) {
    var program = decorator.program && this.compileProgram(decorator.program);
    var params = this.setupFullMustacheParams(decorator, program, undefined),
        path = decorator.path;

    this.useDecorators = true;
    this.opcode('registerDecorator', params.length, path.original);
  },

  PartialStatement: function PartialStatement(partial) {
    this.usePartial = true;

    var program = partial.program;
    if (program) {
      program = this.compileProgram(partial.program);
    }

    var params = partial.params;
    if (params.length > 1) {
      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
    } else if (!params.length) {
      if (this.options.explicitPartialContext) {
        this.opcode('pushLiteral', 'undefined');
      } else {
        params.push({ type: 'PathExpression', parts: [], depth: 0 });
      }
    }

    var partialName = partial.name.original,
        isDynamic = partial.name.type === 'SubExpression';
    if (isDynamic) {
      this.accept(partial.name);
    }

    this.setupFullMustacheParams(partial, program, undefined, true);

    var indent = partial.indent || '';
    if (this.options.preventIndent && indent) {
      this.opcode('appendContent', indent);
      indent = '';
    }

    this.opcode('invokePartial', isDynamic, partialName, indent);
    this.opcode('append');
  },
  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
    this.PartialStatement(partialBlock);
  },

  MustacheStatement: function MustacheStatement(mustache) {
    this.SubExpression(mustache);

    if (mustache.escaped && !this.options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },
  Decorator: function Decorator(decorator) {
    this.DecoratorBlock(decorator);
  },

  ContentStatement: function ContentStatement(content) {
    if (content.value) {
      this.opcode('appendContent', content.value);
    }
  },

  CommentStatement: function CommentStatement() {},

  SubExpression: function SubExpression(sexpr) {
    transformLiteralToPath(sexpr);
    var type = this.classifySexpr(sexpr);

    if (type === 'simple') {
      this.simpleSexpr(sexpr);
    } else if (type === 'helper') {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },
  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
    var path = sexpr.path,
        name = path.parts[0],
        isBlock = program != null || inverse != null;

    this.opcode('getContext', path.depth);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    path.strict = true;
    this.accept(path);

    this.opcode('invokeAmbiguous', name, isBlock);
  },

  simpleSexpr: function simpleSexpr(sexpr) {
    var path = sexpr.path;
    path.strict = true;
    this.accept(path);
    this.opcode('resolvePossibleLambda');
  },

  helperSexpr: function helperSexpr(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse),
        path = sexpr.path,
        name = path.parts[0];

    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
    } else {
      path.strict = true;
      path.falsy = true;

      this.accept(path);
      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
    }
  },

  PathExpression: function PathExpression(path) {
    this.addDepth(path.depth);
    this.opcode('getContext', path.depth);

    var name = path.parts[0],
        scoped = _ast2['default'].helpers.scopedId(path),
        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

    if (blockParamId) {
      this.opcode('lookupBlockParam', blockParamId, path.parts);
    } else if (!name) {
      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
      this.opcode('pushContext');
    } else if (path.data) {
      this.options.data = true;
      this.opcode('lookupData', path.depth, path.parts, path.strict);
    } else {
      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
    }
  },

  StringLiteral: function StringLiteral(string) {
    this.opcode('pushString', string.value);
  },

  NumberLiteral: function NumberLiteral(number) {
    this.opcode('pushLiteral', number.value);
  },

  BooleanLiteral: function BooleanLiteral(bool) {
    this.opcode('pushLiteral', bool.value);
  },

  UndefinedLiteral: function UndefinedLiteral() {
    this.opcode('pushLiteral', 'undefined');
  },

  NullLiteral: function NullLiteral() {
    this.opcode('pushLiteral', 'null');
  },

  Hash: function Hash(hash) {
    var pairs = hash.pairs,
        i = 0,
        l = pairs.length;

    this.opcode('pushHash');

    for (; i < l; i++) {
      this.pushParam(pairs[i].value);
    }
    while (i--) {
      this.opcode('assignToHash', pairs[i].key);
    }
    this.opcode('popHash');
  },

  // HELPERS
  opcode: function opcode(name) {
    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
  },

  addDepth: function addDepth(depth) {
    if (!depth) {
      return;
    }

    this.useDepths = true;
  },

  classifySexpr: function classifySexpr(sexpr) {
    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
    var isEligible = !isBlockParam && (isHelper || isSimple);

    // if ambiguous, we can possibly resolve the ambiguity now
    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
    if (isEligible && !isHelper) {
      var _name2 = sexpr.path.parts[0],
          options = this.options;

      if (options.knownHelpers[_name2]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }

    if (isHelper) {
      return 'helper';
    } else if (isEligible) {
      return 'ambiguous';
    } else {
      return 'simple';
    }
  },

  pushParams: function pushParams(params) {
    for (var i = 0, l = params.length; i < l; i++) {
      this.pushParam(params[i]);
    }
  },

  pushParam: function pushParam(val) {
    var value = val.value != null ? val.value : val.original || '';

    if (this.stringParams) {
      if (value.replace) {
        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
      }

      if (val.depth) {
        this.addDepth(val.depth);
      }
      this.opcode('getContext', val.depth || 0);
      this.opcode('pushStringParam', value, val.type);

      if (val.type === 'SubExpression') {
        // SubExpressions get evaluated and passed in
        // in string params mode.
        this.accept(val);
      }
    } else {
      if (this.trackIds) {
        var blockParamIndex = undefined;
        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
          blockParamIndex = this.blockParamIndex(val.parts[0]);
        }
        if (blockParamIndex) {
          var blockParamChild = val.parts.slice(1).join('.');
          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
        } else {
          value = val.original || value;
          if (value.replace) {
            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
          }

          this.opcode('pushId', val.type, value);
        }
      }
      this.accept(val);
    }
  },

  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
    var params = sexpr.params;
    this.pushParams(params);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if (sexpr.hash) {
      this.accept(sexpr.hash);
    } else {
      this.opcode('emptyHash', omitEmpty);
    }

    return params;
  },

  blockParamIndex: function blockParamIndex(name) {
    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
      var blockParams = this.options.blockParams[depth],
          param = blockParams && _utils.indexOf(blockParams, name);
      if (blockParams && param >= 0) {
        return [depth, param];
      }
    }
  }
};

function precompile(input, options, env) {
  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
  }

  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }

  var ast = env.parse(input, options),
      environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}

function compile(input, options, env) {
  if (options === undefined) options = {};

  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
  }

  options = _utils.extend({}, options);
  if (!('data' in options)) {
    options.data = true;
  }
  if (options.compat) {
    options.useDepths = true;
  }

  var compiled = undefined;

  function compileInput() {
    var ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options),
        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  function ret(context, execOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled.call(this, context, execOptions);
  }
  ret._setup = function (setupOptions) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._setup(setupOptions);
  };
  ret._child = function (i, data, blockParams, depths) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled._child(i, data, blockParams, depths);
  };
  return ret;
}

function argEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (!argEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

function transformLiteralToPath(sexpr) {
  if (!sexpr.path.parts) {
    var literal = sexpr.path;
    // Casting to string here to make false and 0 literal values play nicely with the rest
    // of the system.
    sexpr.path = {
      type: 'PathExpression',
      data: false,
      depth: 0,
      parts: [literal.original + ''],
      original: literal.original + '',
      loc: literal.loc
    };
  }
}


},{"../exception":146,"../utils":159,"./ast":134}],138:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.SourceLocation = SourceLocation;
exports.id = id;
exports.stripFlags = stripFlags;
exports.stripComment = stripComment;
exports.preparePath = preparePath;
exports.prepareMustache = prepareMustache;
exports.prepareRawBlock = prepareRawBlock;
exports.prepareBlock = prepareBlock;
exports.prepareProgram = prepareProgram;
exports.preparePartialBlock = preparePartialBlock;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

function validateClose(open, close) {
  close = close.path ? close.path.original : close;

  if (open.path.original !== close) {
    var errorNode = { loc: open.path.loc };

    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
  }
}

function SourceLocation(source, locInfo) {
  this.source = source;
  this.start = {
    line: locInfo.first_line,
    column: locInfo.first_column
  };
  this.end = {
    line: locInfo.last_line,
    column: locInfo.last_column
  };
}

function id(token) {
  if (/^\[.*\]$/.test(token)) {
    return token.substr(1, token.length - 2);
  } else {
    return token;
  }
}

function stripFlags(open, close) {
  return {
    open: open.charAt(2) === '~',
    close: close.charAt(close.length - 3) === '~'
  };
}

function stripComment(comment) {
  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
}

function preparePath(data, parts, loc) {
  loc = this.locInfo(loc);

  var original = data ? '@' : '',
      dig = [],
      depth = 0,
      depthString = '';

  for (var i = 0, l = parts.length; i < l; i++) {
    var part = parts[i].part,

    // If we have [] syntax then we do not treat path references as operators,
    // i.e. foo.[this] resolves to approximately context.foo['this']
    isLiteral = parts[i].original !== part;
    original += (parts[i].separator || '') + part;

    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
      if (dig.length > 0) {
        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
      } else if (part === '..') {
        depth++;
        depthString += '../';
      }
    } else {
      dig.push(part);
    }
  }

  return {
    type: 'PathExpression',
    data: data,
    depth: depth,
    parts: dig,
    original: original,
    loc: loc
  };
}

function prepareMustache(path, params, hash, open, strip, locInfo) {
  // Must use charAt to support IE pre-10
  var escapeFlag = open.charAt(3) || open.charAt(2),
      escaped = escapeFlag !== '{' && escapeFlag !== '&';

  var decorator = /\*/.test(open);
  return {
    type: decorator ? 'Decorator' : 'MustacheStatement',
    path: path,
    params: params,
    hash: hash,
    escaped: escaped,
    strip: strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareRawBlock(openRawBlock, contents, close, locInfo) {
  validateClose(openRawBlock, close);

  locInfo = this.locInfo(locInfo);
  var program = {
    type: 'Program',
    body: contents,
    strip: {},
    loc: locInfo
  };

  return {
    type: 'BlockStatement',
    path: openRawBlock.path,
    params: openRawBlock.params,
    hash: openRawBlock.hash,
    program: program,
    openStrip: {},
    inverseStrip: {},
    closeStrip: {},
    loc: locInfo
  };
}

function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
  if (close && close.path) {
    validateClose(openBlock, close);
  }

  var decorator = /\*/.test(openBlock.open);

  program.blockParams = openBlock.blockParams;

  var inverse = undefined,
      inverseStrip = undefined;

  if (inverseAndProgram) {
    if (decorator) {
      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
    }

    if (inverseAndProgram.chain) {
      inverseAndProgram.program.body[0].closeStrip = close.strip;
    }

    inverseStrip = inverseAndProgram.strip;
    inverse = inverseAndProgram.program;
  }

  if (inverted) {
    inverted = inverse;
    inverse = program;
    program = inverted;
  }

  return {
    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
    path: openBlock.path,
    params: openBlock.params,
    hash: openBlock.hash,
    program: program,
    inverse: inverse,
    openStrip: openBlock.strip,
    inverseStrip: inverseStrip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}

function prepareProgram(statements, loc) {
  if (!loc && statements.length) {
    var firstLoc = statements[0].loc,
        lastLoc = statements[statements.length - 1].loc;

    /* istanbul ignore else */
    if (firstLoc && lastLoc) {
      loc = {
        source: firstLoc.source,
        start: {
          line: firstLoc.start.line,
          column: firstLoc.start.column
        },
        end: {
          line: lastLoc.end.line,
          column: lastLoc.end.column
        }
      };
    }
  }

  return {
    type: 'Program',
    body: statements,
    strip: {},
    loc: loc
  };
}

function preparePartialBlock(open, program, close, locInfo) {
  validateClose(open, close);

  return {
    type: 'PartialBlockStatement',
    name: open.path,
    params: open.params,
    hash: open.hash,
    program: program,
    openStrip: open.strip,
    closeStrip: close && close.strip,
    loc: this.locInfo(locInfo)
  };
}


},{"../exception":146}],139:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _base = require('../base');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

var _utils = require('../utils');

var _codeGen = require('./code-gen');

var _codeGen2 = _interopRequireDefault(_codeGen);

function Literal(value) {
  this.value = value;
}

function JavaScriptCompiler() {}

JavaScriptCompiler.prototype = {
  // PUBLIC API: You can override these methods in a subclass to provide
  // alternative compiled forms for name lookup and buffering semantics
  nameLookup: function nameLookup(parent, name /* , type*/) {
    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
      return [parent, '.', name];
    } else {
      return [parent, '[', JSON.stringify(name), ']'];
    }
  },
  depthedLookup: function depthedLookup(name) {
    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
  },

  compilerInfo: function compilerInfo() {
    var revision = _base.COMPILER_REVISION,
        versions = _base.REVISION_CHANGES[revision];
    return [revision, versions];
  },

  appendToBuffer: function appendToBuffer(source, location, explicit) {
    // Force a source as this simplifies the merge logic.
    if (!_utils.isArray(source)) {
      source = [source];
    }
    source = this.source.wrap(source, location);

    if (this.environment.isSimple) {
      return ['return ', source, ';'];
    } else if (explicit) {
      // This is a case where the buffer operation occurs as a child of another
      // construct, generally braces. We have to explicitly output these buffer
      // operations to ensure that the emitted code goes in the correct location.
      return ['buffer += ', source, ';'];
    } else {
      source.appendToBuffer = true;
      return source;
    }
  },

  initializeBuffer: function initializeBuffer() {
    return this.quotedString('');
  },
  // END PUBLIC API

  compile: function compile(environment, options, context, asObject) {
    this.environment = environment;
    this.options = options;
    this.stringParams = this.options.stringParams;
    this.trackIds = this.options.trackIds;
    this.precompile = !asObject;

    this.name = this.environment.name;
    this.isChild = !!context;
    this.context = context || {
      decorators: [],
      programs: [],
      environments: []
    };

    this.preamble();

    this.stackSlot = 0;
    this.stackVars = [];
    this.aliases = {};
    this.registers = { list: [] };
    this.hashes = [];
    this.compileStack = [];
    this.inlineStack = [];
    this.blockParams = [];

    this.compileChildren(environment, options);

    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

    var opcodes = environment.opcodes,
        opcode = undefined,
        firstLoc = undefined,
        i = undefined,
        l = undefined;

    for (i = 0, l = opcodes.length; i < l; i++) {
      opcode = opcodes[i];

      this.source.currentLocation = opcode.loc;
      firstLoc = firstLoc || opcode.loc;
      this[opcode.opcode].apply(this, opcode.args);
    }

    // Flush any trailing content that might be pending.
    this.source.currentLocation = firstLoc;
    this.pushSource('');

    /* istanbul ignore next */
    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
      throw new _exception2['default']('Compile completed with content left on stack');
    }

    if (!this.decorators.isEmpty()) {
      this.useDecorators = true;

      this.decorators.prepend('var decorators = container.decorators;\n');
      this.decorators.push('return fn;');

      if (asObject) {
        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
      } else {
        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
        this.decorators.push('}\n');
        this.decorators = this.decorators.merge();
      }
    } else {
      this.decorators = undefined;
    }

    var fn = this.createFunctionContext(asObject);
    if (!this.isChild) {
      var ret = {
        compiler: this.compilerInfo(),
        main: fn
      };

      if (this.decorators) {
        ret.main_d = this.decorators; // eslint-disable-line camelcase
        ret.useDecorators = true;
      }

      var _context = this.context;
      var programs = _context.programs;
      var decorators = _context.decorators;

      for (i = 0, l = programs.length; i < l; i++) {
        if (programs[i]) {
          ret[i] = programs[i];
          if (decorators[i]) {
            ret[i + '_d'] = decorators[i];
            ret.useDecorators = true;
          }
        }
      }

      if (this.environment.usePartial) {
        ret.usePartial = true;
      }
      if (this.options.data) {
        ret.useData = true;
      }
      if (this.useDepths) {
        ret.useDepths = true;
      }
      if (this.useBlockParams) {
        ret.useBlockParams = true;
      }
      if (this.options.compat) {
        ret.compat = true;
      }

      if (!asObject) {
        ret.compiler = JSON.stringify(ret.compiler);

        this.source.currentLocation = { start: { line: 1, column: 0 } };
        ret = this.objectLiteral(ret);

        if (options.srcName) {
          ret = ret.toStringWithSourceMap({ file: options.destName });
          ret.map = ret.map && ret.map.toString();
        } else {
          ret = ret.toString();
        }
      } else {
        ret.compilerOptions = this.options;
      }

      return ret;
    } else {
      return fn;
    }
  },

  preamble: function preamble() {
    // track the last context pushed into place to allow skipping the
    // getContext opcode when it would be a noop
    this.lastContext = 0;
    this.source = new _codeGen2['default'](this.options.srcName);
    this.decorators = new _codeGen2['default'](this.options.srcName);
  },

  createFunctionContext: function createFunctionContext(asObject) {
    var varDeclarations = '';

    var locals = this.stackVars.concat(this.registers.list);
    if (locals.length > 0) {
      varDeclarations += ', ' + locals.join(', ');
    }

    // Generate minimizer alias mappings
    //
    // When using true SourceNodes, this will update all references to the given alias
    // as the source nodes are reused in situ. For the non-source node compilation mode,
    // aliases will not be used, but this case is already being run on the client and
    // we aren't concern about minimizing the template size.
    var aliasCount = 0;
    for (var alias in this.aliases) {
      // eslint-disable-line guard-for-in
      var node = this.aliases[alias];

      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
        node.children[0] = 'alias' + aliasCount;
      }
    }

    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

    if (this.useBlockParams || this.useDepths) {
      params.push('blockParams');
    }
    if (this.useDepths) {
      params.push('depths');
    }

    // Perform a second pass over the output to merge content when possible
    var source = this.mergeSource(varDeclarations);

    if (asObject) {
      params.push(source);

      return Function.apply(this, params);
    } else {
      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
    }
  },
  mergeSource: function mergeSource(varDeclarations) {
    var isSimple = this.environment.isSimple,
        appendOnly = !this.forceBuffer,
        appendFirst = undefined,
        sourceSeen = undefined,
        bufferStart = undefined,
        bufferEnd = undefined;
    this.source.each(function (line) {
      if (line.appendToBuffer) {
        if (bufferStart) {
          line.prepend('  + ');
        } else {
          bufferStart = line;
        }
        bufferEnd = line;
      } else {
        if (bufferStart) {
          if (!sourceSeen) {
            appendFirst = true;
          } else {
            bufferStart.prepend('buffer += ');
          }
          bufferEnd.add(';');
          bufferStart = bufferEnd = undefined;
        }

        sourceSeen = true;
        if (!isSimple) {
          appendOnly = false;
        }
      }
    });

    if (appendOnly) {
      if (bufferStart) {
        bufferStart.prepend('return ');
        bufferEnd.add(';');
      } else if (!sourceSeen) {
        this.source.push('return "";');
      }
    } else {
      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

      if (bufferStart) {
        bufferStart.prepend('return buffer + ');
        bufferEnd.add(';');
      } else {
        this.source.push('return buffer;');
      }
    }

    if (varDeclarations) {
      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
    }

    return this.source.merge();
  },

  // [blockValue]
  //
  // On stack, before: hash, inverse, program, value
  // On stack, after: return value of blockHelperMissing
  //
  // The purpose of this opcode is to take a block of the form
  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
  // replace it on the stack with the result of properly
  // invoking blockHelperMissing.
  blockValue: function blockValue(name) {
    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs(name, 0, params);

    var blockName = this.popStack();
    params.splice(1, 0, blockName);

    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
  },

  // [ambiguousBlockValue]
  //
  // On stack, before: hash, inverse, program, value
  // Compiler value, before: lastHelper=value of last found helper, if any
  // On stack, after, if no lastHelper: same as [blockValue]
  // On stack, after, if lastHelper: value
  ambiguousBlockValue: function ambiguousBlockValue() {
    // We're being a bit cheeky and reusing the options value from the prior exec
    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
        params = [this.contextName(0)];
    this.setupHelperArgs('', 0, params, true);

    this.flushInline();

    var current = this.topStack();
    params.splice(1, 0, current);

    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
  },

  // [appendContent]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Appends the string value of `content` to the current buffer
  appendContent: function appendContent(content) {
    if (this.pendingContent) {
      content = this.pendingContent + content;
    } else {
      this.pendingLocation = this.source.currentLocation;
    }

    this.pendingContent = content;
  },

  // [append]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Coerces `value` to a String and appends it to the current buffer.
  //
  // If `value` is truthy, or 0, it is coerced into a string and appended
  // Otherwise, the empty string is appended
  append: function append() {
    if (this.isInline()) {
      this.replaceStack(function (current) {
        return [' != null ? ', current, ' : ""'];
      });

      this.pushSource(this.appendToBuffer(this.popStack()));
    } else {
      var local = this.popStack();
      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
      if (this.environment.isSimple) {
        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
      }
    }
  },

  // [appendEscaped]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Escape `value` and append it to the buffer
  appendEscaped: function appendEscaped() {
    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
  },

  // [getContext]
  //
  // On stack, before: ...
  // On stack, after: ...
  // Compiler value, after: lastContext=depth
  //
  // Set the value of the `lastContext` compiler value to the depth
  getContext: function getContext(depth) {
    this.lastContext = depth;
  },

  // [pushContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext, ...
  //
  // Pushes the value of the current context onto the stack.
  pushContext: function pushContext() {
    this.pushStackLiteral(this.contextName(this.lastContext));
  },

  // [lookupOnContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext[name], ...
  //
  // Looks up the value of `name` on the current context and pushes
  // it onto the stack.
  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
    var i = 0;

    if (!scoped && this.options.compat && !this.lastContext) {
      // The depthed query is expected to handle the undefined logic for the root level that
      // is implemented below, so we evaluate that directly in compat mode
      this.push(this.depthedLookup(parts[i++]));
    } else {
      this.pushContext();
    }

    this.resolvePath('context', parts, i, falsy, strict);
  },

  // [lookupBlockParam]
  //
  // On stack, before: ...
  // On stack, after: blockParam[name], ...
  //
  // Looks up the value of `parts` on the given block param and pushes
  // it onto the stack.
  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
    this.useBlockParams = true;

    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
    this.resolvePath('context', parts, 1);
  },

  // [lookupData]
  //
  // On stack, before: ...
  // On stack, after: data, ...
  //
  // Push the data lookup operator
  lookupData: function lookupData(depth, parts, strict) {
    if (!depth) {
      this.pushStackLiteral('data');
    } else {
      this.pushStackLiteral('container.data(data, ' + depth + ')');
    }

    this.resolvePath('data', parts, 0, true, strict);
  },

  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
    // istanbul ignore next

    var _this = this;

    if (this.options.strict || this.options.assumeObjects) {
      this.push(strictLookup(this.options.strict && strict, this, parts, type));
      return;
    }

    var len = parts.length;
    for (; i < len; i++) {
      /* eslint-disable no-loop-func */
      this.replaceStack(function (current) {
        var lookup = _this.nameLookup(current, parts[i], type);
        // We want to ensure that zero and false are handled properly if the context (falsy flag)
        // needs to have the special handling for these values.
        if (!falsy) {
          return [' != null ? ', lookup, ' : ', current];
        } else {
          // Otherwise we can use generic falsy handling
          return [' && ', lookup];
        }
      });
      /* eslint-enable no-loop-func */
    }
  },

  // [resolvePossibleLambda]
  //
  // On stack, before: value, ...
  // On stack, after: resolved value, ...
  //
  // If the `value` is a lambda, replace it on the stack by
  // the return value of the lambda
  resolvePossibleLambda: function resolvePossibleLambda() {
    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
  },

  // [pushStringParam]
  //
  // On stack, before: ...
  // On stack, after: string, currentContext, ...
  //
  // This opcode is designed for use in string mode, which
  // provides the string value of a parameter along with its
  // depth rather than resolving it immediately.
  pushStringParam: function pushStringParam(string, type) {
    this.pushContext();
    this.pushString(type);

    // If it's a subexpression, the string result
    // will be pushed after this opcode.
    if (type !== 'SubExpression') {
      if (typeof string === 'string') {
        this.pushString(string);
      } else {
        this.pushStackLiteral(string);
      }
    }
  },

  emptyHash: function emptyHash(omitEmpty) {
    if (this.trackIds) {
      this.push('{}'); // hashIds
    }
    if (this.stringParams) {
      this.push('{}'); // hashContexts
      this.push('{}'); // hashTypes
    }
    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
  },
  pushHash: function pushHash() {
    if (this.hash) {
      this.hashes.push(this.hash);
    }
    this.hash = { values: [], types: [], contexts: [], ids: [] };
  },
  popHash: function popHash() {
    var hash = this.hash;
    this.hash = this.hashes.pop();

    if (this.trackIds) {
      this.push(this.objectLiteral(hash.ids));
    }
    if (this.stringParams) {
      this.push(this.objectLiteral(hash.contexts));
      this.push(this.objectLiteral(hash.types));
    }

    this.push(this.objectLiteral(hash.values));
  },

  // [pushString]
  //
  // On stack, before: ...
  // On stack, after: quotedString(string), ...
  //
  // Push a quoted version of `string` onto the stack
  pushString: function pushString(string) {
    this.pushStackLiteral(this.quotedString(string));
  },

  // [pushLiteral]
  //
  // On stack, before: ...
  // On stack, after: value, ...
  //
  // Pushes a value onto the stack. This operation prevents
  // the compiler from creating a temporary variable to hold
  // it.
  pushLiteral: function pushLiteral(value) {
    this.pushStackLiteral(value);
  },

  // [pushProgram]
  //
  // On stack, before: ...
  // On stack, after: program(guid), ...
  //
  // Push a program expression onto the stack. This takes
  // a compile-time guid and converts it into a runtime-accessible
  // expression.
  pushProgram: function pushProgram(guid) {
    if (guid != null) {
      this.pushStackLiteral(this.programExpression(guid));
    } else {
      this.pushStackLiteral(null);
    }
  },

  // [registerDecorator]
  //
  // On stack, before: hash, program, params..., ...
  // On stack, after: ...
  //
  // Pops off the decorator's parameters, invokes the decorator,
  // and inserts the decorator into the decorators list.
  registerDecorator: function registerDecorator(paramSize, name) {
    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
        options = this.setupHelperArgs(name, paramSize);

    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
  },

  // [invokeHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // Pops off the helper's parameters, invokes the helper,
  // and pushes the helper's return value onto the stack.
  //
  // If the helper is not found, `helperMissing` is called.
  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
    var nonHelper = this.popStack(),
        helper = this.setupHelper(paramSize, name),
        simple = isSimple ? [helper.name, ' || '] : '';

    var lookup = ['('].concat(simple, nonHelper);
    if (!this.options.strict) {
      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
    }
    lookup.push(')');

    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
  },

  // [invokeKnownHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // This operation is used when the helper is known to exist,
  // so a `helperMissing` fallback is not required.
  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
    var helper = this.setupHelper(paramSize, name);
    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
  },

  // [invokeAmbiguous]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of disambiguation
  //
  // This operation is used when an expression like `{{foo}}`
  // is provided, but we don't know at compile-time whether it
  // is a helper or a path.
  //
  // This operation emits more code than the other options,
  // and can be avoided by passing the `knownHelpers` and
  // `knownHelpersOnly` flags at compile-time.
  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
    this.useRegister('helper');

    var nonHelper = this.popStack();

    this.emptyHash();
    var helper = this.setupHelper(0, name, helperCall);

    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
    if (!this.options.strict) {
      lookup[0] = '(helper = ';
      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
    }

    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
  },

  // [invokePartial]
  //
  // On stack, before: context, ...
  // On stack after: result of partial invocation
  //
  // This operation pops off a context, invokes a partial with that context,
  // and pushes the result of the invocation back.
  invokePartial: function invokePartial(isDynamic, name, indent) {
    var params = [],
        options = this.setupParams(name, 1, params);

    if (isDynamic) {
      name = this.popStack();
      delete options.name;
    }

    if (indent) {
      options.indent = JSON.stringify(indent);
    }
    options.helpers = 'helpers';
    options.partials = 'partials';
    options.decorators = 'container.decorators';

    if (!isDynamic) {
      params.unshift(this.nameLookup('partials', name, 'partial'));
    } else {
      params.unshift(name);
    }

    if (this.options.compat) {
      options.depths = 'depths';
    }
    options = this.objectLiteral(options);
    params.push(options);

    this.push(this.source.functionCall('container.invokePartial', '', params));
  },

  // [assignToHash]
  //
  // On stack, before: value, ..., hash, ...
  // On stack, after: ..., hash, ...
  //
  // Pops a value off the stack and assigns it to the current hash
  assignToHash: function assignToHash(key) {
    var value = this.popStack(),
        context = undefined,
        type = undefined,
        id = undefined;

    if (this.trackIds) {
      id = this.popStack();
    }
    if (this.stringParams) {
      type = this.popStack();
      context = this.popStack();
    }

    var hash = this.hash;
    if (context) {
      hash.contexts[key] = context;
    }
    if (type) {
      hash.types[key] = type;
    }
    if (id) {
      hash.ids[key] = id;
    }
    hash.values[key] = value;
  },

  pushId: function pushId(type, name, child) {
    if (type === 'BlockParam') {
      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
    } else if (type === 'PathExpression') {
      this.pushString(name);
    } else if (type === 'SubExpression') {
      this.pushStackLiteral('true');
    } else {
      this.pushStackLiteral('null');
    }
  },

  // HELPERS

  compiler: JavaScriptCompiler,

  compileChildren: function compileChildren(environment, options) {
    var children = environment.children,
        child = undefined,
        compiler = undefined;

    for (var i = 0, l = children.length; i < l; i++) {
      child = children[i];
      compiler = new this.compiler(); // eslint-disable-line new-cap

      var existing = this.matchExistingProgram(child);

      if (existing == null) {
        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
        var index = this.context.programs.length;
        child.index = index;
        child.name = 'program' + index;
        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
        this.context.decorators[index] = compiler.decorators;
        this.context.environments[index] = child;

        this.useDepths = this.useDepths || compiler.useDepths;
        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
        child.useDepths = this.useDepths;
        child.useBlockParams = this.useBlockParams;
      } else {
        child.index = existing.index;
        child.name = 'program' + existing.index;

        this.useDepths = this.useDepths || existing.useDepths;
        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
      }
    }
  },
  matchExistingProgram: function matchExistingProgram(child) {
    for (var i = 0, len = this.context.environments.length; i < len; i++) {
      var environment = this.context.environments[i];
      if (environment && environment.equals(child)) {
        return environment;
      }
    }
  },

  programExpression: function programExpression(guid) {
    var child = this.environment.children[guid],
        programParams = [child.index, 'data', child.blockParams];

    if (this.useBlockParams || this.useDepths) {
      programParams.push('blockParams');
    }
    if (this.useDepths) {
      programParams.push('depths');
    }

    return 'container.program(' + programParams.join(', ') + ')';
  },

  useRegister: function useRegister(name) {
    if (!this.registers[name]) {
      this.registers[name] = true;
      this.registers.list.push(name);
    }
  },

  push: function push(expr) {
    if (!(expr instanceof Literal)) {
      expr = this.source.wrap(expr);
    }

    this.inlineStack.push(expr);
    return expr;
  },

  pushStackLiteral: function pushStackLiteral(item) {
    this.push(new Literal(item));
  },

  pushSource: function pushSource(source) {
    if (this.pendingContent) {
      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
      this.pendingContent = undefined;
    }

    if (source) {
      this.source.push(source);
    }
  },

  replaceStack: function replaceStack(callback) {
    var prefix = ['('],
        stack = undefined,
        createdStack = undefined,
        usedLiteral = undefined;

    /* istanbul ignore next */
    if (!this.isInline()) {
      throw new _exception2['default']('replaceStack on non-inline');
    }

    // We want to merge the inline statement into the replacement statement via ','
    var top = this.popStack(true);

    if (top instanceof Literal) {
      // Literals do not need to be inlined
      stack = [top.value];
      prefix = ['(', stack];
      usedLiteral = true;
    } else {
      // Get or create the current stack name for use by the inline
      createdStack = true;
      var _name = this.incrStack();

      prefix = ['((', this.push(_name), ' = ', top, ')'];
      stack = this.topStack();
    }

    var item = callback.call(this, stack);

    if (!usedLiteral) {
      this.popStack();
    }
    if (createdStack) {
      this.stackSlot--;
    }
    this.push(prefix.concat(item, ')'));
  },

  incrStack: function incrStack() {
    this.stackSlot++;
    if (this.stackSlot > this.stackVars.length) {
      this.stackVars.push('stack' + this.stackSlot);
    }
    return this.topStackName();
  },
  topStackName: function topStackName() {
    return 'stack' + this.stackSlot;
  },
  flushInline: function flushInline() {
    var inlineStack = this.inlineStack;
    this.inlineStack = [];
    for (var i = 0, len = inlineStack.length; i < len; i++) {
      var entry = inlineStack[i];
      /* istanbul ignore if */
      if (entry instanceof Literal) {
        this.compileStack.push(entry);
      } else {
        var stack = this.incrStack();
        this.pushSource([stack, ' = ', entry, ';']);
        this.compileStack.push(stack);
      }
    }
  },
  isInline: function isInline() {
    return this.inlineStack.length;
  },

  popStack: function popStack(wrapped) {
    var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

    if (!wrapped && item instanceof Literal) {
      return item.value;
    } else {
      if (!inline) {
        /* istanbul ignore next */
        if (!this.stackSlot) {
          throw new _exception2['default']('Invalid stack pop');
        }
        this.stackSlot--;
      }
      return item;
    }
  },

  topStack: function topStack() {
    var stack = this.isInline() ? this.inlineStack : this.compileStack,
        item = stack[stack.length - 1];

    /* istanbul ignore if */
    if (item instanceof Literal) {
      return item.value;
    } else {
      return item;
    }
  },

  contextName: function contextName(context) {
    if (this.useDepths && context) {
      return 'depths[' + context + ']';
    } else {
      return 'depth' + context;
    }
  },

  quotedString: function quotedString(str) {
    return this.source.quotedString(str);
  },

  objectLiteral: function objectLiteral(obj) {
    return this.source.objectLiteral(obj);
  },

  aliasable: function aliasable(name) {
    var ret = this.aliases[name];
    if (ret) {
      ret.referenceCount++;
      return ret;
    }

    ret = this.aliases[name] = this.source.wrap(name);
    ret.aliasable = true;
    ret.referenceCount = 1;

    return ret;
  },

  setupHelper: function setupHelper(paramSize, name, blockHelper) {
    var params = [],
        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
    var foundHelper = this.nameLookup('helpers', name, 'helper'),
        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

    return {
      params: params,
      paramsInit: paramsInit,
      name: foundHelper,
      callParams: [callContext].concat(params)
    };
  },

  setupParams: function setupParams(helper, paramSize, params) {
    var options = {},
        contexts = [],
        types = [],
        ids = [],
        objectArgs = !params,
        param = undefined;

    if (objectArgs) {
      params = [];
    }

    options.name = this.quotedString(helper);
    options.hash = this.popStack();

    if (this.trackIds) {
      options.hashIds = this.popStack();
    }
    if (this.stringParams) {
      options.hashTypes = this.popStack();
      options.hashContexts = this.popStack();
    }

    var inverse = this.popStack(),
        program = this.popStack();

    // Avoid setting fn and inverse if neither are set. This allows
    // helpers to do a check for `if (options.fn)`
    if (program || inverse) {
      options.fn = program || 'container.noop';
      options.inverse = inverse || 'container.noop';
    }

    // The parameters go on to the stack in order (making sure that they are evaluated in order)
    // so we need to pop them off the stack in reverse order
    var i = paramSize;
    while (i--) {
      param = this.popStack();
      params[i] = param;

      if (this.trackIds) {
        ids[i] = this.popStack();
      }
      if (this.stringParams) {
        types[i] = this.popStack();
        contexts[i] = this.popStack();
      }
    }

    if (objectArgs) {
      options.args = this.source.generateArray(params);
    }

    if (this.trackIds) {
      options.ids = this.source.generateArray(ids);
    }
    if (this.stringParams) {
      options.types = this.source.generateArray(types);
      options.contexts = this.source.generateArray(contexts);
    }

    if (this.options.data) {
      options.data = 'data';
    }
    if (this.useBlockParams) {
      options.blockParams = 'blockParams';
    }
    return options;
  },

  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
    var options = this.setupParams(helper, paramSize, params);
    options = this.objectLiteral(options);
    if (useRegister) {
      this.useRegister('options');
      params.push('options');
      return ['options=', options];
    } else if (params) {
      params.push(options);
      return '';
    } else {
      return options;
    }
  }
};

(function () {
  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for (var i = 0, l = reservedWords.length; i < l; i++) {
    compilerWords[reservedWords[i]] = true;
  }
})();

JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
};

function strictLookup(requireTerminal, compiler, parts, type) {
  var stack = compiler.popStack(),
      i = 0,
      len = parts.length;
  if (requireTerminal) {
    len--;
  }

  for (; i < len; i++) {
    stack = compiler.nameLookup(stack, parts[i], type);
  }

  if (requireTerminal) {
    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
  } else {
    return stack;
  }
}

exports['default'] = JavaScriptCompiler;
module.exports = exports['default'];


},{"../base":133,"../exception":146,"../utils":159,"./code-gen":136}],140:[function(require,module,exports){
// File ignored in coverage tests via setting in .istanbul.yml
/* Jison generated parser */
"use strict";

exports.__esModule = true;
var handlebars = (function () {
    var parser = { trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
        /**/) {

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:
                    return $$[$0 - 1];
                    break;
                case 2:
                    this.$ = yy.prepareProgram($$[$0]);
                    break;
                case 3:
                    this.$ = $$[$0];
                    break;
                case 4:
                    this.$ = $$[$0];
                    break;
                case 5:
                    this.$ = $$[$0];
                    break;
                case 6:
                    this.$ = $$[$0];
                    break;
                case 7:
                    this.$ = $$[$0];
                    break;
                case 8:
                    this.$ = $$[$0];
                    break;
                case 9:
                    this.$ = {
                        type: 'CommentStatement',
                        value: yy.stripComment($$[$0]),
                        strip: yy.stripFlags($$[$0], $$[$0]),
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 10:
                    this.$ = {
                        type: 'ContentStatement',
                        original: $$[$0],
                        value: $$[$0],
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 11:
                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                    break;
                case 12:
                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                    break;
                case 13:
                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                    break;
                case 14:
                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                    break;
                case 15:
                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 16:
                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 17:
                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                    break;
                case 18:
                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                    break;
                case 19:
                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                    program.chained = true;

                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                    break;
                case 20:
                    this.$ = $$[$0];
                    break;
                case 21:
                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                    break;
                case 22:
                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                    break;
                case 23:
                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                    break;
                case 24:
                    this.$ = {
                        type: 'PartialStatement',
                        name: $$[$0 - 3],
                        params: $$[$0 - 2],
                        hash: $$[$0 - 1],
                        indent: '',
                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 25:
                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                    break;
                case 26:
                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                    break;
                case 27:
                    this.$ = $$[$0];
                    break;
                case 28:
                    this.$ = $$[$0];
                    break;
                case 29:
                    this.$ = {
                        type: 'SubExpression',
                        path: $$[$0 - 3],
                        params: $$[$0 - 2],
                        hash: $$[$0 - 1],
                        loc: yy.locInfo(this._$)
                    };

                    break;
                case 30:
                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 31:
                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 32:
                    this.$ = yy.id($$[$0 - 1]);
                    break;
                case 33:
                    this.$ = $$[$0];
                    break;
                case 34:
                    this.$ = $$[$0];
                    break;
                case 35:
                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                    break;
                case 36:
                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                    break;
                case 37:
                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
                    break;
                case 38:
                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
                    break;
                case 39:
                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
                    break;
                case 40:
                    this.$ = $$[$0];
                    break;
                case 41:
                    this.$ = $$[$0];
                    break;
                case 42:
                    this.$ = yy.preparePath(true, $$[$0], this._$);
                    break;
                case 43:
                    this.$ = yy.preparePath(false, $$[$0], this._$);
                    break;
                case 44:
                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                    break;
                case 45:
                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                    break;
                case 46:
                    this.$ = [];
                    break;
                case 47:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 48:
                    this.$ = [$$[$0]];
                    break;
                case 49:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 50:
                    this.$ = [];
                    break;
                case 51:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 58:
                    this.$ = [];
                    break;
                case 59:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 64:
                    this.$ = [];
                    break;
                case 65:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 70:
                    this.$ = [];
                    break;
                case 71:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 78:
                    this.$ = [];
                    break;
                case 79:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 82:
                    this.$ = [];
                    break;
                case 83:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 86:
                    this.$ = [];
                    break;
                case 87:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 90:
                    this.$ = [];
                    break;
                case 91:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 94:
                    this.$ = [];
                    break;
                case 95:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 98:
                    this.$ = [$$[$0]];
                    break;
                case 99:
                    $$[$0 - 1].push($$[$0]);
                    break;
                case 100:
                    this.$ = [$$[$0]];
                    break;
                case 101:
                    $$[$0 - 1].push($$[$0]);
                    break;
            }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = "",
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }
            function lex() {
                var token;
                token = self.lexer.lex() || 1;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    if (!recovering) {
                        expected = [];
                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                        if (this.lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                    }
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0) recovering--;
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };
    /* Jison generated lexer */
    var lexer = (function () {
        var lexer = { EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput: function setInput(input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                if (this.options.ranges) this.yylloc.range = [0, 0];
                this.offset = 0;
                return this;
            },
            input: function input() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) this.yylloc.range[1]++;

                this._input = this._input.slice(1);
                return ch;
            },
            unput: function unput(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) this.yylineno -= lines.length - 1;
                var r = this.yylloc.range;

                this.yylloc = { first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
            },
            more: function more() {
                this._more = true;
                return this;
            },
            less: function less(n) {
                this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) this.done = true;

                var token, match, tempMatch, index, col, lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = { first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) this.done = false;
                    if (token) return token;else return;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                }
            },
            lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState: function popState() {
                return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
                return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
                this.begin(condition);
            } };
        lexer.options = {};
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
        /**/) {

            function strip(start, end) {
                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
            }

            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
                case 0:
                    if (yy_.yytext.slice(-2) === "\\\\") {
                        strip(0, 1);
                        this.begin("mu");
                    } else if (yy_.yytext.slice(-1) === "\\") {
                        strip(0, 1);
                        this.begin("emu");
                    } else {
                        this.begin("mu");
                    }
                    if (yy_.yytext) return 15;

                    break;
                case 1:
                    return 15;
                    break;
                case 2:
                    this.popState();
                    return 15;

                    break;
                case 3:
                    this.begin('raw');return 15;
                    break;
                case 4:
                    this.popState();
                    // Should be using `this.topState()` below, but it currently
                    // returns the second top instead of the first top. Opened an
                    // issue about it at https://github.com/zaach/jison/issues/291
                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                        return 15;
                    } else {
                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                        return 'END_RAW_BLOCK';
                    }

                    break;
                case 5:
                    return 15;
                    break;
                case 6:
                    this.popState();
                    return 14;

                    break;
                case 7:
                    return 65;
                    break;
                case 8:
                    return 68;
                    break;
                case 9:
                    return 19;
                    break;
                case 10:
                    this.popState();
                    this.begin('raw');
                    return 23;

                    break;
                case 11:
                    return 55;
                    break;
                case 12:
                    return 60;
                    break;
                case 13:
                    return 29;
                    break;
                case 14:
                    return 47;
                    break;
                case 15:
                    this.popState();return 44;
                    break;
                case 16:
                    this.popState();return 44;
                    break;
                case 17:
                    return 34;
                    break;
                case 18:
                    return 39;
                    break;
                case 19:
                    return 51;
                    break;
                case 20:
                    return 48;
                    break;
                case 21:
                    this.unput(yy_.yytext);
                    this.popState();
                    this.begin('com');

                    break;
                case 22:
                    this.popState();
                    return 14;

                    break;
                case 23:
                    return 48;
                    break;
                case 24:
                    return 73;
                    break;
                case 25:
                    return 72;
                    break;
                case 26:
                    return 72;
                    break;
                case 27:
                    return 87;
                    break;
                case 28:
                    // ignore whitespace
                    break;
                case 29:
                    this.popState();return 54;
                    break;
                case 30:
                    this.popState();return 33;
                    break;
                case 31:
                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
                    break;
                case 32:
                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
                    break;
                case 33:
                    return 85;
                    break;
                case 34:
                    return 82;
                    break;
                case 35:
                    return 82;
                    break;
                case 36:
                    return 83;
                    break;
                case 37:
                    return 84;
                    break;
                case 38:
                    return 81;
                    break;
                case 39:
                    return 75;
                    break;
                case 40:
                    return 77;
                    break;
                case 41:
                    return 72;
                    break;
                case 42:
                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
                    break;
                case 43:
                    return 'INVALID';
                    break;
                case 44:
                    return 5;
                    break;
            }
        };
        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer;
    })();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }Parser.prototype = parser;parser.Parser = Parser;
    return new Parser();
})();exports["default"] = handlebars;
module.exports = exports["default"];


},{}],141:[function(require,module,exports){
/* eslint-disable new-cap */
'use strict';

exports.__esModule = true;
exports.print = print;
exports.PrintVisitor = PrintVisitor;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _visitor = require('./visitor');

var _visitor2 = _interopRequireDefault(_visitor);

function print(ast) {
  return new PrintVisitor().accept(ast);
}

function PrintVisitor() {
  this.padding = 0;
}

PrintVisitor.prototype = new _visitor2['default']();

PrintVisitor.prototype.pad = function (string) {
  var out = '';

  for (var i = 0, l = this.padding; i < l; i++) {
    out += '  ';
  }

  out += string + '\n';
  return out;
};

PrintVisitor.prototype.Program = function (program) {
  var out = '',
      body = program.body,
      i = undefined,
      l = undefined;

  if (program.blockParams) {
    var blockParams = 'BLOCK PARAMS: [';
    for (i = 0, l = program.blockParams.length; i < l; i++) {
      blockParams += ' ' + program.blockParams[i];
    }
    blockParams += ' ]';
    out += this.pad(blockParams);
  }

  for (i = 0, l = body.length; i < l; i++) {
    out += this.accept(body[i]);
  }

  this.padding--;

  return out;
};

PrintVisitor.prototype.MustacheStatement = function (mustache) {
  return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
};
PrintVisitor.prototype.Decorator = function (mustache) {
  return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
};

PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
  var out = '';

  out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
  this.padding++;
  out += this.pad(this.SubExpression(block));
  if (block.program) {
    out += this.pad('PROGRAM:');
    this.padding++;
    out += this.accept(block.program);
    this.padding--;
  }
  if (block.inverse) {
    if (block.program) {
      this.padding++;
    }
    out += this.pad('{{^}}');
    this.padding++;
    out += this.accept(block.inverse);
    this.padding--;
    if (block.program) {
      this.padding--;
    }
  }
  this.padding--;

  return out;
};

PrintVisitor.prototype.PartialStatement = function (partial) {
  var content = 'PARTIAL:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }
  return this.pad('{{> ' + content + ' }}');
};
PrintVisitor.prototype.PartialBlockStatement = function (partial) {
  var content = 'PARTIAL BLOCK:' + partial.name.original;
  if (partial.params[0]) {
    content += ' ' + this.accept(partial.params[0]);
  }
  if (partial.hash) {
    content += ' ' + this.accept(partial.hash);
  }

  content += ' ' + this.pad('PROGRAM:');
  this.padding++;
  content += this.accept(partial.program);
  this.padding--;

  return this.pad('{{> ' + content + ' }}');
};

PrintVisitor.prototype.ContentStatement = function (content) {
  return this.pad("CONTENT[ '" + content.value + "' ]");
};

PrintVisitor.prototype.CommentStatement = function (comment) {
  return this.pad("{{! '" + comment.value + "' }}");
};

PrintVisitor.prototype.SubExpression = function (sexpr) {
  var params = sexpr.params,
      paramStrings = [],
      hash = undefined;

  for (var i = 0, l = params.length; i < l; i++) {
    paramStrings.push(this.accept(params[i]));
  }

  params = '[' + paramStrings.join(', ') + ']';

  hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';

  return this.accept(sexpr.path) + ' ' + params + hash;
};

PrintVisitor.prototype.PathExpression = function (id) {
  var path = id.parts.join('/');
  return (id.data ? '@' : '') + 'PATH:' + path;
};

PrintVisitor.prototype.StringLiteral = function (string) {
  return '"' + string.value + '"';
};

PrintVisitor.prototype.NumberLiteral = function (number) {
  return 'NUMBER{' + number.value + '}';
};

PrintVisitor.prototype.BooleanLiteral = function (bool) {
  return 'BOOLEAN{' + bool.value + '}';
};

PrintVisitor.prototype.UndefinedLiteral = function () {
  return 'UNDEFINED';
};

PrintVisitor.prototype.NullLiteral = function () {
  return 'NULL';
};

PrintVisitor.prototype.Hash = function (hash) {
  var pairs = hash.pairs,
      joinedPairs = [];

  for (var i = 0, l = pairs.length; i < l; i++) {
    joinedPairs.push(this.accept(pairs[i]));
  }

  return 'HASH{' + joinedPairs.join(', ') + '}';
};
PrintVisitor.prototype.HashPair = function (pair) {
  return pair.key + '=' + this.accept(pair.value);
};
/* eslint-enable new-cap */


},{"./visitor":142}],142:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

function Visitor() {
  this.parents = [];
}

Visitor.prototype = {
  constructor: Visitor,
  mutating: false,

  // Visits a given value. If mutating, will replace the value if necessary.
  acceptKey: function acceptKey(node, name) {
    var value = this.accept(node[name]);
    if (this.mutating) {
      // Hacky sanity check: This may have a few false positives for type for the helper
      // methods but will generally do the right thing without a lot of overhead.
      if (value && !Visitor.prototype[value.type]) {
        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
      }
      node[name] = value;
    }
  },

  // Performs an accept operation with added sanity check to ensure
  // required keys are not removed.
  acceptRequired: function acceptRequired(node, name) {
    this.acceptKey(node, name);

    if (!node[name]) {
      throw new _exception2['default'](node.type + ' requires ' + name);
    }
  },

  // Traverses a given array. If mutating, empty respnses will be removed
  // for child elements.
  acceptArray: function acceptArray(array) {
    for (var i = 0, l = array.length; i < l; i++) {
      this.acceptKey(array, i);

      if (!array[i]) {
        array.splice(i, 1);
        i--;
        l--;
      }
    }
  },

  accept: function accept(object) {
    if (!object) {
      return;
    }

    /* istanbul ignore next: Sanity code */
    if (!this[object.type]) {
      throw new _exception2['default']('Unknown type: ' + object.type, object);
    }

    if (this.current) {
      this.parents.unshift(this.current);
    }
    this.current = object;

    var ret = this[object.type](object);

    this.current = this.parents.shift();

    if (!this.mutating || ret) {
      return ret;
    } else if (ret !== false) {
      return object;
    }
  },

  Program: function Program(program) {
    this.acceptArray(program.body);
  },

  MustacheStatement: visitSubExpression,
  Decorator: visitSubExpression,

  BlockStatement: visitBlock,
  DecoratorBlock: visitBlock,

  PartialStatement: visitPartial,
  PartialBlockStatement: function PartialBlockStatement(partial) {
    visitPartial.call(this, partial);

    this.acceptKey(partial, 'program');
  },

  ContentStatement: function ContentStatement() /* content */{},
  CommentStatement: function CommentStatement() /* comment */{},

  SubExpression: visitSubExpression,

  PathExpression: function PathExpression() /* path */{},

  StringLiteral: function StringLiteral() /* string */{},
  NumberLiteral: function NumberLiteral() /* number */{},
  BooleanLiteral: function BooleanLiteral() /* bool */{},
  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
  NullLiteral: function NullLiteral() /* literal */{},

  Hash: function Hash(hash) {
    this.acceptArray(hash.pairs);
  },
  HashPair: function HashPair(pair) {
    this.acceptRequired(pair, 'value');
  }
};

function visitSubExpression(mustache) {
  this.acceptRequired(mustache, 'path');
  this.acceptArray(mustache.params);
  this.acceptKey(mustache, 'hash');
}
function visitBlock(block) {
  visitSubExpression.call(this, block);

  this.acceptKey(block, 'program');
  this.acceptKey(block, 'inverse');
}
function visitPartial(partial) {
  this.acceptRequired(partial, 'name');
  this.acceptArray(partial.params);
  this.acceptKey(partial, 'hash');
}

exports['default'] = Visitor;
module.exports = exports['default'];


},{"../exception":146}],143:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _visitor = require('./visitor');

var _visitor2 = _interopRequireDefault(_visitor);

function WhitespaceControl() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  this.options = options;
}
WhitespaceControl.prototype = new _visitor2['default']();

WhitespaceControl.prototype.Program = function (program) {
  var doStandalone = !this.options.ignoreStandalone;

  var isRoot = !this.isRootSeen;
  this.isRootSeen = true;

  var body = program.body;
  for (var i = 0, l = body.length; i < l; i++) {
    var current = body[i],
        strip = this.accept(current);

    if (!strip) {
      continue;
    }

    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
        openStandalone = strip.openStandalone && _isPrevWhitespace,
        closeStandalone = strip.closeStandalone && _isNextWhitespace,
        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

    if (strip.close) {
      omitRight(body, i, true);
    }
    if (strip.open) {
      omitLeft(body, i, true);
    }

    if (doStandalone && inlineStandalone) {
      omitRight(body, i);

      if (omitLeft(body, i)) {
        // If we are on a standalone node, save the indent info for partials
        if (current.type === 'PartialStatement') {
          // Pull out the whitespace from the final line
          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
        }
      }
    }
    if (doStandalone && openStandalone) {
      omitRight((current.program || current.inverse).body);

      // Strip out the previous content node if it's whitespace only
      omitLeft(body, i);
    }
    if (doStandalone && closeStandalone) {
      // Always strip the next node
      omitRight(body, i);

      omitLeft((current.inverse || current.program).body);
    }
  }

  return program;
};

WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
  this.accept(block.program);
  this.accept(block.inverse);

  // Find the inverse program that is involed with whitespace stripping.
  var program = block.program || block.inverse,
      inverse = block.program && block.inverse,
      firstInverse = inverse,
      lastInverse = inverse;

  if (inverse && inverse.chained) {
    firstInverse = inverse.body[0].program;

    // Walk the inverse chain to find the last inverse that is actually in the chain.
    while (lastInverse.chained) {
      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
    }
  }

  var strip = {
    open: block.openStrip.open,
    close: block.closeStrip.close,

    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
    // so our parent can determine if we actually are standalone
    openStandalone: isNextWhitespace(program.body),
    closeStandalone: isPrevWhitespace((firstInverse || program).body)
  };

  if (block.openStrip.close) {
    omitRight(program.body, null, true);
  }

  if (inverse) {
    var inverseStrip = block.inverseStrip;

    if (inverseStrip.open) {
      omitLeft(program.body, null, true);
    }

    if (inverseStrip.close) {
      omitRight(firstInverse.body, null, true);
    }
    if (block.closeStrip.open) {
      omitLeft(lastInverse.body, null, true);
    }

    // Find standalone else statments
    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
      omitLeft(program.body);
      omitRight(firstInverse.body);
    }
  } else if (block.closeStrip.open) {
    omitLeft(program.body, null, true);
  }

  return strip;
};

WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
  return mustache.strip;
};

WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
  /* istanbul ignore next */
  var strip = node.strip || {};
  return {
    inlineStandalone: true,
    open: strip.open,
    close: strip.close
  };
};

function isPrevWhitespace(body, i, isRoot) {
  if (i === undefined) {
    i = body.length;
  }

  // Nodes that end with newlines are considered whitespace (but are special
  // cased for strip operations)
  var prev = body[i - 1],
      sibling = body[i - 2];
  if (!prev) {
    return isRoot;
  }

  if (prev.type === 'ContentStatement') {
    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
  }
}
function isNextWhitespace(body, i, isRoot) {
  if (i === undefined) {
    i = -1;
  }

  var next = body[i + 1],
      sibling = body[i + 2];
  if (!next) {
    return isRoot;
  }

  if (next.type === 'ContentStatement') {
    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
  }
}

// Marks the node to the right of the position as omitted.
// I.e. {{foo}}' ' will mark the ' ' node as omitted.
//
// If i is undefined, then the first child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitRight(body, i, multiple) {
  var current = body[i == null ? 0 : i + 1];
  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
    return;
  }

  var original = current.value;
  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
  current.rightStripped = current.value !== original;
}

// Marks the node to the left of the position as omitted.
// I.e. ' '{{foo}} will mark the ' ' node as omitted.
//
// If i is undefined then the last child will be marked as such.
//
// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
// content is met.
function omitLeft(body, i, multiple) {
  var current = body[i == null ? body.length - 1 : i - 1];
  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
    return;
  }

  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
  var original = current.value;
  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
  current.leftStripped = current.value !== original;
  return current.leftStripped;
}

exports['default'] = WhitespaceControl;
module.exports = exports['default'];


},{"./visitor":142}],144:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":145}],145:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":159}],146:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],147:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":148,"./helpers/each":149,"./helpers/helper-missing":150,"./helpers/if":151,"./helpers/log":152,"./helpers/lookup":153,"./helpers/with":154}],148:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":159}],149:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":146,"../utils":159}],150:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":146}],151:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":159}],152:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],153:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],154:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":159}],155:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":159}],156:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],157:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":133,"./exception":146,"./utils":159}],158:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],159:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],160:[function(require,module,exports){
// USAGE:
// var handlebars = require('handlebars');
/* eslint-disable no-var */

// var local = handlebars.create();

var handlebars = require('../dist/cjs/handlebars')['default'];

var printer = require('../dist/cjs/handlebars/compiler/printer');
handlebars.PrintVisitor = printer.PrintVisitor;
handlebars.print = printer.print;

module.exports = handlebars;

// Publish a Node.js require() handler for .handlebars and .hbs files
function extension(module, filename) {
  var fs = require('fs');
  var templateString = fs.readFileSync(filename, 'utf8');
  module.exports = handlebars.compile(templateString);
}
/* istanbul ignore else */
if (typeof require !== 'undefined' && require.extensions) {
  require.extensions['.handlebars'] = extension;
  require.extensions['.hbs'] = extension;
}

},{"../dist/cjs/handlebars":131,"../dist/cjs/handlebars/compiler/printer":141,"fs":122}],161:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":168,"./source-map/source-map-generator":169,"./source-map/source-node":170}],162:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet.prototype.size = function ArraySet_size() {
    return Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":171,"amdefine":121}],163:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

});

},{"./base64":164,"amdefine":121}],164:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  exports.decode = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

});

},{"amdefine":121}],165:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };

});

},{"amdefine":121}],166:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":171,"amdefine":121}],167:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  exports.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

});

},{"amdefine":121}],168:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');
  var quickSort = require('./quick-sort').quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  exports.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util.join(this.sourceRoot, source);
            }
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      if (this.sourceRoot != null) {
        source = util.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      };
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[i];

          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.column +
              (section.generatedOffset.generatedLine === mapping.generatedLine)
              ? section.generatedOffset.generatedColumn - 1
              : 0,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        };
      };

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

});

},{"./array-set":162,"./base64-vlq":163,"./binary-search":165,"./quick-sort":167,"./util":171,"amdefine":121}],169:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":162,"./base64-vlq":163,"./mapping-list":166,"./util":171,"amdefine":121}],170:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":169,"./util":171,"amdefine":121}],171:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  };
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

});

},{"amdefine":121}],172:[function(require,module,exports){
/*!!
 * Hasher <http://github.com/millermedeiros/hasher>
 * @author Miller Medeiros
 * @version 1.2.0 (2013/11/11 03:18 PM)
 * Released under the MIT License
 */

;(function () {
var factory = function(signals){

/*jshint white:false*/
/*global signals:false, window:false*/

/**
 * Hasher
 * @namespace History Manager for rich-media applications.
 * @name hasher
 */
var hasher = (function(window){

    //--------------------------------------------------------------------------------------
    // Private Vars
    //--------------------------------------------------------------------------------------

    var

        // frequency that it will check hash value on IE 6-7 since it doesn't
        // support the hashchange event
        POOL_INTERVAL = 25,

        // local storage for brevity and better compression --------------------------------

        document = window.document,
        history = window.history,
        Signal = signals.Signal,

        // local vars ----------------------------------------------------------------------

        hasher,
        _hash,
        _checkInterval,
        _isActive,
        _frame, //iframe used for legacy IE (6-7)
        _checkHistory,
        _hashValRegexp = /#(.*)$/,
        _baseUrlRegexp = /(\?.*)|(\#.*)/,
        _hashRegexp = /^\#/,

        // sniffing/feature detection -------------------------------------------------------

        //hack based on this: http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
        _isIE = (!+"\v1"),
        // hashchange is supported by FF3.6+, IE8+, Chrome 5+, Safari 5+ but
        // feature detection fails on IE compatibility mode, so we need to
        // check documentMode
        _isHashChangeSupported = ('onhashchange' in window) && document.documentMode !== 7,
        //check if is IE6-7 since hash change is only supported on IE8+ and
        //changing hash value on IE6-7 doesn't generate history record.
        _isLegacyIE = _isIE && !_isHashChangeSupported,
        _isLocal = (location.protocol === 'file:');


    //--------------------------------------------------------------------------------------
    // Private Methods
    //--------------------------------------------------------------------------------------

    function _escapeRegExp(str){
        return String(str || '').replace(/\W/g, "\\$&");
    }

    function _trimHash(hash){
        if (!hash) return '';
        var regexp = new RegExp('^' + _escapeRegExp(hasher.prependHash) + '|' + _escapeRegExp(hasher.appendHash) + '$', 'g');
        return hash.replace(regexp, '');
    }

    function _getWindowHash(){
        //parsed full URL instead of getting window.location.hash because Firefox decode hash value (and all the other browsers don't)
        //also because of IE8 bug with hash query in local file [issue #6]
        var result = _hashValRegexp.exec( hasher.getURL() );
        var path = (result && result[1]) || '';
        try {
          return hasher.raw? path : decodeURIComponent(path);
        } catch (e) {
          // in case user did not set `hasher.raw` and decodeURIComponent
          // throws an error (see #57)
          return path;
        }
    }

    function _getFrameHash(){
        return (_frame)? _frame.contentWindow.frameHash : null;
    }

    function _createFrame(){
        _frame = document.createElement('iframe');
        _frame.src = 'about:blank';
        _frame.style.display = 'none';
        document.body.appendChild(_frame);
    }

    function _updateFrame(){
        if(_frame && _hash !== _getFrameHash()){
            var frameDoc = _frame.contentWindow.document;
            frameDoc.open();
            //update iframe content to force new history record.
            //based on Really Simple History, SWFAddress and YUI.history.
            frameDoc.write('<html><head><title>' + document.title + '</title><script type="text/javascript">var frameHash="' + _hash + '";</script></head><body>&nbsp;</body></html>');
            frameDoc.close();
        }
    }

    function _registerChange(newHash, isReplace){
        if(_hash !== newHash){
            var oldHash = _hash;
            _hash = newHash; //should come before event dispatch to make sure user can get proper value inside event handler
            if(_isLegacyIE){
                if(!isReplace){
                    _updateFrame();
                } else {
                    _frame.contentWindow.frameHash = newHash;
                }
            }
            hasher.changed.dispatch(_trimHash(newHash), _trimHash(oldHash));
        }
    }

    if (_isLegacyIE) {
        /**
         * @private
         */
        _checkHistory = function(){
            var windowHash = _getWindowHash(),
                frameHash = _getFrameHash();
            if(frameHash !== _hash && frameHash !== windowHash){
                //detect changes made pressing browser history buttons.
                //Workaround since history.back() and history.forward() doesn't
                //update hash value on IE6/7 but updates content of the iframe.
                //needs to trim hash since value stored already have
                //prependHash + appendHash for fast check.
                hasher.setHash(_trimHash(frameHash));
            } else if (windowHash !== _hash){
                //detect if hash changed (manually or using setHash)
                _registerChange(windowHash);
            }
        };
    } else {
        /**
         * @private
         */
        _checkHistory = function(){
            var windowHash = _getWindowHash();
            if(windowHash !== _hash){
                _registerChange(windowHash);
            }
        };
    }

    function _addListener(elm, eType, fn){
        if(elm.addEventListener){
            elm.addEventListener(eType, fn, false);
        } else if (elm.attachEvent){
            elm.attachEvent('on' + eType, fn);
        }
    }

    function _removeListener(elm, eType, fn){
        if(elm.removeEventListener){
            elm.removeEventListener(eType, fn, false);
        } else if (elm.detachEvent){
            elm.detachEvent('on' + eType, fn);
        }
    }

    function _makePath(paths){
        paths = Array.prototype.slice.call(arguments);

        var path = paths.join(hasher.separator);
        path = path? hasher.prependHash + path.replace(_hashRegexp, '') + hasher.appendHash : path;
        return path;
    }

    function _encodePath(path){
        //used encodeURI instead of encodeURIComponent to preserve '?', '/',
        //'#'. Fixes Safari bug [issue #8]
        path = encodeURI(path);
        if(_isIE && _isLocal){
            //fix IE8 local file bug [issue #6]
            path = path.replace(/\?/, '%3F');
        }
        return path;
    }

    //--------------------------------------------------------------------------------------
    // Public (API)
    //--------------------------------------------------------------------------------------

    hasher = /** @lends hasher */ {

        /**
         * hasher Version Number
         * @type string
         * @constant
         */
        VERSION : '1.2.0',

        /**
         * Boolean deciding if hasher encodes/decodes the hash or not.
         * <ul>
         * <li>default value: false;</li>
         * </ul>
         * @type boolean
         */
        raw : false,

        /**
         * String that should always be added to the end of Hash value.
         * <ul>
         * <li>default value: '';</li>
         * <li>will be automatically removed from `hasher.getHash()`</li>
         * <li>avoid conflicts with elements that contain ID equal to hash value;</li>
         * </ul>
         * @type string
         */
        appendHash : '',

        /**
         * String that should always be added to the beginning of Hash value.
         * <ul>
         * <li>default value: '/';</li>
         * <li>will be automatically removed from `hasher.getHash()`</li>
         * <li>avoid conflicts with elements that contain ID equal to hash value;</li>
         * </ul>
         * @type string
         */
        prependHash : '/',

        /**
         * String used to split hash paths; used by `hasher.getHashAsArray()` to split paths.
         * <ul>
         * <li>default value: '/';</li>
         * </ul>
         * @type string
         */
        separator : '/',

        /**
         * Signal dispatched when hash value changes.
         * - pass current hash as 1st parameter to listeners and previous hash value as 2nd parameter.
         * @type signals.Signal
         */
        changed : new Signal(),

        /**
         * Signal dispatched when hasher is stopped.
         * -  pass current hash as first parameter to listeners
         * @type signals.Signal
         */
        stopped : new Signal(),

        /**
         * Signal dispatched when hasher is initialized.
         * - pass current hash as first parameter to listeners.
         * @type signals.Signal
         */
        initialized : new Signal(),

        /**
         * Start listening/dispatching changes in the hash/history.
         * <ul>
         *   <li>hasher won't dispatch CHANGE events by manually typing a new value or pressing the back/forward buttons before calling this method.</li>
         * </ul>
         */
        init : function(){
            if(_isActive) return;

            _hash = _getWindowHash();

            //thought about branching/overloading hasher.init() to avoid checking multiple times but
            //don't think worth doing it since it probably won't be called multiple times.
            if(_isHashChangeSupported){
                _addListener(window, 'hashchange', _checkHistory);
            }else {
                if(_isLegacyIE){
                    if(! _frame){
                        _createFrame();
                    }
                    _updateFrame();
                }
                _checkInterval = setInterval(_checkHistory, POOL_INTERVAL);
            }

            _isActive = true;
            hasher.initialized.dispatch(_trimHash(_hash));
        },

        /**
         * Stop listening/dispatching changes in the hash/history.
         * <ul>
         *   <li>hasher won't dispatch CHANGE events by manually typing a new value or pressing the back/forward buttons after calling this method, unless you call hasher.init() again.</li>
         *   <li>hasher will still dispatch changes made programatically by calling hasher.setHash();</li>
         * </ul>
         */
        stop : function(){
            if(! _isActive) return;

            if(_isHashChangeSupported){
                _removeListener(window, 'hashchange', _checkHistory);
            }else{
                clearInterval(_checkInterval);
                _checkInterval = null;
            }

            _isActive = false;
            hasher.stopped.dispatch(_trimHash(_hash));
        },

        /**
         * @return {boolean}    If hasher is listening to changes on the browser history and/or hash value.
         */
        isActive : function(){
            return _isActive;
        },

        /**
         * @return {string} Full URL.
         */
        getURL : function(){
            return window.location.href;
        },

        /**
         * @return {string} Retrieve URL without query string and hash.
         */
        getBaseURL : function(){
            return hasher.getURL().replace(_baseUrlRegexp, ''); //removes everything after '?' and/or '#'
        },

        /**
         * Set Hash value, generating a new history record.
         * @param {...string} path    Hash value without '#'. Hasher will join
         * path segments using `hasher.separator` and prepend/append hash value
         * with `hasher.appendHash` and `hasher.prependHash`
         * @example hasher.setHash('lorem', 'ipsum', 'dolor') -> '#/lorem/ipsum/dolor'
         */
        setHash : function(path){
            path = _makePath.apply(null, arguments);
            if(path !== _hash){
                // we should store raw value
                _registerChange(path);
                if (path === _hash) {
                    // we check if path is still === _hash to avoid error in
                    // case of multiple consecutive redirects [issue #39]
                    if (! hasher.raw) {
                        path = _encodePath(path);
                    }
                    window.location.hash = '#' + path;
                }
            }
        },

        /**
         * Set Hash value without keeping previous hash on the history record.
         * Similar to calling `window.location.replace("#/hash")` but will also work on IE6-7.
         * @param {...string} path    Hash value without '#'. Hasher will join
         * path segments using `hasher.separator` and prepend/append hash value
         * with `hasher.appendHash` and `hasher.prependHash`
         * @example hasher.replaceHash('lorem', 'ipsum', 'dolor') -> '#/lorem/ipsum/dolor'
         */
        replaceHash : function(path){
            path = _makePath.apply(null, arguments);
            if(path !== _hash){
                // we should store raw value
                _registerChange(path, true);
                if (path === _hash) {
                    // we check if path is still === _hash to avoid error in
                    // case of multiple consecutive redirects [issue #39]
                    if (! hasher.raw) {
                        path = _encodePath(path);
                    }
                    window.location.replace('#' + path);
                }
            }
        },

        /**
         * @return {string} Hash value without '#', `hasher.appendHash` and `hasher.prependHash`.
         */
        getHash : function(){
            //didn't used actual value of the `window.location.hash` to avoid breaking the application in case `window.location.hash` isn't available and also because value should always be synched.
            return _trimHash(_hash);
        },

        /**
         * @return {Array.<string>} Hash value split into an Array.
         */
        getHashAsArray : function(){
            return hasher.getHash().split(hasher.separator);
        },

        /**
         * Removes all event listeners, stops hasher and destroy hasher object.
         * - IMPORTANT: hasher won't work after calling this method, hasher Object will be deleted.
         */
        dispose : function(){
            hasher.stop();
            hasher.initialized.dispose();
            hasher.stopped.dispose();
            hasher.changed.dispose();
            _frame = hasher = window.hasher = null;
        },

        /**
         * @return {string} A string representation of the object.
         */
        toString : function(){
            return '[hasher version="'+ hasher.VERSION +'" hash="'+ hasher.getHash() +'"]';
        }

    };

    hasher.initialized.memorize = true; //see #33

    return hasher;

}(window));


    return hasher;
};

if (typeof define === 'function' && define.amd) {
    define(['signals'], factory);
} else if (typeof exports === 'object') {
    module.exports = factory(require('signals'));
} else {
    /*jshint sub:true */
    window['hasher'] = factory(window['signals']);
}

}());

},{"signals":218}],173:[function(require,module,exports){
'use strict';

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

},{}],174:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

},{}],175:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":182}],176:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":175,"./_getRawTag":179,"./_objectToString":180}],177:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],178:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":181}],179:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":175}],180:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],181:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],182:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":177}],183:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],184:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":176,"./_getPrototype":178,"./isObjectLike":183}],185:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],186:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],187:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var printWarning = function() {};

if ("production" !== 'production') {
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if ("production" !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          )

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

module.exports = checkPropTypes;

},{"./lib/ReactPropTypesSecret":191}],188:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./lib/ReactPropTypesSecret":191}],189:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var checkPropTypes = require('./checkPropTypes');

var printWarning = function() {};

if ("production" !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("production" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("production" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      "production" !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "production" !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./checkPropTypes":187,"./lib/ReactPropTypesSecret":191,"object-assign":185}],190:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("production" !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

},{"./factoryWithThrowingShims":188,"./factoryWithTypeCheckers":189}],191:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

},{}],192:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.createProvider = createProvider;

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PropTypes = require('../utils/PropTypes');

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2.default)('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

function createProvider() {
  var _Provider$childContex;

  var storeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'store';
  var subKey = arguments[1];

  var subscriptionKey = subKey || storeKey + 'Subscription';

  var Provider = function (_Component) {
    _inherits(Provider, _Component);

    Provider.prototype.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
    };

    function Provider(props, context) {
      _classCallCheck(this, Provider);

      var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

      _this[storeKey] = props.store;
      return _this;
    }

    Provider.prototype.render = function render() {
      return _react.Children.only(this.props.children);
    };

    return Provider;
  }(_react.Component);

  if ("production" !== 'production') {
    Provider.prototype.componentWillReceiveProps = function (nextProps) {
      if (this[storeKey] !== nextProps.store) {
        warnAboutReceivingStore();
      }
    };
  }

  Provider.propTypes = {
    store: _PropTypes.storeShape.isRequired,
    children: _propTypes2.default.element.isRequired
  };
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = _PropTypes.storeShape.isRequired, _Provider$childContex[subscriptionKey] = _PropTypes.subscriptionShape, _Provider$childContex);

  return Provider;
}

exports.default = createProvider();
},{"../utils/PropTypes":202,"../utils/warning":206,"prop-types":190,"react":209}],193:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = connectAdvanced;

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _Subscription = require('../utils/Subscription');

var _Subscription2 = _interopRequireDefault(_Subscription);

var _PropTypes = require('../utils/PropTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var hotReloadingVersion = 0;
var dummyState = {};
function noop() {}
function makeSelectorStateful(sourceSelector, store) {
  // wrap the selector in an object that tracks its results between runs.
  var selector = {
    run: function runComponentSelector(props) {
      try {
        var nextProps = sourceSelector(store.getState(), props);
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true;
          selector.props = nextProps;
          selector.error = null;
        }
      } catch (error) {
        selector.shouldComponentUpdate = true;
        selector.error = error;
      }
    }
  };

  return selector;
}

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory) {
  var _contextTypes, _childContextTypes;

  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$getDisplayName = _ref.getDisplayName,
      getDisplayName = _ref$getDisplayName === undefined ? function (name) {
    return 'ConnectAdvanced(' + name + ')';
  } : _ref$getDisplayName,
      _ref$methodName = _ref.methodName,
      methodName = _ref$methodName === undefined ? 'connectAdvanced' : _ref$methodName,
      _ref$renderCountProp = _ref.renderCountProp,
      renderCountProp = _ref$renderCountProp === undefined ? undefined : _ref$renderCountProp,
      _ref$shouldHandleStat = _ref.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref$shouldHandleStat === undefined ? true : _ref$shouldHandleStat,
      _ref$storeKey = _ref.storeKey,
      storeKey = _ref$storeKey === undefined ? 'store' : _ref$storeKey,
      _ref$withRef = _ref.withRef,
      withRef = _ref$withRef === undefined ? false : _ref$withRef,
      connectOptions = _objectWithoutProperties(_ref, ['getDisplayName', 'methodName', 'renderCountProp', 'shouldHandleStateChanges', 'storeKey', 'withRef']);

  var subscriptionKey = storeKey + 'Subscription';
  var version = hotReloadingVersion++;

  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = _PropTypes.storeShape, _contextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _contextTypes);
  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = _PropTypes.subscriptionShape, _childContextTypes);

  return function wrapWithConnect(WrappedComponent) {
    (0, _invariant2.default)(typeof WrappedComponent == 'function', 'You must pass a component to the function returned by ' + (methodName + '. Instead received ' + JSON.stringify(WrappedComponent)));

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';

    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      withRef: withRef,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.state = {};
        _this.renderCount = 0;
        _this.store = props[storeKey] || context[storeKey];
        _this.propsMode = Boolean(props[storeKey]);
        _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);

        (0, _invariant2.default)(_this.store, 'Could not find "' + storeKey + '" in either the context or props of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + ('or explicitly pass "' + storeKey + '" as a prop to "' + displayName + '".'));

        _this.initSelector();
        _this.initSubscription();
        return _this;
      }

      Connect.prototype.getChildContext = function getChildContext() {
        var _ref2;

        // If this component received store from props, its subscription should be transparent
        // to any descendants receiving store+subscription from context; it passes along
        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
        // Connect to control ordering of notifications to flow top-down.
        var subscription = this.propsMode ? null : this.subscription;
        return _ref2 = {}, _ref2[subscriptionKey] = subscription || this.context[subscriptionKey], _ref2;
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        if (!shouldHandleStateChanges) return;

        // componentWillMount fires during server side rendering, but componentDidMount and
        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
        // To handle the case where a child component may have triggered a state change by
        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
        // re-render.
        this.subscription.trySubscribe();
        this.selector.run(this.props);
        if (this.selector.shouldComponentUpdate) this.forceUpdate();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps);
      };

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate;
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe();
        this.subscription = null;
        this.notifyNestedSubs = noop;
        this.store = null;
        this.selector.run = noop;
        this.selector.shouldComponentUpdate = false;
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2.default)(withRef, 'To access the wrapped instance, you need to specify ' + ('{ withRef: true } in the options argument of the ' + methodName + '() call.'));
        return this.wrappedInstance;
      };

      Connect.prototype.setWrappedInstance = function setWrappedInstance(ref) {
        this.wrappedInstance = ref;
      };

      Connect.prototype.initSelector = function initSelector() {
        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
        this.selector = makeSelectorStateful(sourceSelector, this.store);
        this.selector.run(this.props);
      };

      Connect.prototype.initSubscription = function initSubscription() {
        if (!shouldHandleStateChanges) return;

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
        this.subscription = new _Subscription2.default(this.store, parentSub, this.onStateChange.bind(this));

        // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
        // the middle of the notification loop, where `this.subscription` will then be null. An
        // extra null check every change can be avoided by copying the method onto `this` and then
        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
        // listeners logic is changed to not call listeners that have been unsubscribed in the
        // middle of the notification loop.
        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
      };

      Connect.prototype.onStateChange = function onStateChange() {
        this.selector.run(this.props);

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs();
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
          this.setState(dummyState);
        }
      };

      Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
        // needs to notify nested subs. Once called, it unimplements itself until further state
        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
        // a boolean check every time avoids an extra method call most of the time, resulting
        // in some perf boost.
        this.componentDidUpdate = undefined;
        this.notifyNestedSubs();
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed();
      };

      Connect.prototype.addExtraProps = function addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props;
        // make a shallow copy so that fields added don't leak to the original selector.
        // this is especially important for 'ref' since that's a reference back to the component
        // instance. a singleton memoized selector would then be holding a reference to the
        // instance, preventing the instance from being garbage collected, and that would be bad
        var withExtras = _extends({}, props);
        if (withRef) withExtras.ref = this.setWrappedInstance;
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
        return withExtras;
      };

      Connect.prototype.render = function render() {
        var selector = this.selector;
        selector.shouldComponentUpdate = false;

        if (selector.error) {
          throw selector.error;
        } else {
          return (0, _react.createElement)(WrappedComponent, this.addExtraProps(selector.props));
        }
      };

      return Connect;
    }(_react.Component);

    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;
    Connect.childContextTypes = childContextTypes;
    Connect.contextTypes = contextTypes;
    Connect.propTypes = contextTypes;

    if ("production" !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        var _this2 = this;

        // We are hot reloading!
        if (this.version !== version) {
          this.version = version;
          this.initSelector();

          // If any connected descendants don't hot reload (and resubscribe in the process), their
          // listeners will be lost when we unsubscribe. Unfortunately, by copying over all
          // listeners, this does mean that the old versions of connected descendants will still be
          // notified of state changes; however, their onStateChange function is a no-op so this
          // isn't a huge deal.
          var oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get();
            this.subscription.tryUnsubscribe();
          }
          this.initSubscription();
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe();
            oldListeners.forEach(function (listener) {
              return _this2.subscription.listeners.subscribe(listener);
            });
          }
        }
      };
    }

    return (0, _hoistNonReactStatics2.default)(Connect, WrappedComponent);
  };
}
},{"../utils/PropTypes":202,"../utils/Subscription":203,"hoist-non-react-statics":173,"invariant":174,"react":209}],194:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createConnect = createConnect;

var _connectAdvanced = require('../components/connectAdvanced');

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _shallowEqual = require('../utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _mapDispatchToProps = require('./mapDispatchToProps');

var _mapDispatchToProps2 = _interopRequireDefault(_mapDispatchToProps);

var _mapStateToProps = require('./mapStateToProps');

var _mapStateToProps2 = _interopRequireDefault(_mapStateToProps);

var _mergeProps = require('./mergeProps');

var _mergeProps2 = _interopRequireDefault(_mergeProps);

var _selectorFactory = require('./selectorFactory');

var _selectorFactory2 = _interopRequireDefault(_selectorFactory);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error('Invalid value of type ' + typeof arg + ' for ' + name + ' argument when connecting component ' + options.wrappedComponentName + '.');
  };
}

function strictEqual(a, b) {
  return a === b;
}

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
function createConnect() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === undefined ? _connectAdvanced2.default : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === undefined ? _mapStateToProps2.default : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === undefined ? _mapDispatchToProps2.default : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === undefined ? _mergeProps2.default : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === undefined ? _selectorFactory2.default : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref2$pure = _ref2.pure,
        pure = _ref2$pure === undefined ? true : _ref2$pure,
        _ref2$areStatesEqual = _ref2.areStatesEqual,
        areStatesEqual = _ref2$areStatesEqual === undefined ? strictEqual : _ref2$areStatesEqual,
        _ref2$areOwnPropsEqua = _ref2.areOwnPropsEqual,
        areOwnPropsEqual = _ref2$areOwnPropsEqua === undefined ? _shallowEqual2.default : _ref2$areOwnPropsEqua,
        _ref2$areStatePropsEq = _ref2.areStatePropsEqual,
        areStatePropsEqual = _ref2$areStatePropsEq === undefined ? _shallowEqual2.default : _ref2$areStatePropsEq,
        _ref2$areMergedPropsE = _ref2.areMergedPropsEqual,
        areMergedPropsEqual = _ref2$areMergedPropsE === undefined ? _shallowEqual2.default : _ref2$areMergedPropsE,
        extraOptions = _objectWithoutProperties(_ref2, ['pure', 'areStatesEqual', 'areOwnPropsEqual', 'areStatePropsEqual', 'areMergedPropsEqual']);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');

    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: 'connect',

      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return 'Connect(' + name + ')';
      },

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual

    }, extraOptions));
  };
}

exports.default = createConnect();
},{"../components/connectAdvanced":193,"../utils/shallowEqual":204,"./mapDispatchToProps":195,"./mapStateToProps":196,"./mergeProps":197,"./selectorFactory":198}],195:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.whenMapDispatchToPropsIsFunction = whenMapDispatchToPropsIsFunction;
exports.whenMapDispatchToPropsIsMissing = whenMapDispatchToPropsIsMissing;
exports.whenMapDispatchToPropsIsObject = whenMapDispatchToPropsIsObject;

var _redux = require('redux');

var _wrapMapToProps = require('./wrapMapToProps');

function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}

function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return { dispatch: dispatch };
  }) : undefined;
}

function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function (dispatch) {
    return (0, _redux.bindActionCreators)(mapDispatchToProps, dispatch);
  }) : undefined;
}

exports.default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
},{"./wrapMapToProps":200,"redux":216}],196:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.whenMapStateToPropsIsFunction = whenMapStateToPropsIsFunction;
exports.whenMapStateToPropsIsMissing = whenMapStateToPropsIsMissing;

var _wrapMapToProps = require('./wrapMapToProps');

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? (0, _wrapMapToProps.wrapMapToPropsFunc)(mapStateToProps, 'mapStateToProps') : undefined;
}

function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? (0, _wrapMapToProps.wrapMapToPropsConstant)(function () {
    return {};
  }) : undefined;
}

exports.default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
},{"./wrapMapToProps":200}],197:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.defaultMergeProps = defaultMergeProps;
exports.wrapMergePropsFunc = wrapMergePropsFunc;
exports.whenMergePropsIsFunction = whenMergePropsIsFunction;
exports.whenMergePropsIsOmitted = whenMergePropsIsOmitted;

var _verifyPlainObject = require('../utils/verifyPlainObject');

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}

function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;

    var hasRunOnce = false;
    var mergedProps = void 0;

    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;

        if ("production" !== 'production') (0, _verifyPlainObject2.default)(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}

function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}

function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}

exports.default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
},{"../utils/verifyPlainObject":205}],198:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.impureFinalPropsSelectorFactory = impureFinalPropsSelectorFactory;
exports.pureFinalPropsSelectorFactory = pureFinalPropsSelectorFactory;
exports.default = finalPropsSelectorFactory;

var _verifySubselectors = require('./verifySubselectors');

var _verifySubselectors2 = _interopRequireDefault(_verifySubselectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}

function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;

  var hasRunAtLeastOnce = false;
  var state = void 0;
  var ownProps = void 0;
  var stateProps = void 0;
  var dispatchProps = void 0;
  var mergedProps = void 0;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);

    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;

    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);

    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;

    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}

// TODO: Add more comments

// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = _objectWithoutProperties(_ref2, ['initMapStateToProps', 'initMapDispatchToProps', 'initMergeProps']);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if ("production" !== 'production') {
    (0, _verifySubselectors2.default)(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;

  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}
},{"./verifySubselectors":199}],199:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = verifySubselectors;

var _warning = require('../utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error('Unexpected value for ' + methodName + ' in ' + displayName + '.');
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!selector.hasOwnProperty('dependsOnOwnProps')) {
      (0, _warning2.default)('The selector for ' + methodName + ' of ' + displayName + ' did not specify a value for dependsOnOwnProps.');
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}
},{"../utils/warning":206}],200:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.wrapMapToPropsConstant = wrapMapToPropsConstant;
exports.getDependsOnOwnProps = getDependsOnOwnProps;
exports.wrapMapToPropsFunc = wrapMapToPropsFunc;

var _verifyPlainObject = require('../utils/verifyPlainObject');

var _verifyPlainObject2 = _interopRequireDefault(_verifyPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}

// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
// 
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}

// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
// 
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//    
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//    
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//    
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };

    // allow detectFactoryAndVerify to get ownProps
    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if ("production" !== 'production') (0, _verifyPlainObject2.default)(props, displayName, methodName);

      return props;
    };

    return proxy;
  };
}
},{"../utils/verifyPlainObject":205}],201:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.connect = exports.connectAdvanced = exports.createProvider = exports.Provider = undefined;

var _Provider = require('./components/Provider');

var _Provider2 = _interopRequireDefault(_Provider);

var _connectAdvanced = require('./components/connectAdvanced');

var _connectAdvanced2 = _interopRequireDefault(_connectAdvanced);

var _connect = require('./connect/connect');

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Provider = _Provider2.default;
exports.createProvider = _Provider.createProvider;
exports.connectAdvanced = _connectAdvanced2.default;
exports.connect = _connect2.default;
},{"./components/Provider":192,"./components/connectAdvanced":193,"./connect/connect":194}],202:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.storeShape = exports.subscriptionShape = undefined;

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var subscriptionShape = exports.subscriptionShape = _propTypes2.default.shape({
  trySubscribe: _propTypes2.default.func.isRequired,
  tryUnsubscribe: _propTypes2.default.func.isRequired,
  notifyNestedSubs: _propTypes2.default.func.isRequired,
  isSubscribed: _propTypes2.default.func.isRequired
});

var storeShape = exports.storeShape = _propTypes2.default.shape({
  subscribe: _propTypes2.default.func.isRequired,
  dispatch: _propTypes2.default.func.isRequired,
  getState: _propTypes2.default.func.isRequired
});
},{"prop-types":190}],203:[function(require,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var CLEARED = null;
var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  // the current/next pattern is copied from redux's createStore code.
  // TODO: refactor+expose that code to be reusable here?
  var current = [];
  var next = [];

  return {
    clear: function clear() {
      next = CLEARED;
      current = CLEARED;
    },
    notify: function notify() {
      var listeners = current = next;
      for (var i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
    },
    get: function get() {
      return next;
    },
    subscribe: function subscribe(listener) {
      var isSubscribed = true;
      if (next === current) next = current.slice();
      next.push(listener);

      return function unsubscribe() {
        if (!isSubscribed || current === CLEARED) return;
        isSubscribed = false;

        if (next === current) next = current.slice();
        next.splice(next.indexOf(listener), 1);
      };
    }
  };
}

var Subscription = function () {
  function Subscription(store, parentSub, onStateChange) {
    _classCallCheck(this, Subscription);

    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListeners;
  }

  Subscription.prototype.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  Subscription.prototype.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  Subscription.prototype.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  Subscription.prototype.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);

      this.listeners = createListenerCollection();
    }
  };

  Subscription.prototype.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();

exports.default = Subscription;
},{}],204:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = shallowEqual;
var hasOwn = Object.prototype.hasOwnProperty;

function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}
},{}],205:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = verifyPlainObject;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verifyPlainObject(value, displayName, methodName) {
  if (!(0, _isPlainObject2.default)(value)) {
    (0, _warning2.default)(methodName + '() in ' + displayName + ' must return a plain object. Instead received ' + value + '.');
  }
}
},{"./warning":206,"lodash/isPlainObject":184}],206:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],207:[function(require,module,exports){
/** @license React v16.4.2
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';



if ("production" !== "production") {
  (function() {
'use strict';

var _assign = require('object-assign');
var invariant = require('fbjs/lib/invariant');
var emptyObject = require('fbjs/lib/emptyObject');
var warning = require('fbjs/lib/warning');
var emptyFunction = require('fbjs/lib/emptyFunction');
var checkPropTypes = require('prop-types/checkPropTypes');

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.4.2';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

// Relying on the `invariant()` implementation lets us
// have preserve the format and params in the www builds.

// Exports ReactDOM.createRoot


// Experimental error-boundary API that can recover from errors within a single
// render phase

// Suspense
var enableSuspense = false;
// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:


// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.


// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


// Warn about legacy context API


// Gather advanced timing metrics for Profiler subtrees.


// Only used in www builds.

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;

/**
 * Convenience component with default shallow equality check for sCU.
 */
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };
  {
    Object.seal(refObject);
  }
  return refObject;
}

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown = void 0;
var specialPropRefWarningShown = void 0;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName = void 0;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;

  var propName = void 0;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps = void 0;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child = void 0;
  var nextName = void 0;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step = void 0;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    _defaultValue: defaultValue,
    _currentValue: defaultValue,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue2: defaultValue,
    _changedBits: 0,
    _changedBits2: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };

  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  context.Consumer = context;

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function forwardRef(render) {
  {
    !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;

    if (render != null) {
      !(render.defaultProps == null && render.propTypes == null) ? warning(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_TIMEOUT_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  if (typeof type === 'string') {
    return type;
  }
  switch (type) {
    case REACT_ASYNC_MODE_TYPE:
      return 'AsyncMode';
    case REACT_CONTEXT_TYPE:
      return 'Context.Consumer';
    case REACT_FRAGMENT_TYPE:
      return 'ReactFragment';
    case REACT_PORTAL_TYPE:
      return 'ReactPortal';
    case REACT_PROFILER_TYPE:
      return 'Profiler(' + fiber.pendingProps.id + ')';
    case REACT_PROVIDER_TYPE:
      return 'Context.Provider';
    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';
    case REACT_TIMEOUT_TYPE:
      return 'Timeout';
  }
  if (typeof type === 'object' && type !== null) {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        var functionName = type.render.displayName || type.render.name || '';
        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    }
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

var currentlyValidatingElement = void 0;
var propTypesMisspellWarningShown = void 0;

var getDisplayName = function () {};
var getStackAddendum = function () {};

{
  currentlyValidatingElement = null;

  propTypesMisspellWarningShown = false;

  getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    }

    var type = element.type;
    if (type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
      var functionName = type.render.displayName || type.render.name || '';
      return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    } else {
      return type.displayName || type.name || 'Unknown';
    }
  };

  getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step = void 0;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var type = element.type;
  var name = void 0,
      propTypes = void 0;
  if (typeof type === 'function') {
    // Class or functional component
    name = type.displayName || type.name;
    propTypes = type.propTypes;
  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
    // ForwardRef
    var functionName = type.render.displayName || type.render.name || '';
    name = functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    propTypes = type.propTypes;
  } else {
    return;
  }
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof type.getDefaultProps === 'function') {
    !type.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var keys = Object.keys(fragment.props);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== 'children' && key !== 'key') {
      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
      break;
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type);

  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    var typeString = void 0;
    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else {
      typeString = typeof type;
    }

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;
  // Legacy hook: remove it
  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,

  createContext: createContext,
  forwardRef: forwardRef,

  Fragment: REACT_FRAGMENT_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
  unstable_Profiler: REACT_PROFILER_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

if (enableSuspense) {
  React.Timeout = REACT_TIMEOUT_TYPE;
}

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3.default ? React$3.default : React$3;

module.exports = react;
  })();
}

},{"fbjs/lib/emptyFunction":127,"fbjs/lib/emptyObject":128,"fbjs/lib/invariant":129,"fbjs/lib/warning":130,"object-assign":185,"prop-types/checkPropTypes":187}],208:[function(require,module,exports){
/** @license React v16.4.2
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';var k=require("object-assign"),n=require("fbjs/lib/invariant"),p=require("fbjs/lib/emptyObject"),q=require("fbjs/lib/emptyFunction"),r="function"===typeof Symbol&&Symbol.for,t=r?Symbol.for("react.element"):60103,u=r?Symbol.for("react.portal"):60106,v=r?Symbol.for("react.fragment"):60107,w=r?Symbol.for("react.strict_mode"):60108,x=r?Symbol.for("react.profiler"):60114,y=r?Symbol.for("react.provider"):60109,z=r?Symbol.for("react.context"):60110,A=r?Symbol.for("react.async_mode"):60111,B=
r?Symbol.for("react.forward_ref"):60112;r&&Symbol.for("react.timeout");var C="function"===typeof Symbol&&Symbol.iterator;function D(a){for(var b=arguments.length-1,e="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)e+="&args[]="+encodeURIComponent(arguments[c+1]);n(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",e)}
var E={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function F(a,b,e){this.props=a;this.context=b;this.refs=p;this.updater=e||E}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?D("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function G(){}
G.prototype=F.prototype;function H(a,b,e){this.props=a;this.context=b;this.refs=p;this.updater=e||E}var I=H.prototype=new G;I.constructor=H;k(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var c=void 0,d={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];d.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:t,type:a,key:g,ref:h,props:d,_owner:J.current}}
function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===t}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,e,c){if(P.length){var d=P.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a)}
function S(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case t:case u:g=!0}}if(g)return e(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){d=a[h];var f=b+T(d,h);g+=S(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=C&&a[C]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),
h=0;!(d=a.next()).done;)d=d.value,f=b+T(d,h++),g+=S(d,f,e,c);else"object"===d&&(e=""+a,D("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function U(a,b){a.func.call(a.context,b,a.count++)}
function V(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?W(a,c,e,q.thatReturnsArgument):null!=a&&(N(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+e,a={$$typeof:t,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function W(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(O,"$&/")+"/");b=Q(b,g,c,d);null==a||S(a,"",V,b);R(b)}
var X={Children:{map:function(a,b,e){if(null==a)return a;var c=[];W(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=Q(null,null,b,e);null==a||S(a,"",U,b);R(b)},count:function(a){return null==a?0:S(a,"",q.thatReturnsNull,null)},toArray:function(a){var b=[];W(a,b,null,q.thatReturnsArgument);return b},only:function(a){N(a)?void 0:D("143");return a}},createRef:function(){return{current:null}},Component:F,PureComponent:H,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:z,
_calculateChangedBits:b,_defaultValue:a,_currentValue:a,_currentValue2:a,_changedBits:0,_changedBits2:0,Provider:null,Consumer:null};a.Provider={$$typeof:y,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:B,render:a}},Fragment:v,StrictMode:w,unstable_AsyncMode:A,unstable_Profiler:x,createElement:M,cloneElement:function(a,b,e){null===a||void 0===a?D("267",a):void 0;var c=void 0,d=k({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=b){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==
b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(d[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)d.children=e;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];d.children=l}return{$$typeof:t,type:a.type,key:g,ref:h,props:d,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.4.2",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:J,
assign:k}},Y={default:X},Z=Y&&X||Y;module.exports=Z.default?Z.default:Z;

},{"fbjs/lib/emptyFunction":127,"fbjs/lib/emptyObject":128,"fbjs/lib/invariant":129,"object-assign":185}],209:[function(require,module,exports){
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}

},{"./cjs/react.development.js":207,"./cjs/react.production.min.js":208}],210:[function(require,module,exports){
"use strict";

var compose = require('redux').compose;

exports.__esModule = true;
exports.composeWithDevTools = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?
    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ :
    function() {
      if (arguments.length === 0) return undefined;
      if (typeof arguments[0] === 'object') return compose;
      return compose.apply(null, arguments);
    }
);

exports.devToolsEnhancer = (
  typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__ ?
    window.__REDUX_DEVTOOLS_EXTENSION__ :
    function() { return function(noop) { return noop; } }
);

},{"redux":216}],211:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = applyMiddleware;

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = _compose2['default'].apply(undefined, chain)(store.dispatch);

      return _extends({}, store, {
        dispatch: _dispatch
      });
    };
  };
}
},{"./compose":214}],212:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = bindActionCreators;
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
},{}],213:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = combineReducers;

var _createStore = require('./createStore');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!(0, _isPlainObject2['default'])(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if ("production" !== 'production') {
      if (typeof reducers[key] === 'undefined') {
        (0, _warning2['default'])('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  var unexpectedKeyCache = void 0;
  if ("production" !== 'production') {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError = void 0;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var action = arguments[1];

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if ("production" !== 'production') {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        (0, _warning2['default'])(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}
},{"./createStore":215,"./utils/warning":217,"lodash/isPlainObject":184}],214:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = compose;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}
},{}],215:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports['default'] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2['default'])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2['default']] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
}
},{"lodash/isPlainObject":184,"symbol-observable":223}],216:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;

var _createStore = require('./createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _combineReducers = require('./combineReducers');

var _combineReducers2 = _interopRequireDefault(_combineReducers);

var _bindActionCreators = require('./bindActionCreators');

var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);

var _applyMiddleware = require('./applyMiddleware');

var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _warning = require('./utils/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("production" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  (0, _warning2['default'])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

exports.createStore = _createStore2['default'];
exports.combineReducers = _combineReducers2['default'];
exports.bindActionCreators = _bindActionCreators2['default'];
exports.applyMiddleware = _applyMiddleware2['default'];
exports.compose = _compose2['default'];
},{"./applyMiddleware":211,"./bindActionCreators":212,"./combineReducers":213,"./compose":214,"./createStore":215,"./utils/warning":217}],217:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
},{}],218:[function(require,module,exports){
/*jslint onevar:true, undef:true, newcap:true, regexp:true, bitwise:true, maxerr:50, indent:4, white:false, nomen:false, plusplus:false */
/*global define:false, require:false, exports:false, module:false, signals:false */

/** @license
 * JS Signals <http://millermedeiros.github.com/js-signals/>
 * Released under the MIT license
 * Author: Miller Medeiros
 * Version: 1.0.0 - Build: 268 (2012/11/29 05:48 PM)
 */

(function(global){

    // SignalBinding -------------------------------------------------
    //================================================================

    /**
     * Object that represents a binding between a Signal and a listener function.
     * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
     * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
     * @author Miller Medeiros
     * @constructor
     * @internal
     * @name SignalBinding
     * @param {Signal} signal Reference to Signal object that listener is currently bound to.
     * @param {Function} listener Handler function bound to the signal.
     * @param {boolean} isOnce If binding should be executed just once.
     * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
     * @param {Number} [priority] The priority level of the event listener. (default = 0).
     */
    function SignalBinding(signal, listener, isOnce, listenerContext, priority) {

        /**
         * Handler function bound to the signal.
         * @type Function
         * @private
         */
        this._listener = listener;

        /**
         * If binding should be executed just once.
         * @type boolean
         * @private
         */
        this._isOnce = isOnce;

        /**
         * Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @memberOf SignalBinding.prototype
         * @name context
         * @type Object|undefined|null
         */
        this.context = listenerContext;

        /**
         * Reference to Signal object that listener is currently bound to.
         * @type Signal
         * @private
         */
        this._signal = signal;

        /**
         * Listener priority
         * @type Number
         * @private
         */
        this._priority = priority || 0;
    }

    SignalBinding.prototype = {

        /**
         * If binding is active and should be executed.
         * @type boolean
         */
        active : true,

        /**
         * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
         * @type Array|null
         */
        params : null,

        /**
         * Call listener passing arbitrary parameters.
         * <p>If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.</p>
         * @param {Array} [paramsArr] Array of parameters that should be passed to the listener
         * @return {*} Value returned by the listener.
         */
        execute : function (paramsArr) {
            var handlerReturn, params;
            if (this.active && !!this._listener) {
                params = this.params? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        },

        /**
         * Detach binding from signal.
         * - alias to: mySignal.remove(myBinding.getListener());
         * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
         */
        detach : function () {
            return this.isBound()? this._signal.remove(this._listener, this.context) : null;
        },

        /**
         * @return {Boolean} `true` if binding is still bound to the signal and have a listener.
         */
        isBound : function () {
            return (!!this._signal && !!this._listener);
        },

        /**
         * @return {boolean} If SignalBinding will only be executed once.
         */
        isOnce : function () {
            return this._isOnce;
        },

        /**
         * @return {Function} Handler function bound to the signal.
         */
        getListener : function () {
            return this._listener;
        },

        /**
         * @return {Signal} Signal that listener is currently bound to.
         */
        getSignal : function () {
            return this._signal;
        },

        /**
         * Delete instance properties
         * @private
         */
        _destroy : function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';
        }

    };


/*global SignalBinding:false*/

    // Signal --------------------------------------------------------
    //================================================================

    function validateListener(listener, fnName) {
        if (typeof listener !== 'function') {
            throw new Error( 'listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName) );
        }
    }

    /**
     * Custom event broadcaster
     * <br />- inspired by Robert Penner's AS3 Signals.
     * @name Signal
     * @author Miller Medeiros
     * @constructor
     */
    function Signal() {
        /**
         * @type Array.<SignalBinding>
         * @private
         */
        this._bindings = [];
        this._prevParams = null;

        // enforce dispatch to aways work on same context (#47)
        var self = this;
        this.dispatch = function(){
            Signal.prototype.dispatch.apply(self, arguments);
        };
    }

    Signal.prototype = {

        /**
         * Signals Version Number
         * @type String
         * @const
         */
        VERSION : '1.0.0',

        /**
         * If Signal should keep record of previously dispatched parameters and
         * automatically execute listener during `add()`/`addOnce()` if Signal was
         * already dispatched before.
         * @type boolean
         */
        memorize : false,

        /**
         * @type boolean
         * @private
         */
        _shouldPropagate : true,

        /**
         * If Signal is active and should broadcast events.
         * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>
         * @type boolean
         */
        active : true,

        /**
         * @param {Function} listener
         * @param {boolean} isOnce
         * @param {Object} [listenerContext]
         * @param {Number} [priority]
         * @return {SignalBinding}
         * @private
         */
        _registerListener : function (listener, isOnce, listenerContext, priority) {

            var prevIndex = this._indexOfListener(listener, listenerContext),
                binding;

            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add'+ (isOnce? '' : 'Once') +'() then add'+ (!isOnce? '' : 'Once') +'() the same listener without removing the relationship first.');
                }
            } else {
                binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }

            if(this.memorize && this._prevParams){
                binding.execute(this._prevParams);
            }

            return binding;
        },

        /**
         * @param {SignalBinding} binding
         * @private
         */
        _addBinding : function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
            this._bindings.splice(n + 1, 0, binding);
        },

        /**
         * @param {Function} listener
         * @return {number}
         * @private
         */
        _indexOfListener : function (listener, context) {
            var n = this._bindings.length,
                cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur._listener === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        },

        /**
         * Check if listener was attached to Signal.
         * @param {Function} listener
         * @param {Object} [context]
         * @return {boolean} if Signal has the specified listener.
         */
        has : function (listener, context) {
            return this._indexOfListener(listener, context) !== -1;
        },

        /**
         * Add a listener to the signal.
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        add : function (listener, listenerContext, priority) {
            validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        },

        /**
         * Add listener to the signal that should be removed after first execution (will be executed only once).
         * @param {Function} listener Signal handler function.
         * @param {Object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).
         * @param {Number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
         * @return {SignalBinding} An Object representing the binding between the Signal and listener.
         */
        addOnce : function (listener, listenerContext, priority) {
            validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        },

        /**
         * Remove a single listener from the dispatch queue.
         * @param {Function} listener Handler function that should be removed.
         * @param {Object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).
         * @return {Function} Listener handler function.
         */
        remove : function (listener, context) {
            validateListener(listener, 'remove');

            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        },

        /**
         * Remove all listeners from the Signal.
         */
        removeAll : function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        },

        /**
         * @return {number} Number of listeners attached to the Signal.
         */
        getNumListeners : function () {
            return this._bindings.length;
        },

        /**
         * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
         * <p><strong>IMPORTANT:</strong> should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.</p>
         * @see Signal.prototype.disable
         */
        halt : function () {
            this._shouldPropagate = false;
        },

        /**
         * Dispatch/Broadcast Signal to all listeners added to the queue.
         * @param {...*} [params] Parameters that should be passed to each handler.
         */
        dispatch : function (params) {
            if (! this.active) {
                return;
            }

            var paramsArr = Array.prototype.slice.call(arguments),
                n = this._bindings.length,
                bindings;

            if (this.memorize) {
                this._prevParams = paramsArr;
            }

            if (! n) {
                //should come after memorize
                return;
            }

            bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.

            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        },

        /**
         * Forget memorized arguments.
         * @see Signal.memorize
         */
        forget : function(){
            this._prevParams = null;
        },

        /**
         * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
         * <p><strong>IMPORTANT:</strong> calling any method on the signal instance after calling dispose will throw errors.</p>
         */
        dispose : function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        },

        /**
         * @return {string} String representation of the object.
         */
        toString : function () {
            return '[Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';
        }

    };


    // Namespace -----------------------------------------------------
    //================================================================

    /**
     * Signals namespace
     * @namespace
     * @name signals
     */
    var signals = Signal;

    /**
     * Custom event broadcaster
     * @see Signal
     */
    // alias for backwards compatibility (see #gh-44)
    signals.Signal = Signal;



    //exports to multiple environments
    if(typeof define === 'function' && define.amd){ //AMD
        define(function () { return signals; });
    } else if (typeof module !== 'undefined' && module.exports){ //node
        module.exports = signals;
    } else { //browser
        //use string because of Google closure compiler ADVANCED_MODE
        /*jslint sub:true */
        global['signals'] = signals;
    }

}(this));

},{}],219:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  }
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":220,"./request":222,"./request-base":221,"emitter":125}],220:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],221:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

exports.catch = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {

  // name should be either a string or an object.
  if (null === name ||  undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":220}],222:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],223:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill.js');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./ponyfill.js":224}],224:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],225:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[92])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2NvbXBvbmVudHMvZGVwZW5kZWQtcmVsYXRpb24vZGVwZW5kZWQtZHJvcGRvd24tcmVkdWNlci5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvY29tcG9uZW50cy9kZXBlbmRlZC1yZWxhdGlvbi9kZXBlbmRlZC1kcm9wZG93bi1zdG9yZS5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvY29tcG9uZW50cy9kZXBlbmRlZC1yZWxhdGlvbi9kZXBlbmRlZC1yZWxhdGlvbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2NvbXBvbmVudHMvZGVwZW5kZWQtcmVsYXRpb24vcHJvdmlkZXItZGVwZW5kZWQtcmVsYXRpb24uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1pbnB1dC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2ZpZWxkLWxpc3QuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1yb3cuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9iYWNrZW5kLWNhbGxiYWNrLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9jaGVja2JveC1ib29sZWFuLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvY29sb3IuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9kYXRlLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvZGF0ZXRpbWUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9kcm9wZG93bi1zZWFyY2hhYmxlLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvZHJvcGRvd24uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9lbWFpbC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L2VudW0tc2VhcmNoYWJsZS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L2VudW0uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9oaWRkZW4uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9tdWx0aXNlbGVjdC1zZWFyY2hhYmxlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9tdWx0aXNlbGVjdC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvbnVtZXJpYy5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3Bhc3N3b3JkLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVhZC1vbmx5LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVsYXRpb24tbi1uLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmVsYXRpb25hbC1uYXRpdmUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yZWxhdGlvbmFsLXNlYXJjaGFibGUuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yaWNoLXRleHRlZGl0b3ItcmVhZC1vbmx5LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvaW5wdXQvcmljaC10ZXh0ZWRpdG9yLXdpdGgtcGx1Z2luLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9yaWNoLXRleHRlZGl0b3IuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC9zZWFyY2hhYmxlLXJlbGF0aW9uLW4tbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3RleHQuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC90ZXh0YXJlYS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3RoaXJkLXBhcnR5L3JlYWN0LWRyb3B6b25lLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC91cGxvYWQuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9pbnB1dC91cGxvYWQvdXBsb2FkLXNob3ctZmlsZS5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL2lucHV0L3VybC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1jcnVkLWZvcm1zL21vZGFsL3RpdGxlLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLWRhdGFncmlkLXNldHRpbmdzL2djZS1kYXRhZ3JpZC1zZXR0aW5ncy9zZXR0aW5ncy5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1kYXRhZ3JpZC1zZXR0aW5ncy9nY2UtZGF0YWdyaWQtc2V0dGluZ3MvdmlzaWJsZS1jb2x1bW5zLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9iYXNpYy1vcGVyYXRvci5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC1pbnB1dC9kYXRlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLWlucHV0L3NlbGVjdC1kcm9wZG93bi5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC1pbnB1dC9zZWxlY3QtcmVsYXRpb25hbC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC1pbnB1dC9zZWxlY3QuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtdHlwZXMvY2hlY2tib3hfYm9vbGVhbi5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy9kYXRlLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLXR5cGVzL2Ryb3Bkb3duLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLXR5cGVzL2VudW0uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmllbGQtdHlwZXMvbnVtZXJpYy5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy9yZWxhdGlvbmFsLW4tbi5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWVsZC10eXBlcy9yZWxhdGlvbmFsLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpZWxkLXR5cGVzL3RleHQuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvZmlsdGVyLXNlbGVjdC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9maWx0ZXJpbmcuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvbXVsdGlwbGUtc2VhcmNoLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL2NvbXBhcmlzb24uanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvc2VsZWN0LW9wdGlvbnMvZXF1YWxfbm90X2VxdWFsLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL2hhc19vcl9ub3QuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC1maWx0ZXJpbmcvc2VsZWN0LW9wdGlvbnMvdGV4dC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy90cmFuc2xhdGlvbnMvaTE4bi1jb21wYXJpc29uLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL3RyYW5zbGF0aW9ucy9pMThuLWVxdWFsLW5vdC1lcXVhbC5qcyIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkLWZpbHRlcmluZy9zZWxlY3Qtb3B0aW9ucy90cmFuc2xhdGlvbnMvaTE4bi1oYXMtb3Itbm90LmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL3NlbGVjdC1vcHRpb25zL3RyYW5zbGF0aW9ucy9pMThuLXRleHQuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC9idXR0b25zL2RlZmF1bHQtZ3JvdXAtYnV0dG9uLmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL2J1dHRvbnMvZGVmYXVsdC1saW5rLWJ1dHRvbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC9kYXRhZ3JpZC1hY3Rpb25zLWNvbHVtbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC9kYXRhZ3JpZC1jaGVja2JveC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC9kYXRhZ3JpZC1yb3cuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvZGF0YWdyaWQtdGJvZHkuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2ZpZWxkLXJvdy13cmFwcGVyLmpzIiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2dyb3VwLWJ1dHRvbnMtbGlzdC5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtYnV0dG9ucy5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtcHJpbWFyeS1idXR0b24uanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2xpbmstYnV0dG9uLXdyYXBwZXIuanN4IiwiUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL21vZGFsLXRpdGxlLXdyYXBwZXIuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvZmllbGQtcm93LXdyYXBwZXIuanMiLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvZ3JvdXAtYnV0dG9ucy1saXN0LmpzeCIsIlJlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12NC9ncm91cC1wcmltYXJ5LWJ1dHRvbi5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvbGluay1idXR0b24td3JhcHBlci5qc3giLCJSZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvbW9kYWwtdGl0bGUtd3JhcHBlci5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvZGF0YWdyaWQvZ3JvY2VyeS1jcnVkLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9kYXRhZ3JpZC9qcXVlcnkuZ2NydWQuZGF0YWdyaWQuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2hlbHBlcnMvYWpheC1oZWxwZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2hlbHBlcnMvbG9jYWwtc3RvcmFnZS1oZWxwZXIuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2pxdWVyeS1wbHVnaW5zL2Nob3Nlbi5qcXVlcnkuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2pxdWVyeS1wbHVnaW5zL21vZGFsLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9qcXVlcnktcGx1Z2lucy9wcmludFRoaXMuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2pxdWVyeS1wbHVnaW5zL3RyYW5zaXRpb24uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2xpYnJhcmllcy9IYW5kbGViYXJzRXh0ZW5kZWQuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL2xpYnJhcmllcy9qcXVlcnktdWktdGltZXBpY2tlci5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvbWFpbi9tYWluLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9tb2R1bGVzL2pxdWVyeS9qcXVlcnktcGx1Z2lucy5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9yZWFjdC9qc3gvZGF0YWdyaWQvZm9vdGVyL3Blci1wYWdlLWRyb3Bkb3duLmpzeCIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvY29uc3RhbnRzLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9jb2x1bW4uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmNvbHVtbnMuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmdyaWQuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmhlYWRlci1hY3Rpb25zLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5wYWdpbmcuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLnNlYXJjaC5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvb3BlcmF0aW9ucy9hZGQuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL29wZXJhdGlvbnMvY2xvbmUuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL29wZXJhdGlvbnMvY29tbW9uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9vcGVyYXRpb25zL2RlbGV0ZS5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvb3BlcmF0aW9ucy9lZGl0LmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9vcGVyYXRpb25zL3JlYWQuanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL29wZXJhdGlvbnMvcmVkdWNlci5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvcm91dGVzL3JvdXRlci5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvY2FsbGJhY2stY29sdW1uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy9jaGVja2JveC1ib29sZWFuLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy9kYXRlLWFuZC10aW1lLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy9kcm9wZG93bi5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvZW51bS5qcyIsIlJlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvdHlwZXMvbXVsdGlwbGUtc2VsZWN0LmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy9yZWxhdGlvbi1uLW4uanMiLCJSZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL3R5cGVzL3JlbGF0aW9uLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy90ZXh0ZWRpdG9yLmpzIiwiUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy90eXBlcy91cGxvYWQuanMiLCJub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nyb3Nzcm9hZHMvZGlzdC9jcm9zc3JvYWRzLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzLnJ1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvYXN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL2NvZGUtZ2VuLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9jb21waWxlci9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvamF2YXNjcmlwdC1jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2NvbXBpbGVyL3ByaW50ZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9jb21waWxlci92aXNpdG9yLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvY29tcGlsZXIvd2hpdGVzcGFjZS1jb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZGVjb3JhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMvaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvZXhjZXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2VhY2guanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2hlbHBlci1taXNzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9pZi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9sb29rdXAuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL3dpdGguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9sb2dnZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL25vLWNvbmZsaWN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2FycmF5LXNldC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC12bHEuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iaW5hcnktc2VhcmNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvbWFwcGluZy1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvcXVpY2stc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9oYXNoZXIvZGlzdC9qcy9oYXNoZXIuanMiLCJub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvZGlzdC9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy5janMuanMiLCJub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2Nvbm5lY3QvY29ubmVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvY29ubmVjdC9tYXBEaXNwYXRjaFRvUHJvcHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi9jb25uZWN0L21lcmdlUHJvcHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2Nvbm5lY3Qvc2VsZWN0b3JGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvY29ubmVjdC93cmFwTWFwVG9Qcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL3V0aWxzL1Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvU3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVkdXgtZGV2dG9vbHMtZXh0ZW5zaW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9jb21wb3NlLmpzIiwibm9kZV9tb2R1bGVzL3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWR1eC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJub2RlX21vZHVsZXMvc2lnbmFscy9kaXN0L3NpZ25hbHMuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3ltYm9sLW9ic2VydmFibGUvbGliL3BvbnlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FDQUEsSUFBTSxjQUFjLFNBQWQsV0FBYyxHQUF3QjtBQUFBLFFBQXZCLEtBQXVCLHVFQUFmLEVBQWU7QUFBQSxRQUFYLE1BQVc7O0FBQ3hDLFlBQVEsT0FBTyxJQUFmO0FBQ0ksYUFBSyw0QkFBTDtBQUNJLGdDQUNPLE1BRFA7QUFFSSxxQ0FBcUIsT0FBTztBQUZoQzs7QUFLSixhQUFLLDJCQUFMO0FBQ0ksZ0NBQ08sTUFEUDtBQUVJLHFDQUFxQixPQUFPO0FBRmhDO0FBSUo7QUFDSSxtQkFBTyxLQUFQO0FBYlI7QUFlSCxDQWhCRDs7a0JBa0JlLFc7Ozs7Ozs7OztBQ2xCZjs7OztBQUNBOztBQUNBOzs7O0FBRUEsSUFBTSxtQkFB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QUFvRCxVQUExRDs7QUFFQSxlQUFPLGNBQWMsR0FBZCxHQUFvQixvQkFBcEIsR0FBMkMsVUFBM0MsR0FBd0QsTUFBL0Q7QUFDSDtBQTNCc0IsQ0FBZCxDQUFiOztBQThCQSxRQUFRLE1BQVIsR0FBaUIsTUFBakI7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdTQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxTQUFTLEVBQUMsRUFBRSxFQUFDLGVBQWUsRUFBQyxFQUFFLEVBQUMsZ0JBQWdCLEVBQUMsRUFBRSxFQUFDLGlCQUFpQixFQUFDLEVBQUUsRUFBQyxZQUFZLEVBQUMsRUFBRSxFQUFDLE9BQU8sRUFBQyxFQUFFLEVBQUMsY0FBYyxFQUFDLEVBQUUsRUFBQyxvQkFBb0IsRUFBQyxFQUFFLEVBQUMsU0FBUyxFQUFDLEVBQUUsRUFBQyxlQUFlLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUMsZ0JBQWdCLEVBQUMsRUFBRSxFQUFDLGlCQUFpQixFQUFDLEVBQUUsRUFBQyxjQUFjLEVBQUMsRUFBRSxFQUFDLG9CQUFvQixFQUFDLEVBQUUsRUFBQyxZQUFZLEVBQUMsRUFBRSxFQUFDLGFBQWEsRUFBQyxFQUFFLEVBQUMsSUFBSSxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUMsRUFBRSxFQUFDLG1CQUFtQixFQUFDLEVBQUUsRUFBQyxvQkFBb0IsRUFBQyxFQUFFLEVBQUMsUUFBUSxFQUFDLEVBQUUsRUFBQyxRQUFRLEVBQUMsRUFBRSxFQUFDLFNBQVMsRUFBQyxFQUFFLEVBQUMsV0FBVyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDO0FBQzVlLG9CQUFZLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMs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Q0FBQztBQUN0RSwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkYsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RGLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDckosMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUNySSwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ3JJLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDL0UsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFDSCx3QkFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQzt3QkFDN0UsT0FBTyxHQUFHLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3pELDJCQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs7QUFFdkIsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUM7O0FBRXRFLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLENBQUM7QUFDMUUsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0SCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RILDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQ0gsd0JBQUksQ0FBQyxDQUFDLEdBQUc7QUFDUCw0QkFBSSxFQUFFLGtCQUFrQjtBQUN4Qiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQztBQUNoQiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFO0FBQ1YsNkJBQUssRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLDJCQUFHLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO3FCQUN6QixDQUFDOztBQUVOLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzdFLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDOUcsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFDSCx3QkFBSSxDQUFDLENBQUMsR0FBRztBQUNQLDRCQUFJLEVBQUUsZUFBZTtBQUNyQiw0QkFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDO0FBQ2QsOEJBQU0sRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQztBQUNoQiw0QkFBSSxFQUFFLEVB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RUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUM7QUFDOUYsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZELDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN4RCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFFLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEFBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hHLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0FBQzNELDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3BCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsc0JBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzlCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMxQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUNwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHNCQUFFLENBQUMsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUM5QiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDMUIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyxzQkFBRSxDQUFDLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDOUIsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEdBQUc7QUFBQyx3QkFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxHQUFHO0FBQUMsc0JBQUUsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQy9CLDBCQUFNO0FBQUEsYUFDTDtTQUNBO0FBQ0QsYUFBSyxFQUFFLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxHQUFHLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEdBQUcsQ0FBQyxFQUFDLEVBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxDQUFDO0FBQ3hnVyxzQkFBYyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUMsR0FBRyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsRUFBQyxHQUFHLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEVBQUM7QUFDN00sa0JBQVUsRUFBRSxTQUFTLFVBQVUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3ZDLGtCQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO0FBQ0QsYUFBSyxFQUFFLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRTtBQUN6QixnQkFBSSxJQUFJLEdBQUcsSUFBSTtnQkFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQUUsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDO2dCQUFFLE1BQU0sR0FBRyxFQUFFO2dCQUFFLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSztnQkFBRSxNQUFNLEdBQUcsRUFBRTtnQkFBRSxRQUFR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LENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RDLDZCQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3RDLDZCQUFLLENBQUMsRUFBRSxHQUFHLEVBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUEsQUFBQyxDQUFDLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUEsQUFBQyxDQUFDLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUMsQ0FBQztBQUMxTyw0QkFBSSxNQUFNLEVBQUU7QUFDUixpQ0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFBLEFBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDdEc7QUFDRCx5QkFBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDakcsNEJBQUksT0FBTyxDQUFDLEtBQUssV0FBVyxFQUFFO0FB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QUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUNuQywwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUNuQywwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUNMLHdCQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN2Qix3QkFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ2hCLHdCQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUVwQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUNMLHdCQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDaEIsMkJBQU8sRUFBRSxDQUFDOztBQUVaLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sRUFBRSxDQUFDO0FBQ2xCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFOztBQUNQLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxBQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ25DLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsd0JBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxBQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ25DLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsdUJBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUMsT0FBTyxFQUFFLENBQUM7QUFDL0QsMEJBQU07QUFBQSxBQUNOLHFCQUFLLEVBQUU7QUFBQyx1QkFBRyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUMsR0FBRyxDQUFDLENBQUMsQUFBQyxPQUFPLEVBQUUsQ0FBQztBQUMvRCwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLDJCQUFPLEVBQUUsQ0FBQztBQUNsQiwwQkFBTTtBQUFBLEFBQ04scUJBQUssRUFBRTtBQUFDLHVCQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBQyxJQUFJLENBQUMsQ0FBQyxBQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3ZFLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sU0FBUyxDQUFDO0FBQ3pCLDBCQUFNO0FBQUEsQUFDTixxQkFBSyxFQUFFO0FBQUMsMkJBQU8sQ0FBQyxDQUFDO0FBQ2pCLDBCQUFNO0FBQUEsYUFDTDtTQUNBLENBQUM7QUFDRixhQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsMEJBQTBCLEVBQUMsZUFBZSxFQUFDLCtDQUErQyxFQUFDLHdCQUF3QixFQUFDLG9FQUFvRSxFQUFDLDhCQUE4QixFQUFDLHlCQUF5QixFQUFDLFNBQVMsRUFBQyxTQUFTLEVBQUMsZUFBZSxFQUFDLGVBQWUsRUFBQyxnQkFBZ0IsRUFBQyxpQkFBaUIsRUFBQyxtQkFBbUIsRUFBQyxpQkFBaUIsRUFBQyw0QkFBNEIsRUFBQyxpQ0FBaUMsRUFBQyxpQkFBaUIsRUFBQyx3QkFBd0IsRUFBQyxpQkFBaUIsRUFBQyxnQkFBZ0IsRUFBQyxrQkFBa0IsRUFBQyw0QkFBNEIsRUFBQyxrQkFBa0IsRUFBQyxRQUFRLEVBQUMsV0FBVyxFQUFDLDJCQUEyQixFQUFDLFlBQVksRUFBQyxVQUFVLEVBQUMsaUJBQWlCLEVBQUMsZUFBZSxFQUFDLHNCQUFzQixFQUFDLHNCQUFzQixFQUFDLFFBQVEsRUFBQyx3QkFBd0IsRUFBQyx5QkFBeUIsRUFBQyw2QkFBNkIsRUFBQyx3QkFBd0IsRUFBQyx5Q0FBeUMsRUFBQyxjQUFjLEVBQUMsU0FBUyxFQUFDLHlEQUF5RCxFQUFDLHdCQUF3QixFQUFDLFFBQVEsRUFBQyxRQUFRLENBQUMsQ0FBQztBQUNuZ0MsYUFBSyxDQUFDLFVBQVUsR0FBRyxFQUFDLElBQUksRUFBQyxFQUFDLE9BQU8sRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxFQUFFLENBQUMsRUFBQyxXQUFXLEVBQUMsS0FBSyxFQUFDLEVBQUMsS0FBSyxFQUFDLEVBQUMsT0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsV0FBVyxFQUFDLEtBQUssRUFBQyxFQUFDLEtBQUssRUFBQyxFQUFDLE9BQU8sRUFBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLFdBQVcsRUFBQyxLQUFLLEVBQUMsRUFBQyxLQUFLLEVBQUMsRUFBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLFdBQVcsRUFBQyxLQUFLLEVBQUMsRUFBQyxTQUFTLEVBQUMsRUFBQyxPQUFPLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxFQUFDLFdBQVcsRUFBQyxJQUFJLEVBQUMsRUFBQyxDQUFDO0FBQzNVLGVBQU8sS0FBSyxDQUFDO0tBQUMsQ0FBQSxFQUFHLENBQUE7QUFDakIsVUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDckIsYUFBUyxNQUFNLEdBQUk7QUFBRSxZQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztLQUFFLE1BQU0sQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ3JGLFdBQU8sSUFBSSxNQUFNLEVBQUEsQ0FBQztDQUNqQixDQUFBLEVBQUcsQ0FBQyxxQkFBZSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7dUJDNW1CVixXQUFXOzs7O0FBRXhCLFNBQVMsS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUN6QixTQUFPLElBQUksWUFBWSxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZDOztBQUVNLFNBQVMsWUFBWSxHQUFHO0FBQzdCLE1BQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0NBQ2xCOztBQUVELFlBQVksQ0FBQyxTQUFTLEdBQUcsMEJBQWEsQ0FBQzs7QUFFdkMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDNUMsTUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDOztBQUViLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUMsT0FBRyxJQUFJLElBQUksQ0FBQztHQUNiOztBQUVELEtBQUcsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUNqRCxNQUFJLEdBQUcsR0FBRyxFQUFFO01BQ1IsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJO01BQ25CLENBQUMsWUFBQTtNQUFFLENBQUMsWUFBQSxDQUFDOztBQUVULE1BQUksT0FBTyxDQUFDLFdBQVcsRUFBRTtBQUN2QixRQUFJLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQztBQUNwQyxTQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckQsaUJBQVcsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM5QztBQUNELGVBQVcsSUFBSSxJQUFJLENBQUM7QUFDcEIsT0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7R0FDOUI7O0FBRUQsT0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsT0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDN0I7O0FBRUQsTUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUVmLFNBQU8sR0FBRyxDQUFDO0NBQ1osQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVMsUUFBUSxFQUFFO0FBQzVELFNBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztDQUMvRCxDQUFDO0FBQ0YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBUyxRQUFRLEVBQUU7QUFDcEQsU0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO0NBQ3pFLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQ3JDLFlBQVksQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ3RELE1BQUksR0FBRyxHQUFHLEVBQUUsQ0FBQzs7QUFFYixLQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLEVBQUUsQ0FBQSxHQUFJLFFBQVEsQ0FBQyxDQUFDO0FBQ2xGLE1BQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNmLEtBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMzQyxNQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7QUFDakIsT0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDNUIsUUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2YsT0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ2xDLFFBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUNoQjtBQUNELE1BQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtBQUNqQixRQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7QUFBRSxVQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7S0FBRTtBQUN0QyxPQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN6QixRQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDZixPQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbEMsUUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ2YsUUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFO0FBQUUsVUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQUU7R0FDdkM7QUFDRCxNQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRWYsU0FBTyxHQUFHLENBQUM7Q0FDWixDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsVUFBUyxPQUFPLEVBQUU7QUFDMUQsTUFBSSxPQUFPLEdBQUcsVUFBVSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ2pELE1BQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNyQixXQUFPLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ2pEO0FBQ0QsTUFBSSxPQUFPLENBQUMsSUFBSSxFQUFFO0FBQ2hCLFdBQU8sSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDNUM7QUFDRCxTQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQztDQUMzQyxDQUFDO0FBQ0YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUMvRCxNQUFJLE9BQU8sR0FBRyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztBQUN2RCxNQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDckIsV0FBTyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNqRDtBQUNELE1BQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixXQUFPLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzVDOztBQUVELFNBQU8sSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUN0QyxNQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDZixTQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDeEMsTUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUVmLFNBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDO0NBQzNDLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUMxRCxTQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7Q0FDdkQsQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzFELFNBQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQztDQUNuRCxDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQ3JELE1BQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNO01BQ3JCLFlBQVksR0FBRyxFQUFFO01BQ2pCLElBQUksWUFBQSxDQUFDOztBQUVULE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0MsZ0JBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQzNDOztBQUVELFFBQU0sR0FBRyxHQUFHLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7O0FBRTdDLE1BQUksR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7O0FBRXZELFNBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUM7Q0FDdEQsQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxVQUFTLEVBQUUsRUFBRTtBQUNuRCxNQUFJLElBQUksR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM5QixTQUFPLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFBLEdBQUksT0FBTyxHQUFHLElBQUksQ0FBQztDQUM5QyxDQUFDOztBQUdGLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3RELFNBQU8sR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO0NBQ2pDLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDdEQsU0FBTyxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7Q0FDdkMsQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxVQUFTLElBQUksRUFBRTtBQUNyRCxTQUFPLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztDQUN0QyxDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBVztBQUNuRCxTQUFPLFdBQVcsQ0FBQztDQUNwQixDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLFlBQVc7QUFDOUMsU0FBTyxNQUFNLENBQUM7Q0FDZixDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQzNDLE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLO01BQ2xCLFdBQVcsR0FBRyxFQUFFLENBQUM7O0FBRXJCLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUMsZUFBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDekM7O0FBRUQsU0FBTyxPQUFPLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7Q0FDL0MsQ0FBQztBQUNGLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxHQUFHLFVBQVMsSUFBSSxFQUFFO0FBQy9DLFNBQU8sSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDakQsQ0FBQzs7Ozs7Ozs7Ozs7O3lCQ3pLb0IsY0FBYzs7OztBQUVwQyxTQUFTLE9BQU8sR0FBRztBQUNqQixNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztDQUNuQjs7QUFFRCxPQUFPLENBQUMsU0FBUyxHQUFHO0FBQ2xCLGFBQVcsRUFBRSxPQUFPO0FBQ3BCLFVBQVEsRUFBRSxLQUFLOzs7QUFHZixXQUFTLEVBQUUsbUJBQVMsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM5QixRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLFFBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTs7O0FBR2pCLFVBQUksS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDM0MsY0FBTSwyQkFBYyx3QkFBd0IsR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLHlCQUF5QixHQUFHLElBQUksR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ3BIO0FBQ0QsVUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztLQUNwQjtHQUNGOzs7O0FBSUQsZ0JBQWMsRUFBRSx3QkFBUyxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ25DLFFBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDOztBQUUzQixRQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2YsWUFBTSwyQkFBYyxJQUFJLENBQUMsSUFBSSxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsQ0FBQztLQUN0RDtHQUNGOzs7O0FBSUQsYUFBVyxFQUFFLHFCQUFTLEtBQUssRUFBRTtBQUMzQixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzVDLFVBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUV6QixVQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ2IsYUFBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkIsU0FBQyxFQUFFLENBQUM7QUFDSixTQUFDLEVBQUUsQ0FBQztPQUNMO0tBQ0Y7R0FDRjs7QUFFRCxRQUFNLEVBQUUsZ0JBQVMsTUFBTSxFQUFFO0FBQ3ZCLFFBQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxhQUFPO0tBQ1I7OztBQUdELFFBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3RCLFlBQU0sMkJBQWMsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztLQUM3RDs7QUFFRCxRQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDaEIsVUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ3BDO0FBQ0QsUUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7O0FBRXRCLFFBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7O0FBRXBDLFFBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFcEMsUUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksR0FBRyxFQUFFO0FBQ3pCLGFBQU8sR0FBRyxDQUFDO0tBQ1osTUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUU7QUFDeEIsYUFBTyxNQUFNLENBQUM7S0FDZjtHQUNGOztBQUVELFNBQU8sRUFBRSxpQkFBUyxPQUFPLEVBQUU7QUFDekIsUUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7R0FDaEM7O0FBRUQsbUJBQWlCLEVBQUUsa0JBQWtCO0FBQ3JDLFdBQVMsRUFBRSxrQkFBa0I7O0FBRTdCLGdCQUFjLEVBQUUsVUFBVTtBQUMxQixnQkFBYyxFQUFFLFVBQVU7O0FBRTFCLGtCQUFnQixFQUFFLFlBQVk7QUFDOUIsdUJBQXFCLEVBQUUsK0JBQVMsT0FBTyxFQUFFO0FBQ3ZDLGdCQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFakMsUUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDcEM7O0FBRUQsa0JBQWdCLEVBQUUseUNBQXdCLEVBQUU7QUFDNUMsa0JBQWdCLEVBQUUseUNBQXdCLEVBQUU7O0FBRTVDLGVBQWEsRUFBRSxrQkFBa0I7O0FBRWpDLGdCQUFjLEVBQUUsb0NBQXFCLEVBQUU7O0FBRXZDLGVBQWEsRUFBRSxxQ0FBdUIsRUFBRTtBQUN4QyxlQUFhLEVBQUUscUNBQXVCLEVBQUU7QUFDeEMsZ0JBQWMsRUFBRSxvQ0FBcUIsRUFBRTtBQUN2QyxrQkFBZ0IsRUFBRSx5Q0FBd0IsRUFBRTtBQUM1QyxhQUFXLEVBQUUsb0NBQXdCLEVBQUU7O0FBRXZDLE1BQUksRUFBRSxjQUFTLElBQUksRUFBRTtBQUNuQixRQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUM5QjtBQUNELFVBQVEsRUFBRSxrQkFBUyxJQUFJLEVBQUU7QUFDdkIsUUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7R0FDcEM7Q0FDRixDQUFDOztBQUVGLFNBQVMsa0JBQWtCLENBQUMsUUFBUSxFQUFFO0FBQ3BDLE1BQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3RDLE1BQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2xDLE1BQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQ2xDO0FBQ0QsU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFO0FBQ3pCLG9CQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRXJDLE1BQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2pDLE1BQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ2xDO0FBQ0QsU0FBUyxZQUFZLENBQUMsT0FBTyxFQUFFO0FBQzdCLE1BQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3JDLE1BQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2pDLE1BQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0NBQ2pDOztxQkFFYyxPQUFPOzs7Ozs7Ozs7Ozs7dUJDaElGLFdBQVc7Ozs7QUFFL0IsU0FBUyxpQkFBaUIsR0FBZTtNQUFkLE9BQU8seURBQUcsRUFBRTs7QUFDckMsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Q0FDeEI7QUFDRCxpQkFBaUIsQ0FBQyxTQUFTLEdBQUcsMEJBQWEsQ0FBQzs7QUFFNUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUN0RCxNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7O0FBRXBELE1BQUksTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUM5QixNQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQzs7QUFFdkIsTUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzNDLFFBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDakIsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRWpDLFFBQUksQ0FBQyxLQUFLLEVBQUU7QUFDVixlQUFTO0tBQ1Y7O0FBRUQsUUFBSSxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQztRQUNyRCxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQztRQUVyRCxjQUFjLEdBQUcsS0FBSyxDQUFDLGNBQWMsSUFBSSxpQkFBaUI7UUFDMUQsZUFBZSxHQUFHLEtBQUssQ0FBQyxlQUFlLElBQUksaUJBQWlCO1FBQzVELGdCQUFnQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsSUFBSSxpQkFBaUIsSUFBSSxpQkFBaUIsQ0FBQzs7QUFFeEYsUUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQ2YsZUFBUyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDMUI7QUFDRCxRQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUU7QUFDZCxjQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUN6Qjs7QUFFRCxRQUFJLFlBQVksSUFBSSxnQkFBZ0IsRUFBRTtBQUNwQyxlQUFTLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUVuQixVQUFJLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUU7O0FBRXJCLFlBQUksT0FBTyxDQUFDLElBQUksS0FBSyxrQkFBa0IsRUFBRTs7QUFFdkMsaUJBQU8sQ0FBQyxNQUFNLEdBQUcsQUFBQyxXQUFXLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDOUQ7T0FDRjtLQUNGO0FBQ0QsUUFBSSxZQUFZLElBQUksY0FBYyxFQUFFO0FBQ2xDLGVBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQSxDQUFFLElBQUksQ0FBQyxDQUFDOzs7QUFHckQsY0FBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNuQjtBQUNELFFBQUksWUFBWSxJQUFJLGVBQWUsRUFBRTs7QUFFbkMsZUFBUyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQzs7QUFFbkIsY0FBUSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFBLENBQUUsSUFBSSxDQUFDLENBQUM7S0FDckQ7R0FDRjs7QUFFRCxTQUFPLE9BQU8sQ0FBQztDQUNoQixDQUFDOztBQUVGLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQzFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQzFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRyxVQUFTLEtBQUssRUFBRTtBQUNsRSxNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUMzQixNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0FBRzNCLE1BQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU87TUFDeEMsT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU87TUFDeEMsWUFBWSxHQUFHLE9BQU87TUFDdEIsV0FBVyxHQUFHLE9BQU8sQ0FBQzs7QUFFMUIsTUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sRUFBRTtBQUM5QixnQkFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDOzs7QUFHdkMsV0FBTyxXQUFXLENBQUMsT0FBTyxFQUFFO0FBQzFCLGlCQUFXLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7S0FDckU7R0FDRjs7QUFFRCxNQUFJLEtBQUssR0FBRztBQUNWLFFBQUksRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUk7QUFDMUIsU0FBSyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSzs7OztBQUk3QixrQkFBYyxFQUFFLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7QUFDOUMsbUJBQWUsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLFlBQVksSUFBSSxPQUFPLENBQUEsQ0FBRSxJQUFJLENBQUM7R0FDbEUsQ0FBQzs7QUFFRixNQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFO0FBQ3pCLGFBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztHQUNyQzs7QUFFRCxNQUFJLE9BQU8sRUFBRTtBQUNYLFFBQUksWUFBWSxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUM7O0FBRXRDLFFBQUksWUFBWSxDQUFDLElBQUksRUFBRTtBQUNyQixjQUFRLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDcEM7O0FBRUQsUUFBSSxZQUFZLENBQUMsS0FBSyxFQUFFO0FBQ3RCLGVBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztLQUMxQztBQUNELFFBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDekIsY0FBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQ3hDOzs7QUFHRCxRQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsSUFDM0IsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUM5QixnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDMUMsY0FBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN2QixlQUFTLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzlCO0dBQ0YsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQ2hDLFlBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztHQUNwQzs7QUFFRCxTQUFPLEtBQUssQ0FBQztDQUNkLENBQUM7O0FBRUYsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FDckMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVMsUUFBUSxFQUFFO0FBQ2pFLFNBQU8sUUFBUSxDQUFDLEtBQUssQ0FBQztDQUN2QixDQUFDOztBQUVGLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FDeEMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFVBQVMsSUFBSSxFQUFFOztBQUVoRSxNQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUM3QixTQUFPO0FBQ0wsb0JBQWdCLEVBQUUsSUFBSTtBQUN0QixRQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7QUFDaEIsU0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLO0dBQ25CLENBQUM7Q0FDSCxDQUFDOztBQUdGLFNBQVMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUU7QUFDekMsTUFBSSxDQUFDLEtBQUssU0FBUyxFQUFFO0FBQ25CLEtBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0dBQ2pCOzs7O0FBSUQsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDbEIsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDMUIsTUFBSSxDQUFDLElBQUksRUFBRTtBQUNULFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0FBRUQsTUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGtCQUFrQixFQUFFO0FBQ3BDLFdBQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLEdBQUksWUFBWSxHQUFLLGdCQUFnQixDQUFDLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUN2RjtDQUNGO0FBQ0QsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRTtBQUN6QyxNQUFJLENBQUMsS0FBSyxTQUFTLEVBQUU7QUFDbkIsS0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0dBQ1I7O0FBRUQsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7TUFDbEIsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDMUIsTUFBSSxDQUFDLElBQUksRUFBRTtBQUNULFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0FBRUQsTUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGtCQUFrQixFQUFFO0FBQ3BDLFdBQU8sQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLEdBQUksWUFBWSxHQUFLLGdCQUFnQixDQUFDLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUN2RjtDQUNGOzs7Ozs7Ozs7QUFTRCxTQUFTLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRTtBQUNwQyxNQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFDLE1BQUksQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxrQkFBa0IsSUFBSyxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUMsYUFBYSxBQUFDLEVBQUU7QUFDM0YsV0FBTztHQUNSOztBQUVELE1BQUksUUFBUSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDN0IsU0FBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEdBQUksTUFBTSxHQUFLLGVBQWUsQUFBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ25GLFNBQU8sQ0FBQyxhQUFhLEdBQUcsT0FBTyxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUM7Q0FDcEQ7Ozs7Ozs7OztBQVNELFNBQVMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFO0FBQ25DLE1BQUksT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN4RCxNQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssa0JBQWtCLElBQUssQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDLFlBQVksQUFBQyxFQUFFO0FBQzFGLFdBQU87R0FDUjs7O0FBR0QsTUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUM3QixTQUFPLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsR0FBSSxNQUFNLEdBQUssU0FBUyxBQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDN0UsU0FBTyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNsRCxTQUFPLE9BQU8sQ0FBQyxZQUFZLENBQUM7Q0FDN0I7O3FCQUVjLGlCQUFpQjs7Ozs7Ozs7Ozs7OztnQ0N2TkwscUJBQXFCOzs7O0FBRXpDLFNBQVMseUJBQXlCLENBQUMsUUFBUSxFQUFFO0FBQ2xELGdDQUFlLFFBQVEsQ0FBQyxDQUFDO0NBQzFCOzs7Ozs7OztxQkNKb0IsVUFBVTs7cUJBRWhCLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsVUFBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7QUFDM0UsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2IsUUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7QUFDbkIsV0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDcEIsU0FBRyxHQUFHLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTs7QUFFL0IsWUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztBQUNsQyxpQkFBUyxDQUFDLFFBQVEsR0FBRyxjQUFPLEVBQUUsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzFELFlBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDL0IsaUJBQVMsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzlCLGVBQU8sR0FBRyxDQUFDO09BQ1osQ0FBQztLQUNIOztBQUVELFNBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7O0FBRTdDLFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7QUNwQkQsSUFBTSxVQUFVLEdBQUcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFbkcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUNoQyxNQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUc7TUFDdEIsSUFBSSxZQUFBO01BQ0osTUFBTSxZQUFBLENBQUM7QUFDWCxNQUFJLEdBQUcsRUFBRTtBQUNQLFFBQUksR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUN0QixVQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRTFCLFdBQU8sSUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxNQUFNLENBQUM7R0FDeEM7O0FBRUQsTUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7O0FBRzFELE9BQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2hELFFBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDOUM7OztBQUdELE1BQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0FBQzNCLFNBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDMUM7O0FBRUQsTUFBSTtBQUNGLFFBQUksR0FBRyxFQUFFO0FBQ1AsVUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7Ozs7QUFJdkIsVUFBSSxNQUFNLENBQUMsY0FBYyxFQUFFO0FBQ3pCLGNBQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRTtBQUNwQyxlQUFLLEVBQUUsTUFBTTtBQUNiLG9CQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUM7T0FDSixNQUFNO0FBQ0wsWUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7T0FDdEI7S0FDRjtHQUNGLENBQUMsT0FBTyxHQUFHLEVBQUU7O0dBRWI7Q0FDRjs7QUFFRCxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7O3FCQUVuQixTQUFTOzs7Ozs7Ozs7Ozs7O3lDQ2hEZSxnQ0FBZ0M7Ozs7MkJBQzlDLGdCQUFnQjs7OztvQ0FDUCwwQkFBMEI7Ozs7eUJBQ3JDLGNBQWM7Ozs7MEJBQ2IsZUFBZTs7Ozs2QkFDWixrQkFBa0I7Ozs7MkJBQ3BCLGdCQUFnQjs7OztBQUVsQyxTQUFTLHNCQUFzQixDQUFDLFFBQVEsRUFBRTtBQUMvQyx5Q0FBMkIsUUFBUSxDQUFDLENBQUM7QUFDckMsMkJBQWEsUUFBUSxDQUFDLENBQUM7QUFDdkIsb0NBQXNCLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLHlCQUFXLFFBQVEsQ0FBQyxDQUFDO0FBQ3JCLDBCQUFZLFFBQVEsQ0FBQyxDQUFDO0FBQ3RCLDZCQUFlLFFBQVEsQ0FBQyxDQUFDO0FBQ3pCLDJCQUFhLFFBQVEsQ0FBQyxDQUFDO0NBQ3hCOzs7Ozs7OztxQkNoQnFELFVBQVU7O3FCQUVqRCxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN2RSxRQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTztRQUN6QixFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFcEIsUUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFO0FBQ3BCLGFBQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2pCLE1BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7QUFDL0MsYUFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDdEIsTUFBTSxJQUFJLGVBQVEsT0FBTyxDQUFDLEVBQUU7QUFDM0IsVUFBSSxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUN0QixZQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixpQkFBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM5Qjs7QUFFRCxlQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztPQUNoRCxNQUFNO0FBQ0wsZUFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDdEI7S0FDRixNQUFNO0FBQ0wsVUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDL0IsWUFBSSxJQUFJLEdBQUcsbUJBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JDLFlBQUksQ0FBQyxXQUFXLEdBQUcseUJBQWtCLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM3RSxlQUFPLEdBQUcsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUM7T0FDeEI7O0FBRUQsYUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzdCO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7cUJDL0I4RSxVQUFVOzt5QkFDbkUsY0FBYzs7OztxQkFFckIsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsVUFBUyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3pELFFBQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixZQUFNLDJCQUFjLDZCQUE2QixDQUFDLENBQUM7S0FDcEQ7O0FBRUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUU7UUFDZixPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU87UUFDekIsQ0FBQyxHQUFHLENBQUM7UUFDTCxHQUFHLEdBQUcsRUFBRTtRQUNSLElBQUksWUFBQTtRQUNKLFdBQVcsWUFBQSxDQUFDOztBQUVoQixRQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixpQkFBVyxHQUFHLHlCQUFrQixPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0tBQ2pGOztBQUVELFFBQUksa0JBQVcsT0FBTyxDQUFDLEVBQUU7QUFBRSxhQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUFFOztBQUUxRCxRQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFDaEIsVUFBSSxHQUFHLG1CQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsQzs7QUFFRCxhQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtBQUN6QyxVQUFJLElBQUksRUFBRTtBQUNSLFlBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO0FBQ2pCLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLFlBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxLQUFLLENBQUMsQ0FBQztBQUN6QixZQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM7O0FBRW5CLFlBQUksV0FBVyxFQUFFO0FBQ2YsY0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQ3hDO09BQ0Y7O0FBRUQsU0FBRyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzdCLFlBQUksRUFBRSxJQUFJO0FBQ1YsbUJBQVcsRUFBRSxtQkFBWSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLFdBQVcsR0FBRyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDL0UsQ0FBQyxDQUFDO0tBQ0o7O0FBRUQsUUFBSSxPQUFPLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO0FBQzFDLFVBQUksZUFBUSxPQUFPLENBQUMsRUFBRTtBQUNwQixhQUFLLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2QyxjQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7QUFDaEIseUJBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQy9DO1NBQ0Y7T0FDRixNQUFNO0FBQ0wsWUFBSSxRQUFRLFlBQUEsQ0FBQzs7QUFFYixhQUFLLElBQUksR0FBRyxJQUFJLE9BQU8sRUFBRTtBQUN2QixjQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7QUFJL0IsZ0JBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQiwyQkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDaEM7QUFDRCxvQkFBUSxHQUFHLEdBQUcsQ0FBQztBQUNmLGFBQUMsRUFBRSxDQUFDO1dBQ0w7U0FDRjtBQUNELFlBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtBQUMxQix1QkFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3RDO09BQ0Y7S0FDRjs7QUFFRCxRQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDWCxTQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3JCOztBQUVELFdBQU8sR0FBRyxDQUFDO0dBQ1osQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7Ozs7Ozs7eUJDOUVxQixjQUFjOzs7O3FCQUVyQixVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxpQ0FBZ0M7QUFDdkUsUUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTs7QUFFMUIsYUFBTyxTQUFTLENBQUM7S0FDbEIsTUFBTTs7QUFFTCxZQUFNLDJCQUFjLG1CQUFtQixHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztLQUN2RjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ1ppQyxVQUFVOztxQkFFN0IsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBUyxXQUFXLEVBQUUsT0FBTyxFQUFFO0FBQzNELFFBQUksa0JBQVcsV0FBVyxDQUFDLEVBQUU7QUFBRSxpQkFBVyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7Ozs7QUFLdEUsUUFBSSxBQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxXQUFXLElBQUssZUFBUSxXQUFXLENBQUMsRUFBRTtBQUN2RSxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUIsTUFBTTtBQUNMLGFBQU8sT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN6QjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxVQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxVQUFTLFdBQVcsRUFBRSxPQUFPLEVBQUU7QUFDL0QsV0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLEVBQUMsQ0FBQyxDQUFDO0dBQ3ZILENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O3FCQ25CYyxVQUFTLFFBQVEsRUFBRTtBQUNoQyxVQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxrQ0FBaUM7QUFDOUQsUUFBSSxJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUM7UUFDbEIsT0FBTyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM3QyxVQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pCOztBQUVELFFBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNkLFFBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQzlCLFdBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1QixNQUFNLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUU7QUFDckQsV0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQzVCO0FBQ0QsUUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQzs7QUFFaEIsWUFBUSxDQUFDLEdBQUcsTUFBQSxDQUFaLFFBQVEsRUFBUyxJQUFJLENBQUMsQ0FBQztHQUN4QixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNsQmMsVUFBUyxRQUFRLEVBQUU7QUFDaEMsVUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQ3JELFdBQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkNKOEUsVUFBVTs7cUJBRTFFLFVBQVMsUUFBUSxFQUFFO0FBQ2hDLFVBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVMsT0FBTyxFQUFFLE9BQU8sRUFBRTtBQUN6RCxRQUFJLGtCQUFXLE9BQU8sQ0FBQyxFQUFFO0FBQUUsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FBRTs7QUFFMUQsUUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQzs7QUFFcEIsUUFBSSxDQUFDLGVBQVEsT0FBTyxDQUFDLEVBQUU7QUFDckIsVUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN4QixVQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUMvQixZQUFJLEdBQUcsbUJBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFlBQUksQ0FBQyxXQUFXLEdBQUcseUJBQWtCLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNoRjs7QUFFRCxhQUFPLEVBQUUsQ0FBQyxPQUFPLEVBQUU7QUFDakIsWUFBSSxFQUFFLElBQUk7QUFDVixtQkFBVyxFQUFFLG1CQUFZLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO09BQ2hFLENBQUMsQ0FBQztLQUNKLE1BQU07QUFDTCxhQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7R0FDRixDQUFDLENBQUM7Q0FDSjs7Ozs7Ozs7OztxQkN2QnFCLFNBQVM7O0FBRS9CLElBQUksTUFBTSxHQUFHO0FBQ1gsV0FBUyxFQUFFLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDO0FBQzdDLE9BQUssRUFBRSxNQUFNOzs7QUFHYixhQUFXLEVBQUUscUJBQVMsS0FBSyxFQUFFO0FBQzNCLFFBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO0FBQzdCLFVBQUksUUFBUSxHQUFHLGVBQVEsTUFBTSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUM5RCxVQUFJLFFBQVEsSUFBSSxDQUFDLEVBQUU7QUFDakIsYUFBSyxHQUFHLFFBQVEsQ0FBQztPQUNsQixNQUFNO0FBQ0wsYUFBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7T0FDN0I7S0FDRjs7QUFFRCxXQUFPLEtBQUssQ0FBQztHQUNkOzs7QUFHRCxLQUFHLEVBQUUsYUFBUyxLQUFLLEVBQWM7QUFDL0IsU0FBSyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRWxDLFFBQUksT0FBTyxPQUFPLEtBQUssV0FBVyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUMvRSxVQUFJLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLFVBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7O0FBQ3BCLGNBQU0sR0FBRyxLQUFLLENBQUM7T0FDaEI7O3dDQVBtQixPQUFPO0FBQVAsZUFBTzs7O0FBUTNCLGFBQU8sQ0FBQyxNQUFNLE9BQUMsQ0FBZixPQUFPLEVBQVksT0FBTyxDQUFDLENBQUM7S0FDN0I7R0FDRjtDQUNGLENBQUM7O3FCQUVhLE1BQU07Ozs7Ozs7Ozs7O3FCQ2pDTixVQUFTLFVBQVUsRUFBRTs7QUFFbEMsTUFBSSxJQUFJLEdBQUcsT0FBTyxNQUFNLEtBQUssV0FBVyxHQUFHLE1BQU0sR0FBRyxNQUFNO01BQ3RELFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDOztBQUVsQyxZQUFVLENBQUMsVUFBVSxHQUFHLFlBQVc7QUFDakMsUUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLFVBQVUsRUFBRTtBQUNsQyxVQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQztLQUMvQjtBQUNELFdBQU8sVUFBVSxDQUFDO0dBQ25CLENBQUM7Q0FDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkNac0IsU0FBUzs7SUFBcEIsS0FBSzs7eUJBQ0ssYUFBYTs7OztvQkFDOEIsUUFBUTs7QUFFbEUsU0FBUyxhQUFhLENBQUMsWUFBWSxFQUFFO0FBQzFDLE1BQU0sZ0JBQWdCLEdBQUcsWUFBWSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO01BQ3ZELGVBQWUsMEJBQW9CLENBQUM7O0FBRTFDLE1BQUksZ0JBQWdCLEtBQUssZUFBZSxFQUFFO0FBQ3hDLFFBQUksZ0JBQWdCLEdBQUcsZUFBZSxFQUFFO0FBQ3RDLFVBQU0sZUFBZSxHQUFHLHVCQUFpQixlQUFlLENBQUM7VUFDbkQsZ0JBQWdCLEdBQUcsdUJBQWlCLGdCQUFnQixDQUFDLENBQUM7QUFDNUQsWUFBTSwyQkFBYyx5RkFBeUYsR0FDdkcscURBQXFELEdBQUcsZUFBZSxHQUFHLG1EQUFtRCxHQUFHLGdCQUFnQixHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ2hLLE1BQU07O0FBRUwsWUFBTSwyQkFBYyx3RkFBd0YsR0FDdEcsaURBQWlELEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ25GO0dBQ0Y7Q0FDRjs7QUFFTSxTQUFTLFFBQVEsQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFOztBQUUxQyxNQUFJLENBQUMsR0FBRyxFQUFFO0FBQ1IsVUFBTSwyQkFBYyxtQ0FBbUMsQ0FBQyxDQUFDO0dBQzFEO0FBQ0QsTUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUU7QUFDdkMsVUFBTSwyQkFBYywyQkFBMkIsR0FBRyxPQUFPLFlBQVksQ0FBQyxDQUFDO0dBQ3hFOztBQUVELGNBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7Ozs7QUFJbEQsS0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUU1QyxXQUFTLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3ZELFFBQUksT0FBTyxDQUFDLElBQUksRUFBRTtBQUNoQixhQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsRCxVQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixlQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztPQUN2QjtLQUNGOztBQUVELFdBQU8sR0FBRyxHQUFHLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDdEUsUUFBSSxNQUFNLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUV4RSxRQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLE9BQU8sRUFBRTtBQUNqQyxhQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsZUFBZSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ3pGLFlBQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDM0Q7QUFDRCxRQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDbEIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLFlBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsYUFBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM1QyxjQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQzVCLGtCQUFNO1dBQ1A7O0FBRUQsZUFBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO0FBQ0QsY0FBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7T0FDM0I7QUFDRCxhQUFPLE1BQU0sQ0FBQztLQUNmLE1BQU07QUFDTCxZQUFNLDJCQUFjLGNBQWMsR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLDBEQUEwRCxDQUFDLENBQUM7S0FDakg7R0FDRjs7O0FBR0QsTUFBSSxTQUFTLEdBQUc7QUFDZCxVQUFNLEVBQUUsZ0JBQVMsR0FBRyxFQUFFLElBQUksRUFBRTtBQUMxQixVQUFJLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQSxBQUFDLEVBQUU7QUFDbEIsY0FBTSwyQkFBYyxHQUFHLEdBQUcsSUFBSSxHQUFHLG1CQUFtQixHQUFHLEdBQUcsQ0FBQyxDQUFDO09BQzdEO0FBQ0QsYUFBTyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDbEI7QUFDRCxVQUFNLEVBQUUsZ0JBQVMsTUFBTSxFQUFFLElBQUksRUFBRTtBQUM3QixVQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQzFCLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDNUIsWUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRTtBQUN4QyxpQkFBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7T0FDRjtLQUNGO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDakMsYUFBTyxPQUFPLE9BQU8sS0FBSyxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7S0FDeEU7O0FBRUQsb0JBQWdCLEVBQUUsS0FBSyxDQUFDLGdCQUFnQjtBQUN4QyxpQkFBYSxFQUFFLG9CQUFvQjs7QUFFbkMsTUFBRSxFQUFFLFlBQVMsQ0FBQyxFQUFFO0FBQ2QsVUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLFNBQUcsQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN2QyxhQUFPLEdBQUcsQ0FBQztLQUNaOztBQUVELFlBQVEsRUFBRSxFQUFFO0FBQ1osV0FBTyxFQUFFLGlCQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRTtBQUNuRSxVQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztVQUNqQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixVQUFJLElBQUksSUFBSSxNQUFNLElBQUksV0FBVyxJQUFJLG1CQUFtQixFQUFFO0FBQ3hELHNCQUFjLEdBQUcsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7T0FDM0YsTUFBTSxJQUFJLENBQUMsY0FBYyxFQUFFO0FBQzFCLHNCQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztPQUM5RDtBQUNELGFBQU8sY0FBYyxDQUFDO0tBQ3ZCOztBQUVELFFBQUksRUFBRSxjQUFTLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDM0IsYUFBTyxLQUFLLElBQUksS0FBSyxFQUFFLEVBQUU7QUFDdkIsYUFBSyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7T0FDdkI7QUFDRCxhQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0QsU0FBSyxFQUFFLGVBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUM3QixVQUFJLEdBQUcsR0FBRyxLQUFLLElBQUksTUFBTSxDQUFDOztBQUUxQixVQUFJLEtBQUssSUFBSSxNQUFNLElBQUssS0FBSyxLQUFLLE1BQU0sQUFBQyxFQUFFO0FBQ3pDLFdBQUcsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDdkM7O0FBRUQsYUFBTyxHQUFHLENBQUM7S0FDWjs7QUFFRCxlQUFXLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7O0FBRTVCLFFBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUk7QUFDakIsZ0JBQVksRUFBRSxZQUFZLENBQUMsUUFBUTtHQUNwQyxDQUFDOztBQUVGLFdBQVMsR0FBRyxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2hDLFFBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7O0FBRXhCLE9BQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEIsUUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUM1QyxVQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztLQUNoQztBQUNELFFBQUksTUFBTSxZQUFBO1FBQ04sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLEdBQUcsRUFBRSxHQUFHLFNBQVMsQ0FBQztBQUMvRCxRQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUU7QUFDMUIsVUFBSSxPQUFPLENBQUMsTUFBTSxFQUFFO0FBQ2xCLGNBQU0sR0FBRyxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztPQUMzRixNQUFNO0FBQ0wsY0FBTSxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7T0FDcEI7S0FDRjs7QUFFRCxhQUFTLElBQUksQ0FBQyxPQUFPLGdCQUFlO0FBQ2xDLGFBQU8sRUFBRSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNySDtBQUNELFFBQUksR0FBRyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3RHLFdBQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUMvQjtBQUNELEtBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDOztBQUVqQixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQzdCLFFBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQ3BCLGVBQVMsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFbEUsVUFBSSxZQUFZLENBQUMsVUFBVSxFQUFFO0FBQzNCLGlCQUFTLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7T0FDdEU7QUFDRCxVQUFJLFlBQVksQ0FBQyxVQUFVLElBQUksWUFBWSxDQUFDLGFBQWEsRUFBRTtBQUN6RCxpQkFBUyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQzVFO0tBQ0YsTUFBTTtBQUNMLGVBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUNwQyxlQUFTLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsZUFBUyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0tBQzNDO0dBQ0YsQ0FBQzs7QUFFRixLQUFHLENBQUMsTUFBTSxHQUFHLFVBQVMsQ0FBQyxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQ2xELFFBQUksWUFBWSxDQUFDLGNBQWMsSUFBSSxDQUFDLFdBQVcsRUFBRTtBQUMvQyxZQUFNLDJCQUFjLHdCQUF3QixDQUFDLENBQUM7S0FDL0M7QUFDRCxRQUFJLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDckMsWUFBTSwyQkFBYyx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hEOztBQUVELFdBQU8sV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQ2pGLENBQUM7QUFDRixTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLFNBQVMsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQzVGLFdBQVMsSUFBSSxDQUFDLE9BQU8sRUFBZ0I7UUFBZCxPQUFPLHlEQUFHLEVBQUU7O0FBQ2pDLFFBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQztBQUMzQixRQUFJLE1BQU0sSUFBSSxPQUFPLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxLQUFLLFNBQVMsQ0FBQyxXQUFXLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQSxBQUFDLEVBQUU7QUFDaEcsbUJBQWEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMxQzs7QUFFRCxXQUFPLEVBQUUsQ0FBQyxTQUFTLEVBQ2YsT0FBTyxFQUNQLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFDckMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQ3BCLFdBQVcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEVBQ3hELGFBQWEsQ0FBQyxDQUFDO0dBQ3BCOztBQUVELE1BQUksR0FBRyxpQkFBaUIsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUV6RSxNQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNqQixNQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN4QyxNQUFJLENBQUMsV0FBVyxHQUFHLG1CQUFtQixJQUFJLENBQUMsQ0FBQztBQUM1QyxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVNLFNBQVMsY0FBYyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3hELE1BQUksQ0FBQyxPQUFPLEVBQUU7QUFDWixRQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLEVBQUU7QUFDckMsYUFBTyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDekMsTUFBTTtBQUNMLGFBQU8sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxQztHQUNGLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFOztBQUV6QyxXQUFPLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztBQUN2QixXQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUNyQztBQUNELFNBQU8sT0FBTyxDQUFDO0NBQ2hCOztBQUVNLFNBQVMsYUFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFOztBQUV2RCxNQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUMxRSxTQUFPLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN2QixNQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDZixXQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO0dBQ3ZFOztBQUVELE1BQUksWUFBWSxZQUFBLENBQUM7QUFDakIsTUFBSSxPQUFPLENBQUMsRUFBRSxJQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFOztBQUNyQyxhQUFPLENBQUMsSUFBSSxHQUFHLGtCQUFZLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFekMsVUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQztBQUNwQixrQkFBWSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsU0FBUyxtQkFBbUIsQ0FBQyxPQUFPLEVBQWdCO1lBQWQsT0FBTyx5REFBRyxFQUFFOzs7O0FBSS9GLGVBQU8sQ0FBQyxJQUFJLEdBQUcsa0JBQVksT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLGVBQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsbUJBQW1CLENBQUM7QUFDcEQsZUFBTyxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQzdCLENBQUM7QUFDRixVQUFJLEVBQUUsQ0FBQyxRQUFRLEVBQUU7QUFDZixlQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO09BQ3BFOztHQUNGOztBQUVELE1BQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxZQUFZLEVBQUU7QUFDekMsV0FBTyxHQUFHLFlBQVksQ0FBQztHQUN4Qjs7QUFFRCxNQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7QUFDekIsVUFBTSwyQkFBYyxjQUFjLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDO0dBQzVFLE1BQU0sSUFBSSxPQUFPLFlBQVksUUFBUSxFQUFFO0FBQ3RDLFdBQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUNsQztDQUNGOztBQUVNLFNBQVMsSUFBSSxHQUFHO0FBQUUsU0FBTyxFQUFFLENBQUM7Q0FBRTs7QUFFckMsU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtBQUMvQixNQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQSxBQUFDLEVBQUU7QUFDOUIsUUFBSSxHQUFHLElBQUksR0FBRyxrQkFBWSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDckMsUUFBSSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7R0FDckI7QUFDRCxTQUFPLElBQUksQ0FBQztDQUNiOztBQUVELFNBQVMsaUJBQWlCLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDekUsTUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFO0FBQ2hCLFFBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNmLFFBQUksR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM1RixTQUFLLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztHQUMzQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7O0FDdlJELFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRTtBQUMxQixNQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztDQUN0Qjs7QUFFRCxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXO0FBQ3ZFLFNBQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDekIsQ0FBQzs7cUJBRWEsVUFBVTs7Ozs7Ozs7Ozs7Ozs7O0FDVHpCLElBQU0sTUFBTSxHQUFHO0FBQ2IsS0FBRyxFQUFFLE9BQU87QUFDWixLQUFHLEVBQUUsTUFBTTtBQUNYLEtBQUcsRUFBRSxNQUFNO0FBQ1gsS0FBRyxFQUFFLFFBQVE7QUFDYixLQUFHLEVBQUUsUUFBUTtBQUNiLEtBQUcsRUFBRSxRQUFRO0FBQ2IsS0FBRyxFQUFFLFFBQVE7Q0FDZCxDQUFDOztBQUVGLElBQU0sUUFBUSxHQUFHLFlBQVk7SUFDdkIsUUFBUSxHQUFHLFdBQVcsQ0FBQzs7QUFFN0IsU0FBUyxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ3ZCLFNBQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ3BCOztBQUVNLFNBQVMsTUFBTSxDQUFDLEdBQUcsb0JBQW1CO0FBQzNDLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3pDLFNBQUssSUFBSSxHQUFHLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzVCLFVBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtBQUMzRCxXQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzlCO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaOztBQUVNLElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDOzs7Ozs7QUFLaEQsSUFBSSxVQUFVLEdBQUcsb0JBQVMsS0FBSyxFQUFFO0FBQy9CLFNBQU8sT0FBTyxLQUFLLEtBQUssVUFBVSxDQUFDO0NBQ3BDLENBQUM7OztBQUdGLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ25CLFVBSU0sVUFBVSxHQUpoQixVQUFVLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDM0IsV0FBTyxPQUFPLEtBQUssS0FBSyxVQUFVLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxtQkFBbUIsQ0FBQztHQUNwRixDQUFDO0NBQ0g7UUFDTyxVQUFVLEdBQVYsVUFBVTs7Ozs7QUFJWCxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLFVBQVMsS0FBSyxFQUFFO0FBQ3RELFNBQU8sQUFBQyxLQUFLLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxHQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0NBQ2pHLENBQUM7Ozs7O0FBR0ssU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNwQyxPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hELFFBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUN0QixhQUFPLENBQUMsQ0FBQztLQUNWO0dBQ0Y7QUFDRCxTQUFPLENBQUMsQ0FBQyxDQUFDO0NBQ1g7O0FBR00sU0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7QUFDdkMsTUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7O0FBRTlCLFFBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7QUFDM0IsYUFBTyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7S0FDeEIsTUFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7QUFDekIsYUFBTyxFQUFFLENBQUM7S0FDWCxNQUFNLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDbEIsYUFBTyxNQUFNLEdBQUcsRUFBRSxDQUFDO0tBQ3BCOzs7OztBQUtELFVBQU0sR0FBRyxFQUFFLEdBQUcsTUFBTSxDQUFDO0dBQ3RCOztBQUVELE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQUUsV0FBTyxNQUFNLENBQUM7R0FBRTtBQUM5QyxTQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0NBQzdDOztBQUVNLFNBQVMsT0FBTyxDQUFDLEtBQUssRUFBRTtBQUM3QixNQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDekIsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO0FBQy9DLFdBQU8sSUFBSSxDQUFDO0dBQ2IsTUFBTTtBQUNMLFdBQU8sS0FBSyxDQUFDO0dBQ2Q7Q0FDRjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxNQUFNLEVBQUU7QUFDbEMsTUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMvQixPQUFLLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN2QixTQUFPLEtBQUssQ0FBQztDQUNkOztBQUVNLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUU7QUFDdkMsUUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7QUFDbEIsU0FBTyxNQUFNLENBQUM7Q0FDZjs7QUFFTSxTQUFTLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxFQUFFLEVBQUU7QUFDakQsU0FBTyxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQSxHQUFJLEVBQUUsQ0FBQztDQUNwRDs7OztBQzNHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3Qgcm9vdFJlZHVjZXIgPSAoc3RhdGUgPSBbXSwgYWN0aW9uKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVUERBVEVfREVQRU5ERU5DWV9EUk9QRE9XTic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5RmllbGROYW1lOiBhY3Rpb24uZmllbGROYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnQ0xFQVJfREVQRU5ERU5DWV9EUk9QRE9XTic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5RmllbGROYW1lOiBhY3Rpb24uZmllbGROYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCByb290UmVkdWNlcjsiLCJpbXBvcnQgcm9vdFJlZHVjZXIgZnJvbSBcIi4vZGVwZW5kZWQtZHJvcGRvd24tcmVkdWNlclwiO1xuaW1wb3J0IHtjcmVhdGVTdG9yZSwgYXBwbHlNaWRkbGV3YXJlfSBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IGNvbXBvc2VXaXRoRGV2VG9vbHMgfSBmcm9tICdyZWR1eC1kZXZ0b29scy1leHRlbnNpb24nO1xuXG5jb25zdCBjb21wb3NlRW5oYW5jZXJzID0gY29tcG9zZVdpdGhEZXZUb29scyh7fSk7XG5cbmNvbnN0IGN1c3RvbU1pZGRsZVdhcmUgPSBzdG9yZSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XG4gICAgbmV4dChhY3Rpb24pO1xufTtcblxuY29uc3QgZGVwZW5kZWREcm9wZG93blN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgcm9vdFJlZHVjZXIsXG4gICAgY29tcG9zZUVuaGFuY2VycyhhcHBseU1pZGRsZXdhcmUoY3VzdG9tTWlkZGxlV2FyZSkpXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBkZXBlbmRlZERyb3Bkb3duU3RvcmU7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBJbnB1dFJlbGF0aW9uYWxTZWFyY2hhYmxlIGZyb20gXCIuLi8uLi9pbnB1dC9yZWxhdGlvbmFsLXNlYXJjaGFibGUuanN4XCI7XG5cbmNsYXNzIERlcGVuZGVkUmVsYXRpb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIG9uU2VsZWN0Q2FsbGJhY2sgPSAoZmllbGROYW1lLCBmaWVsZFZhbHVlKSA9PiB7XG4gICAgICBjb25zdCB7IG9uQ2hhbmdlQ2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgIG9uQ2hhbmdlQ2FsbGJhY2suYXBwbHkodGhpcywgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgZmllbGRzLCBmaWVsZE5hbWUsIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50LCByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGUsIGkxOG4gfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IGZpZWxkID0gZmllbGRzID8gZmllbGRzLmZpbmQoZmllbGQgPT4gZmllbGQuZmllbGROYW1lID09PSBmaWVsZE5hbWUpIDogdGhpcy5wcm9wcztcblxuICAgIHJldHVybiA8SW5wdXRSZWxhdGlvbmFsU2VhcmNoYWJsZVxuICAgICAgICAgICAgICAgIGRhdGE9e3sgLi4uZmllbGQgfX1cbiAgICAgICAgICAgICAgICBvblNlbGVjdENhbGxiYWNrPXt0aGlzLm9uU2VsZWN0Q2FsbGJhY2t9XG4gICAgICAgICAgICAgICAgb25Db21wb25lbnREaWRNb3VudD17cmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnR9XG4gICAgICAgICAgICAgICAgb25Db21wb25lbnREaWRVcGRhdGU9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZX1cbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgIC8+O1xuICB9XG59XG5cbkRlcGVuZGVkUmVsYXRpb24ucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkczogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZXBlbmRlZFJlbGF0aW9uOyIsImltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgRGVwZW5kZWRSZWxhdGlvbiBmcm9tICcuL2RlcGVuZGVkLXJlbGF0aW9uLmpzeCc7XG5pbXBvcnQgZGVwZW5kZWREcm9wZG93blN0b3JlIGZyb20gJy4vZGVwZW5kZWQtZHJvcGRvd24tc3RvcmUnO1xuXG4vLyBFeGFtcGxlIGZyb206IGh0dHBzOi8vcmVkdXguanMub3JnL2Jhc2ljcy9leGFtcGxlLXRvZG8tbGlzdFxuXG5jb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBzdGF0ZSA9PiAoe1xuICAgIGZpZWxkczogc3RhdGUuZmllbGRzLFxuICAgIGRlcGVuZGVuY3lGaWVsZE5hbWU6IHN0YXRlLmZpZWxkTmFtZSxcbiAgICBmaWVsZFZhbHVlczogc3RhdGUuZmllbGRWYWx1ZXMsXG4gICAgaXNSZWFkT25seTogc3RhdGUuaXNSZWFkT25seSxcbiAgICBmaWVsZFZhbHVlOiBzdGF0ZS5maWVsZFZhbHVlLFxuICAgIGlzTnVsbGFibGU6IHN0YXRlLmlzTnVsbGFibGUsXG4gICAgdGltZXN0YW1wOiBzdGF0ZS50aW1lc3RhbXBcbn0pO1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2gsIHByb3BzKSA9PiAoe1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChmaWVsZE5hbWUsIGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgbGV0IHsgZmV0Y2hEYXRhIH0gPSBwcm9wcyxcbiAgICAgICAgICAgICAgc3RhdGUgPSBkZXBlbmRlZERyb3Bkb3duU3RvcmUuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgICAgZmllbGRzID0gc3RhdGUuZmllbGRzLFxuICAgICAgICAgICAgICBkaWRUcmlnZ2VyQW5FdmVudCA9IGZhbHNlLFxuICAgICAgICAgICAgICBjdXJyZW50RmllbGQ7XG5cbiAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmZpZWxkTmFtZSA9PT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuZmllbGRWYWx1ZSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmRlcGVuZGVkRnJvbSAmJiBmaWVsZC5kZXBlbmRlZEZyb20uaW5kZXhPZihmaWVsZE5hbWUpID09PSAwICkge1xuICAgICAgICAgICAgICAgIGZldGNoRGF0YShmaWVsZE5hbWUsIGZpZWxkVmFsdWUpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZmllbGRWYWx1ZXMgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5maWVsZFZhbHVlID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1VQREFURV9ERVBFTkRFTkNZX0RST1BET1dOJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGQuZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZXM6IGZpZWxkLmZpZWxkVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWFkT25seTogZmllbGQuaXNSZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkLmZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc051bGxhYmxlOiBmaWVsZC5pc051bGxhYmxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICBkaWRUcmlnZ2VyQW5FdmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQuZGVwZW5kZWRGcm9tICYmIGZpZWxkLmRlcGVuZGVkRnJvbS5pbmRleE9mKGZpZWxkTmFtZSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuZmllbGRWYWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDTEVBUl9ERVBFTkRFTkNZX0RST1BET1dOJyxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkLmZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZXM6IGZpZWxkLmZpZWxkVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICBpc1JlYWRPbmx5OiBmaWVsZC5pc1JlYWRPbmx5LFxuICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZC5maWVsZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpc051bGxhYmxlOiBmaWVsZC5pc051bGxhYmxlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFkaWRUcmlnZ2VyQW5FdmVudCkge1xuICAgICAgICAgICAgY3VycmVudEZpZWxkID0gZmllbGRzLmZpbmQoZmllbGQgPT4gZmllbGQuZmllbGROYW1lID09PSBmaWVsZE5hbWUpO1xuXG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1VQREFURV9ERVBFTkRFTkNZX0RST1BET1dOJyxcbiAgICAgICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICAgICAgZmllbGROYW1lOiBjdXJyZW50RmllbGQuZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzOiBjdXJyZW50RmllbGQuZmllbGRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seTogY3VycmVudEZpZWxkLmlzUmVhZE9ubHksXG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZTogY3VycmVudEZpZWxkLmZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgaXNOdWxsYWJsZTogY3VycmVudEZpZWxkLmlzTnVsbGFibGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbnN0IG1lcmdlUHJvcHMgPSBmdW5jdGlvbiAoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3duUHJvcHMsIHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMpO1xufVxuXG5jb25zdCBQcm92aWRlckRlcGVuZGVkUmVsYXRpb24gPSBjb25uZWN0KFxuICAgIG1hcFN0YXRlVG9Qcm9wcyxcbiAgICBtYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgbWVyZ2VQcm9wc1xuKShEZXBlbmRlZFJlbGF0aW9uKTtcblxuZXhwb3J0IHsgUHJvdmlkZXJEZXBlbmRlZFJlbGF0aW9uLCBkZXBlbmRlZERyb3Bkb3duU3RvcmUgfTsiLCJjbGFzcyBMaW5rZWRWYWx1ZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdmFyIHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdmFyIHsgZmllbGRWYWx1ZSB9ID0gbmV4dFByb3BzLmRhdGE7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlID8gZmllbGRWYWx1ZSA6ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rZWRWYWx1ZTsiLCJpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3JlYWN0LXJlZHV4JztcblxuaW1wb3J0IElucHV0VGV4dCBmcm9tICcuL2lucHV0L3RleHQuanN4JztcbmltcG9ydCBJbnB1dFRleHRhcmVhIGZyb20gJy4vaW5wdXQvdGV4dGFyZWEuanN4JztcbmltcG9ydCBJbnB1dFRleHRlZGl0b3IgZnJvbSAnLi9pbnB1dC9yaWNoLXRleHRlZGl0b3IuanN4JztcbmltcG9ydCBJbnB1dERhdGUgZnJvbSAnLi9pbnB1dC9kYXRlLmpzeCc7XG5pbXBvcnQgSW5wdXREYXRldGltZSBmcm9tICcuL2lucHV0L2RhdGV0aW1lLmpzeCc7XG5pbXBvcnQgSW5wdXRFbnVtIGZyb20gJy4vaW5wdXQvZW51bS5qc3gnO1xuaW1wb3J0IElucHV0RW51bVNlYXJjaGFibGUgZnJvbSAnLi9pbnB1dC9lbnVtLXNlYXJjaGFibGUuanN4JztcbmltcG9ydCBJbnB1dERyb3Bkb3duIGZyb20gJy4vaW5wdXQvZHJvcGRvd24uanN4JztcbmltcG9ydCBJbnB1dERyb3Bkb3duU2VhcmNoYWJsZSBmcm9tICcuL2lucHV0L2Ryb3Bkb3duLXNlYXJjaGFibGUuanN4JztcbmltcG9ydCBJbnB1dFJlbGF0aW9uYWxTZWFyY2hhYmxlIGZyb20gJy4vaW5wdXQvcmVsYXRpb25hbC1zZWFyY2hhYmxlLmpzeCc7XG5pbXBvcnQgSW5wdXRSZWxhdGlvbmFsTmF0aXZlIGZyb20gJy4vaW5wdXQvcmVsYXRpb25hbC1uYXRpdmUuanN4JztcbmltcG9ydCBJbnB1dFVwbG9hZCBmcm9tICcuL2lucHV0L3VwbG9hZC5qc3gnO1xuaW1wb3J0IElucHV0UmVsYXRpb25OdG9OIGZyb20gJy4vaW5wdXQvcmVsYXRpb24tbi1uLmpzeCc7XG5pbXBvcnQgSW5wdXRTZWFyY2hhYmxlUmVsYXRpb25OdG9OIGZyb20gJy4vaW5wdXQvc2VhcmNoYWJsZS1yZWxhdGlvbi1uLW4uanN4JztcbmltcG9ydCBJbnB1dE51bWVyaWMgZnJvbSAnLi9pbnB1dC9udW1lcmljLmpzeCc7XG5pbXBvcnQgSW5wdXRDaGVja2JveEJvb2xlYW4gZnJvbSAnLi9pbnB1dC9jaGVja2JveC1ib29sZWFuLmpzeCc7XG5pbXBvcnQgSW5wdXRFbWFpbCBmcm9tICcuL2lucHV0L2VtYWlsLmpzeCc7XG5pbXBvcnQgSW5wdXRDb2xvciBmcm9tICcuL2lucHV0L2NvbG9yLmpzeCc7XG5pbXBvcnQgSW5wdXRQYXNzd29yZCBmcm9tICcuL2lucHV0L3Bhc3N3b3JkLmpzeCc7XG5pbXBvcnQgSW5wdXRVcmwgZnJvbSAnLi9pbnB1dC91cmwuanN4JztcbmltcG9ydCBJbnB1dEJhY2tlbmRDYWxsYmFjayBmcm9tICcuL2lucHV0L2JhY2tlbmQtY2FsbGJhY2suanMnO1xuaW1wb3J0IElucHV0TXVsdGlzZWxlY3RTZWFyY2hhYmxlIGZyb20gJy4vaW5wdXQvbXVsdGlzZWxlY3Qtc2VhcmNoYWJsZS5qcyc7XG5pbXBvcnQgSW5wdXRNdWx0aXNlbGVjdCBmcm9tICcuL2lucHV0L211bHRpc2VsZWN0JztcbmltcG9ydCBEZXBlbmRlZFJlbGF0aW9uIGZyb20gJy4vY29tcG9uZW50cy9kZXBlbmRlZC1yZWxhdGlvbi9kZXBlbmRlZC1yZWxhdGlvbi5qc3gnO1xuXG5pbXBvcnQgeyBQcm92aWRlckRlcGVuZGVkUmVsYXRpb24sIGRlcGVuZGVkRHJvcGRvd25TdG9yZSB9IGZyb20gJy4vY29tcG9uZW50cy9kZXBlbmRlZC1yZWxhdGlvbi9wcm92aWRlci1kZXBlbmRlZC1yZWxhdGlvbic7XG5cbmNsYXNzIEZpZWxkSW5wdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgX190eXBlX2VtYWlsKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0RW1haWwga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV91cmwoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRVcmwga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9jb2xvcihmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dENvbG9yIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfcGFzc3dvcmQoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRQYXNzd29yZCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX2NoZWNrYm94X2Jvb2xlYW4oZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRDaGVja2JveEJvb2xlYW4ga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9kcm9wZG93bihmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dERyb3Bkb3duIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfZHJvcGRvd25fc2VhcmNoKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0RHJvcGRvd25TZWFyY2hhYmxlIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfZW51bShmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dEVudW0ga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9tdWx0aXNlbGVjdF9zZWFyY2hhYmxlKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0TXVsdGlzZWxlY3RTZWFyY2hhYmxlIGtleT17ZmllbGROYW1lfSBkYXRhPXtkYXRhfSAvPjtcbiAgICB9XG5cbiAgICBfX3R5cGVfbXVsdGlzZWxlY3RfbmF0aXZlKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0TXVsdGlzZWxlY3Qga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9lbnVtX3NlYXJjaGFibGUoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiA8SW5wdXRFbnVtU2VhcmNoYWJsZSBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX2ludChmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dE51bWVyaWMga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+O1xuICAgIH1cblxuICAgIF9fdHlwZV9yZWxhdGlvbmFsKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICBjb25zdCB7IGkxOG4sIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50LCByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiA8SW5wdXRSZWxhdGlvbmFsU2VhcmNoYWJsZVxuICAgICAgICAgICAga2V5PXtmaWVsZE5hbWV9XG4gICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgIG9uQ29tcG9uZW50RGlkTW91bnQ9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50fVxuICAgICAgICAgICAgb25Db21wb25lbnREaWRVcGRhdGU9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZX1cbiAgICAgICAgLz47XG4gICAgfVxuXG4gICAgX190eXBlX3JlbGF0aW9uYWxfbmF0aXZlKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0UmVsYXRpb25hbE5hdGl2ZSBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX3JlbGF0aW9uYWxfbl9uKGZpZWxkTmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gPElucHV0U2VhcmNoYWJsZVJlbGF0aW9uTnRvTiBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX25hdGl2ZV9yZWxhdGlvbmFsX25fbihmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dFJlbGF0aW9uTnRvTiBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxuXG4gICAgX190eXBlX251bWVyaWMoZmllbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fdHlwZV9pbnQoZmllbGROYW1lLCBkYXRhKTtcbiAgICB9XG5cbiAgICBfX3R5cGVfYmFja2VuZF9jYWxsYmFjayhmaWVsZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIDxJbnB1dEJhY2tlbmRDYWxsYmFjayBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0vPlxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcblxuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVHlwZSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZ2NydWRJbnN0YW5jZSwgZmV0Y2hEYXRhIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG5cbiAgICAgICAgaWYgKHRoaXNbJ19fdHlwZV8nICsgZmllbGRUeXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snX190eXBlXycgKyBmaWVsZFR5cGVdKGZpZWxkTmFtZSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL150ZXh0ZWRpdG9yJC9pLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDxJbnB1dFRleHRlZGl0b3IgZGF0YT17ZGF0YX0gLz47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL150ZXh0JC9pLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDxJbnB1dFRleHRhcmVhIGtleT17dGltZXN0YW1wfSBkYXRhPXtkYXRhfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXmRhdGUkL2kudGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0RGF0ZSBrZXk9e3RpbWVzdGFtcH0gZGF0YT17ZGF0YX0gZ2NydWRJbnN0YW5jZT17Z2NydWRJbnN0YW5jZX0gLz47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14oZGF0ZXRpbWV8dGltZXN0YW1wKSQvaS50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXREYXRldGltZSBrZXk9e3RpbWVzdGFtcH0gZGF0YT17ZGF0YX0gZ2NydWRJbnN0YW5jZT17Z2NydWRJbnN0YW5jZX0gLz5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXnVwbG9hZCQvaS50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRVcGxvYWQga2V5PXt0aW1lc3RhbXB9IGRhdGE9e2RhdGF9IGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9IG1heFVwbG9hZExpbWl0PXsxfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvXm11bHRpcGxlX3VwbG9hZCQvaS50ZXN0KGZpZWxkVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRVcGxvYWQga2V5PXt0aW1lc3RhbXB9IGRhdGE9e2RhdGF9IGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9IG1heFVwbG9hZExpbWl0PXsxMDB9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgLyppZiAoL2Jsb2IkL2kudGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0VXBsb2FkIGtleT17dGltZXN0YW1wfSBkYXRhPXtkYXRhfSBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfSBtYXhVcGxvYWRMaW1pdD17MX0gLz47XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmICgvXmRlcGVuZGVkX3JlbGF0aW9uYWwkLy50ZXN0KGZpZWxkVHlwZSkpIHtcblxuICAgICAgICAgICAgbGV0IGZpZWxkcyA9IGRlcGVuZGVkRHJvcGRvd25TdG9yZS5nZXRTdGF0ZSgpLmZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWVsZERhdGE7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgaTE4biwgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQsIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICAgICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGREYXRhID0gZmllbGRzLmZpbmQoZmllbGQgPT4gZmllbGQuZmllbGROYW1lID09PSBkYXRhLmZpZWxkTmFtZSk7XG5cbiAgICAgICAgICAgIGRhdGEuZmllbGRWYWx1ZXMgPSB0eXBlb2YgZGF0YS5maWVsZFZhbHVlID09PSAnb2JqZWN0JyA/IGRhdGEuZmllbGRWYWx1ZS5wZXJtaXR0ZWRWYWx1ZXMgOiBkYXRhLmZpZWxkVmFsdWVzO1xuICAgICAgICAgICAgZGF0YS5maWVsZFZhbHVlID0gdHlwZW9mIGRhdGEuZmllbGRWYWx1ZSA9PT0gJ29iamVjdCcgPyBkYXRhLmZpZWxkVmFsdWUudmFsdWUgOiBkYXRhLmZpZWxkVmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgdG8gbWFyayBpdCBhcyBhbHdheXMgbnVsbGFibGUgYXMgd2UgaGF2ZSBzb21lIGlzc3VlcyB3aXRoIHRoZSByZWZyZXNoIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICBkYXRhLmlzTnVsbGFibGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWZpZWxkRGF0YSkge1xuICAgICAgICAgICAgICAgIGZpZWxkRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lOiBkYXRhLmZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZXM6IGRhdGEuZmllbGRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IGRhdGEuaXNSZWFkT25seSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZTogZGF0YS5maWVsZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpc051bGxhYmxlOiBkYXRhLmlzTnVsbGFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVkRnJvbTogZGF0YS5vcHRpb25zLmRlcGVuZGVkRnJvbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGREYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZE5hbWUgPT09IGRhdGEuZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmZpZWxkVmFsdWVzID0gZGF0YS5maWVsZFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuaXNSZWFkT25seSA9IGRhdGEuaXNSZWFkT25seTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZmllbGRWYWx1ZSA9IGRhdGEuZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuaXNOdWxsYWJsZSA9IGRhdGEuaXNOdWxsYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVwZW5kZWREcm9wZG93blN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnVVBEQVRFX0RFUEVOREVOQ1lfRFJPUERPV04nLFxuICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGRhdGEuZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzOiBkYXRhLmZpZWxkVmFsdWVzLFxuICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IGRhdGEuaXNSZWFkT25seSxcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlOiBkYXRhLmZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgaXNOdWxsYWJsZTogZGF0YS5pc051bGxhYmxlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIDxQcm92aWRlciBzdG9yZT17ZGVwZW5kZWREcm9wZG93blN0b3JlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxQcm92aWRlckRlcGVuZGVkUmVsYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU9e2RhdGEuZmllbGROYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YT17ZmV0Y2hEYXRhfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQ9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZT17cmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9Qcm92aWRlcj47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPElucHV0VGV4dCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWVsZElucHV0O1xuIiwiXG5pbXBvcnQgRmllbGRSb3cgZnJvbSAnLi9maWVsZC1yb3cuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIEZpZWxkTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgICAgZ2NydWRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZldGNoRGF0YSxcbiAgICAgICAgICAgIEZpZWxkSW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBGaWVsZFJvd1dyYXBwZXIsXG4gICAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQsXG4gICAgICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGVcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMubWFwKGZ1bmN0aW9uIEZpZWxkc0ZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IGZpZWxkTmFtZSB9ID0gZmllbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8RmllbGRSb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhPXtmaWVsZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaERhdGE9e2ZldGNoRGF0YX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpZWxkSW5wdXRDb21wb25lbnQ9e0ZpZWxkSW5wdXRDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRmllbGRSb3dXcmFwcGVyPXtGaWVsZFJvd1dyYXBwZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudD17cmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlPXtyZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuXG4gICAgfVxufVxuXG5GaWVsZExpc3QucHJvcFR5cGVzID0ge1xuICAgIGdjcnVkSW5zdGFuY2U6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgRmllbGRJbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgRmllbGRSb3dXcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBmaWVsZHM6IFByb3BUeXBlcy5hcnJheSxcbiAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlOiBQcm9wVHlwZXMuZnVuY1xuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWVsZExpc3Q7XG4iLCJpbXBvcnQgSW5wdXRIaWRkZW4gZnJvbSAnLi9pbnB1dC9oaWRkZW4uanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIEZpZWxkUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZGF0YTogeyBmaWVsZFR5cGUsIGlzUmVxdWlyZWQsIGRpc3BsYXlBcyB9LFxuICAgICAgICAgICAgZ2NydWRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZldGNoRGF0YSxcbiAgICAgICAgICAgIEZpZWxkSW5wdXRDb21wb25lbnQsXG4gICAgICAgICAgICBGaWVsZFJvd1dyYXBwZXIsXG4gICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQsXG4gICAgICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGVcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKC9eaGlkZGVuJC9pLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8SW5wdXRIaWRkZW4gZGF0YT17ZGF0YX0gLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPEZpZWxkUm93V3JhcHBlclxuICAgICAgICAgICAgaXNSZXF1aXJlZD17aXNSZXF1aXJlZH1cbiAgICAgICAgICAgIGRpc3BsYXlBcz17ZGlzcGxheUFzfVxuICAgICAgICAgICAgZGF0YT17ZGF0YX1cbiAgICAgICAgICAgIGZldGNoRGF0YT17ZmV0Y2hEYXRhfVxuICAgICAgICAgICAgZ2NydWRJbnN0YW5jZT17Z2NydWRJbnN0YW5jZX1cbiAgICAgICAgICAgIEZpZWxkSW5wdXQ9e0ZpZWxkSW5wdXRDb21wb25lbnR9XG4gICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQ9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50fVxuICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlPXtyZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGV9XG4gICAgICAgIC8+O1xuICAgIH1cbn1cblxuRmllbGRSb3cucHJvcFR5cGVzID0ge1xuICAgIGRhdGE6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIGRpc3BsYXlBczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZmllbGRUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpc1JlcXVpcmVkOiBQcm9wVHlwZXMuYm9vbFxuICAgIH0pLFxuICAgIGdjcnVkSW5zdGFuY2U6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgRmllbGRJbnB1dENvbXBvbmVudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgRmllbGRSb3dXcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuRmllbGRSb3cuZGVmYXVsdFByb3BzID0ge1xuICAgIEZpZWxkSW5wdXRDb21wb25lbnQ6IHByb3BzID0+IDxpbnB1dCBuYW1lPXtwcm9wcy5kYXRhLmZpZWxkTmFtZX0gLz4sXG4gICAgRmllbGRSb3dXcmFwcGVyOiBwcm9wcyA9PiB7XG4gICAgICAgIGNvbnN0IHsgaXNSZXF1aXJlZCwgZGlzcGxheUFzLCBGaWVsZElucHV0LCBkYXRhLCBnY3J1ZEluc3RhbmNlLCBmZXRjaERhdGEsIGkxOG4gfSA9IHByb3BzO1xuXG4gICAgICAgIHJldHVybiAoPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICB7aXNSZXF1aXJlZCA/ICcqJyA6ICcnfVxuICAgICAgICAgICAgICAgIHtkaXNwbGF5QXN9XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8RmllbGRJbnB1dCBkYXRhPXtkYXRhfSBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfSBmZXRjaERhdGE9e2ZldGNoRGF0YX0gaTE4bj17aTE4bn0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj4pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmllbGRSb3c7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBJbnB1dEJhY2tlbmRDYWxsYmFjayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBsZXQgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBkZWZhdWx0VmFsdWUgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGRhbmdlcm91c2x5SW5uZXJIVE1MID0ge1xuICAgICAgICAgICAgICAgIF9faHRtbDogZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17ZGFuZ2Vyb3VzbHlJbm5lckhUTUx9Lz47XG4gICAgfVxufVxuXG5JbnB1dEJhY2tlbmRDYWxsYmFjay5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0QmFja2VuZENhbGxiYWNrOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0Q2hlY2tib3hCb29sZWFuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlLCBkZWZhdWx0VmFsdWUsIHNob3dEZWZhdWx0VmFsdWUgfSA9IHByb3BzLmRhdGEsXG4gICAgICAgICAgICB2YWx1ZSA9IHNob3dEZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHRoaXMuZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IHRoaXMuY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUsIGRlZmF1bHRWYWx1ZSwgc2hvd0RlZmF1bHRWYWx1ZSB9ID0gbmV4dFByb3BzLmRhdGEsXG4gICAgICAgICAgICB2YWx1ZSA9IHNob3dEZWZhdWx0VmFsdWUgJiYgZGVmYXVsdFZhbHVlID8gZGVmYXVsdFZhbHVlIDogZmllbGRWYWx1ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHRoaXMuZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICBpc0NoZWNrZWQ6IHRoaXMuY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoKSB7XG4gICAgICAgIHZhciB7IGlzQ2hlY2tlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGlzQ2hlY2tlZCA/ICcwJyA6ICcxJyxcbiAgICAgICAgICAgIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2hlY2tib3hWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcxJyA/ICcxJyA6ICcwJztcbiAgICB9XG4gICAgY2hlY2tib3hJc0NoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAnMSc7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUsIGlzQ2hlY2tlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBnYy1yZWFkLW9ubHktaW5wdXRcIj5cbiAgICAgICAgICAgICAgICAgICAge2lzQ2hlY2tlZCA/IDxpIGNsYXNzTmFtZT1cImZhIGZhLWNoZWNrXCI+PC9pPiA6ICcnfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2lzQ2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9IC8+XG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJoaWRkZW5cIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5JbnB1dENoZWNrYm94Qm9vbGVhbi5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpc1JlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBzaG93RGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMuYm9vbFxuICAgIH0pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dENoZWNrYm94Qm9vbGVhbjtcbiIsIlxuaW1wb3J0IElucHV0VGV4dCBmcm9tICcuL3RleHQuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0Q29sb3IgZXh0ZW5kcyBJbnB1dFRleHQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIDxJbnB1dFRleHQga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+XG4gICAgfVxufVxuXG5JbnB1dENvbG9yLnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGlzUmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBmaWVsZFR5cGU6IFByb3BUeXBlcy5zdHJpbmdcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dENvbG9yO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dERhdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBqUXVlcnlQbHVnaW5zLmRhdGVwaWNrZXIoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnLmdjLWlucHV0LWRhdGUnKSwgdGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyA9ICdmb3JtLWNvbnRyb2wgZ2MtaW5wdXQtZGF0ZSc7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlfSAvPjtcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyArPSAnIGhpZGRlbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDxkaXY+XG4gICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRDbGFzc2VzfVxuICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICByZWFkT25seT17aXNSZWFkT25seX1cbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIHN0ZXA9XCIxXCJcbiAgICAgICAgICAgIC8+PC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXREYXRlO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dERhdGV0aW1lIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5kYXRldGltZXBpY2tlcigkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCcuZ2MtaW5wdXQtZGF0ZXRpbWUnKSwgdGhpcy5wcm9wcy5nY3J1ZEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NlcyA9ICdmb3JtLWNvbnRyb2wgZ2MtaW5wdXQtZGF0ZXRpbWUnO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBleHRyYUlucHV0ID0gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZX0gLz47XG4gICAgICAgICAgICBpbnB1dENsYXNzZXMgKz0gJyBoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDxkaXY+XG4gICAgICAgICAgICAgICAge2V4dHJhSW5wdXR9XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRDbGFzc2VzfVxuICAgICAgICAgICAgICAgICAgICBuYW1lPXtmaWVsZE5hbWV9XG4gICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5PXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgc3RlcD1cIjFcIlxuICAgICAgICAgICAgICAgIC8+PC9kaXY+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXREYXRldGltZTtcbiIsIlxuaW1wb3J0IExpbmtlZFZhbHVlIGZyb20gJy4uL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzJztcblxuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0RHJvcGRvd25TZWFyY2hhYmxlIGV4dGVuZHMgTGlua2VkVmFsdWUge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgaXNSZWFkT25seSB9IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdCgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgaXNSZWFkT25seSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGlzUmVhZE9ubHkgfSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksIGlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9ICcnLFxuICAgICAgICAgICAgZXh0cmFJbnB1dCA9ICcnLFxuICAgICAgICAgICAgb3B0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goeyBpZDogJycsIHRpdGxlOiAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2goZmllbGRWYWx1ZXMsIGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvbkRpc3BsYXksIG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9uRGlzcGxheVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT09IGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSBvcHRpb25EaXNwbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZXh0cmFJbnB1dCA9IDxJbnB1dFJlYWRPbmx5IGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWVEZXNjcmlwdGlvbn0gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmxpbmtlZENoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNSZWFkT25seX1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3RfYW5fb3B0aW9uJyl9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBEcm9wRG93bkZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0gPnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RHJvcGRvd25TZWFyY2hhYmxlO1xuIiwiXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5jbGFzcyBJbnB1dERyb3Bkb3duIGV4dGVuZHMgTGlua2VkVmFsdWUge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lLCBmaWVsZFZhbHVlcywgaXNOdWxsYWJsZSwgaXNSZWFkT25seSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgZmllbGRWYWx1ZURlc2NyaXB0aW9uID0gJycsXG4gICAgICAgICAgICBvcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKGlzTnVsbGFibGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnJywgdGl0bGU6ICcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChmaWVsZFZhbHVlcywgZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uRGlzcGxheSwgb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IG9wdGlvblZhbHVlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBvcHRpb25EaXNwbGF5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRm9yIHRoZSBzZWxlY3QgaWQgc2hvdyB0aGUgb3B0aW9uIGRpc3BsYXkgaW5zdGVhZCBvZiB0aGUgaWRcbiAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9IG9wdGlvbkRpc3BsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZURlc2NyaXB0aW9ufSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgbmFtZT17ZmllbGROYW1lfVxuICAgICAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmxpbmtlZENoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gRHJvcERvd25Gb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gdmFsdWU9e2lkfSBrZXk9e2lkfSA+e3RpdGxlfTwvb3B0aW9uPjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RHJvcGRvd247XG4iLCJcbmltcG9ydCBJbnB1dFRleHQgZnJvbSAnLi90ZXh0LmpzeCc7XG5cbmNsYXNzIElucHV0RW1haWwgZXh0ZW5kcyBJbnB1dFRleHQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIDxJbnB1dFRleHQga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEVtYWlsO1xuIiwiXG5cbmltcG9ydCBMaW5rZWRWYWx1ZSBmcm9tICcuLi9jb21wb25lbnRzL2xpbmtlZC12YWx1ZS5qcyc7XG5pbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBqUXVlcnlQbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9tb2R1bGVzL2pxdWVyeS9qcXVlcnktcGx1Z2lucycpLmpRdWVyeVBsdWdpbnMsXG4gICAgJCA9IGpRdWVyeSxcbiAgICBpMThuID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9pMThuJykuaTE4bjtcblxuY2xhc3MgSW5wdXRFbnVtU2VhcmNoYWJsZSBleHRlbmRzIExpbmtlZFZhbHVlIHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGlzUmVhZE9ubHkgfSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KCQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLmZpbmQoJ3NlbGVjdCcpLCBpc1JlYWRPbmx5KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgaXNSZWFkT25seSB9IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3RVcGRhdGUoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksIGlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHZhciB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSAnJyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZXh0cmFJbnB1dCA9IDxJbnB1dFJlYWRPbmx5IGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9IC8+O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zID0gXy51bmlxKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3RfYW5fb3B0aW9uJyl9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBvcHRpb25zRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIGRlZmF1bHRWYWx1ZT17ZmllbGR9IGtleT17ZmllbGR9ID57ZmllbGR9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEVudW1TZWFyY2hhYmxlO1xuIiwiXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5jbGFzcyBJbnB1dEVudW0gZXh0ZW5kcyBMaW5rZWRWYWx1ZSB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWVzLCBpc051bGxhYmxlLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBvcHRpb25zID0gW107XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlfSAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goJycpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zID0gXy51bmlxKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlbGVjdCBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPXtmaWVsZFZhbHVlfSBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIiBkaXNhYmxlZD17aXNSZWFkT25seX0gb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9ID5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIG9wdGlvbnNGb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiBkZWZhdWx0VmFsdWU9e2ZpZWxkfSBrZXk9e2ZpZWxkfSA+e2ZpZWxkfTwvb3B0aW9uPjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0RW51bTtcbiIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0SGlkZGVuIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUgfSA9IHByb3BzLmRhdGE7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIDxpbnB1dFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgcmVhZE9ubHk9XCJyZWFkT25seVwiXG4gICAgICAgICAgICB0eXBlPVwiaGlkZGVuXCJcbiAgICAgICAgLz47XG4gICAgfVxufVxuXG5JbnB1dEhpZGRlbi5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBmaWVsZFZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRIaWRkZW47XG4iLCJpbXBvcnQgSW5wdXRNdWx0aXNlbGVjdCBmcm9tICcuL211bHRpc2VsZWN0LmpzJztcblxudmFyIGpRdWVyeVBsdWdpbnMgPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICAkID0galF1ZXJ5O1xuXG5jbGFzcyBJbnB1dE11bHRpc2VsZWN0U2VhcmNoYWJsZSBleHRlbmRzIElucHV0TXVsdGlzZWxlY3Qge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCAkc2VsZWN0ID0gJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSkuZmluZCgnc2VsZWN0JyksXG4gICAgICAgICAgICB7IGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YTtcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KCRzZWxlY3QsIGlzUmVhZE9ubHkpO1xuICAgICAgICAkc2VsZWN0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiBTZWFyY2hhYmxlU2VsZWN0VXBkYXRlKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtlZENoYW5nZS5hcHBseSh0aGlzLCBbZXZlbnRdKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgaXNSZWFkT25seSB9IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdFVwZGF0ZSgkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5maW5kKCdzZWxlY3QnKSwgaXNSZWFkT25seSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE11bHRpc2VsZWN0U2VhcmNoYWJsZTsiLCJpbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBpMThuID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9zZWN0aW9ucy9pMThuJykuaTE4bjtcblxuY2xhc3MgSW5wdXRNdWx0aXNlbGVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZFZhbHVlIH0gPSBwcm9wcy5kYXRhO1xuXG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcy5kYXRhO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVmFsdWVzID0gWy4uLmV2ZW50LnRhcmdldC5vcHRpb25zXVxuICAgICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbXMsXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW1zQXNTdHJpbmcsXG4gICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSBbXSxcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSBudWxsLFxuICAgICAgICAgICAgb3B0aW9ucyA9IFtdLFxuICAgICAgICAgICAgc2VsZWN0Q2xhc3NOYW1lID0gJ2Zvcm0tY29udHJvbCc7XG5cbiAgICAgICAgc2VsZWN0ZWRJdGVtcyA9IGZpZWxkVmFsdWUgIT09IG51bGwgPyBmaWVsZFZhbHVlIDogW107XG4gICAgICAgIHNlbGVjdGVkSXRlbXNBc1N0cmluZyA9IHNlbGVjdGVkSXRlbXMuam9pbigpO1xuXG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goeyBpZDogJycsIHRpdGxlOiAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2goZmllbGRWYWx1ZXMsIGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvbkRpc3BsYXksIG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9uRGlzcGxheVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtcy5pbmRleE9mKG9wdGlvblZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZURlc2NyaXB0aW9uLnB1c2gob3B0aW9uRGlzcGxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBleHRyYUlucHV0ID0gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZURlc2NyaXB0aW9uLmpvaW4oJywgJyl9IC8+O1xuICAgICAgICAgICAgc2VsZWN0Q2xhc3NOYW1lICs9ICcgaGlkZGVuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9e2ZpZWxkTmFtZX0gdmFsdWU9e3NlbGVjdGVkSXRlbXNBc1N0cmluZ30gLz47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICB7ZXh0cmFJbnB1dH1cbiAgICAgICAgICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0ZWRJdGVtc31cbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c2VsZWN0Q2xhc3NOYW1lfVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNSZWFkT25seX1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS1wbGFjZWhvbGRlcj17aTE4bi50KCdzZWxlY3RfYW5fb3B0aW9uJyl9PlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1hcChmdW5jdGlvbiBEcm9wRG93bkZvckVhY2goZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0gPnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0TXVsdGlzZWxlY3Q7IiwiXG5pbXBvcnQgSW5wdXRUZXh0IGZyb20gJy4vdGV4dC5qc3gnO1xuXG5jbGFzcyBJbnB1dE51bWVyaWMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIDxJbnB1dFRleHQga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dE51bWVyaWM7XG4iLCJcbmltcG9ydCBJbnB1dFRleHQgZnJvbSAnLi90ZXh0LmpzeCc7XG5cbmNsYXNzIElucHV0UGFzc3dvcmQgZXh0ZW5kcyBJbnB1dFRleHQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHsgZGF0YSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIDxJbnB1dFRleHQga2V5PXtmaWVsZE5hbWV9IGRhdGE9e2RhdGF9IC8+XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFBhc3N3b3JkO1xuIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgSW5wdXRSZWFkT25seSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmICghZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgZ2MtcmVhZC1vbmx5LWlucHV0XCI+e2ZpZWxkVmFsdWV9PC9kaXY+KTtcbiAgICB9XG59XG5cbklucHV0UmVhZE9ubHkucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkVmFsdWU6IFByb3BUeXBlcy5zdHJpbmdcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSZWFkT25seTtcbiIsIlxuaW1wb3J0IExpbmtlZFZhbHVlIGZyb20gJy4uL2NvbXBvbmVudHMvbGlua2VkLXZhbHVlLmpzJztcblxuY2xhc3MgSW5wdXRSZWxhdGlvbk50b04gZXh0ZW5kcyBMaW5rZWRWYWx1ZSB7XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBzZWxlY3RlZFZhbHVlcyA9IFsuLi5ldmVudC50YXJnZXQub3B0aW9uc11cbiAgICAgICAgICAgIC5maWx0ZXIob3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZClcbiAgICAgICAgICAgIC5tYXAob3B0aW9uID0+IG9wdGlvbi52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBzZWxlY3RlZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWVzLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBvcHRpb25zID0gW107XG5cbiAgICAgICAgZmllbGRWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoRmllbGRWYWx1ZShvcHRpb25WYWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvblZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VsZWN0IG5hbWU9e2ZpZWxkTmFtZX0gbXVsdGlwbGU9XCJtdWx0aXBsZVwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fSB2YWx1ZT17ZmllbGRWYWx1ZX0gb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gRHJvcERvd25Gb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gdmFsdWU9e2lkfSBrZXk9e2lkfT57dGl0bGV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSZWxhdGlvbk50b047XG4iLCJpbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgSW5wdXRSZWxhdGlvbmFsTmF0aXZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgZmllbGRWYWx1ZSB9IH0gPSBwcm9wcztcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgZmllbGRWYWx1ZSB9IH0gPSBuZXh0UHJvcHM7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlID8gZmllbGRWYWx1ZSA6ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBvblNlbGVjdENhbGxiYWNrLCBkYXRhOiB7IGZpZWxkTmFtZSB9IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9uU2VsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9uU2VsZWN0Q2FsbGJhY2suYXBwbHkodGhpcywgW2ZpZWxkTmFtZSAsZmllbGRWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzLFxuICAgICAgICAgICAgICAgIGlzTnVsbGFibGUsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSAnJyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bGxhYmxlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2goeyBpZDogJycsIHRpdGxlOiAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uVmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUuaWQgPT09IGZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlRGVzY3JpcHRpb24gPSBvcHRpb25WYWx1ZS50aXRsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlRGVzY3JpcHRpb259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxzZWxlY3QgbmFtZT17ZmllbGROYW1lfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmxpbmtlZENoYW5nZS5iaW5kKHRoaXMpfT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIERyb3BEb3duRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiB2YWx1ZT17aWR9IGtleT17aWQgPyBpZCA6ICctMSd9ID57dGl0bGV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuSW5wdXRSZWxhdGlvbmFsTmF0aXZlLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmllbGRWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc051bGxhYmxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc1JlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvblNlbGVjdENhbGxiYWNrOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSZWxhdGlvbmFsTmF0aXZlO1xuIiwiaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIElucHV0UmVsYXRpb25hbFNlYXJjaGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcblxuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcy5kYXRhO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGF0YTogeyBpc1JlYWRPbmx5IH0sXG4gICAgICAgICAgICBvbkNvbXBvbmVudERpZE1vdW50XG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBvbkNvbXBvbmVudERpZE1vdW50LmFwcGx5KHRoaXMsIFsgUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIHsgaXNSZWFkT25seSB9XSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkYXRhOiB7IGlzUmVhZE9ubHkgfSxcbiAgICAgICAgICAgIG9uQ29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBvbkNvbXBvbmVudERpZFVwZGF0ZS5hcHBseSh0aGlzLCBbIFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLCB7IGlzUmVhZE9ubHkgfSBdKTtcbiAgICB9XG5cbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBvblNlbGVjdENhbGxiYWNrLCBkYXRhOiB7IGZpZWxkTmFtZSB9IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9uU2VsZWN0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIG9uU2VsZWN0Q2FsbGJhY2suYXBwbHkodGhpcywgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBpMThuLCBkYXRhOiB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzTnVsbGFibGUsIGlzUmVhZE9ubHkgfSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXSxcbiAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9ICcnLFxuICAgICAgICAgICAgZXh0cmFJbnB1dCA9ICcnO1xuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVsbGFibGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaCh7IGlkOiAnJywgdGl0bGU6ICcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaEZpZWxkVmFsdWUob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucHVzaChvcHRpb25WYWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25WYWx1ZS5pZCA9PT0gZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVEZXNjcmlwdGlvbiA9IG9wdGlvblZhbHVlLnRpdGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGV4dHJhSW5wdXQgPSA8SW5wdXRSZWFkT25seSBmaWVsZFZhbHVlPXtmaWVsZFZhbHVlRGVzY3JpcHRpb259IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAge2V4dHJhSW5wdXR9XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgZGlzYWJsZWQ9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX0gZGF0YS1wbGFjZWhvbGRlcj17aTE4bi5zZWxlY3RfYW5fb3B0aW9ufT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXAoZnVuY3Rpb24gRHJvcERvd25Gb3JFYWNoKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgdGl0bGUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0gPnt0aXRsZX08L29wdGlvbj47XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbklucHV0UmVsYXRpb25hbFNlYXJjaGFibGUucHJvcFR5cGVzID0ge1xuICBpMThuOiBQcm9wVHlwZXMuc2hhcGUoeyBzZWxlY3RfYW5fb3B0aW9uOiBQcm9wVHlwZXMuc3RyaW5nfSksXG4gIG9uQ29tcG9uZW50RGlkTW91bnQ6IFByb3BUeXBlcy5mdW5jLFxuICBvbkNvbXBvbmVudERpZFVwZGF0ZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbklucHV0UmVsYXRpb25hbFNlYXJjaGFibGUuZGVmYXVsdFByb3BzID0ge1xuICAgIGkxOG46IHtcbiAgICAgICAgc2VsZWN0X2FuX29wdGlvbjogJ1NlbGVjdCBhbiBvcHRpb24nXG4gICAgfSxcbiAgICBvbkNvbXBvbmVudERpZE1vdW50OiAoKSA9PiB7fSxcbiAgICBvbkNvbXBvbmVudERpZFVwZGF0ZTogKCkgPT4ge31cbn07XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0UmVsYXRpb25hbFNlYXJjaGFibGU7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IElucHV0UmVhZE9ubHkgZnJvbSAnLi9yZWFkLW9ubHkuanN4JztcblxuY2xhc3MgUmljaFRleHRlZGl0b3JSZWFkT25seSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcHJldmlld0FzSHRtbDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0b2dnbGVQcmV2aWV3QXNIdG1sKCkge1xuICAgICAgICBjb25zdCB7IHByZXZpZXdBc0h0bWwgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgcHJldmlld0FzSHRtbDogIXByZXZpZXdBc0h0bWxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGZpZWxkVmFsdWUsIGkxOG4gfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IHByZXZpZXdBc0h0bWwgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgaWYgKCFmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgLz5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3QXNIdG1sID9cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnYy1odG1sLXByZXZpZXdcIiBkYW5nZXJvdXNseVNldElubmVySFRNTD17e19faHRtbDogZmllbGRWYWx1ZX19PjwvZGl2PiA6XG4gICAgICAgICAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwiZ2MtcmljaC10ZXh0ZWRpdG9yLXJlYWQtb25seVwiPntmaWVsZFZhbHVlfTwvcHJlPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlUHJldmlld0FzSHRtbC5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1vdXRsaW5lLWRhcmtcIlxuICAgICAgICAgICAgICAgID57cHJldmlld0FzSHRtbCA/IGkxOG4ucHJldmlld19hc19wbGFpbl90ZXh0IDogaTE4bi5wcmV2aWV3X2FzX2h0bWx9PC9idXR0b24+XG4gICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuUmljaFRleHRlZGl0b3JSZWFkT25seS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpMThuOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBwcmV2aWV3X2FzX3BsYWluX3RleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHByZXZpZXdfYXNfaHRtbDogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0pXG59O1xuXG5SaWNoVGV4dGVkaXRvclJlYWRPbmx5LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpMThuOiB7XG4gICAgICAgIHByZXZpZXdfYXNfcGxhaW5fdGV4dDogJ1ByZXZpZXcgYXMgcGxhaW4gdGV4dCcsXG4gICAgICAgIHByZXZpZXdfYXNfaHRtbDogJ1ByZXZpZXcgYXMgSFRNTCdcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJpY2hUZXh0ZWRpdG9yUmVhZE9ubHk7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jb25zdCBqUXVlcnlQbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vLi4vUmVzb3VyY2VzL3B1YmxpYy9qcy9tb2R1bGVzL2pxdWVyeS9qcXVlcnktcGx1Z2lucycpLmpRdWVyeVBsdWdpbnMsXG4gICAgJCA9IGpRdWVyeTtcblxuY2xhc3MgUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHByb3BzLmZpZWxkVmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcztcbiAgICAgICAgalF1ZXJ5UGx1Z2lucy51cGRhdGVUZXh0ZWRpdG9yKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUsIGZpZWxkVmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGpRdWVyeVBsdWdpbnMudGV4dGVkaXRvcigkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSwgZmllbGROYW1lLCBmaWVsZFZhbHVlKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBqUXVlcnlQbHVnaW5zLmRlc3Ryb3lUZXh0ZWRpdG9yKGZpZWxkTmFtZSk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBmaWVsZE5hbWUgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICB7IGZpZWxkVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIHZhbHVlPXtmaWVsZFZhbHVlfVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgIC8+O1xuICAgIH1cbn1cblxuUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmllbGRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgUmljaFRleHRlZGl0b3JXaXRoUGx1Z2luOyIsImltcG9ydCBSaWNoVGV4dGVkaXRvcldpdGhQbHVnaW4gZnJvbSAnLi9yaWNoLXRleHRlZGl0b3Itd2l0aC1wbHVnaW4nO1xuaW1wb3J0IFJpY2hUZXh0ZWRpdG9yUmVhZE9ubHkgZnJvbSAnLi9yaWNoLXRleHRlZGl0b3ItcmVhZC1vbmx5LmpzeCc7XG5cbmNvbnN0IGkxOG4gPSByZXF1aXJlKCcuLi8uLi8uLi9SZXNvdXJjZXMvcHVibGljL2pzL3NlY3Rpb25zL2kxOG4nKS5pMThuO1xuXG5jbGFzcyBJbnB1dFJpY2hUZXh0ZWRpdG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGROYW1lLCBmaWVsZFZhbHVlLCBpc1JlYWRPbmx5IH0gPSB0aGlzLnByb3BzLmRhdGE7XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiA8UmljaFRleHRlZGl0b3JSZWFkT25seVxuICAgICAgICAgICAgICAgIGkxOG49e2kxOG4udHJhbnNsYXRpb25zfVxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICAvPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8UmljaFRleHRlZGl0b3JXaXRoUGx1Z2luXG4gICAgICAgICAgICBmaWVsZE5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgIC8+O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRSaWNoVGV4dGVkaXRvcjtcbiIsIlxuXG5pbXBvcnQgTGlua2VkVmFsdWUgZnJvbSAnLi4vY29tcG9uZW50cy9saW5rZWQtdmFsdWUuanMnO1xuXG52YXIgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgICQgPSBqUXVlcnksXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG47XG5cbmNsYXNzIElucHV0U2VhcmNoYWJsZVJlbGF0aW9uTnRvTiBleHRlbmRzIExpbmtlZFZhbHVlIHtcbiAgICBsaW5rZWRDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gWy4uLmV2ZW50LnRhcmdldC5vcHRpb25zXVxuICAgICAgICAgICAgLmZpbHRlcihvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gb3B0aW9uLnZhbHVlKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IHNlbGVjdGVkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IGlzUmVhZE9ubHkgfSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBqUXVlcnlQbHVnaW5zLnNlYXJjaGFibGVTZWxlY3QoJChSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKSksIGlzUmVhZE9ubHkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyBpc1JlYWRPbmx5IH0gfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0VXBkYXRlKCQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLCBpc1JlYWRPbmx5KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGZpZWxkTmFtZSwgZmllbGRWYWx1ZXMsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YTtcbiAgICAgICAgbGV0IHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBbXTtcblxuICAgICAgICBmaWVsZFZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hGaWVsZFZhbHVlKG9wdGlvblZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnB1c2gob3B0aW9uVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8c2VsZWN0IG5hbWU9e2ZpZWxkTmFtZX0gbXVsdGlwbGU9XCJtdWx0aXBsZVwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fSB2YWx1ZT17ZmllbGRWYWx1ZX0gb25DaGFuZ2U9e3RoaXMubGlua2VkQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEtcGxhY2Vob2xkZXI9e2kxOG4udCgnc2VsZWN0X3NvbWVfb3B0aW9ucycpfT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWFwKGZ1bmN0aW9uIERyb3BEb3duRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgaWQsIHRpdGxlIH0gPSBmaWVsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIHZhbHVlPXtpZH0ga2V5PXtpZH0+e3RpdGxlfTwvb3B0aW9uPjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0U2VhcmNoYWJsZVJlbGF0aW9uTnRvTjtcbiIsImltcG9ydCBJbnB1dFJlYWRPbmx5IGZyb20gJy4vcmVhZC1vbmx5LmpzeCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBJbnB1dFRleHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUgfSA9IHByb3BzLmRhdGE7XG5cbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlOiBmaWVsZFZhbHVlID8gZmllbGRWYWx1ZSA6ICcnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIHZhciB7IGZpZWxkVmFsdWUgfSA9IG5leHRQcm9wcy5kYXRhO1xuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua2VkQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbnB1dFR5cGUoZmllbGRUeXBlKSB7XG4gICAgICAgIGlmICgvXihlbWFpbHx1cmx8Y29sb3J8cGFzc3dvcmQpJC8udGVzdChmaWVsZFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eKGludHxudW1lcmljKSQvLnRlc3QoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdudW1iZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGlzUmVhZE9ubHksIGZpZWxkVHlwZSB9ID0gdGhpcy5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgeyBmaWVsZFZhbHVlIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmIChpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT17ZmllbGRWYWx1ZX0gLz5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiA8aW5wdXRcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiXG4gICAgICAgICAgICBuYW1lPXtmaWVsZE5hbWV9XG4gICAgICAgICAgICB0eXBlPXt0aGlzLmdldElucHV0VHlwZShmaWVsZFR5cGUpfVxuICAgICAgICAgICAgcmVhZE9ubHk9e2lzUmVhZE9ubHl9XG4gICAgICAgICAgICB2YWx1ZT17ZmllbGRWYWx1ZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmxpbmtlZENoYW5nZS5iaW5kKHRoaXMpfSAvPjtcbiAgICB9XG59XG5cbklucHV0VGV4dC5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgZmllbGROYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBpc1JlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgZmllbGRUeXBlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgSW5wdXRUZXh0O1xuIiwiXG5pbXBvcnQgSW5wdXRSZWFkT25seSBmcm9tICcuL3JlYWQtb25seS5qc3gnO1xuXG5jbGFzcyBJbnB1dFRleHRhcmVhIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBwcm9wcy5kYXRhO1xuXG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZmllbGRWYWx1ZTogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUgOiAnJ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgeyBmaWVsZFZhbHVlIH0gPSBuZXh0UHJvcHMuZGF0YTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGZpZWxkVmFsdWUgPyBmaWVsZFZhbHVlIDogJydcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpbmtlZENoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGZpZWxkVmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBmaWVsZE5hbWUsIGlzUmVhZE9ubHkgfSA9IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIHsgZmllbGRWYWx1ZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNSZWFkT25seSkge1xuICAgICAgICAgICAgcmV0dXJuIDxJbnB1dFJlYWRPbmx5IGZpZWxkVmFsdWU9e2ZpZWxkVmFsdWV9IC8+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9e2ZpZWxkTmFtZX1cbiAgICAgICAgICAgIGRpc2FibGVkPXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgdmFsdWU9e2ZpZWxkVmFsdWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5saW5rZWRDaGFuZ2UuYmluZCh0aGlzKX0gLz47XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dFRleHRhcmVhO1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJwcm9wLXR5cGVzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRyb3B6b25lXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiRHJvcHpvbmVcIl0gPSBmYWN0b3J5KHJvb3RbXCJwcm9wLXR5cGVzXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfc3R5bGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9zdHlsZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3R5bGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfSAvKiBlc2xpbnQgcHJlZmVyLXRlbXBsYXRlOiAwICovXG5cbi8vaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5cbnZhciBEcm9wem9uZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhEcm9wem9uZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJvcHpvbmUocHJvcHMsIGNvbnRleHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJvcHpvbmUpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERyb3B6b25lLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHJvcHpvbmUpKS5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICBfdGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgaXNEcmFnQWN0aXZlLCBpc0RyYWdBY2NlcHQsIGlzRHJhZ1JlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4oX2V4dGVuZHMoe30sIF90aGlzLnN0YXRlLCB7XG4gICAgICAgICAgaXNEcmFnQWN0aXZlOiBpc0RyYWdBY3RpdmUsXG4gICAgICAgICAgaXNEcmFnQWNjZXB0OiBpc0RyYWdBY2NlcHQsXG4gICAgICAgICAgaXNEcmFnUmVqZWN0OiBpc0RyYWdSZWplY3RcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG5cbiAgICBfdGhpcy5jb21wb3NlSGFuZGxlcnMgPSBfdGhpcy5jb21wb3NlSGFuZGxlcnMuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25DbGljayA9IF90aGlzLm9uQ2xpY2suYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25Eb2N1bWVudERyb3AgPSBfdGhpcy5vbkRvY3VtZW50RHJvcC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkRyYWdFbnRlciA9IF90aGlzLm9uRHJhZ0VudGVyLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLm9uRHJhZ0xlYXZlID0gX3RoaXMub25EcmFnTGVhdmUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25EcmFnT3ZlciA9IF90aGlzLm9uRHJhZ092ZXIuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25EcmFnU3RhcnQgPSBfdGhpcy5vbkRyYWdTdGFydC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5vbkRyb3AgPSBfdGhpcy5vbkRyb3AuYmluZChfdGhpcyk7XG4gICAgX3RoaXMub25GaWxlRGlhbG9nQ2FuY2VsID0gX3RoaXMub25GaWxlRGlhbG9nQ2FuY2VsLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLm9uSW5wdXRFbGVtZW50Q2xpY2sgPSBfdGhpcy5vbklucHV0RWxlbWVudENsaWNrLmJpbmQoX3RoaXMpO1xuXG4gICAgX3RoaXMuc2V0UmVmID0gX3RoaXMuc2V0UmVmLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLnNldFJlZnMgPSBfdGhpcy5zZXRSZWZzLmJpbmQoX3RoaXMpO1xuXG4gICAgX3RoaXMuaXNGaWxlRGlhbG9nQWN0aXZlID0gZmFsc2U7XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRyYWdnZWRGaWxlczogW10sXG4gICAgICBhY2NlcHRlZEZpbGVzOiBbXSxcbiAgICAgIHJlamVjdGVkRmlsZXM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJvcHpvbmUsIFt7XG4gICAga2V5OiAnY29tcG9uZW50RGlkTW91bnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBwcmV2ZW50RHJvcE9uRG9jdW1lbnQgPSB0aGlzLnByb3BzLnByZXZlbnREcm9wT25Eb2N1bWVudDtcblxuICAgICAgdGhpcy5kcmFnVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAocHJldmVudERyb3BPbkRvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgX3V0aWxzLm9uRG9jdW1lbnREcmFnT3ZlciwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5vbkRvY3VtZW50RHJvcCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5maWxlSW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25JbnB1dEVsZW1lbnRDbGljaywgZmFsc2UpO1xuICAgICAgLy8gVHJpZWQgaW1wbGVtZW50aW5nIGFkZEV2ZW50TGlzdGVuZXIsIGJ1dCBkaWRuJ3Qgd29yayBvdXRcbiAgICAgIGRvY3VtZW50LmJvZHkub25mb2N1cyA9IHRoaXMub25GaWxlRGlhbG9nQ2FuY2VsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgcHJldmVudERyb3BPbkRvY3VtZW50ID0gdGhpcy5wcm9wcy5wcmV2ZW50RHJvcE9uRG9jdW1lbnQ7XG5cbiAgICAgIGlmIChwcmV2ZW50RHJvcE9uRG9jdW1lbnQpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBfdXRpbHMub25Eb2N1bWVudERyYWdPdmVyKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMub25Eb2N1bWVudERyb3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5maWxlSW5wdXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25JbnB1dEVsZW1lbnRDbGljaywgZmFsc2UpO1xuICAgICAgLy8gQ2FuIGJlIHJlcGxhY2VkIHdpdGggcmVtb3ZlRXZlbnRMaXN0ZW5lciwgaWYgYWRkRXZlbnRMaXN0ZW5lciB3b3Jrc1xuICAgICAgZG9jdW1lbnQuYm9keS5vbmZvY3VzID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb21wb3NlSGFuZGxlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb3NlSGFuZGxlcnMoaGFuZGxlcikge1xuICAgICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRG9jdW1lbnREcm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Eb2N1bWVudERyb3AoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKGV2dC50YXJnZXQpKSB7XG4gICAgICAgIC8vIGlmIHdlIGludGVyY2VwdGVkIGFuIGV2ZW50IGZvciBvdXIgaW5zdGFuY2UsIGxldCBpdCBwcm9wYWdhdGUgZG93biB0byB0aGUgaW5zdGFuY2UncyBvbkRyb3AgaGFuZGxlclxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuZHJhZ1RhcmdldHMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkRyYWdTdGFydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2dCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25EcmFnU3RhcnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydC5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25EcmFnRW50ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbnRlcihldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBDb3VudCB0aGUgZHJvcHpvbmUgYW5kIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBlbnRlcmVkLlxuICAgICAgaWYgKHRoaXMuZHJhZ1RhcmdldHMuaW5kZXhPZihldnQudGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5kcmFnVGFyZ2V0cy5wdXNoKGV2dC50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNEcmFnQWN0aXZlOiB0cnVlLCAvLyBEbyBub3QgcmVseSBvbiBmaWxlcyBmb3IgdGhlIGRyYWcgc3RhdGUuIEl0IGRvZXNuJ3Qgd29yayBpbiBTYWZhcmkuXG4gICAgICAgIGRyYWdnZWRGaWxlczogKDAsIF91dGlscy5nZXREYXRhVHJhbnNmZXJJdGVtcykoZXZ0KVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLm9uRHJhZ0VudGVyKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25EcmFnRW50ZXIuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJhZ092ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdPdmVyKGV2dCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2dC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMub25EcmFnT3Zlcikge1xuICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ092ZXIuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uRHJhZ0xlYXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnTGVhdmUoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIE9ubHkgZGVhY3RpdmF0ZSBvbmNlIHRoZSBkcm9wem9uZSBhbmQgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiBsZWZ0LlxuICAgICAgdGhpcy5kcmFnVGFyZ2V0cyA9IHRoaXMuZHJhZ1RhcmdldHMuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwgIT09IGV2dC50YXJnZXQgJiYgX3RoaXMyLm5vZGUuY29udGFpbnMoZWwpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5kcmFnVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYXIgZHJhZ2dpbmcgZmlsZXMgc3RhdGVcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0RyYWdBY3RpdmU6IGZhbHNlLFxuICAgICAgICBkcmFnZ2VkRmlsZXM6IFtdXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMucHJvcHMub25EcmFnTGVhdmUpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdMZWF2ZS5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25Ecm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Ecm9wKGV2dCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIG9uRHJvcCA9IF9wcm9wcy5vbkRyb3AsXG4gICAgICAgICAgb25Ecm9wQWNjZXB0ZWQgPSBfcHJvcHMub25Ecm9wQWNjZXB0ZWQsXG4gICAgICAgICAgb25Ecm9wUmVqZWN0ZWQgPSBfcHJvcHMub25Ecm9wUmVqZWN0ZWQsXG4gICAgICAgICAgbXVsdGlwbGUgPSBfcHJvcHMubXVsdGlwbGUsXG4gICAgICAgICAgZGlzYWJsZVByZXZpZXcgPSBfcHJvcHMuZGlzYWJsZVByZXZpZXcsXG4gICAgICAgICAgYWNjZXB0ID0gX3Byb3BzLmFjY2VwdDtcblxuICAgICAgdmFyIGZpbGVMaXN0ID0gKDAsIF91dGlscy5nZXREYXRhVHJhbnNmZXJJdGVtcykoZXZ0KTtcbiAgICAgIHZhciBhY2NlcHRlZEZpbGVzID0gW107XG4gICAgICB2YXIgcmVqZWN0ZWRGaWxlcyA9IFtdO1xuXG4gICAgICAvLyBTdG9wIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyIGFsb25nIHdpdGggdGhlIGRyYWcgb24gYSBkcm9wLlxuICAgICAgdGhpcy5kcmFnVGFyZ2V0cyA9IFtdO1xuICAgICAgdGhpcy5pc0ZpbGVEaWFsb2dBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgZmlsZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBpZiAoIWRpc2FibGVQcmV2aWV3KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGUucHJldmlldyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcHJldmlldyBmb3IgZmlsZScsIGZpbGUsIGVycik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoMCwgX3V0aWxzLmZpbGVBY2NlcHRlZCkoZmlsZSwgYWNjZXB0KSAmJiAoMCwgX3V0aWxzLmZpbGVNYXRjaFNpemUpKGZpbGUsIF90aGlzMy5wcm9wcy5tYXhTaXplLCBfdGhpczMucHJvcHMubWluU2l6ZSkpIHtcbiAgICAgICAgICBhY2NlcHRlZEZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0ZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgICAvLyBpZiBub3QgaW4gbXVsdGkgbW9kZSBhZGQgYW55IGV4dHJhIGFjY2VwdGVkIGZpbGVzIHRvIHJlamVjdGVkLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgZW5kIHVzZXJzIHRvIGVhc2lseSBpZ25vcmUgYSBtdWx0aSBmaWxlIGRyb3AgaW4gXCJzaW5nbGVcIiBtb2RlLlxuICAgICAgICByZWplY3RlZEZpbGVzLnB1c2guYXBwbHkocmVqZWN0ZWRGaWxlcywgX3RvQ29uc3VtYWJsZUFycmF5KGFjY2VwdGVkRmlsZXMuc3BsaWNlKDEpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvbkRyb3ApIHtcbiAgICAgICAgb25Ecm9wLmNhbGwodGhpcywgYWNjZXB0ZWRGaWxlcywgcmVqZWN0ZWRGaWxlcywgZXZ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlamVjdGVkRmlsZXMubGVuZ3RoID4gMCAmJiBvbkRyb3BSZWplY3RlZCkge1xuICAgICAgICBvbkRyb3BSZWplY3RlZC5jYWxsKHRoaXMsIHJlamVjdGVkRmlsZXMsIGV2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY2NlcHRlZEZpbGVzLmxlbmd0aCA+IDAgJiYgb25Ecm9wQWNjZXB0ZWQpIHtcbiAgICAgICAgb25Ecm9wQWNjZXB0ZWQuY2FsbCh0aGlzLCBhY2NlcHRlZEZpbGVzLCBldnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciBmaWxlcyB2YWx1ZVxuICAgICAgdGhpcy5kcmFnZ2VkRmlsZXMgPSBudWxsO1xuXG4gICAgICAvLyBSZXNldCBkcmFnIHN0YXRlXG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNEcmFnQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dlZEZpbGVzOiBbXSxcbiAgICAgICAgYWNjZXB0ZWRGaWxlczogYWNjZXB0ZWRGaWxlcyxcbiAgICAgICAgcmVqZWN0ZWRGaWxlczogcmVqZWN0ZWRGaWxlc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb25DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xpY2soZXZ0KSB7XG4gICAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgb25DbGljayA9IF9wcm9wczIub25DbGljayxcbiAgICAgICAgICBkaXNhYmxlQ2xpY2sgPSBfcHJvcHMyLmRpc2FibGVDbGljaztcblxuICAgICAgaWYgKCFkaXNhYmxlQ2xpY2spIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgb25DbGljay5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBJRTExL0VkZ2UgdGhlIGZpbGUtYnJvd3NlciBkaWFsb2cgaXMgYmxvY2tpbmcsIGVuc3VyZSB0aGlzIGlzIGJlaGluZCBzZXRUaW1lb3V0XG4gICAgICAgIC8vIHRoaXMgaXMgc28gcmVhY3QgY2FuIGhhbmRsZSBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBvbkNsaWNrIHByb3AgYWJvdmUgYWJvdmVcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZHJvcHpvbmUvcmVhY3QtZHJvcHpvbmUvaXNzdWVzLzQ1MFxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMub3Blbi5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbklucHV0RWxlbWVudENsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25JbnB1dEVsZW1lbnRDbGljayhldnQpIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmICh0aGlzLnByb3BzLmlucHV0UHJvcHMgJiYgdGhpcy5wcm9wcy5pbnB1dFByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgdGhpcy5wcm9wcy5pbnB1dFByb3BzLm9uQ2xpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbkZpbGVEaWFsb2dDYW5jZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkZpbGVEaWFsb2dDYW5jZWwoKSB7XG4gICAgICAvLyB0aW1lb3V0IHdpbGwgbm90IHJlY29nbml6ZSBjb250ZXh0IG9mIHRoaXMgbWV0aG9kXG4gICAgICB2YXIgb25GaWxlRGlhbG9nQ2FuY2VsID0gdGhpcy5wcm9wcy5vbkZpbGVEaWFsb2dDYW5jZWw7XG4gICAgICB2YXIgZmlsZUlucHV0RWwgPSB0aGlzLmZpbGVJbnB1dEVsO1xuICAgICAgdmFyIGlzRmlsZURpYWxvZ0FjdGl2ZSA9IHRoaXMuaXNGaWxlRGlhbG9nQWN0aXZlO1xuICAgICAgLy8gZXhlY3V0ZSB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBvbkZpbGVEaWFsb2dDYW5jZWwgaXMgZGVmaW5lZCBhbmQgRmlsZURpYWxvZ1xuICAgICAgLy8gaXMgb3BlbmVkIGluIHRoZSBicm93c2VyXG5cbiAgICAgIGlmIChvbkZpbGVEaWFsb2dDYW5jZWwgJiYgaXNGaWxlRGlhbG9nQWN0aXZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IGFzIEZpbGVMaXN0XG4gICAgICAgICAgdmFyIEZpbGVMaXN0ID0gZmlsZUlucHV0RWwuZmlsZXM7XG4gICAgICAgICAgaWYgKCFGaWxlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzRmlsZURpYWxvZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgb25GaWxlRGlhbG9nQ2FuY2VsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldFJlZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlZihyZWYpIHtcbiAgICAgIHRoaXMubm9kZSA9IHJlZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRSZWZzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVmcyhyZWYpIHtcbiAgICAgIHRoaXMuZmlsZUlucHV0RWwgPSByZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gc3lzdGVtIGZpbGUgdXBsb2FkIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3BlbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICB0aGlzLmlzRmlsZURpYWxvZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLmZpbGVJbnB1dEVsLnZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuZmlsZUlucHV0RWwuY2xpY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgYWNjZXB0ID0gX3Byb3BzMy5hY2NlcHQsXG4gICAgICAgICAgYWNjZXB0Q2xhc3NOYW1lID0gX3Byb3BzMy5hY2NlcHRDbGFzc05hbWUsXG4gICAgICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzMy5hY3RpdmVDbGFzc05hbWUsXG4gICAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMzLmNoaWxkcmVuLFxuICAgICAgICAgIGRpc2FibGVkID0gX3Byb3BzMy5kaXNhYmxlZCxcbiAgICAgICAgICBkaXNhYmxlZENsYXNzTmFtZSA9IF9wcm9wczMuZGlzYWJsZWRDbGFzc05hbWUsXG4gICAgICAgICAgaW5wdXRQcm9wcyA9IF9wcm9wczMuaW5wdXRQcm9wcyxcbiAgICAgICAgICBtdWx0aXBsZSA9IF9wcm9wczMubXVsdGlwbGUsXG4gICAgICAgICAgbmFtZSA9IF9wcm9wczMubmFtZSxcbiAgICAgICAgICByZWplY3RDbGFzc05hbWUgPSBfcHJvcHMzLnJlamVjdENsYXNzTmFtZSxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczMsIFsnYWNjZXB0JywgJ2FjY2VwdENsYXNzTmFtZScsICdhY3RpdmVDbGFzc05hbWUnLCAnY2hpbGRyZW4nLCAnZGlzYWJsZWQnLCAnZGlzYWJsZWRDbGFzc05hbWUnLCAnaW5wdXRQcm9wcycsICdtdWx0aXBsZScsICduYW1lJywgJ3JlamVjdENsYXNzTmFtZSddKTtcblxuICAgICAgdmFyIGFjY2VwdFN0eWxlID0gcmVzdC5hY2NlcHRTdHlsZSxcbiAgICAgICAgICBhY3RpdmVTdHlsZSA9IHJlc3QuYWN0aXZlU3R5bGUsXG4gICAgICAgICAgY2xhc3NOYW1lID0gcmVzdC5jbGFzc05hbWUsXG4gICAgICAgICAgZGlzYWJsZWRTdHlsZSA9IHJlc3QuZGlzYWJsZWRTdHlsZSxcbiAgICAgICAgICByZWplY3RTdHlsZSA9IHJlc3QucmVqZWN0U3R5bGUsXG4gICAgICAgICAgc3R5bGUgPSByZXN0LnN0eWxlLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlc3QsIFsnYWNjZXB0U3R5bGUnLCAnYWN0aXZlU3R5bGUnLCAnY2xhc3NOYW1lJywgJ2Rpc2FibGVkU3R5bGUnLCAncmVqZWN0U3R5bGUnLCAnc3R5bGUnXSk7XG5cbiAgICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIGlzRHJhZ0FjdGl2ZSA9IF9zdGF0ZS5pc0RyYWdBY3RpdmUsXG4gICAgICAgICAgZHJhZ2dlZEZpbGVzID0gX3N0YXRlLmRyYWdnZWRGaWxlcztcblxuICAgICAgdmFyIGZpbGVzQ291bnQgPSBkcmFnZ2VkRmlsZXMubGVuZ3RoO1xuICAgICAgdmFyIGlzTXVsdGlwbGVBbGxvd2VkID0gbXVsdGlwbGUgfHwgZmlsZXNDb3VudCA8PSAxO1xuICAgICAgdmFyIGlzRHJhZ0FjY2VwdCA9IGZpbGVzQ291bnQgPiAwICYmICgwLCBfdXRpbHMuYWxsRmlsZXNBY2NlcHRlZCkoZHJhZ2dlZEZpbGVzLCB0aGlzLnByb3BzLmFjY2VwdCk7XG4gICAgICB2YXIgaXNEcmFnUmVqZWN0ID0gZmlsZXNDb3VudCA+IDAgJiYgKCFpc0RyYWdBY2NlcHQgfHwgIWlzTXVsdGlwbGVBbGxvd2VkKTtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCAnJztcbiAgICAgIHZhciBub1N0eWxlcyA9ICFjbGFzc05hbWUgJiYgIXN0eWxlICYmICFhY3RpdmVTdHlsZSAmJiAhYWNjZXB0U3R5bGUgJiYgIXJlamVjdFN0eWxlICYmICFkaXNhYmxlZFN0eWxlO1xuXG4gICAgICBpZiAoaXNEcmFnQWN0aXZlICYmIGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWUgKz0gJyAnICsgYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgaWYgKGlzRHJhZ0FjY2VwdCAmJiBhY2NlcHRDbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIGFjY2VwdENsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RyYWdSZWplY3QgJiYgcmVqZWN0Q2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZSArPSAnICcgKyByZWplY3RDbGFzc05hbWU7XG4gICAgICB9XG4gICAgICBpZiAoZGlzYWJsZWQgJiYgZGlzYWJsZWRDbGFzc05hbWUpIHtcbiAgICAgICAgY2xhc3NOYW1lICs9ICcgJyArIGRpc2FibGVkQ2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9TdHlsZXMpIHtcbiAgICAgICAgc3R5bGUgPSBfc3R5bGVzMi5kZWZhdWx0LmRlZmF1bHQ7XG4gICAgICAgIGFjdGl2ZVN0eWxlID0gX3N0eWxlczIuZGVmYXVsdC5hY3RpdmU7XG4gICAgICAgIGFjY2VwdFN0eWxlID0gc3R5bGUuYWN0aXZlO1xuICAgICAgICByZWplY3RTdHlsZSA9IF9zdHlsZXMyLmRlZmF1bHQucmVqZWN0ZWQ7XG4gICAgICAgIGRpc2FibGVkU3R5bGUgPSBfc3R5bGVzMi5kZWZhdWx0LmRpc2FibGVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXBwbGllZFN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlKTtcbiAgICAgIGlmIChhY3RpdmVTdHlsZSAmJiBpc0RyYWdBY3RpdmUpIHtcbiAgICAgICAgYXBwbGllZFN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXB0U3R5bGUgJiYgaXNEcmFnQWNjZXB0KSB7XG4gICAgICAgIGFwcGxpZWRTdHlsZSA9IF9leHRlbmRzKHt9LCBhcHBsaWVkU3R5bGUsIGFjY2VwdFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWplY3RTdHlsZSAmJiBpc0RyYWdSZWplY3QpIHtcbiAgICAgICAgYXBwbGllZFN0eWxlID0gX2V4dGVuZHMoe30sIGFwcGxpZWRTdHlsZSwgcmVqZWN0U3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FibGVkU3R5bGUgJiYgZGlzYWJsZWQpIHtcbiAgICAgICAgYXBwbGllZFN0eWxlID0gX2V4dGVuZHMoe30sIHN0eWxlLCBkaXNhYmxlZFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgYWNjZXB0OiBhY2NlcHQsXG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSxcbiAgICAgICAgbXVsdGlwbGU6IF91dGlscy5zdXBwb3J0TXVsdGlwbGUgJiYgbXVsdGlwbGUsXG4gICAgICAgIHJlZjogdGhpcy5zZXRSZWZzLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5vbkRyb3AsXG4gICAgICAgIGF1dG9Db21wbGV0ZTogJ29mZidcbiAgICAgIH07XG5cbiAgICAgIGlmIChuYW1lICYmIG5hbWUubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0QXR0cmlidXRlcy5uYW1lID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGN1c3RvbSBwcm9wZXJ0aWVzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gdGhlIHdyYXBwZXIgZGl2IGVsZW1lbnRcbiAgICAgIHZhciBjdXN0b21Qcm9wcyA9IFsnYWNjZXB0ZWRGaWxlcycsICdwcmV2ZW50RHJvcE9uRG9jdW1lbnQnLCAnZGlzYWJsZVByZXZpZXcnLCAnZGlzYWJsZUNsaWNrJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY2NlcHRDbGFzc05hbWUnLCAncmVqZWN0Q2xhc3NOYW1lJywgJ2Rpc2FibGVkQ2xhc3NOYW1lJywgJ29uRHJvcEFjY2VwdGVkJywgJ29uRHJvcFJlamVjdGVkJywgJ29uRmlsZURpYWxvZ0NhbmNlbCcsICdtYXhTaXplJywgJ21pblNpemUnXTtcbiAgICAgIHZhciBkaXZQcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgICBjdXN0b21Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBkZWxldGUgZGl2UHJvcHNbcHJvcF07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBfZXh0ZW5kcyh7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgc3R5bGU6IGFwcGxpZWRTdHlsZVxuICAgICAgICB9LCBkaXZQcm9wcyAvKiBleHBhbmQgdXNlciBwcm92aWRlZCBwcm9wcyBmaXJzdCBzbyBldmVudCBoYW5kbGVycyBhcmUgbmV2ZXIgb3ZlcnJpZGRlbiAqLywge1xuICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25DbGljayksXG4gICAgICAgICAgb25EcmFnU3RhcnQ6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25EcmFnU3RhcnQpLFxuICAgICAgICAgIG9uRHJhZ0VudGVyOiB0aGlzLmNvbXBvc2VIYW5kbGVycyh0aGlzLm9uRHJhZ0VudGVyKSxcbiAgICAgICAgICBvbkRyYWdPdmVyOiB0aGlzLmNvbXBvc2VIYW5kbGVycyh0aGlzLm9uRHJhZ092ZXIpLFxuICAgICAgICAgIG9uRHJhZ0xlYXZlOiB0aGlzLmNvbXBvc2VIYW5kbGVycyh0aGlzLm9uRHJhZ0xlYXZlKSxcbiAgICAgICAgICBvbkRyb3A6IHRoaXMuY29tcG9zZUhhbmRsZXJzKHRoaXMub25Ecm9wKSxcbiAgICAgICAgICByZWY6IHRoaXMuc2V0UmVmLFxuICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogZGlzYWJsZWRcbiAgICAgICAgfSksXG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oY2hpbGRyZW4sIGlzRHJhZ0FjdGl2ZSwgaXNEcmFnQWNjZXB0LCBpc0RyYWdSZWplY3QpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIF9leHRlbmRzKHt9LCBpbnB1dFByb3BzIC8qIGV4cGFuZCB1c2VyIHByb3ZpZGVkIGlucHV0UHJvcHMgZmlyc3Qgc28gaW5wdXRBdHRyaWJ1dGVzIG92ZXJyaWRlIHRoZW0gKi8sIGlucHV0QXR0cmlidXRlcykpXG4gICAgICApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wem9uZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRHJvcHpvbmU7XG5cblxuRHJvcHpvbmUucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQWxsb3cgc3BlY2lmaWMgdHlwZXMgb2YgZmlsZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb2tvbmV0L2F0dHItYWNjZXB0IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiBLZWVwIGluIG1pbmQgdGhhdCBtaW1lIHR5cGUgZGV0ZXJtaW5hdGlvbiBpcyBub3QgcmVsaWFibGUgYWNyb3NzIHBsYXRmb3Jtcy4gQ1NWIGZpbGVzLFxuICAgKiBmb3IgZXhhbXBsZSwgYXJlIHJlcG9ydGVkIGFzIHRleHQvcGxhaW4gdW5kZXIgbWFjT1MgYnV0IGFzIGFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCB1bmRlclxuICAgKiBXaW5kb3dzLiBJbiBzb21lIGNhc2VzIHRoZXJlIG1pZ2h0IG5vdCBiZSBhIG1pbWUgdHlwZSBzZXQgYXQgYWxsLlxuICAgKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kcm9wem9uZS9yZWFjdC1kcm9wem9uZS9pc3N1ZXMvMjc2XG4gICAqL1xuICBhY2NlcHQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBDb250ZW50cyBvZiB0aGUgZHJvcHpvbmVcbiAgICovXG4gIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5ub2RlLCBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmNdKSxcblxuICAvKipcbiAgICogRGlzYWxsb3cgY2xpY2tpbmcgb24gdGhlIGRyb3B6b25lIGNvbnRhaW5lciB0byBvcGVuIGZpbGUgZGlhbG9nXG4gICAqL1xuICBkaXNhYmxlQ2xpY2s6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgKiBFbmFibGUvZGlzYWJsZSB0aGUgZHJvcHpvbmUgZW50aXJlbHlcbiAgKi9cbiAgZGlzYWJsZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcblxuICAvKipcbiAgICogRW5hYmxlL2Rpc2FibGUgcHJldmlldyBnZW5lcmF0aW9uXG4gICAqL1xuICBkaXNhYmxlUHJldmlldzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgYWxsb3cgZHJvcHBlZCBpdGVtcyB0byB0YWtlIG92ZXIgdGhlIGN1cnJlbnQgYnJvd3NlciB3aW5kb3dcbiAgICovXG4gIHByZXZlbnREcm9wT25Eb2N1bWVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBQYXNzIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byB0aGUgYDxpbnB1dCB0eXBlPVwiZmlsZVwiLz5gIHRhZ1xuICAgKi9cbiAgaW5wdXRQcm9wczogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG5cbiAgLyoqXG4gICAqIEFsbG93IGRyb3BwaW5nIG11bHRpcGxlIGZpbGVzXG4gICAqL1xuICBtdWx0aXBsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuXG4gIC8qKlxuICAgKiBgbmFtZWAgYXR0cmlidXRlIGZvciB0aGUgaW5wdXQgdGFnXG4gICAqL1xuICBuYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogTWF4aW11bSBmaWxlIHNpemVcbiAgICovXG4gIG1heFNpemU6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGZpbGUgc2l6ZVxuICAgKi9cbiAgbWluU2l6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG5cbiAgLyoqXG4gICAqIGNsYXNzTmFtZVxuICAgKi9cbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogY2xhc3NOYW1lIGZvciBhY3RpdmUgc3RhdGVcbiAgICovXG4gIGFjdGl2ZUNsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIGNsYXNzTmFtZSBmb3IgYWNjZXB0ZWQgc3RhdGVcbiAgICovXG4gIGFjY2VwdENsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIGNsYXNzTmFtZSBmb3IgcmVqZWN0ZWQgc3RhdGVcbiAgICovXG4gIHJlamVjdENsYXNzTmFtZTogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIGNsYXNzTmFtZSBmb3IgZGlzYWJsZWQgc3RhdGVcbiAgICovXG4gIGRpc2FibGVkQ2xhc3NOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcblxuICAvKipcbiAgICogQ1NTIHN0eWxlcyB0byBhcHBseVxuICAgKi9cbiAgc3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzIHRvIGFwcGx5IHdoZW4gZHJhZyBpcyBhY3RpdmVcbiAgICovXG4gIGFjdGl2ZVN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcblxuICAvKipcbiAgICogQ1NTIHN0eWxlcyB0byBhcHBseSB3aGVuIGRyb3Agd2lsbCBiZSBhY2NlcHRlZFxuICAgKi9cbiAgYWNjZXB0U3R5bGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxuXG4gIC8qKlxuICAgKiBDU1Mgc3R5bGVzIHRvIGFwcGx5IHdoZW4gZHJvcCB3aWxsIGJlIHJlamVjdGVkXG4gICAqL1xuICByZWplY3RTdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG5cbiAgLyoqXG4gICAqIENTUyBzdHlsZXMgdG8gYXBwbHkgd2hlbiBkcm9wem9uZSBpcyBkaXNhYmxlZFxuICAgKi9cbiAgZGlzYWJsZWRTdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXG5cbiAgLyoqXG4gICAqIG9uQ2xpY2sgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIG9uQ2xpY2s6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25Ecm9wIGNhbGxiYWNrXG4gICAqL1xuICBvbkRyb3A6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25Ecm9wQWNjZXB0ZWQgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJvcEFjY2VwdGVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIG9uRHJvcFJlamVjdGVkIGNhbGxiYWNrXG4gICAqL1xuICBvbkRyb3BSZWplY3RlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuXG4gIC8qKlxuICAgKiBvbkRyYWdTdGFydCBjYWxsYmFja1xuICAgKi9cbiAgb25EcmFnU3RhcnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25EcmFnRW50ZXIgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJhZ0VudGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIG9uRHJhZ092ZXIgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJhZ092ZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcblxuICAvKipcbiAgICogb25EcmFnTGVhdmUgY2FsbGJhY2tcbiAgICovXG4gIG9uRHJhZ0xlYXZlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjYWxsYmFjayBvbiBjbGlja2luZyB0aGUgY2FuY2VsIGJ1dHRvbiBvZiB0aGUgZmlsZSBkaWFsb2dcbiAgICovXG4gIG9uRmlsZURpYWxvZ0NhbmNlbDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jXG59O1xuXG5Ecm9wem9uZS5kZWZhdWx0UHJvcHMgPSB7XG4gIHByZXZlbnREcm9wT25Eb2N1bWVudDogdHJ1ZSxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBkaXNhYmxlUHJldmlldzogZmFsc2UsXG4gIGRpc2FibGVDbGljazogZmFsc2UsXG4gIG11bHRpcGxlOiB0cnVlLFxuICBtYXhTaXplOiBJbmZpbml0eSxcbiAgbWluU2l6ZTogMFxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMSkpKVxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN1cHBvcnRNdWx0aXBsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZ2V0RGF0YVRyYW5zZmVySXRlbXMgPSBnZXREYXRhVHJhbnNmZXJJdGVtcztcbmV4cG9ydHMuZmlsZUFjY2VwdGVkID0gZmlsZUFjY2VwdGVkO1xuZXhwb3J0cy5maWxlTWF0Y2hTaXplID0gZmlsZU1hdGNoU2l6ZTtcbmV4cG9ydHMuYWxsRmlsZXNBY2NlcHRlZCA9IGFsbEZpbGVzQWNjZXB0ZWQ7XG5leHBvcnRzLm9uRG9jdW1lbnREcmFnT3ZlciA9IG9uRG9jdW1lbnREcmFnT3ZlcjtcblxudmFyIF9hdHRyQWNjZXB0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9hdHRyQWNjZXB0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F0dHJBY2NlcHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3VwcG9ydE11bHRpcGxlID0gZXhwb3J0cy5zdXBwb3J0TXVsdGlwbGUgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPyAnbXVsdGlwbGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JykgOiB0cnVlO1xuXG5mdW5jdGlvbiBnZXREYXRhVHJhbnNmZXJJdGVtcyhldmVudCkge1xuICB2YXIgZGF0YVRyYW5zZmVySXRlbXNMaXN0ID0gW107XG4gIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICB2YXIgZHQgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gICAgaWYgKGR0LmZpbGVzICYmIGR0LmZpbGVzLmxlbmd0aCkge1xuICAgICAgZGF0YVRyYW5zZmVySXRlbXNMaXN0ID0gZHQuZmlsZXM7XG4gICAgfSBlbHNlIGlmIChkdC5pdGVtcyAmJiBkdC5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIC8vIER1cmluZyB0aGUgZHJhZyBldmVuIHRoZSBkYXRhVHJhbnNmZXIuZmlsZXMgaXMgbnVsbFxuICAgICAgLy8gYnV0IENocm9tZSBpbXBsZW1lbnRzIHNvbWUgZHJhZyBzdG9yZSwgd2hpY2ggaXMgYWNjZXNpYmxlIHZpYSBkYXRhVHJhbnNmZXIuaXRlbXNcbiAgICAgIGRhdGFUcmFuc2Zlckl0ZW1zTGlzdCA9IGR0Lml0ZW1zO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgJiYgZXZlbnQudGFyZ2V0LmZpbGVzKSB7XG4gICAgZGF0YVRyYW5zZmVySXRlbXNMaXN0ID0gZXZlbnQudGFyZ2V0LmZpbGVzO1xuICB9XG4gIC8vIENvbnZlcnQgZnJvbSBEYXRhVHJhbnNmZXJJdGVtc0xpc3QgdG8gdGhlIG5hdGl2ZSBBcnJheVxuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGF0YVRyYW5zZmVySXRlbXNMaXN0KTtcbn1cblxuLy8gRmlyZWZveCB2ZXJzaW9ucyBwcmlvciB0byA1MyByZXR1cm4gYSBib2d1cyBNSU1FIHR5cGUgZm9yIGV2ZXJ5IGZpbGUgZHJhZywgc28gZHJhZ292ZXJzIHdpdGhcbi8vIHRoYXQgTUlNRSB0eXBlIHdpbGwgYWx3YXlzIGJlIGFjY2VwdGVkXG5mdW5jdGlvbiBmaWxlQWNjZXB0ZWQoZmlsZSwgYWNjZXB0KSB7XG4gIHJldHVybiBmaWxlLnR5cGUgPT09ICdhcHBsaWNhdGlvbi94LW1vei1maWxlJyB8fCAoMCwgX2F0dHJBY2NlcHQyLmRlZmF1bHQpKGZpbGUsIGFjY2VwdCk7XG59XG5cbmZ1bmN0aW9uIGZpbGVNYXRjaFNpemUoZmlsZSwgbWF4U2l6ZSwgbWluU2l6ZSkge1xuICByZXR1cm4gZmlsZS5zaXplIDw9IG1heFNpemUgJiYgZmlsZS5zaXplID49IG1pblNpemU7XG59XG5cbmZ1bmN0aW9uIGFsbEZpbGVzQWNjZXB0ZWQoZmlsZXMsIGFjY2VwdCkge1xuICByZXR1cm4gZmlsZXMuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZUFjY2VwdGVkKGZpbGUsIGFjY2VwdCk7XG4gIH0pO1xufVxuXG4vLyBhbGxvdyB0aGUgZW50aXJlIGRvY3VtZW50IHRvIGJlIGEgZHJhZyB0YXJnZXRcbmZ1bmN0aW9uIG9uRG9jdW1lbnREcmFnT3ZlcihldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKGUpe2lmKHJbZV0pcmV0dXJuIHJbZV0uZXhwb3J0czt2YXIgbz1yW2VdPXtleHBvcnRzOnt9LGlkOmUsbG9hZGVkOiExfTtyZXR1cm4gdFtlXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmxvYWRlZD0hMCxvLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIG4ubT10LG4uYz1yLG4ucD1cIlwiLG4oMCl9KFtmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7bi5fX2VzTW9kdWxlPSEwLHIoOCkscig5KSxuW1wiZGVmYXVsdFwiXT1mdW5jdGlvbih0LG4pe2lmKHQmJm4pe3ZhciByPWZ1bmN0aW9uKCl7dmFyIHI9QXJyYXkuaXNBcnJheShuKT9uOm4uc3BsaXQoXCIsXCIpLGU9dC5uYW1lfHxcIlwiLG89dC50eXBlfHxcIlwiLGk9by5yZXBsYWNlKC9cXC8uKiQvLFwiXCIpO3JldHVybnt2OnIuc29tZShmdW5jdGlvbih0KXt2YXIgbj10LnRyaW0oKTtyZXR1cm5cIi5cIj09PW4uY2hhckF0KDApP2UudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChuLnRvTG93ZXJDYXNlKCkpOi9cXC9cXCokLy50ZXN0KG4pP2k9PT1uLnJlcGxhY2UoL1xcLy4qJC8sXCJcIik6bz09PW59KX19KCk7aWYoXCJvYmplY3RcIj09dHlwZW9mIHIpcmV0dXJuIHIudn1yZXR1cm4hMH0sdC5leHBvcnRzPW5bXCJkZWZhdWx0XCJdfSxmdW5jdGlvbih0LG4pe3ZhciByPXQuZXhwb3J0cz17dmVyc2lvbjpcIjEuMi4yXCJ9O1wibnVtYmVyXCI9PXR5cGVvZiBfX2UmJihfX2U9cil9LGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5leHBvcnRzPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5NYXRoPT1NYXRoP3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5NYXRoPT1NYXRoP3NlbGY6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1wibnVtYmVyXCI9PXR5cGVvZiBfX2cmJihfX2c9cil9LGZ1bmN0aW9uKHQsbixyKXt2YXIgZT1yKDIpLG89cigxKSxpPXIoNCksdT1yKDE5KSxjPVwicHJvdG90eXBlXCIsZj1mdW5jdGlvbih0LG4pe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KG4sYXJndW1lbnRzKX19LHM9ZnVuY3Rpb24odCxuLHIpe3ZhciBhLHAsbCx5LGQ9dCZzLkcsaD10JnMuUCx2PWQ/ZTp0JnMuUz9lW25dfHwoZVtuXT17fSk6KGVbbl18fHt9KVtjXSx4PWQ/bzpvW25dfHwob1tuXT17fSk7ZCYmKHI9bik7Zm9yKGEgaW4gcilwPSEodCZzLkYpJiZ2JiZhIGluIHYsbD0ocD92OnIpW2FdLHk9dCZzLkImJnA/ZihsLGUpOmgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGw/ZihGdW5jdGlvbi5jYWxsLGwpOmwsdiYmIXAmJnUodixhLGwpLHhbYV0hPWwmJmkoeCxhLHkpLGgmJigoeFtjXXx8KHhbY109e30pKVthXT1sKX07ZS5jb3JlPW8scy5GPTEscy5HPTIscy5TPTQscy5QPTgscy5CPTE2LHMuVz0zMix0LmV4cG9ydHM9c30sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoNSksbz1yKDE4KTt0LmV4cG9ydHM9cigyMik/ZnVuY3Rpb24odCxuLHIpe3JldHVybiBlLnNldERlc2ModCxuLG8oMSxyKSl9OmZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFtuXT1yLHR9fSxmdW5jdGlvbih0LG4pe3ZhciByPU9iamVjdDt0LmV4cG9ydHM9e2NyZWF0ZTpyLmNyZWF0ZSxnZXRQcm90bzpyLmdldFByb3RvdHlwZU9mLGlzRW51bTp7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxnZXREZXNjOnIuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHNldERlc2M6ci5kZWZpbmVQcm9wZXJ0eSxzZXREZXNjczpyLmRlZmluZVByb3BlcnRpZXMsZ2V0S2V5czpyLmtleXMsZ2V0TmFtZXM6ci5nZXRPd25Qcm9wZXJ0eU5hbWVzLGdldFN5bWJvbHM6ci5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsZWFjaDpbXS5mb3JFYWNofX0sZnVuY3Rpb24odCxuKXt2YXIgcj0wLGU9TWF0aC5yYW5kb20oKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJTeW1ib2woXCIuY29uY2F0KHZvaWQgMD09PXQ/XCJcIjp0LFwiKV9cIiwoKytyK2UpLnRvU3RyaW5nKDM2KSl9fSxmdW5jdGlvbih0LG4scil7dmFyIGU9cigyMCkoXCJ3a3NcIiksbz1yKDIpLlN5bWJvbDt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGVbdF18fChlW3RdPW8mJm9bdF18fChvfHxyKDYpKShcIlN5bWJvbC5cIit0KSl9fSxmdW5jdGlvbih0LG4scil7cigyNiksdC5leHBvcnRzPXIoMSkuQXJyYXkuc29tZX0sZnVuY3Rpb24odCxuLHIpe3IoMjUpLHQuZXhwb3J0cz1yKDEpLlN0cmluZy5lbmRzV2l0aH0sZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IodCtcIiBpcyBub3QgYSBmdW5jdGlvbiFcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LG4pe3ZhciByPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gci5jYWxsKHQpLnNsaWNlKDgsLTEpfX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0LG4scil7aWYoZSh0KSx2b2lkIDA9PT1uKXJldHVybiB0O3N3aXRjaChyKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHIpe3JldHVybiB0LmNhbGwobixyKX07Y2FzZSAyOnJldHVybiBmdW5jdGlvbihyLGUpe3JldHVybiB0LmNhbGwobixyLGUpfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHIsZSxvKXtyZXR1cm4gdC5jYWxsKG4scixlLG8pfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdC5hcHBseShuLGFyZ3VtZW50cyl9fX0sZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIit0KTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsbixyKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIG49Ly4vO3RyeXtcIi8uL1wiW3RdKG4pfWNhdGNoKGUpe3RyeXtyZXR1cm4gbltyKDcpKFwibWF0Y2hcIildPSExLCFcIi8uL1wiW3RdKG4pfWNhdGNoKG8pe319cmV0dXJuITB9fSxmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0cnl7cmV0dXJuISF0KCl9Y2F0Y2gobil7cmV0dXJuITB9fX0sZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQ/bnVsbCE9PXQ6XCJmdW5jdGlvblwiPT10eXBlb2YgdH19LGZ1bmN0aW9uKHQsbixyKXt2YXIgZT1yKDE2KSxvPXIoMTEpLGk9cig3KShcIm1hdGNoXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgbjtyZXR1cm4gZSh0KSYmKHZvaWQgMCE9PShuPXRbaV0pPyEhbjpcIlJlZ0V4cFwiPT1vKHQpKX19LGZ1bmN0aW9uKHQsbil7dC5leHBvcnRzPWZ1bmN0aW9uKHQsbil7cmV0dXJue2VudW1lcmFibGU6ISgxJnQpLGNvbmZpZ3VyYWJsZTohKDImdCksd3JpdGFibGU6ISg0JnQpLHZhbHVlOm59fX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMiksbz1yKDQpLGk9cig2KShcInNyY1wiKSx1PVwidG9TdHJpbmdcIixjPUZ1bmN0aW9uW3VdLGY9KFwiXCIrYykuc3BsaXQodSk7cigxKS5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBjLmNhbGwodCl9LCh0LmV4cG9ydHM9ZnVuY3Rpb24odCxuLHIsdSl7XCJmdW5jdGlvblwiPT10eXBlb2YgciYmKG8ocixpLHRbbl0/XCJcIit0W25dOmYuam9pbihTdHJpbmcobikpKSxcIm5hbWVcImluIHJ8fChyLm5hbWU9bikpLHQ9PT1lP3Rbbl09cjoodXx8ZGVsZXRlIHRbbl0sbyh0LG4scikpfSkoRnVuY3Rpb24ucHJvdG90eXBlLHUsZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzJiZ0aGlzW2ldfHxjLmNhbGwodGhpcyl9KX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMiksbz1cIl9fY29yZS1qc19zaGFyZWRfX1wiLGk9ZVtvXXx8KGVbb109e30pO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gaVt0XXx8KGlbdF09e30pfX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMTcpLG89cigxMyk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsbixyKXtpZihlKG4pKXRocm93IFR5cGVFcnJvcihcIlN0cmluZyNcIityK1wiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtyZXR1cm4gU3RyaW5nKG8odCkpfX0sZnVuY3Rpb24odCxuLHIpe3QuZXhwb3J0cz0hcigxNSkoZnVuY3Rpb24oKXtyZXR1cm4gNyE9T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSl9LGZ1bmN0aW9uKHQsbil7dmFyIHI9TWF0aC5jZWlsLGU9TWF0aC5mbG9vcjt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGlzTmFOKHQ9K3QpPzA6KHQ+MD9lOnIpKHQpfX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoMjMpLG89TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/byhlKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9cigzKSxvPXIoMjQpLGk9cigyMSksdT1cImVuZHNXaXRoXCIsYz1cIlwiW3VdO2UoZS5QK2UuRipyKDE0KSh1KSxcIlN0cmluZ1wiLHtlbmRzV2l0aDpmdW5jdGlvbih0KXt2YXIgbj1pKHRoaXMsdCx1KSxyPWFyZ3VtZW50cyxlPXIubGVuZ3RoPjE/clsxXTp2b2lkIDAsZj1vKG4ubGVuZ3RoKSxzPXZvaWQgMD09PWU/ZjpNYXRoLm1pbihvKGUpLGYpLGE9U3RyaW5nKHQpO3JldHVybiBjP2MuY2FsbChuLGEscyk6bi5zbGljZShzLWEubGVuZ3RoLHMpPT09YX19KX0sZnVuY3Rpb24odCxuLHIpe3ZhciBlPXIoNSksbz1yKDMpLGk9cigxKS5BcnJheXx8QXJyYXksdT17fSxjPWZ1bmN0aW9uKHQsbil7ZS5lYWNoLmNhbGwodC5zcGxpdChcIixcIiksZnVuY3Rpb24odCl7dm9pZCAwPT1uJiZ0IGluIGk/dVt0XT1pW3RdOnQgaW5bXSYmKHVbdF09cigxMikoRnVuY3Rpb24uY2FsbCxbXVt0XSxuKSl9KX07YyhcInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXNcIiwxKSxjKFwiaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlc1wiLDMpLGMoXCJqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiKSxvKG8uUyxcIkFycmF5XCIsdSl9XSk7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICByZWplY3RlZDoge1xuICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgIGJvcmRlckNvbG9yOiAnI2M2NicsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2VlZSdcbiAgfSxcbiAgZGlzYWJsZWQ6IHtcbiAgICBvcGFjaXR5OiAwLjVcbiAgfSxcbiAgYWN0aXZlOiB7XG4gICAgYm9yZGVyU3R5bGU6ICdzb2xpZCcsXG4gICAgYm9yZGVyQ29sb3I6ICcjNmM2JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWVlJ1xuICB9LFxuICBkZWZhdWx0OiB7XG4gICAgd2lkdGg6IDIwMCxcbiAgICBoZWlnaHQ6IDIwMCxcbiAgICBib3JkZXJXaWR0aDogMixcbiAgICBib3JkZXJDb2xvcjogJyM2NjYnLFxuICAgIGJvcmRlclN0eWxlOiAnZGFzaGVkJyxcbiAgICBib3JkZXJSYWRpdXM6IDVcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBEcm9wem9uZSBmcm9tICcuL3RoaXJkLXBhcnR5L3JlYWN0LWRyb3B6b25lJztcbmltcG9ydCBJbnB1dFJlYWRPbmx5IGZyb20gJy4vcmVhZC1vbmx5LmpzeCc7XG5pbXBvcnQgVXBsb2FkU2hvd0ZpbGUgZnJvbSAnLi91cGxvYWQvdXBsb2FkLXNob3ctZmlsZS5qc3gnO1xuaW1wb3J0IHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5sZXQgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvaGVscGVycy9hamF4LWhlbHBlcicpLmFqYXhIZWxwZXIsXG4gICAgaTE4biA9IHJlcXVpcmUoJy4uLy4uLy4uL1Jlc291cmNlcy9wdWJsaWMvanMvc2VjdGlvbnMvaTE4bicpLmkxOG4sXG4gICAgJCA9IGpRdWVyeTtcblxuY2xhc3MgSW5wdXRVcGxvYWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZmllbGRWYWx1ZSB9ID0gcHJvcHMuZGF0YTtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmaWxlczogZmllbGRWYWx1ZSA/IGZpZWxkVmFsdWUuc3BsaXQoJywnKSA6IFtdLFxuICAgICAgICAgICAgbG9hZGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25Ecm9wKGFjY2VwdGVkRmlsZXMpIHtcbiAgICAgICAgbGV0IHVwbG9hZFVybCA9IGFqYXhIZWxwZXIuZ2V0VXJsLmFwcGx5KHRoaXMucHJvcHMuZ2NydWRJbnN0YW5jZSwgWyd1cGxvYWQnXSksXG4gICAgICAgICAgICB1cGxvYWRSZXF1ZXN0ID0gcmVxdWVzdC5wb3N0KHVwbG9hZFVybCksXG4gICAgICAgICAgICByZXF1ZXN0RXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgeyBmaWxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBtYXhVcGxvYWRMaW1pdCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdEV4dHJhSGVhZGVycyA9ICQuYWpheFNldHVwKCkuaGVhZGVycztcblxuICAgICAgICBpZiAocmVxdWVzdEV4dHJhSGVhZGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyZXF1ZXN0RXh0cmFIZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIGZvcmVhY2hSZXF1ZXN0SGVhZGVycyhoZWFkZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyVmFsdWUgPSByZXF1ZXN0RXh0cmFIZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgICAgICAgICAgIHVwbG9hZFJlcXVlc3Quc2V0KGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFVwbG9hZExpbWl0ID4gMSkge1xuICAgICAgICAgICAgYWNjZXB0ZWRGaWxlcy5mb3JFYWNoKChhY2NlcHRlZEZpbGUsIG51bUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwbG9hZFJlcXVlc3QuYXR0YWNoKHRoaXMucHJvcHMuZGF0YS5maWVsZE5hbWUgKyAnWycgKyBudW1LZXkgKyAnXScsIGFjY2VwdGVkRmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY2VwdGVkRmlsZXMuZm9yRWFjaCgoYWNjZXB0ZWRGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgdXBsb2FkUmVxdWVzdC5hdHRhY2godGhpcy5wcm9wcy5kYXRhLmZpZWxkTmFtZSwgYWNjZXB0ZWRGaWxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBsb2FkUmVxdWVzdC5lbmQoZnVuY3Rpb24gdXBsb2FkUmVzcG9uc2UoZXJyLCBvdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2NydWRJbnN0YW5jZSB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBqc29uUmVzcG9uc2UgPSBvdXRwdXQuYm9keTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnIgfHwganNvblJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWpheEhlbHBlci5hamF4T25GYWlsLmFwcGx5KGdjcnVkSW5zdGFuY2UsIFtvdXRwdXQudGV4dCwgKGVyciA/IGVyci5zdGF0dXMgOiAnTm90IHdlbGwgSlNPTiBmb3JtYXR0ZWQgcmVzcG9uc2UnKSwgJ2Vycm9yJ10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLnN0YXR1cyA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuYWpheE9uRmFpbC5hcHBseShnY3J1ZEluc3RhbmNlLCBbanNvblJlc3BvbnNlLm1lc3NhZ2UsIGpzb25SZXNwb25zZS5zdGF0dXMsICdlcnJvciddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICBnY3J1ZEluc3RhbmNlLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlsZXMucHVzaChqc29uUmVzcG9uc2UudXBsb2FkUmVzdWx0LmZpbGVuYW1lKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWxlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBkZWxldGVPbkNsaWNrKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgZ2NydWRJbnN0YW5jZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGRlbGV0ZUZpbGVVcmwgPSBhamF4SGVscGVyLmdldFVybC5hcHBseShnY3J1ZEluc3RhbmNlLCBbXSksXG4gICAgICAgICAgICBkZWxldGVGaWxlUmVxdWVzdCA9IHJlcXVlc3QucG9zdChkZWxldGVGaWxlVXJsKSxcbiAgICAgICAgICAgIHsgZmllbGROYW1lIH0gPSB0aGlzLnByb3BzLmRhdGEsXG4gICAgICAgICAgICB7IGZpbGVzIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdEV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGRhdGFUb1NlbmQgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZGVsZXRlLWZpbGUnLFxuICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgIGRhdGFUb1NlbmRbZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXROYW1lXSA9IGdjcnVkSW5zdGFuY2UuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0RXh0cmFIZWFkZXJzID0gJC5hamF4U2V0dXAoKS5oZWFkZXJzO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0RXh0cmFIZWFkZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3RFeHRyYUhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gZm9yZWFjaFJlcXVlc3RIZWFkZXJzKGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IHJlcXVlc3RFeHRyYUhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlRmlsZVJlcXVlc3Quc2V0KGhlYWRlck5hbWUsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlRmlsZVJlcXVlc3QudHlwZSgnZm9ybScpO1xuICAgICAgICBkZWxldGVGaWxlUmVxdWVzdC5zZW5kKGRhdGFUb1NlbmQpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxvYWRpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZUZpbGVSZXF1ZXN0LmVuZChmdW5jdGlvbiBkZWxldGVGaWxlUmVxdWVzdEVuZChlcnIsIG91dHB1dCkge1xuICAgICAgICAgICAgY29uc3QganNvblJlc3BvbnNlID0gb3V0cHV0LmJvZHk7XG5cbiAgICAgICAgICAgIGlmIChlcnIgfHwganNvblJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWpheEhlbHBlci5hamF4T25GYWlsLmFwcGx5KGdjcnVkSW5zdGFuY2UsIFtvdXRwdXQudGV4dCwgKGVyciA/IGVyci5zdGF0dXMgOiAnTm90IHdlbGwgSlNPTiBmb3JtYXR0ZWQgcmVzcG9uc2UnKSwgJ2Vycm9yJ10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgICAgICAgICAgICBhamF4SGVscGVyLmFqYXhPbkZhaWwuYXBwbHkoZ2NydWRJbnN0YW5jZSwgW2pzb25SZXNwb25zZS5tZXNzYWdlLCBqc29uUmVzcG9uc2Uuc3RhdHVzLCAnZXJyb3InXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2NydWRJbnN0YW5jZS5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGZpbGVzLmZpbHRlcihmaWxlID0+IGZpbGUgIT09IGZpbGVuYW1lKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBnZXRUcmFuc2xhdGlvbkZpbGVBdHRhY2goKSB7XG4gICAgICAgIGxldCBzcGxpdHRlZFN0cmluZyA9IGkxOG4udCgndXBsb2FkX2F0dGFjaF9maWxlJykuc3BsaXQoJ3ticm93c2VfZmlsZX0nKTtcblxuICAgICAgICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdHRlZFN0cmluZ1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoPHNwYW4+XG4gICAgICAgICAgICB7c3BsaXR0ZWRTdHJpbmdbMF19IHs8YT57aTE4bi50KCdicm93c2VfZmlsZScpfTwvYT59IHtzcGxpdHRlZFN0cmluZ1sxXX1cbiAgICAgICAgPC9zcGFuPik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgbG9hZGluZywgZmlsZXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7IG1heFVwbG9hZExpbWl0LCBkYXRhOiB7IGZpZWxkTmFtZSwgaXNSZWFkT25seSwgb3B0aW9ucyB9IH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgSlNYYXJyYXkgPSBbXTtcblxuXG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxkaXY+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZmEgZmEtcmVmcmVzaCBmYS1zcGluXCI+PC9pPiBMb2FkaW5nLi4uXG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVhZE9ubHkgJiYgZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gPElucHV0UmVhZE9ubHkgZmllbGRWYWx1ZT1cIlwiLz47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoIDwgbWF4VXBsb2FkTGltaXQpIHtcbiAgICAgICAgICAgIEpTWGFycmF5LnB1c2goXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9XCJkcm9wem9uZVwiIHN0eWxlPXt7bWFyZ2luQm90dG9tOiAnNXB4J319PlxuICAgICAgICAgICAgICAgICAgICA8RHJvcHpvbmUgc3R5bGU9e3sgZGlzcGxheTogJ2Jsb2NrJyB9fSBvbkRyb3A9e3RoaXMub25Ecm9wLmJpbmQodGhpcyl9IG11bHRpcGxlPXttYXhVcGxvYWRMaW1pdCA+IDF9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJnYy1kcm9wem9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZhIGZhLWNsb3VkLXVwbG9hZFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmbmJzcDsge3RoaXMuZ2V0VHJhbnNsYXRpb25GaWxlQXR0YWNoKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9Ecm9wem9uZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmaWxlcy5mb3JFYWNoKGZpbGVuYW1lID0+IHtcbiAgICAgICAgICAgIEpTWGFycmF5LnB1c2goXG4gICAgICAgICAgICAgICAgPFVwbG9hZFNob3dGaWxlXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoPXtvcHRpb25zLnB1YmxpY1BhdGggKyAnLycgKyBmaWxlbmFtZX1cbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU9e2ZpbGVuYW1lfVxuICAgICAgICAgICAgICAgICAgICBrZXk9e2ZpbGVuYW1lfVxuICAgICAgICAgICAgICAgICAgICBpc1JlYWRPbmx5PXtpc1JlYWRPbmx5fVxuICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZT17dGhpcy5kZWxldGVPbkNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbl9kZWxldGU6IGkxOG4udCgnYWN0aW9uX2RlbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEpTWGFycmF5LnB1c2goPGlucHV0IGtleT17ZmllbGROYW1lfSBuYW1lPXtmaWVsZE5hbWV9IHZhbHVlPXtmaWxlcy5qb2luKCcsJyl9IHR5cGU9XCJoaWRkZW5cIiAvPik7XG5cbiAgICAgICAgcmV0dXJuIEpTWGFycmF5O1xuICAgIH1cbn1cblxuSW5wdXRVcGxvYWQucHJvcFR5cGVzID0ge1xuICAgIG1heFVwbG9hZExpbWl0OiBQcm9wVHlwZXMubnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0VXBsb2FkO1xuIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgVXBsb2FkU2hvd0ZpbGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBmaWxlbmFtZSwgZmlsZVBhdGgsIGlzUmVhZE9ubHksIG9uRGVsZXRlLCBpMThuIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICA8YSBocmVmPXtmaWxlUGF0aH0gdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC9cXC4oanAoZSk/Z3xnaWZ8cG5nfHRpZmYpJC8udGVzdChmaWxlUGF0aCkgP1xuICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtmaWxlUGF0aH0gaGVpZ2h0PVwiNTBcIi8+IDpcbiAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57ZmlsZW5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgPC9hPiAmbmJzcDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzUmVhZE9ubHkgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBvbkRlbGV0ZShmaWxlbmFtZSl9IGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmYSBmYS10cmFzaC1vXCI+PC9pPiZuYnNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB7aTE4bi5hY3Rpb25fZGVsZXRlfVxuICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgIH0gJm5ic3A7XG4gICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICk7XG4gIH1cbn1cblxuVXBsb2FkU2hvd0ZpbGUucHJvcFR5cGVzID0ge1xuICAgIGZpbGVuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGZpbGVQYXRoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGlzUmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxuICAgIGZpZWxkTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkRlbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaTE4bjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgICAgYWN0aW9uX2RlbGV0ZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0pXG59O1xuXG5VcGxvYWRTaG93RmlsZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaTE4bjoge1xuICAgICAgICBhY3Rpb25fZGVsZXRlOiAnRGVsZXRlJ1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkU2hvd0ZpbGU7IiwiXG5pbXBvcnQgSW5wdXRUZXh0IGZyb20gJy4vdGV4dC5qc3gnO1xuXG5jbGFzcyBJbnB1dFVybCBleHRlbmRzIElucHV0VGV4dCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgeyBkYXRhIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBmaWVsZE5hbWUgfSA9IHRoaXMucHJvcHMuZGF0YTtcblxuICAgICAgICByZXR1cm4gPElucHV0VGV4dCBrZXk9e2ZpZWxkTmFtZX0gZGF0YT17ZGF0YX0gLz5cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0VXJsO1xuIiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgTW9kYWxUaXRsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHRpdGxlLCBNb2RhbFRpdGxlV3JhcHBlciB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPE1vZGFsVGl0bGVXcmFwcGVyIHRpdGxlPXt0aXRsZX0gLz5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbk1vZGFsVGl0bGUucHJvcFR5cGVzID0ge1xuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIE1vZGFsVGl0bGVXcmFwcGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuTW9kYWxUaXRsZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgTW9kYWxUaXRsZVdyYXBwZXI6IHByb3BzID0+IDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjbG9zZVwiXG4gICAgICAgICAgICBkYXRhLWRpc21pc3M9XCJtb2RhbFwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGg0IGNsYXNzTmFtZT1cIm1vZGFsLXRpdGxlXCI+XG4gICAgICAgICAgICB7cHJvcHMudGl0bGV9XG4gICAgICAgIDwvaDQ+XG4gICAgPC9SZWFjdC5GcmFnbWVudD5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsVGl0bGU7XG4iLCJpbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBWaXNpYmxlQ29sdW1ucyBmcm9tICcuL3Zpc2libGUtY29sdW1ucy5qc3gnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyID0gdGhpcy5zZXRDb250YWluZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNldHRpbmdzT3BlbjogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNldHRpbmdzT3BlbjogIXRoaXMuc3RhdGUuc2V0dGluZ3NPcGVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldENvbnRhaW5lcihyZWYpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNsaWNrT3V0c2lkZShlKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNsaWNrT3V0c2lkZShlKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2V0dGluZ3NPcGVuIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmIChzZXR0aW5nc09wZW4gJiYgdGhpcy5jb250YWluZXIgJiYgIXRoaXMuY29udGFpbmVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNldHRpbmdzT3BlbjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25SZWZyZXNoQ2FsbGJhY2soKSB7XG4gICAgICAgIGNvbnN0IHsgb25SZWZyZXNoQ2FsbGJhY2sgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uUmVmcmVzaENhbGxiYWNrKSB7XG4gICAgICAgICAgICBvblJlZnJlc2hDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DbGVhckZpbHRlcmluZ0NhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCB7IG9uQ2xlYXJGaWx0ZXJpbmdDYWxsYmFjayB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25DbGVhckZpbHRlcmluZ0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBvbkNsZWFyRmlsdGVyaW5nQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2xlYXJDYWNoZUNhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCB7IG9uQ2xlYXJDYWNoZUNhbGxiYWNrIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNsZWFyQ2FjaGVDYWxsYmFjaykge1xuICAgICAgICAgICAgb25DbGVhckNhY2hlQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBzZXR0aW5nc09wZW4gfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaTE4bixcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1uc0NhbGxiYWNrT25DaGFuZ2UsXG4gICAgICAgICAgICAgICAgY29sdW1ucyxcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgICAgICAgICBnY3J1ZEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbixcbiAgICAgICAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0LFxuICAgICAgICAgICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uXG4gICAgICAgICAgICB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoYXNTdWJNZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdWJNZW51TGVmdERpcmVjdGlvbjogc3ViTWVudUxlZnREaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGljb246ICdmYSBmYS1saXN0LWFsdCcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGkxOG4uY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY29sdW1ucycsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgICAgICBzdWJDb21wb25lbnQ6IDxWaXNpYmxlQ29sdW1uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tPbkNoYW5nZT17dmlzaWJsZUNvbHVtbnNDYWxsYmFja09uQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucz17Y29sdW1uc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucz17dmlzaWJsZUNvbHVtbnN9XG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb246ICdmYSBmYS1yZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaTE4bi5yZWZyZXNoLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdyZWZyZXNoJyxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZSA9PiB0aGlzLm9uUmVmcmVzaENhbGxiYWNrKGUpXG5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLWZpbHRlcicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGkxOG4uY2xlYXJfZmlsdGVyaW5nLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdjbGVhcl9maWx0ZXJpbmcnLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBlID0+IHRoaXMub25DbGVhckZpbHRlcmluZ0NhbGxiYWNrKGUpXG5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLWVyYXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGkxOG4uY2xlYXJfY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2NsZWFyX2NhY2hlJyxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogZSA9PiB0aGlzLm9uQ2xlYXJDYWNoZUNhbGxiYWNrKGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcblxuICAgICAgICByZXR1cm4gKDxkaXYgcmVmPXt0aGlzLnNldENvbnRhaW5lcn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdidG4tZ3JvdXAnLCB7XG4gICAgICAgICAgICBvcGVuOiBzZXR0aW5nc09wZW5cbiAgICAgICAgfSl9ID5cbiAgICAgICAgICAgIDxHcm91cFByaW1hcnlCdXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHRoaXMudG9nZ2xlU2V0dGluZ3MoKX0+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmEgZmEtZ2VhclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAmbmJzcDt7aTE4bi5zZXR0aW5nc30mbmJzcDtcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvR3JvdXBQcmltYXJ5QnV0dG9uPlxuICAgICAgICAgICAgPEdyb3VwQnV0dG9uc0xpc3RcbiAgICAgICAgICAgICAgICBzdWJNZW51TGVmdERpcmVjdGlvbj17c3ViTWVudUxlZnREaXJlY3Rpb259XG4gICAgICAgICAgICAgICAgYnV0dG9ucz17YnV0dG9ucy5tYXAoYnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJNZW51TGVmdERpcmVjdGlvbjogYnV0dG9uLnN1Yk1lbnVMZWZ0RGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBoYXNTdWJNZW51OiBidXR0b24uaGFzU3ViTWVudSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogYnV0dG9uLmljb24sXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGJ1dHRvbi50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5rZXksXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24ub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWJDb21wb25lbnQ6IGJ1dHRvbi5zdWJDb21wb25lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KX0+XG4gICAgICAgICAgICA8L0dyb3VwQnV0dG9uc0xpc3Q+XG4gICAgICAgIDwvZGl2Pik7XG4gICAgfVxufVxuXG5TZXR0aW5ncy5wcm9wVHlwZXMgPSB7XG4gICAgb25SZWZyZXNoQ2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xlYXJGaWx0ZXJpbmdDYWxsYmFjazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbGVhckNhY2hlQ2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBnY3J1ZEluc3RhbmNlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHZpc2libGVDb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgdmlzaWJsZUNvbHVtbnNDYWxsYmFja09uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBpMThuOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBzZXR0aW5nczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY29sdW1uczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgcmVmcmVzaDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgY2xlYXJfZmlsdGVyaW5nOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBjbGVhcl9jYWNoZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH0pLFxuICAgIEdyb3VwUHJpbWFyeUJ1dHRvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc3ViTWVudUxlZnREaXJlY3Rpb246IFByb3BUeXBlcy5ib29sXG59O1xuXG5TZXR0aW5ncy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiAocHJvcHMpID0+IDxidXR0b24gey4uLnByb3BzfT57cHJvcHMuY2hpbGRyZW59PC9idXR0b24+LFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IChwcm9wcykgPT4gKDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgIHtwcm9wcy5idXR0b25zLm1hcChidXR0b24gPT5cbiAgICAgICAgICAgIDxsaSBrZXk9e2J1dHRvbi5rZXl9IGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Ryb3Bkb3duLXN1Ym1lbnUnOiBidXR0b24uaGFzU3ViTWVudSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0LWRpcmVjdGlvbic6IGJ1dHRvbi5oYXNTdWJNZW51ICYmIGJ1dHRvbi5zdWJNZW51TGVmdERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfT5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtidXR0b24uaHJlZiA/IGJ1dHRvbi5ocmVmIDogJyd9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2J1dHRvbi5vbkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9e2J1dHRvbi50YXJnZXR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLmljb24gJiYgPGkgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGJ1dHRvbi5pY29uLCAnZ2MtYnV0dG9uLWljb24nKX0gLz59XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24udGV4dH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc3ViQ29tcG9uZW50ICYmIDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLnN1YkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICApfVxuICAgIDwvdWw+KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0dGluZ3M7XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBWaXNpYmxlQ29sdW1ucyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgbGV0IGNoZWNrZWRDb2x1bW5zID0ge30sXG4gICAgICAgICAgICB7IHZpc2libGVDb2x1bW5zIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHRoaXMucHJvcHMuY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgIGNoZWNrZWRDb2x1bW5zW2NvbHVtbi5jb2x1bW5OYW1lXSA9IHZpc2libGVDb2x1bW5zLmluZGV4T2YoY29sdW1uLmNvbHVtbk5hbWUpID4gLTE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaGVja2VkQ29sdW1uc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGVja2JveENoYW5nZShldmVudCkge1xuICAgICAgICBsZXQgY2hlY2tlZENvbHVtbnMgPSB0aGlzLnN0YXRlLmNoZWNrZWRDb2x1bW5zLFxuICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSBbXTtcblxuICAgICAgICBjaGVja2VkQ29sdW1uc1tldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkLW5hbWUnKV0gPSBldmVudC50YXJnZXQuY2hlY2tlZDtcblxuICAgICAgICBpZiAoIXRoaXMuaGFzQXRMZWFzdE9uZUNoZWNrZWQoY2hlY2tlZENvbHVtbnMpKSB7XG4gICAgICAgICAgICBjaGVja2VkQ29sdW1uc1tldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkLW5hbWUnKV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjaGVja2VkQ29sdW1uc1xuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3Qua2V5cyhjaGVja2VkQ29sdW1ucykuZm9yRWFjaCgoY29sdW1uTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZWRDb2x1bW5zW2NvbHVtbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMucHVzaChjb2x1bW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5wcm9wcy5jYWxsYmFja09uQ2hhbmdlLmFwcGx5KHRoaXMucHJvcHMuZ2NydWRJbnN0YW5jZSwgW3Zpc2libGVDb2x1bW5zXSk7XG4gICAgfVxuXG4gICAgaGFzQXRMZWFzdE9uZUNoZWNrZWQoY2hlY2tlZENvbHVtbnMpIHtcbiAgICAgICAgbGV0IGF0TGVhc3RPbmVDaGVja2VkID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY2hlY2tlZENvbHVtbnMpLmZvckVhY2goKGNvbHVtbk5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGVja2VkQ29sdW1uc1tjb2x1bW5OYW1lXSkge1xuICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGF0TGVhc3RPbmVDaGVja2VkO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBjaGVja2VkQ29sdW1ucyB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIGNvbHVtbnNDaGVja2JveGVzID0gY29sdW1ucy5tYXAoKGNvbHVtbikgPT5cbiAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiZHJvcGRvd24taXRlbVwiIGtleT17Y29sdW1uLmNvbHVtbk5hbWV9PlxuICAgICAgICAgICAgICAgICAgICA8YT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgZGF0YS1maWVsZC1uYW1lPXtjb2x1bW4uY29sdW1uTmFtZX0gb25DaGFuZ2U9e3RoaXMub25DaGVja2JveENoYW5nZS5iaW5kKHRoaXMpfSBjaGVja2VkPXtjaGVja2VkQ29sdW1uc1tjb2x1bW4uY29sdW1uTmFtZV19IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJm5ic3A7IHtjb2x1bW4uZGlzcGxheUFzfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjb2x1bW5zQ2hlY2tib3hlcztcbiAgICB9XG59XG5cblZpc2libGVDb2x1bW5zLnByb3BUeXBlcyA9IHtcbiAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgdmlzaWJsZUNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBnY3J1ZEluc3RhbmNlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNhbGxiYWNrT25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBWaXNpYmxlQ29sdW1ucztcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljT3BlcmF0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGkxOG4gPSB7XG4gICAgICAgICAgICBiYXNpY19vcGVyYXRvcjogJ0Jhc2ljIE9wZXJhdG9yJyxcbiAgICAgICAgICAgIGFuZF9zdGF0ZW1lbnQ6ICdBTkQnLFxuICAgICAgICAgICAgb3Jfc3RhdGVtZW50OiAnT1InXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaTE4bikge1xuICAgICAgICAgICAgaTE4biA9IE9iamVjdC5hc3NpZ24oe30sIGkxOG4sIHRoaXMucHJvcHMuaTE4bik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJyb3cgZm9ybS1ncm91cFwiPlxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImNvbC1tZC0zIGNvbnRyb2wtbGFiZWxcIj57aTE4bi5iYXNpY19vcGVyYXRvcn0gOjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC0zXCI+XG4gICAgICAgICAgICAgICAgPHNlbGVjdCBuYW1lPVwiYmFzaWNfb3BlcmF0b3JcIiBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIkFORFwiPntpMThuLmFuZF9zdGF0ZW1lbnR9PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJPUlwiPntpMThuLm9yX3N0YXRlbWVudH08L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICB9XG59IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXREYXRlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgb25Db21wb25lbnRNb3VudCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRNb3VudCkge1xuICAgICAgICAgICAgb25Db21wb25lbnRNb3VudC5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudFVwZGF0ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyICgpIHtcbiAgICAgICAgY29uc3QgeyBpbnB1dFZhbHVlLCBmaWVsZEluZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiA8aW5wdXRcbiAgICAgICAgICAgIHJlcXVpcmVkPXt0cnVlfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgIG5hbWU9eydleHRlbmRlZF9zZWFyY2hbJyArIGZpZWxkSW5kZXggKyAnXVt2YWx1ZV0nfVxuICAgICAgICAgICAgdHlwZT1cInRleHRcIiB2YWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgLz47XG4gICAgfVxufVxuXG5JbnB1dERhdGUucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaW5wdXRWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpbnB1dFZhbHVlT25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59OyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0U2VsZWN0RHJvcGRvd24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudE1vdW50IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudE1vdW50KSB7XG4gICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50LmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IG9uQ29tcG9uZW50VXBkYXRlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGlmIChvbkNvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGUuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIgKCkge1xuICAgICAgICBjb25zdCB7IHBlcm1pdHRlZFZhbHVlcywgZmllbGRJbmRleCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IG9wdGlvbnNBcnJheSA9IFtdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHBlcm1pdHRlZFZhbHVlcykuZm9yRWFjaCgoaXRlbUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRGlzcGxheSA9IHBlcm1pdHRlZFZhbHVlc1tpdGVtSWRdO1xuICAgICAgICAgICAgb3B0aW9uc0FycmF5LnB1c2goPG9wdGlvbiB2YWx1ZT17aXRlbUlkfSBrZXk9e2l0ZW1JZH0+e2l0ZW1EaXNwbGF5fTwvb3B0aW9uPik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiA8c2VsZWN0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIG5hbWU9eydleHRlbmRlZF9zZWFyY2hbJyArIGZpZWxkSW5kZXggKyAnXVt2YWx1ZV0nfT5cbiAgICAgICAgICAgIHtvcHRpb25zQXJyYXl9XG4gICAgICAgIDwvc2VsZWN0PjtcbiAgICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRTZWxlY3RSZWxhdGlvbmFsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgb25Db21wb25lbnRNb3VudCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRNb3VudCkge1xuICAgICAgICAgICAgb25Db21wb25lbnRNb3VudC5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBvbmVudFVwZGF0ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICBpZiAob25Db21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlLmFwcGx5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyICgpIHtcbiAgICAgICAgY29uc3QgeyBwZXJtaXR0ZWRWYWx1ZXMsIGZpZWxkSW5kZXggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuIDxzZWxlY3QgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9PlxuICAgICAgICAgICAge3Blcm1pdHRlZFZhbHVlcy5tYXAoKGl0ZW0pID0+IDxvcHRpb24gdmFsdWU9e2l0ZW0uaWR9IGtleT17aXRlbS5pZH0+e2l0ZW0udGl0bGV9PC9vcHRpb24+KX1cbiAgICAgICAgPC9zZWxlY3Q+O1xuICAgIH1cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dFNlbGVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IG9uQ29tcG9uZW50TW91bnQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50TW91bnQpIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQuYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgb25Db21wb25lbnRVcGRhdGUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZS5hcHBseSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbmRlciAoKSB7XG4gICAgICAgIGNvbnN0IHsgcGVybWl0dGVkVmFsdWVzLCBmaWVsZEluZGV4IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiA8c2VsZWN0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIG5hbWU9eydleHRlbmRlZF9zZWFyY2hbJyArIGZpZWxkSW5kZXggKyAnXVt2YWx1ZV0nfT5cbiAgICAgICAgICAgIHtwZXJtaXR0ZWRWYWx1ZXMubWFwKChpdGVtKSA9PiA8b3B0aW9uIHZhbHVlPXtpdGVtfSBrZXk9e2l0ZW19PntpdGVtfTwvb3B0aW9uPil9XG4gICAgICAgIDwvc2VsZWN0PjtcbiAgICB9XG59IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBTZWxlY3RPcHRpb25zRXF1YWxOb3RFcXVhbCBmcm9tICcuLi9zZWxlY3Qtb3B0aW9ucy9lcXVhbF9ub3RfZXF1YWwnO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tIFwiLi4vZmlsdGVyLXNlbGVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hDaGVja2JveEJvb2xlYW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWU6ICdlcXVhbHMnLFxuICAgICAgICAgICAgaXNDaGVja2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXRWYWx1ZU9uQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB7IGlzQ2hlY2tlZCB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uT25DaGFuZ2UoY29tcGFyaXNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBpc0NoZWNrZWQsIGNvbXBhcmlzb25WYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17U2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWx9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtpc0NoZWNrZWR9IG9uQ2hhbmdlPXt0aGlzLmlucHV0VmFsdWVPbkNoYW5nZS5iaW5kKHRoaXMpfSBzdHlsZT17eyBtYXJnaW5Ub3A6IDEyIH19IC8+XG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9eydleHRlbmRlZF9zZWFyY2hbJyArIGZpZWxkSW5kZXggKyAnXVt2YWx1ZV0nfSB0eXBlPVwiaGlkZGVuXCIgdmFsdWU9e2lzQ2hlY2tlZCA/ICcxJyA6ICcwJ30vPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKc3hBcnJheTtcbiAgICB9XG59XG5cblNlYXJjaENoZWNrYm94Qm9vbGVhbi5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaENoZWNrYm94Qm9vbGVhbi5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaXNNb2JpbGU6IGZhbHNlXG59OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29tcGFyaXNvblNlbGVjdE9wdGlvbnMgZnJvbSAnLi4vc2VsZWN0LW9wdGlvbnMvY29tcGFyaXNvbic7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gXCIuLi9maWx0ZXItc2VsZWN0XCI7XG5pbXBvcnQgSW5wdXREYXRlIGZyb20gXCIuLi9maWVsZC1pbnB1dC9kYXRlXCI7XG5cbmNsYXNzIFNlYXJjaERhdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWU6ICdjb250YWlucycsXG4gICAgICAgICAgICBpbnB1dFZhbHVlOiAnJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbXBhcmlzb25WYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgb25Db21wb25lbnRNb3VudCwgb25Db21wb25lbnRVcGRhdGUsIGkxOG4sIGlzTW9iaWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgSnN4QXJyYXk7XG5cbiAgICAgICAgSnN4QXJyYXkgPSBbXG4gICAgICAgICAgICA8RmlsdGVyU2VsZWN0XG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgIFNlbGVjdE9wdGlvbnM9e0NvbXBhcmlzb25TZWxlY3RPcHRpb25zfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2s9e3RoaXMuY29tcGFyaXNvbk9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAga2V5PVwiMFwiXG4gICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblZhbHVlICE9PSAnaXNfZW1wdHknICYmIGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX25vdF9lbXB0eScpIHtcbiAgICAgICAgICAgIEpzeEFycmF5LnB1c2goPGRpdiBrZXk9XCIyXCIgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXREYXRlXG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKc3hBcnJheTtcbiAgICB9XG59XG5cblNlYXJjaERhdGUucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgb25Db21wb25lbnRNb3VudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Db21wb25lbnRVcGRhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuU2VhcmNoRGF0ZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaXNNb2JpbGU6IGZhbHNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWFyY2hEYXRlOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gXCIuLi9maWx0ZXItc2VsZWN0XCI7XG5pbXBvcnQgSW5wdXRTZWxlY3REcm9wZG93biBmcm9tIFwiLi4vZmllbGQtaW5wdXQvc2VsZWN0LWRyb3Bkb3duXCI7XG5pbXBvcnQgU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWwgZnJvbSBcIi4uL3NlbGVjdC1vcHRpb25zL2VxdWFsX25vdF9lcXVhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hEcm9wZG93biBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJ2NvbnRhaW5zJyxcbiAgICAgICAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgeyBmaWVsZEluZGV4LCBwZXJtaXR0ZWRWYWx1ZXMsIG9uQ29tcG9uZW50TW91bnQsIG9uQ29tcG9uZW50VXBkYXRlLCBpMThuLCBpc01vYmlsZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IEpzeEFycmF5LFxuICAgICAgICAgICAgb3B0aW9uc0FycmF5ID0gW107XG5cbiAgICAgICAgSnN4QXJyYXkgPSBbXG4gICAgICAgICAgICA8RmlsdGVyU2VsZWN0XG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgIFNlbGVjdE9wdGlvbnM9e1NlbGVjdE9wdGlvbnNFcXVhbE5vdEVxdWFsfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2s9e3RoaXMuY29tcGFyaXNvbk9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAga2V5PVwiMFwiXG4gICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgXTtcblxuICAgICAgICBPYmplY3Qua2V5cyhwZXJtaXR0ZWRWYWx1ZXMpLmZvckVhY2goKGl0ZW1JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbURpc3BsYXkgPSBwZXJtaXR0ZWRWYWx1ZXNbaXRlbUlkXTtcbiAgICAgICAgICAgIG9wdGlvbnNBcnJheS5wdXNoKDxvcHRpb24gdmFsdWU9e2l0ZW1JZH0ga2V5PXtpdGVtSWR9PntpdGVtRGlzcGxheX08L29wdGlvbj4pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblZhbHVlICE9PSAnaXNfZW1wdHknICYmIGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX25vdF9lbXB0eScpIHtcbiAgICAgICAgICAgIEpzeEFycmF5LnB1c2goPGRpdiBrZXk9XCIyXCIgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXRTZWxlY3REcm9wZG93blxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoRHJvcGRvd24ucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcGVybWl0dGVkVmFsdWVzOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuaXNNb2JpbGVcbn07XG5cblNlYXJjaERyb3Bkb3duLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSBcIi4uL2ZpbHRlci1zZWxlY3RcIjtcbmltcG9ydCBJbnB1dFNlbGVjdCBmcm9tIFwiLi4vZmllbGQtaW5wdXQvc2VsZWN0XCI7XG5pbXBvcnQgU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWwgZnJvbSBcIi4uL3NlbGVjdC1vcHRpb25zL2VxdWFsX25vdF9lcXVhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hFbnVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnY29udGFpbnMnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcGFyaXNvbk9uQ2hhbmdlKGNvbXBhcmlzb25WYWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGFyaXNvblZhbHVlIH0gPSB0aGlzLnN0YXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXgsXG4gICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQsXG4gICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgICAgICAgaTE4bixcbiAgICAgICAgICAgICAgICBpc01vYmlsZVxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17U2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWx9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFNlbGVjdFxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoRW51bS5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwZXJtaXR0ZWRWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaEVudW0uZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBhcmlzb25TZWxlY3RPcHRpb25zIGZyb20gJy4uL3NlbGVjdC1vcHRpb25zL2NvbXBhcmlzb24nO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tICcuLi9maWx0ZXItc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoTnVtZXJpYyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJ2VxdWFscycsXG4gICAgICAgICAgICBpbnB1dFZhbHVlOiAnJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlucHV0VmFsdWVPbkNoYW5nZShldmVudCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGlucHV0VmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uT25DaGFuZ2UoY29tcGFyaXNvblZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjb21wYXJpc29uVmFsdWUsIGlucHV0VmFsdWUgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7IGZpZWxkSW5kZXgsIGkxOG4sIGlzTW9iaWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgSnN4QXJyYXk7XG5cbiAgICAgICAgSnN4QXJyYXkgPSBbXG4gICAgICAgICAgICA8RmlsdGVyU2VsZWN0XG4gICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgIFNlbGVjdE9wdGlvbnM9e0NvbXBhcmlzb25TZWxlY3RPcHRpb25zfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2s9e3RoaXMuY29tcGFyaXNvbk9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAga2V5PVwiMFwiXG4gICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblZhbHVlICE9PSAnaXNfZW1wdHknICYmIGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX25vdF9lbXB0eScpIHtcbiAgICAgICAgICAgIEpzeEFycmF5LnB1c2goPGRpdiBrZXk9XCIyXCIgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQ9e3RydWV9IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIG5hbWU9eydleHRlbmRlZF9zZWFyY2hbJyArIGZpZWxkSW5kZXggKyAnXVt2YWx1ZV0nfSB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2lucHV0VmFsdWV9IG9uQ2hhbmdlPXt0aGlzLmlucHV0VmFsdWVPbkNoYW5nZS5iaW5kKHRoaXMpfSAvPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKc3hBcnJheTtcbiAgICB9XG59XG5cblNlYXJjaE51bWVyaWMucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaXNNb2JpbGU6IFByb3BUeXBlcy5ib29sXG59O1xuXG5TZWFyY2hOdW1lcmljLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBTZWxlY3RPcHRpb25zSGFzT3JOb3QgZnJvbSBcIi4uL3NlbGVjdC1vcHRpb25zL2hhc19vcl9ub3RcIjtcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSBcIi4uL2ZpbHRlci1zZWxlY3RcIjtcbmltcG9ydCBJbnB1dFNlbGVjdFJlbGF0aW9uYWwgZnJvbSBcIi4uL2ZpZWxkLWlucHV0L3NlbGVjdC1yZWxhdGlvbmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaFJlbGF0aW9uYWxOdG9OIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnaGFzJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbXBhcmlzb25WYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgcGVybWl0dGVkVmFsdWVzLCBvbkNvbXBvbmVudE1vdW50LCBvbkNvbXBvbmVudFVwZGF0ZSwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17U2VsZWN0T3B0aW9uc0hhc09yTm90fVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlQ2FsbGJhY2s9e3RoaXMuY29tcGFyaXNvbk9uQ2hhbmdlLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAga2V5PVwiMFwiXG4gICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblZhbHVlICE9PSAnaXNfZW1wdHknICYmIGNvbXBhcmlzb25WYWx1ZSAhPT0gJ2lzX25vdF9lbXB0eScpIHtcbiAgICAgICAgICAgIEpzeEFycmF5LnB1c2goPGRpdiBrZXk9XCIyXCIgY2xhc3NOYW1lPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICA8SW5wdXRTZWxlY3RSZWxhdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlcz17cGVybWl0dGVkVmFsdWVzfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2Pik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSnN4QXJyYXk7XG4gICAgfVxufVxuXG5TZWFyY2hSZWxhdGlvbmFsTnRvTi5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwZXJtaXR0ZWRWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaFJlbGF0aW9uYWxOdG9OLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn07IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSBcIi4uL2ZpbHRlci1zZWxlY3RcIjtcbmltcG9ydCBJbnB1dFNlbGVjdFJlbGF0aW9uYWwgZnJvbSBcIi4uL2ZpZWxkLWlucHV0L3NlbGVjdC1yZWxhdGlvbmFsXCI7XG5pbXBvcnQgU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWwgZnJvbSBcIi4uL3NlbGVjdC1vcHRpb25zL2VxdWFsX25vdF9lcXVhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hSZWxhdGlvbmFsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgY29tcGFyaXNvblZhbHVlOiAnaGFzJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbXBhcmlzb25WYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgcGVybWl0dGVkVmFsdWVzLCBvbkNvbXBvbmVudE1vdW50LCBvbkNvbXBvbmVudFVwZGF0ZSwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17U2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWx9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIwXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxJbnB1dFNlbGVjdFJlbGF0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzPXtwZXJtaXR0ZWRWYWx1ZXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKc3hBcnJheTtcbiAgICB9XG59XG5cblNlYXJjaFJlbGF0aW9uYWwucHJvcFR5cGVzID0ge1xuICAgIGZpZWxkSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcGVybWl0dGVkVmFsdWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgaXNNb2JpbGU6IFByb3BUeXBlcy5ib29sXG59O1xuXG5TZWFyY2hSZWxhdGlvbmFsLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEZpbHRlclNlbGVjdCBmcm9tICcuLi9maWx0ZXItc2VsZWN0JztcbmltcG9ydCBUZXh0U2VsZWN0T3B0aW9ucyBmcm9tICcuLi9zZWxlY3Qtb3B0aW9ucy90ZXh0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VhcmNoVGV4dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJ2NvbnRhaW5zJyxcbiAgICAgICAgICAgIGlucHV0VmFsdWU6ICcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5wdXRWYWx1ZU9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgaW5wdXRWYWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbXBhcmlzb25PbkNoYW5nZShjb21wYXJpc29uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wYXJpc29uVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGNvbXBhcmlzb25WYWx1ZSwgaW5wdXRWYWx1ZSB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHsgZmllbGRJbmRleCwgaTE4biwgaXNNb2JpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBKc3hBcnJheTtcblxuICAgICAgICBKc3hBcnJheSA9IFtcbiAgICAgICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgU2VsZWN0T3B0aW9ucz17VGV4dFNlbGVjdE9wdGlvbnN9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VDYWxsYmFjaz17dGhpcy5jb21wYXJpc29uT25DaGFuZ2UuYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICBrZXk9XCIxXCJcbiAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAvPlxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uVmFsdWUgIT09ICdpc19lbXB0eScgJiYgY29tcGFyaXNvblZhbHVlICE9PSAnaXNfbm90X2VtcHR5Jykge1xuICAgICAgICAgICAgSnN4QXJyYXkucHVzaCg8ZGl2IGtleT1cIjJcIiBjbGFzc05hbWU9XCJjb2wtbWQtOFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZD17dHJ1ZX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW3ZhbHVlXSd9XG4gICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmlucHV0VmFsdWVPbkNoYW5nZS5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpzeEFycmF5O1xuICAgIH1cbn1cblxuU2VhcmNoVGV4dC5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBpc01vYmlsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cblNlYXJjaFRleHQuZGVmYXVsdFByb3BzID0ge1xuICAgIGlzTW9iaWxlOiBmYWxzZVxufTsiLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbHRlclNlbGVjdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZTogJydcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdE9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25WYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZSxcbiAgICAgICAgICAgIHsgb25DaGFuZ2VDYWxsYmFjayB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGNvbXBhcmlzb25WYWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBvbkNoYW5nZUNhbGxiYWNrKGNvbXBhcmlzb25WYWx1ZSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGZpZWxkSW5kZXgsIFNlbGVjdE9wdGlvbnMsIGkxOG4sIGlzTW9iaWxlIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBjb21wYXJpc29uVmFsdWUgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdjb2wtbWQtNCcse1xuICAgICAgICAgICAgJ2IxMCc6IGlzTW9iaWxlXG4gICAgICAgIH0pfT5cbiAgICAgICAgICAgIDxzZWxlY3QgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW2ZpbHRlcl0nfSB2YWx1ZT17Y29tcGFyaXNvblZhbHVlfSBvbkNoYW5nZT17dGhpcy5zZWxlY3RPbkNoYW5nZS5iaW5kKHRoaXMpfT5cbiAgICAgICAgICAgICAgICA8U2VsZWN0T3B0aW9ucyBpMThuPXtpMThufSAvPlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgIH1cbn1cblxuRmlsdGVyU2VsZWN0LnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFNlbGVjdE9wdGlvbnM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIGlzTW9iaWxlOiBQcm9wVHlwZXMuYm9vbFxufTtcblxuRmlsdGVyU2VsZWN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc01vYmlsZTogZmFsc2Vcbn1cbiIsImltcG9ydCBCYXNpY09wZXJhdG9yIGZyb20gJy4vYmFzaWMtb3BlcmF0b3IuanMnO1xuaW1wb3J0IE11bHRpcGxlU2VhcmNoIGZyb20gJy4vbXVsdGlwbGUtc2VhcmNoLmpzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsdGVyaW5nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5kZXhlczogW1xuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRNb3JlRmlsdGVycygpIHtcbiAgICAgICAgbGV0IHsgaW5kZXhlcyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICAvLyB0aGUgbGFzdCBpbmRleCBpcyBhbHdheXMgdGhlIGJpZ2dlciBvbmUgc28gYWRkICsxXG4gICAgICAgIGluZGV4ZXMucHVzaChpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV0gKyAxKTtcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGluZGV4ZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsdGVyKGZpZWxkSW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaW5kZXhlcyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBpbmRleGVzID0gaW5kZXhlcy5maWx0ZXIoKGluZGV4KSA9PiBpbmRleCAhPT0gZmllbGRJbmRleClcblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGluZGV4ZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGluZGV4ZXMgfSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgIG9uU3VibWl0Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgb25JbnB1dE1vdW50LFxuICAgICAgICAgICAgICAgIE1vZGFsVGl0bGUsXG4gICAgICAgICAgICAgICAgc2NyZWVuU2l6ZVxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbmRleGVzTGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIGxldCBKU1hhcnJheSxcbiAgICAgICAgICAgIGkxOG4gPSB7XG4gICAgICAgICAgICAgICAgYmFzaWNfb3BlcmF0b3I6ICdCYXNpYyBPcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgYW5kX3N0YXRlbWVudDogJ0FORCcsXG4gICAgICAgICAgICAgICAgb3Jfc3RhdGVtZW50OiAnT1InLFxuICAgICAgICAgICAgICAgIGZpbHRlcmluZzogJ0ZpbHRlcmluZycsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiAnRmlsdGVyJyxcbiAgICAgICAgICAgICAgICBjYW5jZWxfZmlsdGVyaW5nOiAnQ2FuY2VsJyxcbiAgICAgICAgICAgICAgICBhZGRfbW9yZTogJ0FkZCBtb3JlJyxcbiAgICAgICAgICAgICAgICByZW1vdmVfZmlsdGVyOiAnUmVtb3ZlIEZpbHRlcidcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaTE4bikge1xuICAgICAgICAgICAgaTE4biA9IE9iamVjdC5hc3NpZ24oe30sIGkxOG4sIHRoaXMucHJvcHMuaTE4bik7XG4gICAgICAgIH1cblxuICAgICAgICBKU1hhcnJheSA9IGluZGV4ZXMubWFwKFxuICAgICAgICAgICAgKGluZGV4KSA9PlxuICAgICAgICAgICAgICAgIDxNdWx0aXBsZVNlYXJjaFxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM9e2ZpZWxkc31cbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGhhc1JlbW92ZUJ1dHRvbj17aW5kZXhlc0xlbmd0aCA+IDF9XG4gICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlQ2FsbGJhY2s9e3RoaXMucmVtb3ZlRmlsdGVyLmJpbmQodGhpcyl9XG4gICAgICAgICAgICAgICAgICAgIG9uSW5wdXRNb3VudD17b25JbnB1dE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaXplPXtzY3JlZW5TaXplfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtZGlhbG9nIGdjLW1vZGFsLWRpYWxvZ1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgPGZvcm0gbWV0aG9kPVwicG9zdFwiIGNsYXNzTmFtZT1cImZvcm0taG9yaXpvbnRhbFwiIG9uU3VibWl0PXtvblN1Ym1pdENhbGxiYWNrLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPE1vZGFsVGl0bGUgdGl0bGU9e2kxOG4uZmlsdGVyaW5nfS8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWJvZHkgZGVsZXRlLW1vZGFsXCI+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QmFzaWNPcGVyYXRvciBpMThuPXtpMThufSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtKU1hhcnJheX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdjLWZpbHRlcmluZy1yb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLWRlZmF1bHQgYnRuLW91dGxpbmUtZGFya1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLmFkZE1vcmVGaWx0ZXJzLmJpbmQodGhpcyl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGVtIGNsYXNzTmFtZT1cImZhIGZhLXBsdXNcIj48L2VtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJm5ic3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aTE4bi5hZGRfbW9yZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1vdXRsaW5lLWRhcmtcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpMThuLmNhbmNlbF9maWx0ZXJpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzTmFtZT1cImJ0biBidG4tc3VjY2VzcyBkZWxldGUtbXVsdGlwbGUtY29uZmlybWF0aW9uLWJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpMThuLmZpbHRlcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+O1xuICAgIH1cbn1cblxuRmlsdGVyaW5nLnByb3BUeXBlcyA9IHtcbiAgICBmaWVsZHM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBvblN1Ym1pdENhbGxiYWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbklucHV0TW91bnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgTW9kYWxUaXRsZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2NyZWVuU2l6ZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuRmlsdGVyaW5nLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBNb2RhbFRpdGxlOiBwcm9wcyA9PiA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2xvc2VcIlxuICAgICAgICAgICAgZGF0YS1kaXNtaXNzPVwibW9kYWxcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkNsb3NlXCJcbiAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxoNCBjbGFzc05hbWU9XCJtb2RhbC10aXRsZVwiPlxuICAgICAgICAgICAge3Byb3BzLnRpdGxlfVxuICAgICAgICA8L2g0PlxuICAgIDwvUmVhY3QuRnJhZ21lbnQ+LFxuICAgIHNjcmVlblNpemU6ICdsJ1xufTtcbiIsImltcG9ydCBTZWFyY2hUZXh0IGZyb20gXCIuL2ZpZWxkLXR5cGVzL3RleHRcIjtcbmltcG9ydCBTZWFyY2hEYXRlIGZyb20gXCIuL2ZpZWxkLXR5cGVzL2RhdGVcIjtcbmltcG9ydCBTZWFyY2hOdW1lcmljIGZyb20gXCIuL2ZpZWxkLXR5cGVzL251bWVyaWNcIjtcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcbmltcG9ydCBTZWFyY2hDaGVja2JveEJvb2xlYW4gZnJvbSBcIi4vZmllbGQtdHlwZXMvY2hlY2tib3hfYm9vbGVhblwiO1xuaW1wb3J0IFNlYXJjaEVudW0gZnJvbSBcIi4vZmllbGQtdHlwZXMvZW51bVwiO1xuaW1wb3J0IFNlYXJjaERyb3Bkb3duIGZyb20gXCIuL2ZpZWxkLXR5cGVzL2Ryb3Bkb3duXCI7XG5pbXBvcnQgU2VhcmNoUmVsYXRpb25hbCBmcm9tIFwiLi9maWVsZC10eXBlcy9yZWxhdGlvbmFsXCI7XG5pbXBvcnQgU2VhcmNoUmVsYXRpb25hbE50b04gZnJvbSBcIi4vZmllbGQtdHlwZXMvcmVsYXRpb25hbC1uLW5cIjtcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuXG5jbGFzcyBNdWx0aXBsZVNlYXJjaCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgY29uc3QgZmlyc3RGaWVsZHNLZXkgPSBwcm9wcy5maWVsZHMuZmluZCgoX19pdGVtLCBrZXkpID0+IGtleSA9PT0gMCksXG4gICAgICAgICAgICB7ZmllbGROYW1lLCB0eXBlLCBwZXJtaXR0ZWRWYWx1ZXN9ID0gZmlyc3RGaWVsZHNLZXk7XG5cbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hhbmdlU2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkRmllbGQgPSB0aGlzLnByb3BzLmZpZWxkcy5maW5kKChmaWVsZCkgPT4gZmllbGQuZmllbGROYW1lID09PSBldmVudC50YXJnZXQudmFsdWUpLFxuICAgICAgICAgICAge2ZpZWxkTmFtZSwgdHlwZSwgcGVybWl0dGVkVmFsdWVzfSA9IHNlbGVjdGVkRmllbGQ7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICBzZWxlY3RlZFR5cGU6IHR5cGUsXG4gICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM6IHBlcm1pdHRlZFZhbHVlc1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkRlbGV0ZUNsaWNrKCkge1xuICAgICAgICBjb25zdCB7ZmllbGRJbmRleCwgb25EZWxldGVDYWxsYmFja30gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIG9uRGVsZXRlQ2FsbGJhY2soZmllbGRJbmRleCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7c2VsZWN0ZWRWYWx1ZSwgc2VsZWN0ZWRUeXBlLCBwZXJtaXR0ZWRWYWx1ZXN9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWVsZEluZGV4LFxuICAgICAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgICAgICBoYXNSZW1vdmVCdXR0b24sXG4gICAgICAgICAgICAgICAgb25JbnB1dE1vdW50LFxuICAgICAgICAgICAgICAgIHNjcmVlblNpemVcbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgZXZlbk9yT2RkID0gZmllbGRJbmRleCAlIDIgPT09IDAgPyAnZXZlbicgOiAnb2RkJyxcbiAgICAgICAgICAgIGlzTW9iaWxlID0gc2NyZWVuU2l6ZSA9PT0gJ3MnIHx8IHNjcmVlblNpemUgPT09ICd4cyc7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCwgb25Db21wb25lbnRNb3VudCwgb25Db21wb25lbnRVcGRhdGUsXG4gICAgICAgICAgICBpMThuID0ge1xuICAgICAgICAgICAgICAgIHJlbW92ZV9maWx0ZXI6ICdSZW1vdmUgRmlsdGVyJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbklucHV0TW91bnQgJiYgb25JbnB1dE1vdW50W3NlbGVjdGVkVHlwZV0pIHtcbiAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQgPSBvbklucHV0TW91bnRbc2VsZWN0ZWRUeXBlXS5vbk1vdW50O1xuICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGUgPSBvbklucHV0TW91bnRbc2VsZWN0ZWRUeXBlXS5vblVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoc2VsZWN0ZWRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICAgICAgc2VhcmNoSW5wdXQgPSA8U2VhcmNoRGF0ZVxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgIGNhc2UgJ251bWVyaWMnOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaE51bWVyaWNcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94X2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaENoZWNrYm94Qm9vbGVhblxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmVsYXRpb25hbF9uX24nOlxuICAgICAgICAgICAgY2FzZSAnbmF0aXZlX3JlbGF0aW9uYWxfbl9uJzpcbiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dCA9IDxTZWFyY2hSZWxhdGlvbmFsTnRvTlxuICAgICAgICAgICAgICAgICAgICBmaWVsZEluZGV4PXtmaWVsZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM9e3Blcm1pdHRlZFZhbHVlc31cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlbGF0aW9uYWwnOlxuICAgICAgICAgICAgY2FzZSAncmVsYXRpb25hbF9uYXRpdmUnOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaFJlbGF0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzPXtwZXJtaXR0ZWRWYWx1ZXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtdWx0aXNlbGVjdF9uYXRpdmUnOlxuICAgICAgICAgICAgY2FzZSAnbXVsdGlzZWxlY3Rfc2VhcmNoYWJsZSc6XG4gICAgICAgICAgICBjYXNlICdkcm9wZG93bic6XG4gICAgICAgICAgICBjYXNlICdkcm9wZG93bl9zZWFyY2gnOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaERyb3Bkb3duXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5kZXg9e2ZpZWxkSW5kZXh9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIHBlcm1pdHRlZFZhbHVlcz17cGVybWl0dGVkVmFsdWVzfVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudE1vdW50PXtvbkNvbXBvbmVudE1vdW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNvbXBvbmVudFVwZGF0ZT17b25Db21wb25lbnRVcGRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlzTW9iaWxlPXtpc01vYmlsZX1cbiAgICAgICAgICAgICAgICAvPjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZW51bV9zZWFyY2hhYmxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaEVudW1cbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgcGVybWl0dGVkVmFsdWVzPXtwZXJtaXR0ZWRWYWx1ZXN9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50TW91bnQ9e29uQ29tcG9uZW50TW91bnR9XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcG9uZW50VXBkYXRlPXtvbkNvbXBvbmVudFVwZGF0ZX1cbiAgICAgICAgICAgICAgICAgICAgaXNNb2JpbGU9e2lzTW9iaWxlfVxuICAgICAgICAgICAgICAgIC8+O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0ID0gPFNlYXJjaFRleHRcbiAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleD17ZmllbGRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRNb3VudD17b25Db21wb25lbnRNb3VudH1cbiAgICAgICAgICAgICAgICAgICAgb25Db21wb25lbnRVcGRhdGU9e29uQ29tcG9uZW50VXBkYXRlfVxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaXplPXtzY3JlZW5TaXplfVxuICAgICAgICAgICAgICAgICAgICBpc01vYmlsZT17aXNNb2JpbGV9XG4gICAgICAgICAgICAgICAgLz47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9eydyb3cgZ2MtZmlsdGVyaW5nLXJvdyAnICsgZXZlbk9yT2RkfT5cbiAgICAgICAgICAgIHtoYXNSZW1vdmVCdXR0b25cbiAgICAgICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdjb2wtbWQtMScsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2IxMCc6IGlzTW9iaWxlXG4gICAgICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J0bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdidG4tZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdidG4tb3V0bGluZS1kYXJrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2J0bi1ibG9jaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLm9uRGVsZXRlQ2xpY2suYmluZCh0aGlzKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPXtpMThuLnJlbW92ZV9maWx0ZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxlbSBjbGFzc05hbWU9XCJmYSBmYS10cmFzaC1vXCI+PC9lbT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNNb2JpbGUgJiYgPFJlYWN0LkZyYWdtZW50PiZuYnNwOyB7aTE4bi5yZW1vdmVfZmlsdGVyfTwvUmVhY3QuRnJhZ21lbnQ+fVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA6ICcnfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2NvbC1tZC0zJywge1xuICAgICAgICAgICAgICAgICdiMTAnOiBpc01vYmlsZVxuICAgICAgICAgICAgfSl9PlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgY2xhc3NOYW1lPVwiZm9ybS1jb250cm9sXCIgbmFtZT17J2V4dGVuZGVkX3NlYXJjaFsnICsgZmllbGRJbmRleCArICddW25hbWVdJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlU2VsZWN0LmJpbmQodGhpcyl9IHZhbHVlPXtzZWxlY3RlZFZhbHVlfT5cbiAgICAgICAgICAgICAgICAgICAge2ZpZWxkcy5tYXAoKGZpZWxkKSA9PiA8b3B0aW9uIHZhbHVlPXtmaWVsZC5maWVsZE5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2ZpZWxkLmZpZWxkTmFtZX0+e2ZpZWxkLmRpc3BsYXlBc308L29wdGlvbj4pfVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcygncm93Jywge1xuICAgICAgICAgICAgICAgICAgICAnY29sLW1kLTgnOiBoYXNSZW1vdmVCdXR0b24sXG4gICAgICAgICAgICAgICAgICAgICdjb2wtbWQtOSc6ICFoYXNSZW1vdmVCdXR0b24sXG4gICAgICAgICAgICAgICAgICAgICdiMTAnOiBpc01vYmlsZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9PlxuICAgICAgICAgICAgICAgIHtzZWFyY2hJbnB1dH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj47XG4gICAgfVxufVxuXG5NdWx0aXBsZVNlYXJjaC5wcm9wVHlwZXMgPSB7XG4gICAgZmllbGRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBmaWVsZHM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBoYXNSZW1vdmVCdXR0b246IFByb3BUeXBlcy5ib29sLFxuICAgIG9uRGVsZXRlQ2FsbGJhY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNjcmVlblNpemU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbk11bHRpcGxlU2VhcmNoLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBzY3JlZW5TaXplOiAnbCdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpcGxlU2VhcmNoOyIsImltcG9ydCBpMThuQ29tcGFyaXNvbiBmcm9tICcuL3RyYW5zbGF0aW9ucy9pMThuLWNvbXBhcmlzb24nO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgQ29tcGFyaXNvblNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGkxOG4gPSBpMThuQ29tcGFyaXNvbjtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGkxOG4pO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImVxdWFsc1wiIHZhbHVlPVwiZXF1YWxzXCI+e2kxOG4uY29tcGFyaXNvbl9lcXVhbHN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJub3RfZXF1YWxzXCIgdmFsdWU9XCJub3RfZXF1YWxzXCI+e2kxOG4uY29tcGFyaXNvbl9ub3RfZXF1YWxzfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiZ3JlYXRlcl90aGFuXCIgdmFsdWU9XCJncmVhdGVyX3RoYW5cIj57aTE4bi5jb21wYXJpc29uX2dyZWF0ZXJfdGhhbn08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImxlc3NfdGhhblwiIHZhbHVlPVwibGVzc190aGFuXCI+e2kxOG4uY29tcGFyaXNvbl9sZXNzX3RoYW59PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJncmVhdGVyX3RoYW5fb3JfZXF1YWxcIiB2YWx1ZT1cImdyZWF0ZXJfdGhhbl9vcl9lcXVhbFwiPntpMThuLmNvbXBhcmlzb25fZ3JlYXRlcl90aGFuX29yX2VxdWFsfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwibGVzc190aGFuX29yX2VxdWFsXCIgdmFsdWU9XCJsZXNzX3RoYW5fb3JfZXF1YWxcIj57aTE4bi5jb21wYXJpc29uX2xlc3NfdGhhbl9vcl9lcXVhbH08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImlzX2VtcHR5XCIgdmFsdWU9XCJpc19lbXB0eVwiPntpMThuLmNvbXBhcmlzb25faXNfZW1wdHl9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJpc19ub3RfZW1wdHlcIiB2YWx1ZT1cImlzX25vdF9lbXB0eVwiPntpMThuLmNvbXBhcmlzb25faXNfbm90X2VtcHR5fTwvb3B0aW9uPlxuICAgICAgICBdXG4gICAgfVxufVxuXG5Db21wYXJpc29uU2VsZWN0T3B0aW9ucy5wcm9wVHlwZXMgPSB7XG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdFxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wYXJpc29uU2VsZWN0T3B0aW9uczsiLCJpbXBvcnQgaTE4bkVxdWFsTm90RXF1YWwgZnJvbSAnLi90cmFuc2xhdGlvbnMvaTE4bi1lcXVhbC1ub3QtZXF1YWwnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgU2VsZWN0T3B0aW9uc0VxdWFsTm90RXF1YWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGkxOG4gPSBpMThuRXF1YWxOb3RFcXVhbDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImVxdWFsc1wiIHZhbHVlPVwiZXF1YWxzXCI+e2kxOG4uY29tcGFyaXNvbl9lcXVhbHN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJub3RfZXF1YWxzXCIgdmFsdWU9XCJub3RfZXF1YWxzXCI+e2kxOG4uY29tcGFyaXNvbl9ub3RfZXF1YWxzfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfZW1wdHlcIiB2YWx1ZT1cImlzX2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19lbXB0eX08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImlzX25vdF9lbXB0eVwiIHZhbHVlPVwiaXNfbm90X2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19ub3RfZW1wdHl9PC9vcHRpb24+XG4gICAgICAgIF1cbiAgICB9XG59XG5cblNlbGVjdE9wdGlvbnNFcXVhbE5vdEVxdWFsLnByb3BUeXBlcyA9IHtcbiAgICBpMThuOiBQcm9wVHlwZXMub2JqZWN0XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdE9wdGlvbnNFcXVhbE5vdEVxdWFsOyIsImltcG9ydCBpMThuSGFzT3JOb3QgZnJvbSAnLi90cmFuc2xhdGlvbnMvaTE4bi1oYXMtb3Itbm90JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIFNlbGVjdE9wdGlvbnNIYXNPck5vdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaTE4biA9IGkxOG5IYXNPck5vdDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5pMThuKSB7XG4gICAgICAgICAgICBpMThuID0gT2JqZWN0LmFzc2lnbih7fSwgaTE4biwgdGhpcy5wcm9wcy5pMThuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImhhc1wiIHZhbHVlPVwiaGFzXCI+e2kxOG4uY29tcGFyaXNvbl9oYXN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJkb2VzX25vdF9oYXZlXCIgdmFsdWU9XCJkb2VzX25vdF9oYXZlXCI+e2kxOG4uY29tcGFyaXNvbl9kb2VzX25vdF9oYXZlfTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfZW1wdHlcIiB2YWx1ZT1cImlzX2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19lbXB0eX08L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cImlzX25vdF9lbXB0eVwiIHZhbHVlPVwiaXNfbm90X2VtcHR5XCI+e2kxOG4uY29tcGFyaXNvbl9pc19ub3RfZW1wdHl9PC9vcHRpb24+XG4gICAgICAgIF1cbiAgICB9XG59XG5cblNlbGVjdE9wdGlvbnNIYXNPck5vdC5wcm9wVHlwZXMgPSB7XG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdFxufVxuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3RPcHRpb25zSGFzT3JOb3Q7IiwiaW1wb3J0IGkxOG5UZXh0IGZyb20gJy4vdHJhbnNsYXRpb25zL2kxOG4tdGV4dCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBUZXh0U2VsZWN0T3B0aW9ucyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgaTE4biA9IGkxOG5UZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmkxOG4pIHtcbiAgICAgICAgICAgIGkxOG4gPSBPYmplY3QuYXNzaWduKHt9LCBpMThuLCB0aGlzLnByb3BzLmkxOG4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiY29udGFpbnNcIiB2YWx1ZT1cImNvbnRhaW5zXCI+e2kxOG4uY29tcGFyaXNvbl9jb250YWluc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cInN0YXJ0c193aXRoXCIgdmFsdWU9XCJzdGFydHNfd2l0aFwiPntpMThuLmNvbXBhcmlzb25fc3RhcnRzX3dpdGh9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJlbmRzX3dpdGhcIiB2YWx1ZT1cImVuZHNfd2l0aFwiPntpMThuLmNvbXBhcmlzb25fZW5kc193aXRofTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiZXF1YWxzXCIgdmFsdWU9XCJlcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX2VxdWFsc308L29wdGlvbj4sXG4gICAgICAgICAgICA8b3B0aW9uIGtleT1cIm5vdF9lcXVhbHNcIiB2YWx1ZT1cIm5vdF9lcXVhbHNcIj57aTE4bi5jb21wYXJpc29uX25vdF9lcXVhbHN9PC9vcHRpb24+LFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9XCJpc19lbXB0eVwiIHZhbHVlPVwiaXNfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX2VtcHR5fTwvb3B0aW9uPixcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PVwiaXNfbm90X2VtcHR5XCIgdmFsdWU9XCJpc19ub3RfZW1wdHlcIj57aTE4bi5jb21wYXJpc29uX2lzX25vdF9lbXB0eX08L29wdGlvbj5cbiAgICAgICAgXVxuICAgIH1cbn1cblxuVGV4dFNlbGVjdE9wdGlvbnMucHJvcFR5cGVzID0ge1xuICAgIGkxOG46IFByb3BUeXBlcy5vYmplY3Rcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFNlbGVjdE9wdGlvbnM7IiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBhcmlzb25fZXF1YWxzOiAnZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX25vdF9lcXVhbHM6ICdub3QgZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX2dyZWF0ZXJfdGhhbjogJ2dyZWF0ZXIgdGhhbicsXG4gICAgY29tcGFyaXNvbl9sZXNzX3RoYW46ICdsZXNzIHRoYW4nLFxuICAgIGNvbXBhcmlzb25fZ3JlYXRlcl90aGFuX29yX2VxdWFsOiAnZ3JlYXRlciB0aGFuIG9yIGVxdWFsJyxcbiAgICBjb21wYXJpc29uX2xlc3NfdGhhbl9vcl9lcXVhbDogJ2xlc3MgdGhhbiBvciBlcXVhbCcsXG4gICAgY29tcGFyaXNvbl9pc19lbXB0eTogJ2lzIGVtcHR5JyxcbiAgICBjb21wYXJpc29uX2lzX25vdF9lbXB0eTogJ2lzIG5vdCBlbXB0eSdcbn07IiwiZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBhcmlzb25fZXF1YWxzOiAnZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX25vdF9lcXVhbHM6ICdub3QgZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX2lzX2VtcHR5OiAnaXMgZW1wdHknLFxuICAgIGNvbXBhcmlzb25faXNfbm90X2VtcHR5OiAnaXMgbm90IGVtcHR5J1xufTsiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcGFyaXNvbl9oYXM6ICdoYXMnLFxuICAgIGNvbXBhcmlzb25fZG9lc19ub3RfaGF2ZTogJ2RvZXMgbm90IGhhdmUnLFxuICAgIGNvbXBhcmlzb25faXNfZW1wdHk6ICdpcyBlbXB0eScsXG4gICAgY29tcGFyaXNvbl9pc19ub3RfZW1wdHk6ICdpcyBub3QgZW1wdHknXG59OyIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBjb21wYXJpc29uX2NvbnRhaW5zOiAnY29udGFpbnMnLFxuICAgIGNvbXBhcmlzb25fc3RhcnRzX3dpdGg6ICdzdGFydHMgd2l0aCcsXG4gICAgY29tcGFyaXNvbl9lbmRzX3dpdGg6ICdlbmRzIHdpdGgnLFxuICAgIGNvbXBhcmlzb25fZXF1YWxzOiAnZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX25vdF9lcXVhbHM6ICdub3QgZXF1YWxzJyxcbiAgICBjb21wYXJpc29uX2lzX2VtcHR5OiAnaXMgZW1wdHknLFxuICAgIGNvbXBhcmlzb25faXNfbm90X2VtcHR5OiAnaXMgbm90IGVtcHR5J1xufTsiLCJpbXBvcnQgUHJvcFR5cGVzLCB7IHNoYXBlIH0gZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBEZWZhdWx0R3JvdXBCdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyID0gdGhpcy5zZXRDb250YWluZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNldHRpbmdzT3BlbjogZmFsc2VcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZVNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHNldHRpbmdzT3BlbjogIXRoaXMuc3RhdGUuc2V0dGluZ3NPcGVuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldENvbnRhaW5lcihyZWYpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSByZWY7XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNsaWNrT3V0c2lkZShlKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZSA9PiB0aGlzLmNsaWNrT3V0c2lkZShlKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY2xpY2tPdXRzaWRlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2V0dGluZ3NPcGVuIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmIChzZXR0aW5nc09wZW4gJiYgdGhpcy5jb250YWluZXIgJiYgIXRoaXMuY29udGFpbmVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHNldHRpbmdzT3BlbjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHNldHRpbmdzT3BlbiB9ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgeyBidXR0b25zLCBtYXhCdXR0b25zLCBpMThuLCBHcm91cFByaW1hcnlCdXR0b24sIEdyb3VwQnV0dG9uc0xpc3QgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuICg8ZGl2XG4gICAgICAgICAgICByZWY9e3RoaXMuc2V0Q29udGFpbmVyfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdidG4tZ3JvdXAnLCB7XG4gICAgICAgICAgICAgICAgb3Blbjogc2V0dGluZ3NPcGVuXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIHJvbGU9XCJncm91cFwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxHcm91cFByaW1hcnlCdXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9e2UgPT4gdGhpcy50b2dnbGVTZXR0aW5ncygpfT5cbiAgICAgICAgICAgICAgICB7bWF4QnV0dG9ucyA9PT0gMSA/IGkxOG4uYWN0aW9ucyA6IGkxOG4ubW9yZX0mbmJzcDtcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvR3JvdXBQcmltYXJ5QnV0dG9uPlxuICAgICAgICAgICAgPEdyb3VwQnV0dG9uc0xpc3QgYnV0dG9ucz17YnV0dG9ucy5tYXAoYnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBidXR0b24udXJsID8gYnV0dG9uLnVybDogJycsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogYnV0dG9uLm5ld1RhYiA/ICdfYmxhbmsnIDogJycsXG4gICAgICAgICAgICAgICAgICAgIGljb246IGJ1dHRvbi5pY29uLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBidXR0b24udGV4dCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBidXR0b24ua2V5LFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b24ub25DbGljaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24ub25DbGljayhidXR0b24ucHJpbWFyeUtleVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pfT5cbiAgICAgICAgICAgIDwvR3JvdXBCdXR0b25zTGlzdD5cbiAgICAgICAgPC9kaXY+KTtcbiAgICB9XG59XG5cbkRlZmF1bHRHcm91cEJ1dHRvbi5wcm9wVHlwZXMgPSB7XG4gICAgYnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIG1heEJ1dHRvbnM6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaTE4bjogc2hhcGUoe1xuICAgICAgICBhY3Rpb25zOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgICBtb3JlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSlcbn07XG5cbkRlZmF1bHRHcm91cEJ1dHRvbi5kZWZhdWx0UHJvcHMgPSB7XG4gICAgaTE4bjoge1xuICAgICAgICBhY3Rpb25zOiAnQWN0aW9ucycsXG4gICAgICAgIG1vcmU6ICdNb3JlJ1xuICAgIH0sXG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiAocHJvcHMpID0+IDxidXR0b24gey4uLnByb3BzfT57cHJvcHMuY2hpbGRyZW59PC9idXR0b24+LFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IChwcm9wcykgPT4gKDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgIHtwcm9wcy5idXR0b25zLm1hcChidXR0b24gPT5cbiAgICAgICAgICAgIDxsaSBrZXk9e2J1dHRvbi5rZXl9IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyh7J2Ryb3Bkb3duLXN1Ym1lbnUnOiBidXR0b24uaGFzU3ViTWVudX0pfT5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtidXR0b24uaHJlZn1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YnV0dG9uLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD17YnV0dG9uLnRhcmdldH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24uaWNvbiAmJiA8aSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYnV0dG9uLmljb24sICdnYy1idXR0b24taWNvbicpfSAvPn1cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi50ZXh0fVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICl9XG4gICAgPC91bD4pXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0R3JvdXBCdXR0b247IiwiaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBEZWZhdWx0TGlua0J1dHRvbiBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQge1xuXG4gICAgb25DbGlja0NhbGxiYWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9uQ2xpY2ssXG4gICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkNsaWNrKHByaW1hcnlLZXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBpY29uLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHJpZ2h0TWFyZ2luLFxuICAgICAgICAgICAgICAgIG5ld1RhYixcbiAgICAgICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlclxuICAgICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgcmV0dXJuICg8TGlua0J1dHRvbldyYXBwZXJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM9e3sncjUnOiByaWdodE1hcmdpbn19XG4gICAgICAgICAgICBocmVmPXsodXJsID8gdXJsIDogJycpfVxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBvbkNsaWNrPXtlID0+IHRoaXMub25DbGlja0NhbGxiYWNrKGUpfVxuICAgICAgICAgICAgdGFyZ2V0PXtuZXdUYWIgPyAnX2JsYW5rJyA6ICcnfVxuICAgICAgICA+XG4gICAgICAgICAgICB7aWNvbiAmJiA8aSBjbGFzc05hbWU9e2ljb259IC8+fVxuICAgICAgICAgICAge3RleHQgJiYgKDxzcGFuPiZuYnNwO3t0ZXh0fTwvc3Bhbj4pfVxuICAgICAgICA8L0xpbmtCdXR0b25XcmFwcGVyPik7XG4gICAgfVxufTtcblxuRGVmYXVsdExpbmtCdXR0b24ucHJvcFR5cGVzID0ge1xuICAgIGljb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcmlnaHRNYXJnaW46IFByb3BUeXBlcy5ib29sLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHByaW1hcnlLZXlWYWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuZXdUYWI6IFByb3BUeXBlcy5ib29sLFxuICAgIExpbmtCdXR0b25XcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbkRlZmF1bHRMaW5rQnV0dG9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICBMaW5rQnV0dG9uV3JhcHBlcjogKHByb3BzKSA9PiA8YSB7Li4ucHJvcHN9Pntwcm9wcy5jaGlsZHJlbn08L2E+XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0TGlua0J1dHRvbjsiLCJpbXBvcnQgR3JvdXBCdXR0b25zIGZyb20gJy4vd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2dyb3VwLWJ1dHRvbnMuanN4JztcbmltcG9ydCBQcm9wVHlwZXMsIHsgc2hhcGUgfSBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBEYXRhZ3JpZENoZWNrYm94IGZyb20gJy4vZGF0YWdyaWQtY2hlY2tib3guanN4JztcblxuY2xhc3MgRGF0YWdyaWRBY3Rpb25zQ29sdW1uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9ucyxcbiAgICAgICAgICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zLFxuICAgICAgICAgICAgb3B0aW9uczogeyBoYXNFZGl0LCBoYXNSZWFkICwgaGFzQ2xvbmUsIGhhc0RlbGV0ZSwgaGFzQWN0aW9uQnV0dG9ucywgZGVsZXRlTXVsdGlwbGUgfSxcbiAgICAgICAgICAgIG9uRWRpdENsaWNrLFxuICAgICAgICAgICAgb25SZWFkQ2xpY2ssXG4gICAgICAgICAgICBvbkNsb25lQ2xpY2ssXG4gICAgICAgICAgICBvbkRlbGV0ZUNsaWNrLFxuICAgICAgICAgICAgb25Sb3dDaGVja2JveENsaWNrLFxuICAgICAgICAgICAgdXJsVW5pcXVlSGFzaCxcbiAgICAgICAgICAgIHNjcmVlblNpemUsXG4gICAgICAgICAgICByb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIHRvZ2dsZVNlbGVjdFJvdyxcbiAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZSxcbiAgICAgICAgICAgIGkxOG4sXG4gICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcixcbiAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbixcbiAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3RcbiAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBidXR0b25zID0gW107XG5cbiAgICAgICAgaWYgKGhhc0VkaXQpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZ2MtZWRpdCcsXG4gICAgICAgICAgICAgICAgdXJsOiAnIy8nICsgdXJsVW5pcXVlSGFzaCArICdlZGl0LycgKyBwcmltYXJ5S2V5VmFsdWUsXG4gICAgICAgICAgICAgICAgaWNvbjogJ2ZhIGZhLXBlbmNpbCcsXG4gICAgICAgICAgICAgICAgdGV4dDogaTE4bi5lZGl0LFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uRWRpdENsaWNrLFxuICAgICAgICAgICAgICAgIG5ld1RhYjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNSZWFkKSB7XG4gICAgICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogJ2djLXJlYWQnLFxuICAgICAgICAgICAgICAgIHVybDogJyMvJyArIHVybFVuaXF1ZUhhc2ggKyAncmVhZC8nICsgcHJpbWFyeUtleVZhbHVlLFxuICAgICAgICAgICAgICAgIGljb246ICdmYSBmYS1leWUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IGkxOG4udmlldyxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBvblJlYWRDbGljayxcbiAgICAgICAgICAgICAgICBuZXdUYWI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQ2xvbmUpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZ2MtY2xvbmUnLFxuICAgICAgICAgICAgICAgIHVybDogJyMvJyArIHVybFVuaXF1ZUhhc2ggKyAnY2xvbmUvJyArIHByaW1hcnlLZXlWYWx1ZSxcbiAgICAgICAgICAgICAgICBpY29uOiAnZmEgZmEtY29weScsXG4gICAgICAgICAgICAgICAgdGV4dDogaTE4bi5jbG9uZSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBvbkNsb25lQ2xpY2ssXG4gICAgICAgICAgICAgICAgbmV3VGFiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0FjdGlvbkJ1dHRvbnMgJiYgYWN0aW9uQnV0dG9ucykge1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9ucy5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogYnV0dG9uLmljb25Dc3NDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYnV0dG9uLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBidXR0b24ub25DbGljayxcbiAgICAgICAgICAgICAgICAgICAgbmV3VGFiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNBY3Rpb25CdXR0b25zICYmIGJhY2tlbmRBY3Rpb25CdXR0b25zKSB7XG4gICAgICAgICAgICBiYWNrZW5kQWN0aW9uQnV0dG9ucy5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGJ1dHRvbi5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogYnV0dG9uLmljb25Dc3NDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYnV0dG9uLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBuZXdUYWI6IGJ1dHRvbi5uZXdUYWIsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYnV0dG9uLnVybCxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNEZWxldGUpIHtcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiAnZ2MtZGVsZXRlJyxcbiAgICAgICAgICAgICAgICBpY29uOiAnZmEgZmEtdHJhc2gtbycsXG4gICAgICAgICAgICAgICAgdGV4dDogaTE4bi5hY3Rpb25fZGVsZXRlLFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uRGVsZXRlQ2xpY2ssXG4gICAgICAgICAgICAgICAgbmV3VGFiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJnYy1hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVNdWx0aXBsZSAmJiBzY3JlZW5TaXplICE9PSAneHMnICYmIHNjcmVlblNpemUgIT09ICdzJyAmJlxuICAgICAgICAgICAgICAgICAgICA8RGF0YWdyaWRDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93U2VsZWN0ZWQ9e3Jvd1NlbGVjdGVkfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlU2VsZWN0Um93PXt0b2dnbGVTZWxlY3RSb3d9XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2s9e29uUm93Q2hlY2tib3hDbGlja31cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZT17cHJpbWFyeUtleVZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA8R3JvdXBCdXR0b25zXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM9e2J1dHRvbnN9XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblNpemU9e3NjcmVlblNpemV9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyPXtMaW5rQnV0dG9uV3JhcHBlcn1cbiAgICAgICAgICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uPXtHcm91cFByaW1hcnlCdXR0b259XG4gICAgICAgICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5EYXRhZ3JpZEFjdGlvbnNDb2x1bW4ucHJvcFR5cGVzID0ge1xuICAgIGFjdGlvbkJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBiYWNrZW5kQWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9wdGlvbnM6IHNoYXBlKHtcbiAgICAgICAgZGVsZXRlTXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNFZGl0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQ2xvbmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNEZWxldGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNSZWFkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmJvb2xcbiAgICB9KSxcbiAgICBvbkVkaXRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbG9uZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJlYWRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZWxldGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Sb3dDaGVja2JveENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB1cmxVbmlxdWVIYXNoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNjcmVlblNpemU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcm93U2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHRvZ2dsZVNlbGVjdFJvdzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcHJpbWFyeUtleVZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGkxOG46IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAgIGVkaXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHZpZXc6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGFjdGlvbl9kZWxldGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGFjdGlvbnM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIG1vcmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIGNsb25lOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgfSksXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuRGF0YWdyaWRBY3Rpb25zQ29sdW1uLmRlZmF1bHRQcm9wcyA9IHtcbiAgICB1cmxVbmlxdWVIYXNoOiAnJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YWdyaWRBY3Rpb25zQ29sdW1uOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIERhdGFncmlkQ2hlY2tib3ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIG9uQ2hlY2tib3hDbGljayhldmVudCkge1xuICAgICAgICBjb25zdCB7IHRvZ2dsZVNlbGVjdFJvdywgb25Sb3dDaGVja2JveENsaWNrLCBwcmltYXJ5S2V5VmFsdWUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAgICAgdG9nZ2xlU2VsZWN0Um93KHByaW1hcnlLZXlWYWx1ZSk7XG4gICAgICAgIG9uUm93Q2hlY2tib3hDbGljayhldmVudCwgcHJpbWFyeUtleVZhbHVlKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcm93U2VsZWN0ZWQsIHByaW1hcnlLZXlWYWx1ZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgY2hlY2tlZD17cm93U2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB0aGlzLm9uQ2hlY2tib3hDbGljayhlKX1cbiAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImdjLXNlbGVjdC1yb3dcIlxuICAgICAgICAgICAgICAgIGRhdGEtaWQ9e3ByaW1hcnlLZXlWYWx1ZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5EYXRhZ3JpZENoZWNrYm94LnByb3BUeXBlcyA9IHtcbiAgICByb3dTZWxlY3RlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJvd0NoZWNrYm94Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHByaW1hcnlLZXlWYWx1ZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YWdyaWRDaGVja2JveDsiLCJpbXBvcnQgRGF0YWdyaWRBY3Rpb25zQ29sdW1uIGZyb20gXCIuL2RhdGFncmlkLWFjdGlvbnMtY29sdW1uLmpzeFwiO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgUHJvcFR5cGVzLCB7IHNoYXBlIH0gZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIERhdGFncmlkUm93IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtjb2x1bW5zRGF0YX0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7IGhhc0FjdGlvbkJ1dHRvbnMgfSxcbiAgICAgICAgICAgICAgICBvbkVkaXRDbGljayxcbiAgICAgICAgICAgICAgICBvbkNsb25lQ2xpY2ssXG4gICAgICAgICAgICAgICAgb25SZWFkQ2xpY2ssXG4gICAgICAgICAgICAgICAgb25EZWxldGVDbGljayxcbiAgICAgICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2ssXG4gICAgICAgICAgICAgICAgdXJsVW5pcXVlSGFzaCxcbiAgICAgICAgICAgICAgICBhY3Rpb25CdXR0b25zLFxuICAgICAgICAgICAgICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zLFxuICAgICAgICAgICAgICAgIHNjcmVlblNpemUsXG4gICAgICAgICAgICAgICAgb3JkZXJCeSxcbiAgICAgICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZSxcbiAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RSb3csXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgTGlua0J1dHRvbldyYXBwZXIsXG4gICAgICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uLFxuICAgICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3RcbiAgICAgICAgICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIGxldCBjb2x1bW5EYXRhID0gW107XG5cbiAgICAgICAgY29sdW1uc0RhdGEuZm9yRWFjaChjb2x1bW4gPT4ge1xuXG4gICAgICAgICAgICBjb2x1bW5EYXRhLnB1c2goXG4gICAgICAgICAgICAgICAgPHRkXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJzogb3JkZXJCeSA9PT0gY29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGFibGUtYWN0aXZlJzogb3JkZXJCeSA9PT0gY29sdW1uLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwgJ2djLWRhdGEtY29udGFpbmVyJyl9XG4gICAgICAgICAgICAgICAgICAgIGtleT17Y29sdW1uLm5hbWV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgeyFjb2x1bW4udmFsdWUgJiYgPHNwYW4+Jm5ic3A7PC9zcGFuPn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb2x1bW4udmFsdWUgJiYgIWNvbHVtbi5pc0h0bWwgJiYgPGRpdiBjbGFzc05hbWU9XCJnYy1kYXRhLWNvbnRhaW5lci10ZXh0XCI+e2NvbHVtbi52YWx1ZX08L2Rpdj59XG4gICAgICAgICAgICAgICAgICAgICAgICB7Y29sdW1uLnZhbHVlICYmIGNvbHVtbi5pc0h0bWwgJiYgPGRpdiBjbGFzc05hbWU9XCJnYy1kYXRhLWNvbnRhaW5lci10ZXh0XCIgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tfX2h0bWw6IGNvbHVtbi52YWx1ZX19PjwvZGl2Pn1cbiAgICAgICAgICAgICAgICAgPC90ZD5cblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDx0ciBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoe1xuICAgICAgICAgICAgICAgICAgICAnd2FybmluZyc6IHJvd1NlbGVjdGVkXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgZGF0YS1pZD17cHJpbWFyeUtleVZhbHVlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtoYXNBY3Rpb25CdXR0b25zICYmXG4gICAgICAgICAgICAgICAgPERhdGFncmlkQWN0aW9uc0NvbHVtblxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zPXtvcHRpb25zfVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25CdXR0b25zPXthY3Rpb25CdXR0b25zfVxuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kQWN0aW9uQnV0dG9ucz17YmFja2VuZEFjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICAgICAgICAgIG9uRWRpdENsaWNrPXtvbkVkaXRDbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25DbG9uZUNsaWNrPXtvbkNsb25lQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZENsaWNrPXtvblJlYWRDbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGVDbGljaz17b25EZWxldGVDbGlja31cbiAgICAgICAgICAgICAgICAgICAgb25Sb3dDaGVja2JveENsaWNrPXtvblJvd0NoZWNrYm94Q2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIHVybFVuaXF1ZUhhc2g9e3VybFVuaXF1ZUhhc2h9XG4gICAgICAgICAgICAgICAgICAgIHNjcmVlblNpemU9e3NjcmVlblNpemV9XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVNlbGVjdFJvdz17dG9nZ2xlU2VsZWN0Um93fVxuICAgICAgICAgICAgICAgICAgICByb3dTZWxlY3RlZD17cm93U2VsZWN0ZWR9XG4gICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG59XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZT17cHJpbWFyeUtleVZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcj17TGlua0J1dHRvbldyYXBwZXJ9XG4gICAgICAgICAgICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbj17R3JvdXBQcmltYXJ5QnV0dG9ufVxuICAgICAgICAgICAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0PXtHcm91cEJ1dHRvbnNMaXN0fVxuICAgICAgICAgICAgICAgIC8+fVxuICAgICAgICAgICAgICAgIHtjb2x1bW5EYXRhfVxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbkRhdGFncmlkUm93LnByb3BUeXBlcyA9IHtcbiAgICBkYXRhOiBzaGFwZSh7XG4gICAgICAgIGNvbHVtbnNEYXRhOiBQcm9wVHlwZXMuYXJyYXlcbiAgICB9KSxcbiAgICBvcHRpb25zOiBzaGFwZSh7XG4gICAgICAgIGRlbGV0ZU11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzRWRpdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0Nsb25lOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzRGVsZXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzUmVhZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgICAgIGhhc0FjdGlvbkJ1dHRvbnM6IFByb3BUeXBlcy5ib29sXG4gICAgfSksXG4gICAgb25FZGl0Q2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xvbmVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZWFkQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRGVsZXRlQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUm93Q2hlY2tib3hDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgdXJsVW5pcXVlSGFzaDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY3Rpb25CdXR0b25zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgYmFja2VuZEFjdGlvbkJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBzY3JlZW5TaXplOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGkxOG46IFByb3BUeXBlcy5vYmplY3QsXG4gICAgcHJpbWFyeUtleVZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvZ2dsZVNlbGVjdFJvdzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcm93U2VsZWN0ZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIExpbmtCdXR0b25XcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBMaW5rQnV0dG9uV3JhcHBlcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgR3JvdXBCdXR0b25zTGlzdDogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhZ3JpZFJvdzsiLCJpbXBvcnQgRGF0YWdyaWRSb3cgZnJvbSAnLi9kYXRhZ3JpZC1yb3cuanN4JztcbmltcG9ydCBQcm9wVHlwZXMsIHtzaGFwZX0gZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIERhdGFncmlkVGJvZHkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzZWxlY3RlZElkczogW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZVNlbGVjdFJvdyhpZCkge1xuICAgICAgICBsZXQgeyBzZWxlY3RlZElkcyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBpZiAoc2VsZWN0ZWRJZHMuaW5kZXhPZihpZCkgPiAtMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRJZHMgPSBzZWxlY3RlZElkcy5maWx0ZXIoc2VsZWN0ZWRJZCA9PiBzZWxlY3RlZElkICE9PSBpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZElkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgc2VsZWN0ZWRJZHNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByb3dzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9yZGVyQnksXG4gICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgb25FZGl0Q2xpY2ssXG4gICAgICAgICAgICBvbkNsb25lQ2xpY2ssXG4gICAgICAgICAgICBvblJlYWRDbGljayxcbiAgICAgICAgICAgIG9uRGVsZXRlQ2xpY2ssXG4gICAgICAgICAgICBvblJvd0NoZWNrYm94Q2xpY2ssXG4gICAgICAgICAgICB1cmxVbmlxdWVIYXNoLFxuICAgICAgICAgICAgYWN0aW9uQnV0dG9ucyxcbiAgICAgICAgICAgIHNjcmVlblNpemUsXG4gICAgICAgICAgICBpMThuLFxuICAgICAgICAgICAgTGlua0J1dHRvbldyYXBwZXIsXG4gICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b24sXG4gICAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0XG4gICAgICAgIH0gPSB0aGlzLnByb3BzLFxuICAgICAgICAgICAgeyBzZWxlY3RlZElkcyB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICByZXR1cm4gKHJvd3MubWFwKChyb3csIGtleSkgPT5cbiAgICAgICAgICAgIDxEYXRhZ3JpZFJvd1xuICAgICAgICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XG4gICAgICAgICAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgICAgICAgICBkYXRhPXtyb3d9XG4gICAgICAgICAgICAgICAgb3JkZXJCeT17b3JkZXJCeX1cbiAgICAgICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgICAgICBvbkVkaXRDbGljaz17b25FZGl0Q2xpY2t9XG4gICAgICAgICAgICAgICAgb25SZWFkQ2xpY2s9e29uUmVhZENsaWNrfVxuICAgICAgICAgICAgICAgIG9uQ2xvbmVDbGljaz17b25DbG9uZUNsaWNrfVxuICAgICAgICAgICAgICAgIG9uRGVsZXRlQ2xpY2s9e29uRGVsZXRlQ2xpY2t9XG4gICAgICAgICAgICAgICAgb25Sb3dDaGVja2JveENsaWNrPXtvblJvd0NoZWNrYm94Q2xpY2t9XG4gICAgICAgICAgICAgICAgdXJsVW5pcXVlSGFzaD17dXJsVW5pcXVlSGFzaH1cbiAgICAgICAgICAgICAgICBhY3Rpb25CdXR0b25zPXthY3Rpb25CdXR0b25zfVxuICAgICAgICAgICAgICAgIGJhY2tlbmRBY3Rpb25CdXR0b25zPXtyb3cuYmFja2VuZEFjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICAgICAgc2NyZWVuU2l6ZT17c2NyZWVuU2l6ZX1cbiAgICAgICAgICAgICAgICB0b2dnbGVTZWxlY3RSb3c9e2lkID0+IHRoaXMudG9nZ2xlU2VsZWN0Um93KGlkKX1cbiAgICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZT17cm93LnByaW1hcnlLZXlWYWx1ZX1cbiAgICAgICAgICAgICAgICByb3dTZWxlY3RlZD17c2VsZWN0ZWRJZHMuaW5kZXhPZihyb3cucHJpbWFyeUtleVZhbHVlKSA+IC0xfVxuICAgICAgICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyPXtMaW5rQnV0dG9uV3JhcHBlcn1cbiAgICAgICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b249e0dyb3VwUHJpbWFyeUJ1dHRvbn1cbiAgICAgICAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0PXtHcm91cEJ1dHRvbnNMaXN0fVxuICAgICAgICAgICAgLz4pKTtcbiAgICB9XG59XG5cbkRhdGFncmlkVGJvZHkucHJvcFR5cGVzPSB7XG4gICAgcm93czogUHJvcFR5cGVzLmFycmF5LFxuICAgIG9wdGlvbnM6IHNoYXBlKHtcbiAgICAgICAgZGVsZXRlTXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNFZGl0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQ2xvbmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNEZWxldGU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBoYXNSZWFkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAgICAgaGFzQWN0aW9uQnV0dG9uczogUHJvcFR5cGVzLmJvb2xcbiAgICB9KSxcbiAgICBvcmRlckJ5OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNvbHVtbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBvbkVkaXRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25DbG9uZUNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJlYWRDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EZWxldGVDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Sb3dDaGVja2JveENsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICB1cmxVbmlxdWVIYXNoOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGlvbkJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBzY3JlZW5TaXplOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGkxOG46IFByb3BUeXBlcy5vYmplY3QsXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIEdyb3VwUHJpbWFyeUJ1dHRvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgR3JvdXBCdXR0b25zTGlzdDogUHJvcFR5cGVzLmZ1bmMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhZ3JpZFRib2R5OyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIEZpZWxkUm93V3JhcHBlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAgIGRpc3BsYXlBcyxcbiAgICAgICAgRmllbGRJbnB1dCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZ2NydWRJbnN0YW5jZSxcbiAgICAgICAgZmV0Y2hEYXRhLFxuICAgICAgICBpMThuLFxuICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudCxcbiAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gKDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiPlxuICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImNvbC1zbS0zIGNvbnRyb2wtbGFiZWxcIj5cbiAgICAgICAgICB7aXNSZXF1aXJlZCA/ICcqJyA6ICcnfVxuICAgICAgICAgIHtkaXNwbGF5QXN9XG4gICAgICA8L2xhYmVsPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tOVwiPlxuICAgICAgICAgIDxGaWVsZElucHV0XG4gICAgICAgICAgICAgIGRhdGE9e2RhdGF9XG4gICAgICAgICAgICAgIGdjcnVkSW5zdGFuY2U9e2djcnVkSW5zdGFuY2V9XG4gICAgICAgICAgICAgIGZldGNoRGF0YT17ZmV0Y2hEYXRhfVxuICAgICAgICAgICAgICBpMThuPXtpMThufVxuICAgICAgICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudD17cmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnR9XG4gICAgICAgICAgICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZT17cmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlfVxuICAgICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj4pO1xuICB9XG59XG5cbkZpZWxkUm93V3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgaXNSZXF1aXJlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZGlzcGxheUFzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIEZpZWxkSW5wdXQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgZ2NydWRJbnN0YW5jZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBpMThuOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWVsZFJvd1dyYXBwZXI7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gXCJjbGFzc25hbWVzXCI7XG5cbmNsYXNzIEdyb3VwQnV0dG9uc0xpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7YnV0dG9uc30gPSB0aGlzLnByb3BzO1xuXG4gICAgcmV0dXJuICg8dWwgY2xhc3NOYW1lPVwiZHJvcGRvd24tbWVudVwiPlxuICAgICAgICB7YnV0dG9ucy5tYXAoYnV0dG9uID0+XG4gICAgICAgICAgICA8bGlcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgICAgICAgICBrZXk9e2J1dHRvbi5rZXl9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZHJvcGRvd24tc3VibWVudSc6IGJ1dHRvbi5oYXNTdWJNZW51LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnQtZGlyZWN0aW9uJzogYnV0dG9uLmhhc1N1Yk1lbnUgJiYgYnV0dG9uLnN1Yk1lbnVMZWZ0RGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pfT5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtidXR0b24uaHJlZiA/IGJ1dHRvbi5ocmVmIDogJyd9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2J1dHRvbi5vbkNsaWNrfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9e2J1dHRvbi50YXJnZXR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLmljb24gJiYgPGkgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGJ1dHRvbi5pY29uLCAnZ2MtYnV0dG9uLWljb24nKX0gLz59XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24udGV4dH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc3ViQ29tcG9uZW50ICYmIDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLnN1YkNvbXBvbmVudH1cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICApfVxuICAgIDwvdWw+KTtcbiAgfVxufVxuXG5Hcm91cEJ1dHRvbnNMaXN0LnByb3BUeXBlcyA9IHtcbiAgICBidXR0b25zOiBQcm9wVHlwZXMuYXJyYXlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyb3VwQnV0dG9uc0xpc3Q7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBEZWZhdWx0TGlua0J1dHRvbiBmcm9tIFwiLi4vLi4vYnV0dG9ucy9kZWZhdWx0LWxpbmstYnV0dG9uLmpzeFwiO1xuaW1wb3J0IERlZmF1bHRHcm91cEJ1dHRvbiBmcm9tIFwiLi4vLi4vYnV0dG9ucy9kZWZhdWx0LWdyb3VwLWJ1dHRvbi5qc3hcIjtcblxuY2xhc3MgR3JvdXBCdXR0b25zIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgc2NyZWVuU2l6ZSxcbiAgICAgICAgICBpMThuLFxuICAgICAgICAgIExpbmtCdXR0b25XcmFwcGVyLFxuICAgICAgICAgIEdyb3VwUHJpbWFyeUJ1dHRvbixcbiAgICAgICAgICBHcm91cEJ1dHRvbnNMaXN0XG4gICAgICB9ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbWF4QnV0dG9ucyA9IChzY3JlZW5TaXplID09PSAneHMnIHx8IHNjcmVlblNpemUgPT09ICdzJykgPyAxIDogMixcbiAgICAgICAgYnV0dG9uTWFwID0gYnV0dG9uID0+XG4gICAgICAgICAgICA8RGVmYXVsdExpbmtCdXR0b25cbiAgICAgICAgICAgICAgIGtleT17YnV0dG9uLmtleX1cbiAgICAgICAgICAgICAgIHVybD17YnV0dG9uLnVybH1cbiAgICAgICAgICAgICAgIGljb249e2J1dHRvbi5pY29ufVxuICAgICAgICAgICAgICAgdGV4dD17YnV0dG9uLnRleHR9XG4gICAgICAgICAgICAgICBuZXdUYWI9e2J1dHRvbi5uZXdUYWJ9XG4gICAgICAgICAgICAgICByaWdodE1hcmdpbj17dHJ1ZX1cbiAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZT17YnV0dG9uLnByaW1hcnlLZXlWYWx1ZX1cbiAgICAgICAgICAgICAgIG9uQ2xpY2s9e2J1dHRvbi5vbkNsaWNrfVxuICAgICAgICAgICAgICAgTGlua0J1dHRvbldyYXBwZXI9e0xpbmtCdXR0b25XcmFwcGVyfVxuICAgICAgICAgICAgLz5cblxuICAgICAgaWYgKCFidXR0b25zIHx8IGJ1dHRvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChidXR0b25zLmxlbmd0aCA8PSBtYXhCdXR0b25zKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1dHRvbnMubWFwKGJ1dHRvbk1hcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoPHNwYW4+XG4gICAgICAgICAgeyhidXR0b25zLmZpbHRlcigoX19idXR0b24sIGtleSkgPT4ga2V5IDwgKG1heEJ1dHRvbnMgLSAxKSkubWFwKGJ1dHRvbk1hcCkpfVxuICAgICAgICAgIDxEZWZhdWx0R3JvdXBCdXR0b25cbiAgICAgICAgICAgICAgYnV0dG9ucz17YnV0dG9ucy5maWx0ZXIoKF9fYnV0dG9uLCBrZXkpID0+IGtleSA+PSAobWF4QnV0dG9ucyAtIDEpKX1cbiAgICAgICAgICAgICAgbWF4QnV0dG9ucz17bWF4QnV0dG9uc31cbiAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uPXtHcm91cFByaW1hcnlCdXR0b259XG4gICAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cbn1cblxuR3JvdXBCdXR0b25zLnByb3BUeXBlcyA9IHtcbiAgICBidXR0b25zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgc2NyZWVuU2l6ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBpMThuOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IFByb3BUeXBlcy5mdW5jLFxuICAgIExpbmtCdXR0b25XcmFwcGVyOiBQcm9wVHlwZXMuZnVuYyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdyb3VwQnV0dG9uczsiLCJjbGFzcyBHcm91cFByaW1hcnlCdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdCBkcm9wZG93bi10b2dnbGVcIiB7Li4ucHJvcHN9Pntwcm9wcy5jaGlsZHJlbn08L2J1dHRvbj5cbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyb3VwUHJpbWFyeUJ1dHRvbjsiLCJpbXBvcnQgY2xhc3NOYW1lc0xpYnJhcnkgZnJvbSBcImNsYXNzbmFtZXNcIjtcblxuY2xhc3MgTGlua0J1dHRvbldyYXBwZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgICBjb25zdFxuICAgICAgICAgIHsgY2hpbGRyZW4sIGNsYXNzTmFtZXMsIGhyZWYsIHJvbGUsIG9uQ2xpY2ssIHRhcmdldCB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGFcbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXNMaWJyYXJ5KCdidG4nLCAnYnRuLWRlZmF1bHQnLCBjbGFzc05hbWVzKX1cbiAgICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICAgIHJvbGU9e3JvbGV9XG4gICAgICAgICAgb25DbGljaz17b25DbGlja31cbiAgICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua0J1dHRvbldyYXBwZXI7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgTW9kYWxUaXRsZVdyYXBwZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNsb3NlXCJcbiAgICAgICAgICAgICAgZGF0YS1kaXNtaXNzPVwibW9kYWxcIlxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj5cbiAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgIDwvaDQ+XG4gICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICB9XG59XG5cbk1vZGFsVGl0bGVXcmFwcGVyLnByb3BUeXBlcyA9IHtcbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxUaXRsZVdyYXBwZXI7IiwiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgRmllbGRSb3dXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgaXNSZXF1aXJlZCxcbiAgICAgICAgZGlzcGxheUFzLFxuICAgICAgICBGaWVsZElucHV0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBnY3J1ZEluc3RhbmNlLFxuICAgICAgICBmZXRjaERhdGEsXG4gICAgICAgIGkxOG4sXG4gICAgICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50LFxuICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwIHJvd1wiPlxuICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImNvbC1zbS0zIGNvbC1mb3JtLWxhYmVsXCI+XG4gICAgICAgICAge2lzUmVxdWlyZWQgPyAnKicgOiAnJ31cbiAgICAgICAgICB7ZGlzcGxheUFzfVxuICAgICAgPC9sYWJlbD5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXNtLTlcIj5cbiAgICAgICAgICA8RmllbGRJbnB1dFxuICAgICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgICBnY3J1ZEluc3RhbmNlPXtnY3J1ZEluc3RhbmNlfVxuICAgICAgICAgICAgICBmZXRjaERhdGE9e2ZldGNoRGF0YX1cbiAgICAgICAgICAgICAgaTE4bj17aTE4bn1cbiAgICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkTW91bnQ9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50fVxuICAgICAgICAgICAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRVcGRhdGU9e3JlbGF0aW9uYWxPbkNvbXBvbmVudERpZFVwZGF0ZX1cbiAgICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+KTtcbiAgfVxufVxuXG5GaWVsZFJvd1dyYXBwZXIucHJvcFR5cGVzID0ge1xuICAgIGlzUmVxdWlyZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc3BsYXlBczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBGaWVsZElucHV0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBkYXRhOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGdjcnVkSW5zdGFuY2U6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgaTE4bjogUHJvcFR5cGVzLm9iamVjdCxcbiAgICByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRmllbGRSb3dXcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBHcm91cEJ1dHRvbnNMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3Qge2J1dHRvbnN9ID0gdGhpcy5wcm9wcztcblxuICAgIHJldHVybiAoPGRpdiBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgIHtidXR0b25zLm1hcChidXR0b24gPT5cbiAgICAgICAgICAgICFidXR0b24uaGFzU3ViTWVudSA/XG4gICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAga2V5PXtidXR0b24ua2V5fVxuICAgICAgICAgICAgICAgICAgICBocmVmPXtidXR0b24uaHJlZn1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YnV0dG9uLm9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD17YnV0dG9uLnRhcmdldH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZHJvcGRvd24taXRlbVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7YnV0dG9uLmljb24gJiYgPGkgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGJ1dHRvbi5pY29uLCAnZ2MtYnV0dG9uLWljb24nKX0gLz59XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24udGV4dH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAga2V5PXtidXR0b24ua2V5fVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2Ryb3Bkb3duLWl0ZW0nLCAnZHJvcGRvd24tc3VibWVudScsICdkcm9wZG93bi1zdWJtZW51LWl0ZW0nLHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0LWRpcmVjdGlvbic6IGJ1dHRvbi5zdWJNZW51TGVmdERpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtidXR0b24uaWNvbiAmJiA8aSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoYnV0dG9uLmljb24sICdnYy1idXR0b24taWNvbicpfSAvPn1cbiAgICAgICAgICAgICAgICAgICAge2J1dHRvbi50ZXh0fVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc3ViQ29tcG9uZW50ICYmIDx1bCBjbGFzc05hbWU9XCJkcm9wZG93bi1tZW51XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2J1dHRvbi5zdWJDb21wb25lbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgKX1cbiAgICA8L2Rpdj4pO1xuICB9XG59XG5cbkdyb3VwQnV0dG9uc0xpc3QucHJvcFR5cGVzID0ge1xuICAgIGJ1dHRvbnM6IFByb3BUeXBlcy5hcnJheVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR3JvdXBCdXR0b25zTGlzdDsiLCJjbGFzcyBHcm91cFByaW1hcnlCdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT1cImJ0biBidG4tb3V0bGluZS1kYXJrIGRyb3Bkb3duLXRvZ2dsZVwiIHsuLi5wcm9wc30+e3Byb3BzLmNoaWxkcmVufTwvYnV0dG9uPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR3JvdXBQcmltYXJ5QnV0dG9uOyIsImltcG9ydCBjbGFzc05hbWVzTGlicmFyeSBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuXG5jbGFzcyBMaW5rQnV0dG9uV3JhcHBlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0XG4gICAgICAgICAgeyBjaGlsZHJlbiwgY2xhc3NOYW1lcywgaHJlZiwgcm9sZSwgb25DbGljaywgdGFyZ2V0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lc0xpYnJhcnkoJ2J0bicsICdidG4tb3V0bGluZS1kYXJrJywgY2xhc3NOYW1lcyl9XG4gICAgICAgICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgICAgICAgIHJvbGU9e3JvbGV9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICAgICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgICAgID5cbiAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvYT4pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtCdXR0b25XcmFwcGVyOyIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNsYXNzIE1vZGFsVGl0bGVXcmFwcGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyB0aXRsZSB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgcmV0dXJuIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj5cbiAgICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2xvc2VcIlxuICAgICAgICAgICAgICBkYXRhLWRpc21pc3M9XCJtb2RhbFwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDbG9zZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9SZWFjdC5GcmFnbWVudD5cbiAgfVxufVxuXG5Nb2RhbFRpdGxlV3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gICAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsVGl0bGVXcmFwcGVyOyIsImltcG9ydCBQZXJQYWdlRHJvcGRvd24gZnJvbSAnLi4vbW9kdWxlcy9yZWFjdC9qc3gvZGF0YWdyaWQvZm9vdGVyL3Blci1wYWdlLWRyb3Bkb3duLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBGaWx0ZXJpbmcgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQtZmlsdGVyaW5nL2ZpbHRlcmluZyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBEYXRhZ3JpZFRib2R5IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL2RhdGFncmlkLXRib2R5LmpzeCc7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtZGF0YWdyaWQtc2V0dGluZ3MvZ2NlLWRhdGFncmlkLXNldHRpbmdzL3NldHRpbmdzLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBHcm91cFByaW1hcnlCdXR0b25Cb290c3RyYXBWMyBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtcHJpbWFyeS1idXR0b24uanN4JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEdyb3VwQnV0dG9uc0xpc3RCb290c3RyYXBWMyBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjMvZ3JvdXAtYnV0dG9ucy1saXN0LmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBMaW5rQnV0dG9uV3JhcHBlckJvb3RzdHJhcFYzIGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12My9saW5rLWJ1dHRvbi13cmFwcGVyLmpzeCc7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgRmllbGRSb3dXcmFwcGVyQm9vdHN0cmFwVjMgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL2ZpZWxkLXJvdy13cmFwcGVyJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IE1vZGFsVGl0bGVXcmFwcGVyQm9vdHN0cmFwVjMgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXYzL21vZGFsLXRpdGxlLXdyYXBwZXInOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgR3JvdXBQcmltYXJ5QnV0dG9uQm9vdHN0cmFwVjQgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2dyb3VwLXByaW1hcnktYnV0dG9uLmpzeCc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBHcm91cEJ1dHRvbnNMaXN0Qm9vdHN0cmFwVjQgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtcmVhY3QtZGF0YWdyaWQvd3JhcHBlcnMvYm9vdHN0cmFwLXY0L2dyb3VwLWJ1dHRvbnMtbGlzdC5qc3gnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgTGlua0J1dHRvbldyYXBwZXJCb290c3RyYXBWNCBmcm9tICcuLi8uLi8uLi8uLi9SZWFjdC1Db21wb25lbnRzL2djZS1yZWFjdC1kYXRhZ3JpZC93cmFwcGVycy9ib290c3RyYXAtdjQvbGluay1idXR0b24td3JhcHBlci5qc3gnOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IEZpZWxkUm93V3JhcHBlckJvb3RzdHJhcFY0IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12NC9maWVsZC1yb3ctd3JhcHBlcic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBNb2RhbFRpdGxlV3JhcHBlckJvb3RzdHJhcFY0IGZyb20gJy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLXJlYWN0LWRhdGFncmlkL3dyYXBwZXJzL2Jvb3RzdHJhcC12NC9tb2RhbC10aXRsZS13cmFwcGVyJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IE1vZGFsVGl0bGUgZnJvbSAnLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9tb2RhbC90aXRsZS5qc3gnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cblxubGV0IEhhbmRsZWJhcnMgPSByZXF1aXJlKCcuLi9saWJyYXJpZXMvSGFuZGxlYmFyc0V4dGVuZGVkJykuSGFuZGxlYmFycyxcbiAgICBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLFxuICAgICQgPSBqUXVlcnksXG4gICAgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIGkxOG4gPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9pMThuJykuaTE4bixcbiAgICBsb2NhbFN0b3JhZ2VIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2xvY2FsLXN0b3JhZ2UtaGVscGVyJykubG9jYWxTdG9yYWdlSGVscGVyLFxuICAgIEdyaWQgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmdyaWQuanMnKS5HcmlkLFxuICAgIE9wZXJhdGlvbkFkZCA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9hZGQuanMnKS5PcGVyYXRpb25BZGQsXG4gICAgT3BlcmF0aW9uRWRpdCA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9lZGl0LmpzJykuT3BlcmF0aW9uRWRpdCxcbiAgICBPcGVyYXRpb25DbG9uZSA9IHJlcXVpcmUoJy4vLi4vc2VjdGlvbnMvb3BlcmF0aW9ucy9jbG9uZS5qcycpLk9wZXJhdGlvbkNsb25lLFxuICAgIE9wZXJhdGlvblJlYWQgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL29wZXJhdGlvbnMvcmVhZC5qcycpLk9wZXJhdGlvblJlYWQsXG4gICAgT3BlcmF0aW9uRGVsZXRlID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9vcGVyYXRpb25zL2RlbGV0ZS5qcycpLk9wZXJhdGlvbkRlbGV0ZSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9vcGVyYXRpb25zL2NvbW1vbi5qcycpLk9wZXJhdGlvbnNDb21tb24sXG4gICAgQ29sdW1uID0gcmVxdWlyZSgnLi4vc2VjdGlvbnMvZGF0YWdyaWQvY29sdW1uJykuQ29sdW1uLFxuICAgIERhdGFncmlkQ29sdW1ucyA9IHJlcXVpcmUoJy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmNvbHVtbnMnKS5EYXRhZ3JpZENvbHVtbnMsXG4gICAgRGF0YWdyaWRQYWdpbmcgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5wYWdpbmcnKS5EYXRhZ3JpZFBhZ2luZyxcbiAgICBEYXRhZ3JpZEhlYWRlckFjdGlvbnMgPSByZXF1aXJlKCcuLy4uL3NlY3Rpb25zL2RhdGFncmlkL2RhdGFncmlkLmhlYWRlci1hY3Rpb25zLmpzJykuRGF0YWdyaWRIZWFkZXJBY3Rpb25zLFxuICAgIERhdGFncmlkU2VhcmNoID0gcmVxdWlyZSgnLi8uLi9zZWN0aW9ucy9kYXRhZ3JpZC9kYXRhZ3JpZC5zZWFyY2guanMnKS5EYXRhZ3JpZFNlYXJjaCxcbiAgICBSb3V0ZXIgPSByZXF1aXJlKCcuLi9zZWN0aW9ucy9yb3V0ZXMvcm91dGVyJykuUm91dGVyLFxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGJhc2ljIE9iamVjdCB0aGF0IGRvZXMgYWxsIHRoZSBmdW5jdGlvbmFsaXR5IGZvciBHcm9jZXJ5Q3J1ZFxuICAgICAqXG4gICAgICogQGNsYXNzIEdyb2NlcnlDcnVkXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGdjcnVkX2NvbnRhaW5lclxuICAgICAqIEBwYXJhbSBPYmplY3Qgc2V0dGluZ3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBHcm9jZXJ5Q3J1ZCA9IGZ1bmN0aW9uIEdyb2NlcnlDcnVkKGdjcnVkX2NvbnRhaW5lciwgc2V0dGluZ3MpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2pRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGdjID0gZ2NydWRfY29udGFpbmVyO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfTtcblxuaWYgKCQuZm4gIT09IHVuZGVmaW5lZCkge1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL3ByaW50VGhpcycpO1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL3RyYW5zaXRpb24nKTtcbiAgICByZXF1aXJlKCcuLi9qcXVlcnktcGx1Z2lucy9tb2RhbCcpO1xuICAgIHJlcXVpcmUoJy4uL2pxdWVyeS1wbHVnaW5zL2Nob3Nlbi5qcXVlcnknKTtcbiAgICByZXF1aXJlKCcuLi9saWJyYXJpZXMvanF1ZXJ5LXVpLXRpbWVwaWNrZXInKTtcbn1cblxuLy9Hcm9jZXJ5Q3J1ZCBwdWJsaWMgdmFyaWFibGVzXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5zZXJ0RmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUudXJsID0gJyc7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5kZXhlZENvbHVtbnMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5oYXNBY3Rpb25zID0gJyc7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZW51bUZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmVudW1GaWVsZHNEYXRhID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZHJvcGRvd25GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5kcm9wZG93bkZpZWxkc0RhdGEgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jaGVja2JveEJvb2xlYW5GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jaGVja2JveEJvb2xlYW5GaWVsZHNEYXRhID0gW107XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbk50b05GaWVsZHMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbk50b05EYXRhID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubXVsdGlwbGVTZWxlY3RGaWVsZHMgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5tdWx0aXBsZVNlbGVjdERhdGEgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS50ZXh0ZWRpdG9yRmllbGRzID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY2FsbGJhY2tDb2x1bW5GaWVsZHMgPSB7fTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmNvbXBvbmVudHMgPSB7XG4gICAgR3JvdXBQcmltYXJ5QnV0dG9uOiBudWxsLFxuICAgIEdyb3VwQnV0dG9uc0xpc3Q6IG51bGwsXG4gICAgTGlua0J1dHRvbldyYXBwZXI6IG51bGwsXG4gICAgRmllbGRSb3dXcmFwcGVyOiBudWxsLFxuICAgIE1vZGFsVGl0bGVXcmFwcGVyOiBudWxsXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVsYXRpb25GaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5yZWxhdGlvbkRhdGEgPSB7fTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51cGxvYWRGaWVsZHMgPSBbXTtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51cGxvYWRGaWVsZHNEYXRhID0ge307XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmRhdGV0aW1lRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZvcm1hdHRlciA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUudXBkYXRlRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVhZEZpZWxkcyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmNsb25lRmllbGRzID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY29sdW1ucyA9IFtdO1xuR3JvY2VyeUNydWQucHJvdG90eXBlLnZpc2libGVDb2x1bW5zID0gW107XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuc2VhcmNoX3RpbWVyID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jYWNoZWRJbml0aWFsRGF0YSA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucHJpbWFyeUtleUZpZWxkID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5qc29uRGF0YSA9IHt9O1xuR3JvY2VyeUNydWQucHJvdG90eXBlLnJvd3NEYXRhID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS51bmlxdWVJZCA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0ZUZvcm1hdCA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZGF0YWdyaWRTdG9yZSA9IG51bGw7XG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaGFzaEV2ZW50ID0gbnVsbDtcbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zdHJpbmdWYXJpYWJsZXMgPSB7XG4gICAgc3ViamVjdDogJ1JlY29yZCcsXG4gICAgc3ViamVjdFBsdXJhbDogJydcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLmdldEluaXREYXRhKCk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY29tcG9uZW50c0luaXQgPSBmdW5jdGlvbiBjb21wb25lbnRzSW5pdCgpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jb25maWcuc2tpbiA9PT0gJ2Jvb3RzdHJhcC12NCcpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkdyb3VwQnV0dG9uc0xpc3QgPSBHcm91cEJ1dHRvbnNMaXN0Qm9vdHN0cmFwVjQ7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5Hcm91cFByaW1hcnlCdXR0b24gPSBHcm91cFByaW1hcnlCdXR0b25Cb290c3RyYXBWNDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkxpbmtCdXR0b25XcmFwcGVyID0gTGlua0J1dHRvbldyYXBwZXJCb290c3RyYXBWNDtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLkZpZWxkUm93V3JhcHBlciA9IEZpZWxkUm93V3JhcHBlckJvb3RzdHJhcFY0O1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXIgPSBNb2RhbFRpdGxlV3JhcHBlckJvb3RzdHJhcFY0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5Hcm91cEJ1dHRvbnNMaXN0ID0gR3JvdXBCdXR0b25zTGlzdEJvb3RzdHJhcFYzO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHMuR3JvdXBQcmltYXJ5QnV0dG9uID0gR3JvdXBQcmltYXJ5QnV0dG9uQm9vdHN0cmFwVjM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5MaW5rQnV0dG9uV3JhcHBlciA9IExpbmtCdXR0b25XcmFwcGVyQm9vdHN0cmFwVjM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5GaWVsZFJvd1dyYXBwZXIgPSBGaWVsZFJvd1dyYXBwZXJCb290c3RyYXBWMztcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyID0gTW9kYWxUaXRsZVdyYXBwZXJCb290c3RyYXBWMztcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5pdEZhY2FkZSA9IGZ1bmN0aW9uIGluaXRGYWNhZGUoKSB7XG4gICAgUm91dGVyLnNldFJvdXRlcy5hcHBseSh0aGlzKTtcbiAgICB0aGlzLmNvbXBvbmVudHNJbml0KCk7XG4gICAgdGhpcy5kYXRhZ3JpZEluaXQoKTtcblxuICAgIGpRdWVyeVBsdWdpbnMuaW5pdCgpO1xuXG4gICAgT3BlcmF0aW9uQWRkLmxpc3RlbmVyQWRkQnV0dG9uLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbnNDb21tb24ubGlzdGVuZXJTdWJtaXRGb3JtLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZVNpbmdsZU1vZGFsLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZU11bHRpcGxlLmFwcGx5KHRoaXMpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lckRlbGV0ZU11bHRpcGxlTW9kYWwuYXBwbHkodGhpcyk7XG4gICAgT3BlcmF0aW9uc0NvbW1vbi5pbml0UmVkdXhTdG9yZS5hcHBseSh0aGlzKTtcblxuICAgIERhdGFncmlkU2VhcmNoLmxpc3RlbmVyU2VhcmNoQnV0dG9uLmFwcGx5KHRoaXMpO1xuICAgIEdyaWQubGlzdGVuZXJDb2x1bW5XaXRoT3JkZXJpbmcuYXBwbHkodGhpcyk7XG4gICAgR3JpZC5saXN0ZW5lclBhZ2luZ0J1dHRvbnMuYXBwbHkodGhpcyk7XG4gICAgRGF0YWdyaWRIZWFkZXJBY3Rpb25zLmxpc3RlbmVyUHJpbnRCdXR0b24uYXBwbHkodGhpcyk7XG4gICAgdGhpcy5saXN0ZW5lclBlclBhZ2UoKTtcblxuICAgIHRoaXMubGlzdGVuZXJPblNjcmVlblJlc2l6ZSgpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplRmllbGRUeXBlc0RhdGEoKTtcblxuICAgIENvbHVtbi5pbml0Q2FjaGVkRGF0YS5hcHBseSh0aGlzKTtcblxuICAgIC8vIEFsbCB0aGVzZSBNVVNUIGJlIGFmdGVyIHRoZSBpbml0aWFsaXplRmllbGRUeXBlc0RhdGEgYW5kIGluaXRDYWNoZWREYXRhXG4gICAgRGF0YWdyaWRDb2x1bW5zLnNldFZpc2libGVDb2x1bW5zLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMucmVuZGVyU2V0dGluZ3NCdXR0b24uYXBwbHkodGhpcyk7XG4gICAgdGhpcy5lbmFibGVGaWx0ZXJpbmdDb21wb25lbnQuYXBwbHkodGhpcyk7XG5cbiAgICB0aGlzLmluaXRpYWxpemluZ0RhdGEoKTtcblxuICAgIFJvdXRlci5pbml0LmFwcGx5KHRoaXMpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmxpc3RlbmVyT25TY3JlZW5SZXNpemUgPSBmdW5jdGlvbiBsaXN0ZW5lck9uU2NyZWVuUmVzaXplKCkge1xuICAgIGxldCByZXNpemVyVGltZW91dCA9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAod2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmIChyZXNpemVyVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNpemVyVGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc2l6ZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiB3aW5kb3dSZXNpemVUaW1lb3V0KCkge1xuICAgICAgICAgICAgICAgIHJlc2l6ZXJUaW1lb3V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvd3NEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YWdyaWRCb2R5KHRoaXMucm93c0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRmlsdGVyaW5nQ29tcG9uZW50KCk7XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjUwKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuX2ZpbHRlcmluZ09uU3VibWl0Q2FsbGJhY2sgPSBmdW5jdGlvbiBfZmlsdGVyaW5nT25TdWJtaXRDYWxsYmFjayhldmVudCkge1xuICAgIGxldCBkYXRhVG9TZW5kID0gYWpheEhlbHBlci5nZXRNdWx0aWxheWVyUG9zdERhdGFGcm9tRm9ybS5hcHBseSh0aGlzLCBbICQoZXZlbnQudGFyZ2V0KSBdKSxcbiAgICAgICAgaGlkZGVuRmllbGRzSHRtbCA9ICcnLFxuICAgICAgICBudW1iZXJPZkZpbHRlcnMgPSAwO1xuICAgIGNvbnN0IHBlcl9wYWdlID0gR3JpZC5nZXRQZXJQYWdlLmFwcGx5KHRoaXMpLFxuICAgICAgICBvcmRlcl9ieSA9IEdyaWQuZ2V0T3JkZXJCeS5hcHBseSh0aGlzKSxcbiAgICAgICAgc29ydGluZyA9IEdyaWQuZ2V0U29ydGluZy5hcHBseSh0aGlzKTtcblxuICAgIF8uZWFjaChkYXRhVG9TZW5kLCBmdW5jdGlvbiBmb3JlYWNoRGF0YVRvU2VuZChmaWVsZFZhbHVlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gL15leHRlbmRlZF9zZWFyY2gvLnRlc3QoZmllbGROYW1lKSA/ICdnYy1leHRlbmRlZC1zZWFyY2gtaW5wdXQnIDogJyc7XG5cbiAgICAgICAgaWYgKC9eZXh0ZW5kZWRfc2VhcmNoXFxbXFxkK1xcXVxcW25hbWVcXF0kLy50ZXN0KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIG51bWJlck9mRmlsdGVycysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlkZGVuRmllbGRzSHRtbCArPSAnPGlucHV0IHR5cGU9XCJoaWRkZW5cIiBuYW1lPVwiJyArIGZpZWxkTmFtZSArICdcIiB2YWx1ZT1cIicgKyBmaWVsZFZhbHVlICsgJ1wiIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIiAvPic7XG4gICAgfSk7XG5cbiAgICAkKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5odG1sKGhpZGRlbkZpZWxkc0h0bWwpO1xuXG4gICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgIGRhdGFUb1NlbmRbdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXROYW1lXSA9IHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgZGF0YVRvU2VuZC5hY3Rpb24gPSAnZGF0YWdyaWQnO1xuICAgIGRhdGFUb1NlbmQucGFnZSA9ICcxJztcbiAgICBkYXRhVG9TZW5kLnBlcl9wYWdlID0gcGVyX3BhZ2U7XG4gICAgZGF0YVRvU2VuZC5vcmRlcl9ieSA9IG9yZGVyX2J5O1xuICAgIGRhdGFUb1NlbmQuc29ydGluZyA9IHNvcnRpbmc7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaW5wdXQnKS52YWwoJzEnKTtcbiAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuJGdjXG4gICAgICAgIC5maW5kKCcuZ2MtZmlsdGVyaW5nLW1vZGFsJylcbiAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG5cbiAgICB0aGlzLnNlbmRQb3N0UmVxdWVzdCh7XG4gICAgICAgIHVybDogdGhpcy4kZ2MuZGF0YSgndXJsJyksXG4gICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0YWdyaWQoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRGF0YWdyaWQoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIEdyaWQudXBkYXRlR3JpZERldGFpbHMuYXBwbHkodGhpcywgWyBqc29uUmVzcG9uc2UgXSk7XG4gICAgICAgICAgICBEYXRhZ3JpZENvbHVtbnMudHJpZ2dlckNvbHVtbnNSZW5kZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgLmFkZENsYXNzKCdidG4tc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdidG4tb3V0bGluZS1kYXJrJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtcmVtb3ZlLWZpbHRlci1jb250YWluZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLXRleHQnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXInKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItbnVtYmVyJykuaHRtbChudW1iZXJPZkZpbHRlcnMudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkZpbHRlcnMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItdGV4dCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXItdGV4dC1wbHVyYWwnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXItY291bnRlci10ZXh0JykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXItY291bnRlci10ZXh0LXBsdXJhbCcpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5lbmFibGVGaWx0ZXJpbmdDb21wb25lbnQgPSBmdW5jdGlvbiBlbmFibGVGaWx0ZXJpbmdDb21wb25lbnQoKSB7XG4gICAgY29uc3QgZ2NJbnN0YW5jZSA9IHRoaXMsXG4gICAgICAgIHNlYXJjaGFibGVTZWxlY3QgPSB7XG4gICAgICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiBvblNlYXJjaGFibGVNb3VudCgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVPdXRmb3JTZWFyY2hhYmxlU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgICAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5jaG9zZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfc2luZ2xlX2Rlc2VsZWN0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNTAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25TZWFyY2hhYmxlVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLnRyaWdnZXIoJ2Nob3Nlbjp1cGRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0RGF0ZXRpbWUgPSB7XG4gICAgICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbkRhdGVNb3VudCgpIHtcbiAgICAgICAgICAgICAgICAkKFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKS5kYXRldGltZXBpY2tlcih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IChnY0luc3RhbmNlLmRhdGVGb3JtYXQpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0RGF0ZSA9IHtcbiAgICAgICAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uRGF0ZU1vdW50KCkge1xuICAgICAgICAgICAgICAgICQoUmVhY3RET00uZmluZERPTU5vZGUodGhpcykpLmRhdGVwaWNrZXIoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiAoZ2NJbnN0YW5jZS5kYXRlRm9ybWF0KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGlmICghdGhpcy5zZXR0aW5ncy5kYXRhZ3JpZFNlYXJjaEFsbElucHV0KSB7XG4gICAgICAgIFJlYWN0RE9NLnJlbmRlcig8RmlsdGVyaW5nXG4gICAgICAgICAgICBNb2RhbFRpdGxlPXtwcm9wcyA9PiA8TW9kYWxUaXRsZVxuICAgICAgICAgICAgICAgIE1vZGFsVGl0bGVXcmFwcGVyPXt0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXJ9XG4gICAgICAgICAgICAgICAgdGl0bGU9e3Byb3BzLnRpdGxlfVxuICAgICAgICAgICAgLz59XG4gICAgICAgICAgICBpMThuPXt7XG4gICAgICAgICAgICAgICAgYmFzaWNfb3BlcmF0b3I6IGkxOG4udCgnZmlsdGVyaW5nX29wZXJhdG9yJyksXG4gICAgICAgICAgICAgICAgYW5kX3N0YXRlbWVudDogaTE4bi50KCdmaWx0ZXJpbmdfYW5kX3N0YXRlbWVudCcpLFxuICAgICAgICAgICAgICAgIG9yX3N0YXRlbWVudDogaTE4bi50KCdmaWx0ZXJpbmdfb3Jfc3RhdGVtZW50JyksXG4gICAgICAgICAgICAgICAgZmlsdGVyaW5nOiBpMThuLnQoJ2ZpbHRlcmluZ190ZXh0JyksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBpMThuLnQoJ2ZpbHRlcmluZ19maWx0ZXJfdGV4dCcpLFxuICAgICAgICAgICAgICAgIGNhbmNlbF9maWx0ZXJpbmc6IGkxOG4udCgnZmlsdGVyaW5nX2NhbmNlbCcpLFxuICAgICAgICAgICAgICAgIGFkZF9tb3JlOiBpMThuLnQoJ2ZpbHRlcmluZ19hZGRfbW9yZScpLFxuICAgICAgICAgICAgICAgIHJlbW92ZV9maWx0ZXI6IGkxOG4udCgnZmlsdGVyaW5nX3JlbW92ZV9maWx0ZXInKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2NvbnRhaW5zOiBpMThuLnQoJ2ZpbHRlcmluZ19jb250YWlucycpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fc3RhcnRzX3dpdGg6IGkxOG4udCgnZmlsdGVyaW5nX3N0YXJ0c193aXRoJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9lbmRzX3dpdGg6IGkxOG4udCgnZmlsdGVyaW5nX2VuZHNfd2l0aCcpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZXF1YWxzOiBpMThuLnQoJ2ZpbHRlcmluZ19lcXVhbHMnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX25vdF9lcXVhbHM6IGkxOG4udCgnZmlsdGVyaW5nX25vdF9lcXVhbHMnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2lzX2VtcHR5OiBpMThuLnQoJ2ZpbHRlcmluZ19pc19lbXB0eScpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25faXNfbm90X2VtcHR5OiBpMThuLnQoJ2ZpbHRlcmluZ19pc19ub3RfZW1wdHknKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2dyZWF0ZXJfdGhhbjogaTE4bi50KCdmaWx0ZXJpbmdfZ3JlYXRlcl90aGFuJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9sZXNzX3RoYW46IGkxOG4udCgnZmlsdGVyaW5nX2xlc3NfdGhhbicpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZ3JlYXRlcl90aGFuX29yX2VxdWFsOiBpMThuLnQoJ2ZpbHRlcmluZ19ncmVhdGVyX3RoYW5fb3JfZXF1YWwnKSxcbiAgICAgICAgICAgICAgICBjb21wYXJpc29uX2xlc3NfdGhhbl9vcl9lcXVhbDogaTE4bi50KCdmaWx0ZXJpbmdfbGVzc190aGFuX29yX2VxdWFsJyksXG4gICAgICAgICAgICAgICAgY29tcGFyaXNvbl9oYXM6IGkxOG4udCgnZmlsdGVyaW5nX2hhcycpLFxuICAgICAgICAgICAgICAgIGNvbXBhcmlzb25fZG9lc19ub3RfaGF2ZTogaTE4bi50KCdmaWx0ZXJpbmdfZG9lc19ub3RfaGF2ZScpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgc2NyZWVuU2l6ZT17dGhpcy5nZXRTY3JlZW5XaWR0aCgpfVxuICAgICAgICAgICAgZmllbGRzPXt0aGlzLmdldEZpZWxkc0ZvckZpbHRlcmluZy5hcHBseSh0aGlzKX1cbiAgICAgICAgICAgIG9uU3VibWl0Q2FsbGJhY2s9e3RoaXMuX2ZpbHRlcmluZ09uU3VibWl0Q2FsbGJhY2suYmluZCh0aGlzKX1cbiAgICAgICAgICAgIG9uSW5wdXRNb3VudD17e1xuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0RGF0ZSxcbiAgICAgICAgICAgICAgICBkYXRldGltZTogaW5wdXREYXRldGltZSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGlucHV0RGF0ZXRpbWUsXG4gICAgICAgICAgICAgICAgZW51bV9zZWFyY2hhYmxlOiBzZWFyY2hhYmxlU2VsZWN0LFxuICAgICAgICAgICAgICAgIGRyb3Bkb3duX3NlYXJjaDogc2VhcmNoYWJsZVNlbGVjdCxcbiAgICAgICAgICAgICAgICByZWxhdGlvbmFsOiBzZWFyY2hhYmxlU2VsZWN0LFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uYWxfbl9uOiBzZWFyY2hhYmxlU2VsZWN0XG4gICAgICAgICAgICB9fVxuICAgICAgICAvPiwgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlcmluZy1jb250YWluZXInKVswXSk7XG4gICAgfVxufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnJlbmRlclNldHRpbmdzQnV0dG9uID0gZnVuY3Rpb24gcmVuZGVyVmlzaWJsZUNvbHVtbnNDaGVja2JveGVzKCkge1xuICAgIGNvbnN0IHJlZnJlc2hDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJNZW51TGVmdERpcmVjdGlvbiA9ICF0aGlzLmNhY2hlZEluaXRpYWxEYXRhLm9wZXJhdGlvbnMuZXhwb3J0RGF0YSB8fCAhdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLnByaW50LFxuICAgICAgICBjbGVhckZpbHRlcmluZ0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtaW5wdXQnKS52YWwoJycpO1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtc2VsZWN0JykudmFsKCcnKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWNoZWNrYm94JykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2gtaW5wdXQnKS52YWwoJycpLmJsdXIoKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1oaWRkZW4tc2VhcmNoLWlucHV0cycpLmh0bWwoJycpO1xuXG4gICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJDYWNoZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkVmlzaWJsZUNvbHVtbnNfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkUHJlZmVyZW5jZXMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZUNvbHVtbnNDYWxsYmFjayA9ICh2aXNpYmxlQ29sdW1ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRWaXNpYmxlQ29sdW1ucyA9IERhdGFncmlkQ29sdW1ucy5maWx0ZXJWaXNpYmxlQ29sdW1ucy5hcHBseSh0aGlzLCBbdmlzaWJsZUNvbHVtbnNdKTtcbiAgICAgICAgICAgIERhdGFncmlkQ29sdW1ucy50cmlnZ2VyQ29sdW1uc1JlbmRlci5hcHBseSh0aGlzLCBbZmlsdGVyZWRWaXNpYmxlQ29sdW1uc10pO1xuICAgICAgICAgICAgRGF0YWdyaWRDb2x1bW5zLnNldENhY2hlRm9yVmlzaWJsZUNvbHVtbnMuYXBwbHkodGhpcywgW3Zpc2libGVDb2x1bW5zXSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFncmlkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgR3JvdXBQcmltYXJ5QnV0dG9uLCBHcm91cEJ1dHRvbnNMaXN0IH0gPSB0aGlzLmNvbXBvbmVudHM7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoPFNldHRpbmdzXG4gICAgICAgIHN1Yk1lbnVMZWZ0RGlyZWN0aW9uPXtzdWJNZW51TGVmdERpcmVjdGlvbn1cbiAgICAgICAgb25SZWZyZXNoQ2FsbGJhY2s9e3JlZnJlc2hDYWxsYmFja31cbiAgICAgICAgb25DbGVhckZpbHRlcmluZ0NhbGxiYWNrPXtjbGVhckZpbHRlcmluZ0NhbGxiYWNrfVxuICAgICAgICBvbkNsZWFyQ2FjaGVDYWxsYmFjaz17Y2xlYXJDYWNoZUNhbGxiYWNrfVxuICAgICAgICBjb2x1bW5zPXt0aGlzLmNvbHVtbnN9XG4gICAgICAgIHZpc2libGVDb2x1bW5zPXt0aGlzLnZpc2libGVDb2x1bW5zfVxuICAgICAgICBnY3J1ZEluc3RhbmNlPXt0aGlzfVxuICAgICAgICB2aXNpYmxlQ29sdW1uc0NhbGxiYWNrT25DaGFuZ2U9e3Zpc2libGVDb2x1bW5zQ2FsbGJhY2t9XG4gICAgICAgIGkxOG49e3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuaTE4bn1cbiAgICAgICAgR3JvdXBQcmltYXJ5QnV0dG9uPXtHcm91cFByaW1hcnlCdXR0b259XG4gICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgLz4sIHRoaXMuJGdjLmZpbmQoJy5nYy1zZXR0aW5ncy1idXR0b24tY29udGFpbmVyJylbMF0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnJlbmRlckRhdGFncmlkID0gZnVuY3Rpb24gcmVyZW5kZXJEYXRhZ3JpZChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmpzb25EYXRhID0gZGF0YTtcbiAgICB9XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0SW5pdERhdGEgPSBmdW5jdGlvbiBnZXRJbml0RGF0YSgpIHtcblxuICAgIC8qIEBpZiBFTlZJUk9OTUVOVD0nd2Vic2l0ZScgKi9cbiAgICAgICAgLyogUHJvdGVjdGlvbiBpbiBjYXNlIHNvbWVvbmUgd2lsbCBkb3dubG9hZFxuICAgICAgICAqICB0aGUgSlMgY29kZS4gQ3JhenlmeSByZWFkcyB0aGUgaG9zdCBuYW1lIGFuZCBpZiBpdCBkb2Vzbid0IGluY2x1ZGVcbiAgICAgICAgKiAgZ3JvY2VyeWNydWQgaXQgd2lsbCBkbyBzb21lIGNyYXp5IHN0dWZmIGF0IHRoZSBjb2RlLiBJZiB5b3UgdHJ5IHRvIGRlYnVnXG4gICAgICAgICogIGl0LCBpdCBjYW4gZHJpdmUgeW91IGNyYXp5IDotUFxuICAgICAgICAqICAqL1xuICAgICAgICAvKiBAZWNobyBDUkFaWUZZICovXG4gICAgLyogQGVuZGlmICovXG5cbiAgICB0aGlzLnVuaXF1ZUlkID0gdGhpcy4kZ2MuZGF0YSgndW5pcXVlLWlkJyk7XG4gICAgdGhpcy51cmwgPSB0aGlzLiRnYy5kYXRhKCd1cmwnKTtcblxuICAgIHRoaXMuc2VuZEdldFJlcXVlc3Qoe1xuICAgICAgICB1cmw6IHRoaXMuJGdjLmRhdGEoJ3VybCcpLFxuICAgICAgICBkYXRhVG9TZW5kOiB7XG4gICAgICAgICAgICBhY3Rpb246IENvbnN0YW50cy5BQ1RJT05fSU5JVF9EQVRBXG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuXG4gICAgICAgICAgICB0aGlzLnNldEluaXRWYXJpYWJsZXMoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEgPSBqc29uUmVzcG9uc2U7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdEZhY2FkZSgpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5keW5hbWljVHJhbnNsYXRpb24gPSBmdW5jdGlvbiBkeW5hbWljVHJhbnNsYXRpb24oaTE4blN0cmluZ3MpIHtcbiAgICB2YXIgcGFnaW5nU3ViU3RyaW5nO1xuXG4gICAgaTE4blN0cmluZ3MuY29uZmlybV9kZWxldGVfbXVsdGlwbGUgPSBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5jb25maXJtX2RlbGV0ZV9tdWx0aXBsZSwge1xuICAgICAgICBpdGVtc19hbW91bnQ6ICc8c3BhbiBjbGFzcz1cImdjLWRlbGV0ZS1jb3VudFwiPjwvc3Bhbj4nXG4gICAgfSk7XG5cbiAgICBpMThuU3RyaW5ncy5wYWdpbmdfZGlzcGxheWluZyA9IGkxOG4uZm9ybWF0KGkxOG5TdHJpbmdzLnBhZ2luZ19kaXNwbGF5aW5nLCB7XG4gICAgICAgIHN0YXJ0OiAnPHNwYW4gY2xhc3M9XCJwYWdpbmctc3RhcnRzXCI+MTwvc3Bhbj4nLFxuICAgICAgICBlbmQ6ICc8c3BhbiBjbGFzcz1cInBhZ2luZy1lbmRzXCI+MTA8L3NwYW4+JyxcbiAgICAgICAgcmVzdWx0czogJzxzcGFuIGNsYXNzPVwiY3VycmVudC10b3RhbC1yZXN1bHRzXCI+PC9zcGFuPidcbiAgICB9KTtcblxuICAgIHBhZ2luZ1N1YlN0cmluZyA9IGkxOG5TdHJpbmdzLnBhZ2luZ19zaG93X2VudHJpZXMubWF0Y2goLyguKikrXFx7cGFnaW5nXFx9KC4qKSsvKTtcbiAgICBpMThuU3RyaW5ncy5wYWdpbmdfc2hvd19lbnRyaWVzID0ge1xuICAgICAgICBmaXJzdDogcGFnaW5nU3ViU3RyaW5nICE9PSBudWxsID8gcGFnaW5nU3ViU3RyaW5nWzFdIDogJycsXG4gICAgICAgIHNlY29uZDogcGFnaW5nU3ViU3RyaW5nICE9PSBudWxsID8gcGFnaW5nU3ViU3RyaW5nWzJdIDogJydcbiAgICB9O1xuXG4gICAgaTE4blN0cmluZ3MucGFnaW5nX2ZpbHRlcmVkX2Zyb20gPSBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5wYWdpbmdfZmlsdGVyZWRfZnJvbSwge1xuICAgICAgICB0b3RhbF9yZXN1bHRzOiAnPHNwYW4gY2xhc3M9XCJmdWxsLXRvdGFsXCI+PC9zcGFuPidcbiAgICB9KTtcbn07XG5cbi8vIEdDLTE5NTogQXV0b21hdGljYWxseSByZW5kZXIgdGhlIHN1Ym1lbnUgdG8gdGhlIGxlZnQgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZS5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zdWJNZW51T3ZlcmZsb3dDaGVjayA9IGZ1bmN0aW9uIHN1Yk1lbnVPdmVyZmxvd0NoZWNrKCkge1xuICAgIHZhciBzZXR0aW5nc0J1dHRvbk9mZnNldCA9IHRoaXMuJGdjLmZpbmQoJy5nYy1zZXR0aW5ncy1idXR0b24nKS5vZmZzZXQoKTtcbiAgICBpZiAoc2V0dGluZ3NCdXR0b25PZmZzZXQgJiYgKHNldHRpbmdzQnV0dG9uT2Zmc2V0LmxlZnQgKyAxNjAgKyAxODApID4gJCh3aW5kb3cpLndpZHRoKCkpIHtcbiAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgIC5maW5kKCcuZ2Mtc2V0dGluZ3MtYnV0dG9uJylcbiAgICAgICAgICAgIC5uZXh0KClcbiAgICAgICAgICAgIC5maW5kKCcuZHJvcGRvd24tc3VibWVudScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2xlZnQtZGlyZWN0aW9uJyk7XG4gICAgfVxufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmRhdGFncmlkSW5pdCA9IGZ1bmN0aW9uIGRhdGFncmlkSW5pdCgpIHtcbiAgICB2YXIgaTE4blN0cmluZ3MgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmkxOG4sXG4gICAgICAgIGluaXREYXRhID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YTtcblxuICAgIHRoaXMuZHluYW1pY1RyYW5zbGF0aW9uKGkxOG5TdHJpbmdzKTtcblxuICAgIHRoaXMuc3RyaW5nVmFyaWFibGVzLmlzQm9vdHN0cmFwVjQgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNvbmZpZy5za2luID09PSAnYm9vdHN0cmFwLXY0JztcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5hZGRVcmwgPSAnIy8nICsgdGhpcy5oYXNoRXZlbnQuYWRkSXRlbTtcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25BZGRFbmFibGVkID0gaW5pdERhdGEub3BlcmF0aW9ucy5hZGQ7XG4gICAgdGhpcy5zdHJpbmdWYXJpYWJsZXMub3BlcmF0aW9uRXhwb3J0RW5hYmxlZCA9IGluaXREYXRhLm9wZXJhdGlvbnMuZXhwb3J0RGF0YTtcbiAgICB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25QcmludEVuYWJsZWQgPSBpbml0RGF0YS5vcGVyYXRpb25zLnByaW50O1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX1NFQVJDSF9ST1cpXG4gICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgdGhpcy5oYW5kbGViYXJzVGVtcGxhdGUoJy5nYy1oZWFkZXItYWN0aW9ucy1vcGVyYXRpb25zJywge1xuICAgICAgICAgICAgICBpc0Jvb3RzdHJhcFY0OiB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5pc0Jvb3RzdHJhcFY0LFxuICAgICAgICAgICAgICBkZWxldGVNdWx0aXBsZTogaW5pdERhdGEub3BlcmF0aW9ucy5kZWxldGVNdWx0aXBsZSxcbiAgICAgICAgICAgICAgaGFzQWN0aW9uQnV0dG9uczogdGhpcy5kYXRhZ3JpZEhhc0FjdGlvbnMuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjXG4gICAgICAgIC5maW5kKCcuZm9vdGVyLXRvb2xzJylcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZ2MtZm9vdGVyLXRlbXBsYXRlJywge1xuICAgICAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzLFxuICAgICAgICAgICAgICAgIGlzQm9vdHN0cmFwVjQ6IHRoaXMuc3RyaW5nVmFyaWFibGVzLmlzQm9vdHN0cmFwVjRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICB0aGlzLiRnY1xuICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfREFUQUdSSURfQ09OVEFJTkVSKVxuICAgICAgICAucHJlcGVuZChcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX1RFTVBMQVRFX0NBUFRJT05fVElUTEUsIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnN1YmplY3Quc3ViamVjdF9zaW5nbGUsXG4gICAgICAgICAgICAgICAgc3ViamVjdFBsdXJhbDogdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5zdWJqZWN0LnN1YmplY3RfcGx1cmFsXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0hFQURFUl9UT09MUylcbiAgICAgICAgLnByZXBlbmQoXG4gICAgICAgICAgICB0aGlzLmhhbmRsZWJhcnNUZW1wbGF0ZShDb25zdGFudHMuSEFORExFQkFSU19BRERfQlVUVE9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uQWRkRW5hYmxlZDogdGhpcy5zdHJpbmdWYXJpYWJsZXMub3BlcmF0aW9uQWRkRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBhZGRVcmw6IHRoaXMuc3RyaW5nVmFyaWFibGVzLmFkZFVybCxcbiAgICAgICAgICAgICAgICBhZGRJdGVtU3RyaW5nOiBpMThuLmZvcm1hdChpMThuU3RyaW5ncy5hZGRfaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnN1YmplY3Quc3ViamVjdF9zaW5nbGVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1leHBvcnQtYnV0dG9uLWNvbnRhaW5lcicpLmh0bWwoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0VYUE9SVF9CVVRUT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbkV4cG9ydEVuYWJsZWQ6IHRoaXMuc3RyaW5nVmFyaWFibGVzLm9wZXJhdGlvbkV4cG9ydEVuYWJsZWQsXG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcuZ2MtcHJpbnQtYnV0dG9uLWNvbnRhaW5lcicpLmh0bWwoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX1BSSU5UX0JVVFRPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uUHJpbnRFbmFibGVkOiB0aGlzLnN0cmluZ1ZhcmlhYmxlcy5vcGVyYXRpb25QcmludEVuYWJsZWQsXG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLWZpbHRlci1idXR0b24tY29udGFpbmVyJykuaHRtbChcbiAgICAgICAgdGhpcy5oYW5kbGViYXJzVGVtcGxhdGUoJy5zZWFyY2gtYnV0dG9uLXRlbXBsYXRlJywge1xuICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3MsXG4gICAgICAgICAgICBzZWFyY2hBbGxCdXR0b246IHRoaXMuc2V0dGluZ3MuZGF0YWdyaWRTZWFyY2hBbGxJbnB1dFxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1Yk1lbnVPdmVyZmxvd0NoZWNrLmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy4kZ2NcbiAgICAgICAgLnByZXBlbmQoXG4gICAgICAgICAgICB0aGlzLmhhbmRsZWJhcnNUZW1wbGF0ZShDb25zdGFudHMuSEFORExFQkFSU19JTlNFUlRfTU9EQUwsIHtcbiAgICAgICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgIHRoaXMuJGdjLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0RFTEVURV9TSU5HTEVfTU9EQUwsIHtcbiAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuJGdjLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKENvbnN0YW50cy5IQU5ETEVCQVJTX0RFTEVURV9NVVRMSVBMRV9NT0RBTCwge1xuICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3NcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1lbnRyaWVzLWNvbnRhaW5lcicpLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcucGFnaW5nLWVudHJpZXMtdGVtcGxhdGUnLCB7XG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBBZnRlciB0aGUgcGFnaW5nIGlzIHJlbmRlcmVkIHdlIHdpbGwgYWxzbyBuZWVkIHRvIGFkZCB0aGUgcGFnaW5nQ29tcG9uZW50XG4gICAgUmVhY3RET00ucmVuZGVyKDxQZXJQYWdlRHJvcGRvd24gZGVmYXVsdFBlclBhZ2U9e2luaXREYXRhLnBhZ2luZy5kZWZhdWx0UGVyUGFnZX0gcGFnaW5nT3B0aW9ucz17aW5pdERhdGEucGFnaW5nLnBhZ2luZ09wdGlvbnN9IC8+LCB0aGlzLiRnYy5maW5kKCcucGVyLXBhZ2UtY29udGFpbmVyJylbMF0pO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLmRpc3BsYXlpbmctcGFnaW5nLWNvbnRhaW5lcicpLnByZXBlbmQoXG4gICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZGlzcGxheWluZy1wYWdpbmctdGVtcGxhdGUnLCB7XG4gICAgICAgICAgICBpMThuOiBpMThuU3RyaW5nc1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxNb2RhbFRpdGxlXG4gICAgICAgICAgICBNb2RhbFRpdGxlV3JhcHBlcj17dGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgdGl0bGU9e2kxOG5TdHJpbmdzLmVycm9yX2dlbmVyaWNfdGl0bGV9XG4gICAgICAgIC8+LFxuICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgLmZpbmQoJy5tb2RhbC1oZWFkZXInKVswXSk7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxNb2RhbFRpdGxlXG4gICAgICAgICAgICBNb2RhbFRpdGxlV3JhcHBlcj17dGhpcy5jb21wb25lbnRzLk1vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgdGl0bGU9e2kxOG5TdHJpbmdzLmFjdGlvbl9kZWxldGV9XG4gICAgICAgIC8+LFxuICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgLmZpbmQoJy5kZWxldGUtc2luZ2xlLWNvbmZpcm1hdGlvbicpXG4gICAgICAgICAgICAuZmluZCgnLm1vZGFsLWhlYWRlcicpWzBdKTtcblxuICAgIFJlYWN0RE9NLnJlbmRlcihcbiAgICAgICAgPE1vZGFsVGl0bGVcbiAgICAgICAgICAgIE1vZGFsVGl0bGVXcmFwcGVyPXt0aGlzLmNvbXBvbmVudHMuTW9kYWxUaXRsZVdyYXBwZXJ9XG4gICAgICAgICAgICB0aXRsZT17aTE4blN0cmluZ3MuYWN0aW9uX2RlbGV0ZX1cbiAgICAgICAgLz4sXG4gICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAuZmluZCgnLmdjLWRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24nKVxuICAgICAgICAgICAgLmZpbmQoJy5tb2RhbC1oZWFkZXInKVswXSk7XG5cbiAgICBpMThuLmluaXQoaTE4blN0cmluZ3MpO1xuXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0RmllbGRzRm9yRmlsdGVyaW5nID0gZnVuY3Rpb24gZ2V0RmllbGRzRm9yRmlsdGVyaW5nKCkge1xuICAgIGxldCBmaWVsZHMgPSBbXSxcbiAgICAgICAgaW5kZXhlZENvbHVtbnMgPSB7fTtcbiAgICBjb25zdCB7IGZpZWxkVHlwZXNDb2x1bW5zLCBjb2x1bW5zIH0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhO1xuXG4gICAgY29sdW1ucy5mb3JFYWNoKChjb2x1bW4pID0+IHtcbiAgICAgICAgaW5kZXhlZENvbHVtbnNbY29sdW1uLm5hbWVdID0gY29sdW1uLmRpc3BsYXlBcztcbiAgICB9KTtcblxuICAgIE9iamVjdC5rZXlzKGZpZWxkVHlwZXNDb2x1bW5zKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hGaWVsZFR5cGVzQ29sdW1ucyhmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKGluZGV4ZWRDb2x1bW5zW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZFR5cGVzQ29sdW1uc1tmaWVsZE5hbWVdLmRhdGFUeXBlLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlBczogaW5kZXhlZENvbHVtbnNbZmllbGROYW1lXSxcbiAgICAgICAgICAgICAgICBwZXJtaXR0ZWRWYWx1ZXM6IGZpZWxkVHlwZXNDb2x1bW5zW2ZpZWxkTmFtZV0ucGVybWl0dGVkVmFsdWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpZWxkcztcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybnMge2pRdWVyeX1cbiAqL1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuJGdjLmZpbmQoc2VsZWN0b3IpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnNldEluaXRWYXJpYWJsZXMgPSBmdW5jdGlvbiBzZXRJbml0VmFyaWFibGVzKGRhdGEpIHtcbiAgICB0aGlzLmNvbHVtbnMgPSBbXTtcblxuICAgIF8uZWFjaChkYXRhLmNvbHVtbnMsIGZ1bmN0aW9uIGZvcmVhY2hDb2x1bW5zKGNvbHVtbikge1xuICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICBjb2x1bW5OYW1lOiBjb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGRpc3BsYXlBczogY29sdW1uLmRpc3BsYXlBc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmluZGV4ZWRDb2x1bW5zW2NvbHVtbi5uYW1lXSA9IGNvbHVtbi5kaXNwbGF5QXM7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5zZW5kR2V0UmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRHZXRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnVybCA9ICFfLmlzVW5kZWZpbmVkKG9wdGlvbnMudXJsKSA/IG9wdGlvbnMudXJsIDogdGhpcy4kZ2MuZGF0YSgndXJsJyk7XG5cbiAgICByZXR1cm4gYWpheEhlbHBlci5zZW5kR2V0UmVxdWVzdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLnNlbmRQb3N0UmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRQb3N0UmVxdWVzdChvcHRpb25zKSB7XG4gICAgb3B0aW9ucy51cmwgPSAhXy5pc1VuZGVmaW5lZChvcHRpb25zLnVybCkgPyBvcHRpb25zLnVybCA6IHRoaXMuJGdjLmRhdGEoJ3VybCcpO1xuXG4gICAgcmV0dXJuIGFqYXhIZWxwZXIuc2VuZFBvc3RSZXF1ZXN0LmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaGFuZGxlYmFyc1RlbXBsYXRlID0gZnVuY3Rpb24gaGFuZGxlYmFyc1RlbXBsYXRlKHN0cmluZ1NlbGVjdG9yLCB0ZW1wbGF0ZU9iamVjdCkge1xuXG4gICAgdmFyIGhhbmRsZWJhcnNUZW1wbGF0ZUNvbXBpbGVkID0gSGFuZGxlYmFycy5jb21waWxlKFxuICAgICAgICB0aGlzLiRnYy5maW5kKHN0cmluZ1NlbGVjdG9yKS5odG1sKClcbiAgICApO1xuXG4gICAgcmV0dXJuIGhhbmRsZWJhcnNUZW1wbGF0ZUNvbXBpbGVkKHRlbXBsYXRlT2JqZWN0KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5kYXRhZ3JpZEhhc0FjdGlvbnMgPSBmdW5jdGlvbiBkYXRhZ3JpZEhhc0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEub3BlcmF0aW9ucy5kZWxldGVTaW5nbGUgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLmVkaXQgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLnJlYWQgfHxcbiAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5vcGVyYXRpb25zLmFjdGlvbkJ1dHRvbnMgfHxcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hY3Rpb25CdXR0b25zLmxlbmd0aCA+IDA7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuaW5pdGlhbGl6ZUZpZWxkVHlwZXNEYXRhID0gZnVuY3Rpb24gaW5pdGlhbGl6ZUZpZWxkVHlwZXNEYXRhKCkge1xuICAgIHZhciBmaWVsZFR5cGVzQWRkRm9ybSA9IHt9LFxuICAgICAgICBmaWVsZFR5cGVzRWRpdEZvcm0gPSB7fSxcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybSA9IHt9LFxuICAgICAgICBmaWVsZFR5cGVzUmVhZEZvcm0gPSB7fSxcbiAgICAgICAgZmllbGRUeXBlc0NvbHVtbnMgPSB7fTtcblxuICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXMsIGZ1bmN0aW9uIGZpZWxkVHlwZXNGb3JFYXJjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQWRkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgICAgICBmaWVsZFR5cGVzRWRpdEZvcm1bZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgICAgICBmaWVsZFR5cGVzUmVhZEZvcm1bZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICAgICAgZmllbGRUeXBlc0NvbHVtbnNbZmllbGROYW1lXSA9IGZpZWxkVHlwZU9iamVjdDtcbiAgICB9KTtcblxuICAgIC8vIG92ZXJyaWRpbmcgdGhlIGZpZWxkIHR5cGVzXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0FkZEZvcm0sIGZ1bmN0aW9uIGZpZWxkVHlwZXNBZGRGb3JtRm9yRWFjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQWRkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0VkaXRGb3JtLCBmdW5jdGlvbiBmaWVsZFR5cGVzRWRpdEZvcm1Gb3JFYWNoKGZpZWxkVHlwZU9iamVjdCwgZmllbGROYW1lKSB7XG4gICAgICAgIGZpZWxkVHlwZXNFZGl0Rm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0Nsb25lRm9ybSwgZnVuY3Rpb24gZmllbGRUeXBlc0Nsb25lRm9ybUZvckVhY2goZmllbGRUeXBlT2JqZWN0LCBmaWVsZE5hbWUpIHtcbiAgICAgICAgZmllbGRUeXBlc0Nsb25lRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc1JlYWRGb3JtLCBmdW5jdGlvbiBmaWVsZFR5cGVzUmVhZEZvcm1Gb3JFYWNoKGZpZWxkVHlwZU9iamVjdCwgZmllbGROYW1lKSB7XG4gICAgICAgIGZpZWxkVHlwZXNSZWFkRm9ybVtmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXNDb2x1bW5zRm9yRWFjaChmaWVsZFR5cGVPYmplY3QsIGZpZWxkTmFtZSkge1xuICAgICAgICBmaWVsZFR5cGVzQ29sdW1uc1tmaWVsZE5hbWVdID0gZmllbGRUeXBlT2JqZWN0O1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQWRkRm9ybSA9IGZpZWxkVHlwZXNBZGRGb3JtO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0VkaXRGb3JtID0gZmllbGRUeXBlc0VkaXRGb3JtO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0Nsb25lRm9ybSA9IGZpZWxkVHlwZXNDbG9uZUZvcm07XG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzUmVhZEZvcm0gPSBmaWVsZFR5cGVzUmVhZEZvcm07XG4gICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucyA9IGZpZWxkVHlwZXNDb2x1bW5zO1xuXG4gICAgc3dpdGNoICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNvbmZpZy5kYXRlRm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3VrLWRhdGUnOlxuICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gJ2RkL21tL3l5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3VzLWRhdGUnOlxuICAgICAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gJ21tL2RkL3l5JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NxbC1kYXRlJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZUZvcm1hdCA9ICd5eS1tbS1kZCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhdmluZyB0aGUgZmlyc3QgY2FsbCBpbnRvIHRoZSBiYWNrZW5kIGluIG9yZGVyIHRvIGZpbGwgb3VyIGRhdGFncmlkIHdpdGggc29tZSBkYXRhXG4gKi9cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5pbml0aWFsaXppbmdEYXRhID0gZnVuY3Rpb24gaW5pdGlhbGl6aW5nRGF0YSgpIHtcbiAgICB2YXIgZGF0YVRvU2VuZCA9IHt9LFxuICAgICAgICBjYWNoZWREYXRhLFxuICAgICAgICBjYWNoZWRQcmVmZXJlbmNlcyxcbiAgICAgICAgY29sdW1uX3RpdGxlLFxuICAgICAgICAkY29sdW1uVG9PcmRlcixcbiAgICAgICAgcmVhZE9ubHlBZGRGaWVsZHMgPSB7fSxcbiAgICAgICAgcmVhZE9ubHlFZGl0RmllbGRzID0ge30sXG4gICAgICAgIHJlYWRPbmx5Q2xvbmVGaWVsZHMgPSB7fTtcblxuICAgIEdyaWQuc2V0RXhwb3J0VXJsLmFwcGx5KHRoaXMpO1xuICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9EQVRBR1JJRDtcblxuICAgIGlmICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbikge1xuICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzQWN0aW9ucyA9IHRoaXMuZGF0YWdyaWRIYXNBY3Rpb25zLmFwcGx5KHRoaXMpO1xuXG4gICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlBZGRGaWVsZHMsIGZ1bmN0aW9uIHJlYWRPbmx5QWRkRmllbGRzRm9yRWFyY2goZmllbGQpIHtcbiAgICAgICAgcmVhZE9ubHlBZGRGaWVsZHNbZmllbGRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLnJlYWRPbmx5QWRkRmllbGRzID0gcmVhZE9ubHlBZGRGaWVsZHM7XG5cbiAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5yZWFkT25seUNsb25lRmllbGRzLCBmdW5jdGlvbiByZWFkT25seUNsb25lRmllbGRzRm9yRWFyY2goZmllbGQpIHtcbiAgICAgICAgcmVhZE9ubHlDbG9uZUZpZWxkc1tmaWVsZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlDbG9uZUZpZWxkcyA9IHJlYWRPbmx5Q2xvbmVGaWVsZHM7XG5cbiAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5yZWFkT25seUVkaXRGaWVsZHMsIGZ1bmN0aW9uIHJlYWRPbmx5RWRpdEZpZWxkc0ZvckVhcmNoKGZpZWxkKSB7XG4gICAgICAgIHJlYWRPbmx5RWRpdEZpZWxkc1tmaWVsZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEucmVhZE9ubHlFZGl0RmllbGRzID0gcmVhZE9ubHlFZGl0RmllbGRzO1xuXG4gICAgY2FjaGVkRGF0YSA9IGxvY2FsU3RvcmFnZUhlbHBlci5nZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZEluaXRpYWxEYXRhXycgKyB0aGlzLnVuaXF1ZUlkKTtcbiAgICBjYWNoZWRQcmVmZXJlbmNlcyA9IGxvY2FsU3RvcmFnZUhlbHBlci5nZXRMb2NhbFN0b3JhZ2VJdGVtKCdnY3J1ZFByZWZlcmVuY2VzJyk7XG5cbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgICBjYWNoZWREYXRhID0gSlNPTi5wYXJzZShjYWNoZWREYXRhKTtcbiAgICAgICAgZGF0YVRvU2VuZC5vcmRlcl9ieSA9IGNhY2hlZERhdGEub3JkZXJfYnk7XG4gICAgICAgIGRhdGFUb1NlbmQuc29ydGluZyA9IGNhY2hlZERhdGEuc29ydGluZztcblxuICAgICAgICBpZiAoY2FjaGVkUHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGNhY2hlZFByZWZlcmVuY2VzID0gSlNPTi5wYXJzZShjYWNoZWRQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBkYXRhVG9TZW5kLnBlcl9wYWdlID0gY2FjaGVkUHJlZmVyZW5jZXMucGVyX3BhZ2U7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGVyX3BhZ2UnKS52YWwoZGF0YVRvU2VuZC5wZXJfcGFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkY29sdW1uVG9PcmRlciA9IHRoaXMuJGdjLmZpbmQoJy5jb2x1bW4td2l0aC1vcmRlcmluZ1tkYXRhLW9yZGVyLWJ5PVwiJyArIGRhdGFUb1NlbmQub3JkZXJfYnkgKyAnXCJdJyk7XG4gICAgICAgIGNvbHVtbl90aXRsZSA9ICRjb2x1bW5Ub09yZGVyLmFkZENsYXNzKCdhY3RpdmUgdGFibGUtYWN0aXZlIG9yZGVyaW5nLScgKyBkYXRhVG9TZW5kLnNvcnRpbmcpLnRleHQoKTtcblxuICAgICAgICBpZiAoZGF0YVRvU2VuZC5vcmRlcl9ieSAmJiBkYXRhVG9TZW5kLnNvcnRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1vcmRlci1ieS1oaWRkZW4nKS52YWwoZGF0YVRvU2VuZC5vcmRlcl9ieSk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc29ydGluZy1oaWRkZW4nKS52YWwoZGF0YVRvU2VuZC5zb3J0aW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHVtbl90aXRsZSA9ICQudHJpbShjb2x1bW5fdGl0bGUpO1xuXG4gICAgICAgICRjb2x1bW5Ub09yZGVyLmh0bWwoJzxkaXY+JyArIGNvbHVtbl90aXRsZSArICc8L2Rpdj4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbmRQb3N0UmVxdWVzdCh7XG4gICAgICAgIHVybDogdGhpcy4kZ2MuZGF0YSgndXJsJyksXG4gICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgIHBhZ2luZ0VuZHM7XG5cbiAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKCcuY3VycmVudC10b3RhbC1yZXN1bHRzJylcbiAgICAgICAgICAgICAgICAuaHRtbChqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWwpO1xuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZCgnLmZ1bGwtdG90YWwnKVxuICAgICAgICAgICAgICAgIC5odG1sKGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFncmlkKGpzb25SZXNwb25zZSk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhVG9TZW5kLnNvcnRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gJGNvbHVtblRvT3JkZXIuaW5kZXgoKSArIDE7XG4gICAgICAgICAgICAgICAgJGNvbHVtblRvT3JkZXIuY2xvc2VzdCgnLmdyb2NlcnktY3J1ZC10YWJsZScpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCd0aGVhZCB0ciB0ZDpudGgtY2hpbGQoJyArIGNvbHVtbkluZGV4ICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhZ2luZ0VuZHMgPSBkYXRhVG9TZW5kLnBlcl9wYWdlID4ganNvblJlc3BvbnNlLmZpbHRlcmVkX3RvdGFsXG4gICAgICAgICAgICAgICAgPyBqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWxcbiAgICAgICAgICAgICAgICA6IGRhdGFUb1NlbmQucGVyX3BhZ2U7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctZW5kcycpLmh0bWwocGFnaW5nRW5kcyk7XG4gICAgICAgICAgICBEYXRhZ3JpZFBhZ2luZy5wYWdpbmdDYWxjdWxhdGlvbnMuYXBwbHkodGhpcyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZXJyb3JDYWxsYmFjazogZnVuY3Rpb24gZGF0YWdyaWRFcnJvckNhbGxiYWNrKCkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICB9LmJpbmQodGhpcylcbiAgICB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS50cmFuc2Zvcm1Sb3dzRGF0YSA9IGZ1bmN0aW9uIHRyYW5zZm9ybVJvd3NEYXRhKHJlc3VsdCkge1xuICAgIGxldCByb3dzID0gW107XG5cbiAgICBfLmVhY2gocmVzdWx0LmRhdGEsIGZ1bmN0aW9uIGVhY2hEYXRhKGRhdGFPYmplY3QpIHtcbiAgICAgICAgcm93cy5wdXNoKENvbHVtbi5nZXRSb3dzRGF0YS5hcHBseSh0aGlzLCBbZGF0YU9iamVjdF0pKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHJvd3M7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGJvZHkgZnJvbSB0aGUgcmVzcG9uc2Ugd2l0aCBIYW5kbGVCYXJzIHRlbXBsYXRlXG4gKiAqL1xuR3JvY2VyeUNydWQucHJvdG90eXBlLmdldFRhYmxlQm9keUZyb21SZXNwb25zZSA9IGZ1bmN0aW9uIGdldFRhYmxlQm9keUZyb21SZXNwb25zZShyZXN1bHQpIHtcbiAgICBjb25zdFxuICAgICAgICByb3dfaHRtbCA9IHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLkhBTkRMRUJBUlNfVEVNUExBVEVfUk9XKS5odG1sKCksXG4gICAgICAgIHJvd190ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShyb3dfaHRtbCksXG4gICAgICAgIHJvd3MgPSB0aGlzLnRyYW5zZm9ybVJvd3NEYXRhKHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcm93X3RlbXBsYXRlKHsgcm93cyB9KTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5vbkVkaXRDbGljayA9IGZ1bmN0aW9uIG9uRWRpdENsaWNrKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgIE9wZXJhdGlvbkVkaXQub25FZGl0Q2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLm9uQ2xvbmVDbGljayA9IGZ1bmN0aW9uIG9uQ2xvbmVDbGljayhwcmltYXJ5S2V5VmFsdWUpIHtcbiAgICBPcGVyYXRpb25DbG9uZS5vbkNsb25lQ2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLm9uUmVhZENsaWNrID0gZnVuY3Rpb24gb25SZWFkQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgT3BlcmF0aW9uUmVhZC5vblJlYWRDbGljay5hcHBseSh0aGlzLCBbcHJpbWFyeUtleVZhbHVlXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUub25EZWxldGVDbGljayA9IGZ1bmN0aW9uIG9uRGVsZXRlQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgT3BlcmF0aW9uRGVsZXRlLm9uRGVsZXRlQ2xpY2suYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmNyZWF0ZURhdGFncmlkID0gZnVuY3Rpb24gY3JlYXRlRGF0YWdyaWQoZGF0YSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5qc29uRGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgdGhpcy5yb3dzRGF0YSA9IHRoaXMudHJhbnNmb3JtUm93c0RhdGEodGhpcy5qc29uRGF0YSk7XG5cbiAgICB0aGlzLnJlbmRlckRhdGFncmlkQm9keS5hcHBseSh0aGlzLCBbdGhpcy5yb3dzRGF0YV0pO1xuXG4gICAgLyp0aGlzLmxpc3RlbmVyQWN0aW9uS2V5cygpO1xuICAgIE9wZXJhdGlvbkRlbGV0ZS5saXN0ZW5lclNlbGVjdFJvdy5hcHBseSh0aGlzKTtcbiAgICBHcmlkLmFjdGl2YXRlT3JkZXJpbmdSb3dzLmFwcGx5KHRoaXMpOyovXG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuZ2V0U2NyZWVuV2lkdGggPSBmdW5jdGlvbiBnZXRTY3JlZW5XaWR0aCgpIHtcbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKSB7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKCcobWF4LXdpZHRoOiA1NzZweCknKS5tYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3hzJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogNzY4cHgpJykubWF0Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuICdzJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnbCc7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUucmVuZGVyRGF0YWdyaWRCb2R5ID0gZnVuY3Rpb24gcmVuZGVyRGF0YWdyaWRCb2R5KHJvd3MpIHtcbiAgICBjb25zdCB7IG9wZXJhdGlvbnM6IHsgZWRpdCwgcmVhZCwgZGVsZXRlU2luZ2xlLCBkZWxldGVNdWx0aXBsZSwgY2xvbmUgfSB9ID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YSxcbiAgICAgICAgeyBHcm91cFByaW1hcnlCdXR0b24sIEdyb3VwQnV0dG9uc0xpc3QsIExpbmtCdXR0b25XcmFwcGVyIH0gPSB0aGlzLmNvbXBvbmVudHM7XG5cbiAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgIDxEYXRhZ3JpZFRib2R5XG4gICAgICAgICAgICByb3dzPXtyb3dzfVxuICAgICAgICAgICAgb3B0aW9ucz17e1xuICAgICAgICAgICAgICAgIGRlbGV0ZU11bHRpcGxlOiBkZWxldGVNdWx0aXBsZSxcbiAgICAgICAgICAgICAgICBoYXNFZGl0OiBlZGl0LFxuICAgICAgICAgICAgICAgIGhhc0Nsb25lOiBjbG9uZSxcbiAgICAgICAgICAgICAgICBoYXNEZWxldGU6IGRlbGV0ZVNpbmdsZSxcbiAgICAgICAgICAgICAgICBoYXNSZWFkOiByZWFkLFxuICAgICAgICAgICAgICAgIGhhc0FjdGlvbkJ1dHRvbnM6IHRoaXMuaGFzQWN0aW9uc1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHVybFVuaXF1ZUhhc2g9e3RoaXMuaGFzaEV2ZW50LnVybFVuaXF1ZUhhc2h9XG4gICAgICAgICAgICBvcmRlckJ5PXtHcmlkLmdldE9yZGVyQnkuYXBwbHkodGhpcyl9XG4gICAgICAgICAgICBjb2x1bW5zPXt0aGlzLmNvbHVtbnN9XG4gICAgICAgICAgICBvbkVkaXRDbGljaz17dGhpcy5vbkVkaXRDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25DbG9uZUNsaWNrPXt0aGlzLm9uQ2xvbmVDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25Sb3dDaGVja2JveENsaWNrPXt0aGlzLmhpZGVTaG93RGVsZXRlQnV0dG9uLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBvblJlYWRDbGljaz17dGhpcy5vblJlYWRDbGljay5iaW5kKHRoaXMpfVxuICAgICAgICAgICAgb25EZWxldGVDbGljaz17dGhpcy5vbkRlbGV0ZUNsaWNrLmJpbmQodGhpcyl9XG4gICAgICAgICAgICBhY3Rpb25CdXR0b25zPXt0aGlzLnNldHRpbmdzLmFjdGlvbkJ1dHRvbnN9XG4gICAgICAgICAgICBzY3JlZW5TaXplPXt0aGlzLmdldFNjcmVlbldpZHRoKCl9XG4gICAgICAgICAgICBpMThuPXt0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmkxOG59XG4gICAgICAgICAgICBMaW5rQnV0dG9uV3JhcHBlcj17TGlua0J1dHRvbldyYXBwZXJ9XG4gICAgICAgICAgICBHcm91cFByaW1hcnlCdXR0b249e0dyb3VwUHJpbWFyeUJ1dHRvbn1cbiAgICAgICAgICAgIEdyb3VwQnV0dG9uc0xpc3Q9e0dyb3VwQnV0dG9uc0xpc3R9XG4gICAgICAgIC8+LCB0aGlzLiRnYy5maW5kKCcuZ2MtdGJvZHknKVswXSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubGlzdGVuZXJBY3Rpb25LZXlzID0gZnVuY3Rpb24gbGlzdGVuZXJBY3Rpb25LZXlzKCkge1xuICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1hY3Rpb24nKS5jbGljayhmdW5jdGlvbiBjbGlja0FjdGlvbkJ1dHRvbihldmVudCkge1xuICAgICAgICB2YXIgJGN1cnJlbnRCdXR0b24gPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxuICAgICAgICAgICAgcHJpbWFyeUtleVZhbHVlID0gJGN1cnJlbnRCdXR0b24uZGF0YSgncHJpbWFyeS1rZXktdmFsdWUnKSxcbiAgICAgICAgICAgIGFjdGlvbkJ1dHRvbktleSA9ICRjdXJyZW50QnV0dG9uLmRhdGEoJ2FjdGlvbi1rZXknKTtcblxuICAgICAgICAvKiBhY3Rpb25CdXR0b25zIERhdGEgaXMgbG9va2luZyBsaWtlIHRoaXNcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgaWNvbkNzc0NsYXNzOiAnZmEgZmEtc21pbGUtbycsXG4gICAgICAgICAgICAgbGFiZWw6ICdTbWlsZXknLFxuICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIHNtaWxleUNhbGxiYWNrKCkge31cbiAgICAgICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNldHRpbmdzLmFjdGlvbkJ1dHRvbnNbYWN0aW9uQnV0dG9uS2V5XVxuICAgICAgICAgIC5hY3Rpb25DYWxsYmFjay5hcHBseSh0aGlzLCBbJGN1cnJlbnRCdXR0b24sIHByaW1hcnlLZXlWYWx1ZSwgdGhpc10pO1xuXG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbkdyb2NlcnlDcnVkLnByb3RvdHlwZS5jbGVhckZpbHRlcmluZ0NhY2hlID0gZnVuY3Rpb24gY2xlYXJGaWx0ZXJpbmdDYWNoZSgpIHtcbiAgICB2YXIgJHNlYXJjaEFsbElucHV0ID0gdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24gPiBpbnB1dC5nYy1zZWFyY2gtaW5wdXQnKTtcblxuICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0hJRERFTl9QQUdFX05VTUJFUikudmFsKCcxJyk7XG4gICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfUEFHRV9OVU1CRVJfSU5QVVQpLnZhbCgnMScpO1xuICAgIHRoaXMuJGdjLmZpbmQoJy5ncm9jZXJ5LWNydWQtdGFibGUgdHI6Zmlyc3QnKS5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9BQ1RJVkUpXG4gICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlIHRhYmxlLWFjdGl2ZSBvcmRlcmluZy1kZXNjIG9yZGVyaW5nLWFzYycpO1xuICAgIHRoaXMuJGdjLmZpbmQoJ3RoZWFkJykuZmluZCgndGQuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICB0aGlzLiRnYy5maW5kKCd0aGVhZCAudmFsdWUtbm90LWVtcHR5JykucmVtb3ZlQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpLnZhbCgnJyk7XG5cbiAgICBpZiAoJHNlYXJjaEFsbElucHV0LnZhbCgpICE9PSAnJykge1xuICAgICAgICAkc2VhcmNoQWxsSW5wdXQudmFsKCcnKS50cmlnZ2VyKCdibHVyJyk7XG4gICAgfVxuXG4gICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuYXBwZW5kU2VhcmNoQ2xlYXJCdXR0b25zID0gZnVuY3Rpb24gYXBwZW5kU2VhcmNoQ2xlYXJCdXR0b25zKCkge1xuICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgdGhpcy4kZ2MuZmluZCgnLmNsZWFyLXNlYXJjaCcpLnJlbW92ZSgpO1xuXG4gICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfU0VBUkNIX0ZJRUxEX0lOUFVUKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWFyY2hhYmxlSW5wdXQoKSB7XG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpO1xuICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ3ZhbHVlLW5vdC1lbXB0eScpO1xuICAgICAgICAkKHRoaXMpLmFmdGVyKCc8aSBjbGFzcz1cImZhIGZhLXRpbWVzIGNsZWFyLXNlYXJjaFwiPjwvaT4nKTtcblxuICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5jbGVhci1zZWFyY2gnKS5jbGljayhmdW5jdGlvbiBjbGVhclNlYXJjaCgpIHtcbiAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgndGQnKS5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1pbnB1dCcpLnZhbCgnJykudHJpZ2dlcigna2V5dXAnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUubGlzdGVuZXJQZXJQYWdlID0gZnVuY3Rpb24gbGlzdGVuZXJQZXJQYWdlKCkge1xuICAgIHRoaXMuJGdjLmZpbmQoJy4nICsgQ29uc3RhbnRzLkNMQVNTX1BFUl9QQUdFKS5jaGFuZ2UoZnVuY3Rpb24gcGVyUGFnZU9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG4gICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Hcm9jZXJ5Q3J1ZC5wcm90b3R5cGUuY2xlYXJGaWx0ZXJpbmdMaXN0ZW5lciA9IGZ1bmN0aW9uIGNsZWFyRmlsdGVyaW5nTGlzdGVuZXIoJHNldHRpbmdzQ29udGFpbmVyKSB7XG4gICAgJHNldHRpbmdzQ29udGFpbmVyLmZpbmQoJy5jbGVhci1maWx0ZXJpbmcnKS5jbGljayhmdW5jdGlvbiBjbGVhckZpbHRlcmluZ0NsaWNrQnV0dG9uKCkge1xuICAgICAgICB0aGlzLmNsZWFyRmlsdGVyaW5nQ2FjaGUoKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuR3JvY2VyeUNydWQucHJvdG90eXBlLmhpZGVTaG93RGVsZXRlQnV0dG9uID0gZnVuY3Rpb24gaGlkZVNob3dEZWxldGVCdXR0b24oKSB7XG5cbiAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3c6Y2hlY2tlZCcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmRlbGV0ZS1zZWxlY3RlZC1idXR0b24nKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmRlbGV0ZS1zZWxlY3RlZC1idXR0b24nKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5Hcm9jZXJ5Q3J1ZCA9IEdyb2NlcnlDcnVkO1xuIiwidmFyIEdyb2NlcnlDcnVkID0gcmVxdWlyZSgnLi9ncm9jZXJ5LWNydWQnKS5Hcm9jZXJ5Q3J1ZCxcbiAgICAkID0galF1ZXJ5O1xuXG4kLmZuLmdyb2NlcnlDcnVkID0gZnVuY3Rpb24galF1ZXJ5Rm5EYXRhZ3JpZChvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe1xuICAgICAgICBhY3Rpb25CdXR0b25zOiBbXSxcbiAgICAgICAgaGFzaEV2ZW50czogdHJ1ZSxcbiAgICAgICAgZGF0YWdyaWRTZWFyY2hBbGxJbnB1dDogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiBmb3JFYWNoRGF0YWdyaWQoKSB7XG4gICAgICAgIChuZXcgR3JvY2VyeUNydWQoJCh0aGlzKSwgc2V0dGluZ3MpKS5pbml0KCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJjb25zdCAkID0galF1ZXJ5LFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vc2VjdGlvbnMvY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIGFqYXhIZWxwZXIgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgc2V0TG9hZGluZzogZnVuY3Rpb24gc2V0TG9hZGluZygpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5sb2FkaW5nLW9wYWNpdHknKVxuICAgICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgKHRoaXMuJGdjLndpZHRoKCkgKyAxNSkgKyAncHgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsIHRoaXMuJGdjLmhlaWdodCgpICsgJ3B4JylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICB9LFxuICAgICAgICB1bnNldExvYWRpbmc6IGZ1bmN0aW9uIHVuc2V0TG9hZGluZygpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5sb2FkaW5nLW9wYWNpdHknKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaGlkZGVuJylcbiAgICAgICAgICAgICAgICAuY3NzKCd3aWR0aCcsICcwcHgnKVxuICAgICAgICAgICAgICAgIC5jc3MoJ2hlaWdodCcsICcwcHgnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZEdldFJlcXVlc3Q6IGZ1bmN0aW9uIHNlbmRHZXRSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBhamF4SGVscGVyLnNlbmRBamF4UmVxdWVzdC5hcHBseSh0aGlzLCBbb3B0aW9ucywgJ2dldCddKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFBvc3RSZXF1ZXN0OiBmdW5jdGlvbiBzZW5kUG9zdFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGFqYXhIZWxwZXIuc2VuZEFqYXhSZXF1ZXN0LmFwcGx5KHRoaXMsIFtvcHRpb25zLCAncG9zdCddKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWpheE9uRmFpbDogZnVuY3Rpb24gYWpheE9uRmFpbChlcnJvckFzU3RyaW5nLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICAgICAgYWpheEhlbHBlci51bnNldExvYWRpbmcuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgICAgIC5maW5kKCcuZ2MtZXJyb3ItYm9keScpXG4gICAgICAgICAgICAgICAgLmh0bWwoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlYmFyc1RlbXBsYXRlKCcuZ2MtbW9kYWwtZXJyb3ItdGV4dC10ZW1wbGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTdGF0dXM6IHRleHRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclRocm93bjogZXJyb3JUaHJvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckFzU3RyaW5nOiBlcnJvckFzU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKC9cXDwoaHRtbHxzY3JpcHR8Ym9keXxzdHlsZXxsaW5rKVxcPi9pLnRlc3QoZXJyb3JBc1N0cmluZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItaHRtbC1wcmV2aWV3LWJ1dHRvbicpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWVycm9yLWh0bWwtcHJldmlldy1idXR0b24nKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItaHRtbC1wcmV2aWV3LWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBlcnJvckhUTUxQcmV2aWV3Q2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtY29kZS1lcnJvci1yZXNwb25zZScpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1tZXNzYWdlLWh0bWwnKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbWVzc2FnZS1odG1sJykuaHRtbChlcnJvckFzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1odG1sLXByZXZpZXctYnV0dG9uJykuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZEFqYXhSZXF1ZXN0OiBmdW5jdGlvbiBzZW5kQWpheFJlcXVlc3Qob3B0aW9ucywgcmVxdWVzdE1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogYWpheEhlbHBlci5zZXRMb2FkaW5nLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhVG9TZW5kLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmxcbiAgICAgICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gYWpheENhbGxEb25lKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBhamF4SGVscGVyLnVuc2V0TG9hZGluZy5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gQ29uc3RhbnRzLlJFU1BPTlNFLkZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheEhlbHBlci5zaG93RXJyb3JNb2RhbC5hcHBseSh0aGlzLCBbZGF0YS5tZXNzYWdlXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzQ2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIC5mYWlsKGZ1bmN0aW9uIGFqYXhPbkZhaWwoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvckFzU3RyaW5nID0ganFYSFIucmVzcG9uc2VUZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuYWpheE9uRmFpbC5hcHBseSh0aGlzLCBbZXJyb3JBc1N0cmluZywgdGV4dFN0YXR1cywgZXJyb3JUaHJvd25dKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvckNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JDYWxsYmFjayhlcnJvckFzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dFcnJvck1vZGFsOiBmdW5jdGlvbiBzaG93RXJyb3JNb2RhbChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1lcnJvci1tb2RhbCcpXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5nYy1lcnJvci1ib2R5JylcbiAgICAgICAgICAgICAgICAuaHRtbChlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VXJsOiBmdW5jdGlvbiBnZXRVcmwoYWN0aW9uLCBkYXRhX3RvX3NlbmQpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnVybDtcblxuICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHVybCArPSAvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPyc7XG4gICAgICAgICAgICAgICAgdXJsICs9ICdhY3Rpb249JyArIGFjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGFfdG9fc2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5lYWNoKGRhdGFfdG9fc2VuZCwgZnVuY3Rpb24gZm9yRWFjaERhdGFUb1NlbmQoX2ZpZWxkX3ZhbHVlLCBfZmllbGRfbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChfZmllbGRfdmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2goX2ZpZWxkX3ZhbHVlLCBmdW5jdGlvbiBmb3JFYWNoRmllbGRzKF9hcnJheV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJyArIF9maWVsZF9uYW1lICsgJ1tdPScgKyBfYXJyYXlfdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2ZpZWxkX3ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChfZmllbGRfdmFsdWUsIGZ1bmN0aW9uIGZvckVhY2hGaWVsZHMob2JqZWN0RmllbGRWYWx1ZSwgb2JqZWN0RmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gJyYnICsgX2ZpZWxkX25hbWUgKyAnWycgKyBvYmplY3RGaWVsZE5hbWUgKyAnXT0nICsgb2JqZWN0RmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcmJyArIF9maWVsZF9uYW1lICsgJz0nICsgKF8uaXNVbmRlZmluZWQoX2ZpZWxkX3ZhbHVlKSA/ICcnIDogX2ZpZWxkX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zdERhdGFGcm9tRm9ybTogZnVuY3Rpb24gZ2V0UG9zdERhdGFGcm9tRm9ybSgkanF1ZXJ5Rm9ybSkge1xuICAgICAgICAgICAgdmFyIHBvc3REYXRhID0ge307XG4gICAgICAgICAgICBfLmVhY2goJGpxdWVyeUZvcm0uc2VyaWFsaXplQXJyYXkoKSwgZnVuY3Rpb24gZWFjaEZvcm1GaWVsZHMoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVR5cGUgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNbZmllbGQubmFtZV0uZGF0YVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAncmVsYXRpb25hbF9uX24nIHx8IGRhdGFUeXBlID09PSAnbmF0aXZlX3JlbGF0aW9uYWxfbl9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zdERhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGFbZmllbGQubmFtZV0gPSBbZmllbGQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdERhdGFbZmllbGQubmFtZV0ucHVzaChmaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YVtmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwb3N0RGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TXVsdGlsYXllclBvc3REYXRhRnJvbUZvcm06IGZ1bmN0aW9uIGdldE11bHRpbGF5ZXJQb3N0RGF0YUZyb21Gb3JtKCRqcXVlcnlGb3JtKSB7XG4gICAgICAgICAgICBsZXQgcG9zdERhdGEgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gJGpxdWVyeUZvcm0uc2VyaWFsaXplQXJyYXkoKTtcblxuICAgICAgICAgICAgZm9ybURhdGEuZm9yRWFjaChmdW5jdGlvbiBmb3JlYWNoRm9ybURhdGEoaXRlbSkge1xuICAgICAgICAgICAgICAgIHBvc3REYXRhW2l0ZW0ubmFtZV0gPSBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwb3N0RGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLmFqYXhIZWxwZXIgPSBhamF4SGVscGVyO1xuIiwidmFyIGxvY2FsU3RvcmFnZUhlbHBlciA9IE9iamVjdC5jcmVhdGUoe1xuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIHNldExvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIHNldExvY2FsU3RvcmFnZUl0ZW0oX19pdGVtLCBfX3ZhbHVlKSB7XG5cbiAgICB9LFxuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oX19pdGVtKSB7XG5cbiAgICB9LFxuXG4gICAgLy8gQnkgZGVmYXVsdCB0aGlzIGlzIGVtcHR5IGFzIHNvbWUgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGxvY2FsU3RvcmFnZSBjYWNoZVxuICAgIGdldExvY2FsU3RvcmFnZUl0ZW06IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUl0ZW0oX19pdGVtKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgYmVsb3cgZnVuY3Rpb24gaXMgY29waWVkIGZyb20gdGhlIG1vZGVybml6ciBsb2NhbCBzdG9yYWdlIHN1cHBvcnRcbiAgICBicm93c2VyU3VwcG9ydHNMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c0xvY2FsU3RvcmFnZSgpIHtcbiAgICAgICAgdmFyIG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdpbmcgdGhlIGRlZmF1bHQgZW1wdHkgdmFsdWVzIG9mIHRoZSBmdW5jdGlvbnMgdG8gc3VwcG9ydCBsb2NhbCBzdG9yYWdlLiBUaGUgYmVsb3cgZnVuY3Rpb25cbiAgICAvLyBpcyBjYWxsZWQgb25seSBvbmNlIGZvciBvcHRpbWl6aW5nIHJlYXNvbnNcbiAgICBzZXRMb2NhbFN0b3JhZ2VDYWNoZTogZnVuY3Rpb24gc2V0TG9jYWxTdG9yYWdlQ2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb3dzZXJTdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAvL2lmIGJyb3dzZXIgaXMgc3VwcG9ydGluZyBsb2NhbCBzdG9yYWdlIG92ZXJyaWRlcyB0aGUgZW1wdHkgZnVuY3Rpb25zXG4gICAgICAgICAgICB0aGlzLnNldExvY2FsU3RvcmFnZUl0ZW0gPSBmdW5jdGlvbiBzZXRMb2NhbFN0b3JhZ2VJdGVtKGl0ZW0sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTG9jYWxTdG9yYWdlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TG9jYWxTdG9yYWdlSXRlbSA9IGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZUl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubG9jYWxTdG9yYWdlSGVscGVyLnNldExvY2FsU3RvcmFnZUNhY2hlKCk7XG5cbmV4cG9ydHMubG9jYWxTdG9yYWdlSGVscGVyID0gbG9jYWxTdG9yYWdlSGVscGVyOyIsIi8qIVxuQ2hvc2VuLCBhIFNlbGVjdCBCb3ggRW5oYW5jZXIgZm9yIGpRdWVyeSBhbmQgUHJvdG90eXBlXG5ieSBQYXRyaWNrIEZpbGxlciBmb3IgSGFydmVzdCwgaHR0cDovL2dldGhhcnZlc3QuY29tXG5cblZlcnNpb24gMS42LjJcbkZ1bGwgc291cmNlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9oYXJ2ZXN0aHEvY2hvc2VuXG5Db3B5cmlnaHQgKGMpIDIwMTEtMjAxNiBIYXJ2ZXN0IGh0dHA6Ly9nZXRoYXJ2ZXN0LmNvbVxuXG5NSVQgTGljZW5zZSwgaHR0cHM6Ly9naXRodWIuY29tL2hhcnZlc3RocS9jaG9zZW4vYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBgZ3J1bnQgYnVpbGRgLCBkbyBub3QgZWRpdCBpdCBieSBoYW5kLlxuKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgJCwgQWJzdHJhY3RDaG9zZW4sIENob3NlbiwgU2VsZWN0UGFyc2VyLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIFNlbGVjdFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTZWxlY3RQYXJzZXIoKSB7XG4gICAgICB0aGlzLm9wdGlvbnNfaW5kZXggPSAwO1xuICAgICAgdGhpcy5wYXJzZWQgPSBbXTtcbiAgICB9XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ub2RlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2dyb3VwKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZF9vcHRpb24oY2hpbGQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9ncm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICB2YXIgZ3JvdXBfcG9zaXRpb24sIG9wdGlvbiwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgZ3JvdXBfcG9zaXRpb24gPSB0aGlzLnBhcnNlZC5sZW5ndGg7XG4gICAgICB0aGlzLnBhcnNlZC5wdXNoKHtcbiAgICAgICAgYXJyYXlfaW5kZXg6IGdyb3VwX3Bvc2l0aW9uLFxuICAgICAgICBncm91cDogdHJ1ZSxcbiAgICAgICAgbGFiZWw6IHRoaXMuZXNjYXBlRXhwcmVzc2lvbihncm91cC5sYWJlbCksXG4gICAgICAgIHRpdGxlOiBncm91cC50aXRsZSA/IGdyb3VwLnRpdGxlIDogdm9pZCAwLFxuICAgICAgICBjaGlsZHJlbjogMCxcbiAgICAgICAgZGlzYWJsZWQ6IGdyb3VwLmRpc2FibGVkLFxuICAgICAgICBjbGFzc2VzOiBncm91cC5jbGFzc05hbWVcbiAgICAgIH0pO1xuICAgICAgX3JlZiA9IGdyb3VwLmNoaWxkTm9kZXM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9wdGlvbiA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWRkX29wdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cC5kaXNhYmxlZCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZWxlY3RQYXJzZXIucHJvdG90eXBlLmFkZF9vcHRpb24gPSBmdW5jdGlvbihvcHRpb24sIGdyb3VwX3Bvc2l0aW9uLCBncm91cF9kaXNhYmxlZCkge1xuICAgICAgaWYgKG9wdGlvbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgIGlmIChvcHRpb24udGV4dCAhPT0gXCJcIikge1xuICAgICAgICAgIGlmIChncm91cF9wb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFtncm91cF9wb3NpdGlvbl0uY2hpbGRyZW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbi52YWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbi50ZXh0LFxuICAgICAgICAgICAgaHRtbDogb3B0aW9uLmlubmVySFRNTCxcbiAgICAgICAgICAgIHRpdGxlOiBvcHRpb24udGl0bGUgPyBvcHRpb24udGl0bGUgOiB2b2lkIDAsXG4gICAgICAgICAgICBzZWxlY3RlZDogb3B0aW9uLnNlbGVjdGVkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGdyb3VwX2Rpc2FibGVkID09PSB0cnVlID8gZ3JvdXBfZGlzYWJsZWQgOiBvcHRpb24uZGlzYWJsZWQsXG4gICAgICAgICAgICBncm91cF9hcnJheV9pbmRleDogZ3JvdXBfcG9zaXRpb24sXG4gICAgICAgICAgICBncm91cF9sYWJlbDogZ3JvdXBfcG9zaXRpb24gIT0gbnVsbCA/IHRoaXMucGFyc2VkW2dyb3VwX3Bvc2l0aW9uXS5sYWJlbCA6IG51bGwsXG4gICAgICAgICAgICBjbGFzc2VzOiBvcHRpb24uY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU6IG9wdGlvbi5zdHlsZS5jc3NUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJzZWQucHVzaCh7XG4gICAgICAgICAgICBhcnJheV9pbmRleDogdGhpcy5wYXJzZWQubGVuZ3RoLFxuICAgICAgICAgICAgb3B0aW9uc19pbmRleDogdGhpcy5vcHRpb25zX2luZGV4LFxuICAgICAgICAgICAgZW1wdHk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zX2luZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdFBhcnNlci5wcm90b3R5cGUuZXNjYXBlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBtYXAsIHVuc2FmZV9jaGFycztcbiAgICAgIGlmICgodGV4dCA9PSBudWxsKSB8fCB0ZXh0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICghL1tcXCZcXDxcXD5cXFwiXFwnXFxgXS8udGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICAgIG1hcCA9IHtcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgICAgIFwiJ1wiOiBcIiYjeDI3O1wiLFxuICAgICAgICBcImBcIjogXCImI3g2MDtcIlxuICAgICAgfTtcbiAgICAgIHVuc2FmZV9jaGFycyA9IC8mKD8hXFx3KzspfFtcXDxcXD5cXFwiXFwnXFxgXS9nO1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSh1bnNhZmVfY2hhcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAgICByZXR1cm4gbWFwW2Nocl0gfHwgXCImYW1wO1wiO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3RQYXJzZXI7XG5cbiAgfSkoKTtcblxuICBTZWxlY3RQYXJzZXIuc2VsZWN0X3RvX2FycmF5ID0gZnVuY3Rpb24oc2VsZWN0KSB7XG4gICAgdmFyIGNoaWxkLCBwYXJzZXIsIF9pLCBfbGVuLCBfcmVmO1xuICAgIHBhcnNlciA9IG5ldyBTZWxlY3RQYXJzZXIoKTtcbiAgICBfcmVmID0gc2VsZWN0LmNoaWxkTm9kZXM7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBjaGlsZCA9IF9yZWZbX2ldO1xuICAgICAgcGFyc2VyLmFkZF9ub2RlKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZWQ7XG4gIH07XG5cbiAgQWJzdHJhY3RDaG9zZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDaG9zZW4oZm9ybV9maWVsZCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkID0gZm9ybV9maWVsZDtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzX211bHRpcGxlID0gdGhpcy5mb3JtX2ZpZWxkLm11bHRpcGxlO1xuICAgICAgdGhpcy5zZXRfZGVmYXVsdF90ZXh0KCk7XG4gICAgICB0aGlzLnNldF9kZWZhdWx0X3ZhbHVlcygpO1xuICAgICAgdGhpcy5zZXR1cCgpO1xuICAgICAgdGhpcy5zZXRfdXBfaHRtbCgpO1xuICAgICAgdGhpcy5yZWdpc3Rlcl9vYnNlcnZlcnMoKTtcbiAgICAgIHRoaXMub25fcmVhZHkoKTtcbiAgICB9XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2V0X2RlZmF1bHRfdmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5jbGlja190ZXN0X2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMudGVzdF9hY3RpdmVfY2xpY2soZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2YXRlX2FjdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZV9maWVsZCA9IGZhbHNlO1xuICAgICAgdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHRlZCA9IG51bGw7XG4gICAgICB0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA9ICh0aGlzLm9wdGlvbnMuYWxsb3dfc2luZ2xlX2Rlc2VsZWN0ICE9IG51bGwpICYmICh0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXSAhPSBudWxsKSAmJiB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1swXS50ZXh0ID09PSBcIlwiID8gdGhpcy5vcHRpb25zLmFsbG93X3NpbmdsZV9kZXNlbGVjdCA6IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlX3NlYXJjaF90aHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkIHx8IDA7XG4gICAgICB0aGlzLmRpc2FibGVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmRpc2FibGVfc2VhcmNoIHx8IGZhbHNlO1xuICAgICAgdGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggPSB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZW5hYmxlX3NwbGl0X3dvcmRfc2VhcmNoIDogdHJ1ZTtcbiAgICAgIHRoaXMuZ3JvdXBfc2VhcmNoID0gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCAhPSBudWxsID8gdGhpcy5vcHRpb25zLmdyb3VwX3NlYXJjaCA6IHRydWU7XG4gICAgICB0aGlzLnNlYXJjaF9jb250YWlucyA9IHRoaXMub3B0aW9ucy5zZWFyY2hfY29udGFpbnMgfHwgZmFsc2U7XG4gICAgICB0aGlzLnNpbmdsZV9iYWNrc3Ryb2tlX2RlbGV0ZSA9IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5zaW5nbGVfYmFja3N0cm9rZV9kZWxldGUgOiB0cnVlO1xuICAgICAgdGhpcy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuaW5oZXJpdF9zZWxlY3RfY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzIHx8IGZhbHNlO1xuICAgICAgdGhpcy5kaXNwbGF5X3NlbGVjdGVkX29wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuZGlzcGxheV9zZWxlY3RlZF9vcHRpb25zIDogdHJ1ZTtcbiAgICAgIHRoaXMuZGlzcGxheV9kaXNhYmxlZF9vcHRpb25zID0gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyAhPSBudWxsID8gdGhpcy5vcHRpb25zLmRpc3BsYXlfZGlzYWJsZWRfb3B0aW9ucyA6IHRydWU7XG4gICAgICB0aGlzLmluY2x1ZGVfZ3JvdXBfbGFiZWxfaW5fc2VsZWN0ZWQgPSB0aGlzLm9wdGlvbnMuaW5jbHVkZV9ncm91cF9sYWJlbF9pbl9zZWxlY3RlZCB8fCBmYWxzZTtcbiAgICAgIHRoaXMubWF4X3Nob3duX3Jlc3VsdHMgPSB0aGlzLm9wdGlvbnMubWF4X3Nob3duX3Jlc3VsdHMgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgcmV0dXJuIHRoaXMuY2FzZV9zZW5zaXRpdmVfc2VhcmNoID0gdGhpcy5vcHRpb25zLmNhc2Vfc2Vuc2l0aXZlX3NlYXJjaCB8fCBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnNldF9kZWZhdWx0X3RleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wbGFjZWhvbGRlclwiKSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRfdGV4dCA9IHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdF90ZXh0ID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHRfbXVsdGlwbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHQgfHwgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9tdWx0aXBsZV90ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0X3RleHQgPSB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXJfdGV4dF9zaW5nbGUgfHwgdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyX3RleHQgfHwgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9zaW5nbGVfdGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfbm9uZV9mb3VuZCA9IHRoaXMuZm9ybV9maWVsZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5vX3Jlc3VsdHNfdGV4dFwiKSB8fCB0aGlzLm9wdGlvbnMubm9fcmVzdWx0c190ZXh0IHx8IEFic3RyYWN0Q2hvc2VuLmRlZmF1bHRfbm9fcmVzdWx0X3RleHQ7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5jaG9pY2VfbGFiZWwgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlX2dyb3VwX2xhYmVsX2luX3NlbGVjdGVkICYmIChpdGVtLmdyb3VwX2xhYmVsICE9IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBcIjxiIGNsYXNzPSdncm91cC1uYW1lJz5cIiArIGl0ZW0uZ3JvdXBfbGFiZWwgKyBcIjwvYj5cIiArIGl0ZW0uaHRtbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpdGVtLmh0bWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5tb3VzZV9lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2Vfb25fY29udGFpbmVyID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLm1vdXNlX2xlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZV9vbl9jb250YWluZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2ZvY3VzID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKCk7XG4gICAgICAgICAgfSksIDUwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmlucHV0X2JsdXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMubW91c2Vfb25fY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlX2ZpZWxkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYmx1cl90ZXN0KCk7XG4gICAgICAgIH0pLCAxMDApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19vcHRpb25fYnVpbGQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29udGVudCwgZGF0YSwgZGF0YV9jb250ZW50LCBzaG93bl9yZXN1bHRzLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGNvbnRlbnQgPSAnJztcbiAgICAgIHNob3duX3Jlc3VsdHMgPSAwO1xuICAgICAgX3JlZiA9IHRoaXMucmVzdWx0c19kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRhdGEgPSBfcmVmW19pXTtcbiAgICAgICAgZGF0YV9jb250ZW50ID0gJyc7XG4gICAgICAgIGlmIChkYXRhLmdyb3VwKSB7XG4gICAgICAgICAgZGF0YV9jb250ZW50ID0gdGhpcy5yZXN1bHRfYWRkX2dyb3VwKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFfY29udGVudCA9IHRoaXMucmVzdWx0X2FkZF9vcHRpb24oZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFfY29udGVudCAhPT0gJycpIHtcbiAgICAgICAgICBzaG93bl9yZXN1bHRzKys7XG4gICAgICAgICAgY29udGVudCArPSBkYXRhX2NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuZmlyc3QgOiB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoZGF0YS5zZWxlY3RlZCAmJiB0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuc2VsZWN0ZWQgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0KHRoaXMuY2hvaWNlX2xhYmVsKGRhdGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3duX3Jlc3VsdHMgPj0gdGhpcy5tYXhfc2hvd25fcmVzdWx0cykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfb3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICB2YXIgY2xhc3Nlcywgb3B0aW9uX2VsO1xuICAgICAgaWYgKCFvcHRpb24uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlX29wdGlvbl9pbl9yZXN1bHRzKG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY2xhc3NlcyA9IFtdO1xuICAgICAgaWYgKCFvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYWN0aXZlLXJlc3VsdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb24uZGlzYWJsZWQgJiYgIShvcHRpb24uc2VsZWN0ZWQgJiYgdGhpcy5pc19tdWx0aXBsZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZGlzYWJsZWQtcmVzdWx0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goXCJyZXN1bHQtc2VsZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKFwiZ3JvdXAtb3B0aW9uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbi5jbGFzc2VzICE9PSBcIlwiKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChvcHRpb24uY2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICBvcHRpb25fZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBvcHRpb25fZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIG9wdGlvbl9lbC5zdHlsZS5jc3NUZXh0ID0gb3B0aW9uLnN0eWxlO1xuICAgICAgb3B0aW9uX2VsLnNldEF0dHJpYnV0ZShcImRhdGEtb3B0aW9uLWFycmF5LWluZGV4XCIsIG9wdGlvbi5hcnJheV9pbmRleCk7XG4gICAgICBvcHRpb25fZWwuaW5uZXJIVE1MID0gb3B0aW9uLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKG9wdGlvbi50aXRsZSkge1xuICAgICAgICBvcHRpb25fZWwudGl0bGUgPSBvcHRpb24udGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwob3B0aW9uX2VsKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9hZGRfZ3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgICAgdmFyIGNsYXNzZXMsIGdyb3VwX2VsO1xuICAgICAgaWYgKCEoZ3JvdXAuc2VhcmNoX21hdGNoIHx8IGdyb3VwLmdyb3VwX21hdGNoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIShncm91cC5hY3RpdmVfb3B0aW9ucyA+IDApKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGNsYXNzZXMgPSBbXTtcbiAgICAgIGNsYXNzZXMucHVzaChcImdyb3VwLXJlc3VsdFwiKTtcbiAgICAgIGlmIChncm91cC5jbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChncm91cC5jbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGdyb3VwX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgZ3JvdXBfZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICAgIGdyb3VwX2VsLmlubmVySFRNTCA9IGdyb3VwLnNlYXJjaF90ZXh0O1xuICAgICAgaWYgKGdyb3VwLnRpdGxlKSB7XG4gICAgICAgIGdyb3VwX2VsLnRpdGxlID0gZ3JvdXAudGl0bGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vdXRlckhUTUwoZ3JvdXBfZWwpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUucmVzdWx0c191cGRhdGVfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0X2RlZmF1bHRfdGV4dCgpO1xuICAgICAgaWYgKCF0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5yZXNldF9zaW5nbGVfc2VsZWN0X29wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzdWx0ID0gX3JlZltfaV07XG4gICAgICAgIGlmIChyZXN1bHQuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHJlc3VsdC5zZWxlY3RlZCA9IGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfdG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfc2VhcmNoID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lubm93X3Jlc3VsdHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdHNfc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlc2NhcGVkU2VhcmNoVGV4dCwgb3B0aW9uLCByZWdleCwgcmVzdWx0cywgcmVzdWx0c19ncm91cCwgc2VhcmNoVGV4dCwgc3RhcnRwb3MsIHRleHQsIHpyZWdleCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICB0aGlzLm5vX3Jlc3VsdHNfY2xlYXIoKTtcbiAgICAgIHJlc3VsdHMgPSAwO1xuICAgICAgc2VhcmNoVGV4dCA9IHRoaXMuZ2V0X3NlYXJjaF90ZXh0KCk7XG4gICAgICBlc2NhcGVkU2VhcmNoVGV4dCA9IHNlYXJjaFRleHQucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpO1xuICAgICAgenJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVkU2VhcmNoVGV4dCwgJ2knKTtcbiAgICAgIHJlZ2V4ID0gdGhpcy5nZXRfc2VhcmNoX3JlZ2V4KGVzY2FwZWRTZWFyY2hUZXh0KTtcbiAgICAgIF9yZWYgPSB0aGlzLnJlc3VsdHNfZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgb3B0aW9uLnNlYXJjaF9tYXRjaCA9IGZhbHNlO1xuICAgICAgICByZXN1bHRzX2dyb3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZV9vcHRpb25faW5fcmVzdWx0cyhvcHRpb24pKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbi5ncm91cCkge1xuICAgICAgICAgICAgb3B0aW9uLmdyb3VwX21hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBvcHRpb24uYWN0aXZlX29wdGlvbnMgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKG9wdGlvbi5ncm91cF9hcnJheV9pbmRleCAhPSBudWxsKSAmJiB0aGlzLnJlc3VsdHNfZGF0YVtvcHRpb24uZ3JvdXBfYXJyYXlfaW5kZXhdKSB7XG4gICAgICAgICAgICByZXN1bHRzX2dyb3VwID0gdGhpcy5yZXN1bHRzX2RhdGFbb3B0aW9uLmdyb3VwX2FycmF5X2luZGV4XTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzX2dyb3VwLmFjdGl2ZV9vcHRpb25zID09PSAwICYmIHJlc3VsdHNfZ3JvdXAuc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHNfZ3JvdXAuYWN0aXZlX29wdGlvbnMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3B0aW9uLnNlYXJjaF90ZXh0ID0gb3B0aW9uLmdyb3VwID8gb3B0aW9uLmxhYmVsIDogb3B0aW9uLmh0bWw7XG4gICAgICAgICAgaWYgKCEob3B0aW9uLmdyb3VwICYmICF0aGlzLmdyb3VwX3NlYXJjaCkpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSB0aGlzLnNlYXJjaF9zdHJpbmdfbWF0Y2gob3B0aW9uLnNlYXJjaF90ZXh0LCByZWdleCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlYXJjaF9tYXRjaCAmJiAhb3B0aW9uLmdyb3VwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb24uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIGlmIChzZWFyY2hUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0cG9zID0gb3B0aW9uLnNlYXJjaF90ZXh0LnNlYXJjaCh6cmVnZXgpO1xuICAgICAgICAgICAgICAgIHRleHQgPSBvcHRpb24uc2VhcmNoX3RleHQuc3Vic3RyKDAsIHN0YXJ0cG9zICsgc2VhcmNoVGV4dC5sZW5ndGgpICsgJzwvZW0+JyArIG9wdGlvbi5zZWFyY2hfdGV4dC5zdWJzdHIoc3RhcnRwb3MgKyBzZWFyY2hUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlYXJjaF90ZXh0ID0gdGV4dC5zdWJzdHIoMCwgc3RhcnRwb3MpICsgJzxlbT4nICsgdGV4dC5zdWJzdHIoc3RhcnRwb3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHRzX2dyb3VwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzX2dyb3VwLmdyb3VwX21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICgob3B0aW9uLmdyb3VwX2FycmF5X2luZGV4ICE9IG51bGwpICYmIHRoaXMucmVzdWx0c19kYXRhW29wdGlvbi5ncm91cF9hcnJheV9pbmRleF0uc2VhcmNoX21hdGNoKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWFyY2hfbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICBpZiAocmVzdWx0cyA8IDEgJiYgc2VhcmNoVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub19yZXN1bHRzKHNlYXJjaFRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51cGRhdGVfcmVzdWx0c19jb250ZW50KHRoaXMucmVzdWx0c19vcHRpb25fYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpbm5vd19yZXN1bHRzX3NldF9oaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmdldF9zZWFyY2hfcmVnZXggPSBmdW5jdGlvbihlc2NhcGVkX3NlYXJjaF9zdHJpbmcpIHtcbiAgICAgIHZhciByZWdleF9hbmNob3IsIHJlZ2V4X2ZsYWc7XG4gICAgICByZWdleF9hbmNob3IgPSB0aGlzLnNlYXJjaF9jb250YWlucyA/IFwiXCIgOiBcIl5cIjtcbiAgICAgIHJlZ2V4X2ZsYWcgPSB0aGlzLmNhc2Vfc2Vuc2l0aXZlX3NlYXJjaCA/IFwiXCIgOiBcImlcIjtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4X2FuY2hvciArIGVzY2FwZWRfc2VhcmNoX3N0cmluZywgcmVnZXhfZmxhZyk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfc3RyaW5nX21hdGNoID0gZnVuY3Rpb24oc2VhcmNoX3N0cmluZywgcmVnZXgpIHtcbiAgICAgIHZhciBwYXJ0LCBwYXJ0cywgX2ksIF9sZW47XG4gICAgICBpZiAocmVnZXgudGVzdChzZWFyY2hfc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbmFibGVfc3BsaXRfd29yZF9zZWFyY2ggJiYgKHNlYXJjaF9zdHJpbmcuaW5kZXhPZihcIiBcIikgPj0gMCB8fCBzZWFyY2hfc3RyaW5nLmluZGV4T2YoXCJbXCIpID09PSAwKSkge1xuICAgICAgICBwYXJ0cyA9IHNlYXJjaF9zdHJpbmcucmVwbGFjZSgvXFxbfFxcXS9nLCBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhcnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydHNbX2ldO1xuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5jaG9pY2VzX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9uLCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gMDtcbiAgICAgIF9yZWYgPSB0aGlzLmZvcm1fZmllbGQub3B0aW9ucztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBvcHRpb24gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNob2ljZXNfY2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCEodGhpcy5yZXN1bHRzX3Nob3dpbmcgfHwgdGhpcy5pc19kaXNhYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5rZXl1cF9jaGVja2VyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgc3Ryb2tlLCBfcmVmO1xuICAgICAgc3Ryb2tlID0gKF9yZWYgPSBldnQud2hpY2gpICE9IG51bGwgPyBfcmVmIDogZXZ0LmtleUNvZGU7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPCAxICYmIHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5ZG93bl9iYWNrc3Ryb2tlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zZWFyY2goKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfc2VsZWN0KGV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuY2xpcGJvYXJkX2V2ZW50X2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZXN1bHRzX3NlYXJjaCgpO1xuICAgICAgfSksIDUwKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmNvbnRhaW5lcl93aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMuZm9ybV9maWVsZC5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4ucHJvdG90eXBlLmluY2x1ZGVfb3B0aW9uX2luX3Jlc3VsdHMgPSBmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmICghdGhpcy5kaXNwbGF5X3NlbGVjdGVkX29wdGlvbnMgJiYgb3B0aW9uLnNlbGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGlzcGxheV9kaXNhYmxlZF9vcHRpb25zICYmIG9wdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfdG91Y2hzdGFydCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy50b3VjaF9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3ZlcihldnQpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfdG91Y2htb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLnRvdWNoX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0KGV2dCk7XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c190b3VjaGVuZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKHRoaXMudG91Y2hfc3RhcnRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0c19tb3VzZXVwKGV2dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEFic3RyYWN0Q2hvc2VuLnByb3RvdHlwZS5vdXRlckhUTUwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgdG1wO1xuICAgICAgaWYgKGVsZW1lbnQub3V0ZXJIVE1MKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbiAgICAgIH1cbiAgICAgIHRtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0bXAuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdG1wLmlubmVySFRNTDtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiID09PSB3aW5kb3cubmF2aWdhdG9yLmFwcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50TW9kZSA+PSA4O1xuICAgICAgfVxuICAgICAgaWYgKC9pUChvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9JRU1vYmlsZS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9XaW5kb3dzIFBob25lL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0JsYWNrQmVycnkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvQkIxMC9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9BbmRyb2lkLipNb2JpbGUvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RDaG9zZW4uZGVmYXVsdF9tdWx0aXBsZV90ZXh0ID0gXCJTZWxlY3QgU29tZSBPcHRpb25zXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X3NpbmdsZV90ZXh0ID0gXCJTZWxlY3QgYW4gT3B0aW9uXCI7XG5cbiAgICBBYnN0cmFjdENob3Nlbi5kZWZhdWx0X25vX3Jlc3VsdF90ZXh0ID0gXCJObyByZXN1bHRzIG1hdGNoXCI7XG5cbiAgICByZXR1cm4gQWJzdHJhY3RDaG9zZW47XG5cbiAgfSkoKTtcblxuICAkID0galF1ZXJ5O1xuXG4gICQuZm4uZXh0ZW5kKHtcbiAgICBjaG9zZW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghQWJzdHJhY3RDaG9zZW4uYnJvd3Nlcl9pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5wdXRfZmllbGQpIHtcbiAgICAgICAgdmFyICR0aGlzLCBjaG9zZW47XG4gICAgICAgICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgY2hvc2VuID0gJHRoaXMuZGF0YSgnY2hvc2VuJyk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHtcbiAgICAgICAgICBpZiAoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSB7XG4gICAgICAgICAgICBjaG9zZW4uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY2hvc2VuIGluc3RhbmNlb2YgQ2hvc2VuKSkge1xuICAgICAgICAgICR0aGlzLmRhdGEoJ2Nob3NlbicsIG5ldyBDaG9zZW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIENob3NlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hvc2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ2hvc2VuKCkge1xuICAgICAgX3JlZiA9IENob3Nlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcSA9ICQodGhpcy5mb3JtX2ZpZWxkKTtcbiAgICAgIHRoaXMuY3VycmVudF9zZWxlY3RlZEluZGV4ID0gdGhpcy5mb3JtX2ZpZWxkLnNlbGVjdGVkSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5pc19ydGwgPSB0aGlzLmZvcm1fZmllbGRfanEuaGFzQ2xhc3MoXCJjaG9zZW4tcnRsXCIpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNldF91cF9odG1sID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGFpbmVyX2NsYXNzZXMsIGNvbnRhaW5lcl9wcm9wcztcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzID0gW1wiY2hvc2VuLWNvbnRhaW5lclwiXTtcbiAgICAgIGNvbnRhaW5lcl9jbGFzc2VzLnB1c2goXCJjaG9zZW4tY29udGFpbmVyLVwiICsgKHRoaXMuaXNfbXVsdGlwbGUgPyBcIm11bHRpXCIgOiBcInNpbmdsZVwiKSk7XG4gICAgICBpZiAodGhpcy5pbmhlcml0X3NlbGVjdF9jbGFzc2VzICYmIHRoaXMuZm9ybV9maWVsZC5jbGFzc05hbWUpIHtcbiAgICAgICAgY29udGFpbmVyX2NsYXNzZXMucHVzaCh0aGlzLmZvcm1fZmllbGQuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzX3J0bCkge1xuICAgICAgICBjb250YWluZXJfY2xhc3Nlcy5wdXNoKFwiY2hvc2VuLXJ0bFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lcl9wcm9wcyA9IHtcbiAgICAgICAgJ2NsYXNzJzogY29udGFpbmVyX2NsYXNzZXMuam9pbignICcpLFxuICAgICAgICAnc3R5bGUnOiBcIndpZHRoOiBcIiArICh0aGlzLmNvbnRhaW5lcl93aWR0aCgpKSArIFwiO1wiLFxuICAgICAgICAndGl0bGUnOiB0aGlzLmZvcm1fZmllbGQudGl0bGVcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLmlkLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXJfcHJvcHMuaWQgPSB0aGlzLmZvcm1fZmllbGQuaWQucmVwbGFjZSgvW15cXHddL2csICdfJykgKyBcIl9jaG9zZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyID0gJChcIjxkaXYgLz5cIiwgY29udGFpbmVyX3Byb3BzKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmh0bWwoJzx1bCBjbGFzcz1cImNob3Nlbi1jaG9pY2VzXCI+PGxpIGNsYXNzPVwic2VhcmNoLWZpZWxkXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9XCInICsgdGhpcy5kZWZhdWx0X3RleHQgKyAnXCIgY2xhc3M9XCJkZWZhdWx0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgc3R5bGU9XCJ3aWR0aDoyNXB4O1wiIC8+PC9saT48L3VsPjxkaXYgY2xhc3M9XCJjaG9zZW4tZHJvcFwiPjx1bCBjbGFzcz1cImNob3Nlbi1yZXN1bHRzXCI+PC91bD48L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmh0bWwoJzxhIGNsYXNzPVwiY2hvc2VuLXNpbmdsZSBjaG9zZW4tZGVmYXVsdFwiPjxzcGFuPicgKyB0aGlzLmRlZmF1bHRfdGV4dCArICc8L3NwYW4+PGRpdj48Yj48L2I+PC9kaXY+PC9hPjxkaXYgY2xhc3M9XCJjaG9zZW4tZHJvcFwiPjxkaXYgY2xhc3M9XCJjaG9zZW4tc2VhcmNoXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgLz48L2Rpdj48dWwgY2xhc3M9XCJjaG9zZW4tcmVzdWx0c1wiPjwvdWw+PC9kaXY+Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEuaGlkZSgpLmFmdGVyKHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2hvc2VuLWRyb3AnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdpbnB1dCcpLmZpcnN0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzID0gdGhpcy5jb250YWluZXIuZmluZCgndWwuY2hvc2VuLXJlc3VsdHMnKS5maXJzdCgpO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGRfc2NhbGUoKTtcbiAgICAgIHRoaXMuc2VhcmNoX25vX3Jlc3VsdHMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdsaS5uby1yZXN1bHRzJykuZmlyc3QoKTtcbiAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2Nob2ljZXMgPSB0aGlzLmNvbnRhaW5lci5maW5kKCd1bC5jaG9zZW4tY2hvaWNlcycpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2NvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLmZpbmQoJ2xpLnNlYXJjaC1maWVsZCcpLmZpcnN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9jb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5maW5kKCdkaXYuY2hvc2VuLXNlYXJjaCcpLmZpcnN0KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbSA9IHRoaXMuY29udGFpbmVyLmZpbmQoJy5jaG9zZW4tc2luZ2xlJykuZmlyc3QoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzdWx0c19idWlsZCgpO1xuICAgICAgdGhpcy5zZXRfdGFiX2luZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRfbGFiZWxfYmVoYXZpb3IoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5vbl9yZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOnJlYWR5XCIsIHtcbiAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZWdpc3Rlcl9vYnNlcnZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmNvbnRhaW5lci5iaW5kKCd0b3VjaHN0YXJ0LmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYmluZCgndG91Y2hlbmQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICAgIHJldHVybiBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYmluZCgnbW91c2Vkb3duLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJfbW91c2Vkb3duKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNldXAuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZXVwKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlZW50ZXIuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLm1vdXNlX2VudGVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmJpbmQoJ21vdXNlbGVhdmUuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLm1vdXNlX2xlYXZlKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2V1cC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cChldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmJpbmQoJ21vdXNlb3Zlci5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdmVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2VvdXQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNlb3V0KGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgnbW91c2V3aGVlbC5jaG9zZW4gRE9NTW91c2VTY3JvbGwuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnNlYXJjaF9yZXN1bHRzX21vdXNld2hlZWwoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5iaW5kKCd0b3VjaHN0YXJ0LmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c190b3VjaHN0YXJ0KGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX3Jlc3VsdHMuYmluZCgndG91Y2htb3ZlLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5zZWFyY2hfcmVzdWx0c190b3VjaG1vdmUoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfcmVzdWx0cy5iaW5kKCd0b3VjaGVuZC5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuc2VhcmNoX3Jlc3VsdHNfdG91Y2hlbmQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46dXBkYXRlZC5jaG9zZW5cIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLnJlc3VsdHNfdXBkYXRlX2ZpZWxkKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS5iaW5kKFwiY2hvc2VuOmFjdGl2YXRlLmNob3NlblwiLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMuYWN0aXZhdGVfZmllbGQoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46b3Blbi5jaG9zZW5cIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLmJpbmQoXCJjaG9zZW46Y2xvc2UuY2hvc2VuXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5pbnB1dF9ibHVyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ2JsdXIuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmlucHV0X2JsdXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgna2V5dXAuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmtleXVwX2NoZWNrZXIoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQuYmluZCgna2V5ZG93bi5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgX3RoaXMua2V5ZG93bl9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ2ZvY3VzLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5pbnB1dF9mb2N1cyhldnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC5iaW5kKCdjdXQuY2hvc2VuJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIF90aGlzLmNsaXBib2FyZF9ldmVudF9jaGVja2VyKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmJpbmQoJ3Bhc3RlLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBfdGhpcy5jbGlwYm9hcmRfZXZlbnRfY2hlY2tlcihldnQpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfY2hvaWNlcy5iaW5kKCdjbGljay5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICBfdGhpcy5jaG9pY2VzX2NsaWNrKGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmJpbmQoJ2NsaWNrLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAkKHRoaXMuY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQpLnVuYmluZChcImNsaWNrLmNob3NlblwiLCB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleCkge1xuICAgICAgICB0aGlzLmZvcm1fZmllbGRfanFbMF0udGFiSW5kZXggPSB0aGlzLnNlYXJjaF9maWVsZFswXS50YWJJbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnJlbW92ZURhdGEoJ2Nob3NlbicpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS5zaG93KCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX2ZpZWxkX2Rpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzX2Rpc2FibGVkID0gdGhpcy5mb3JtX2ZpZWxkX2pxWzBdLmRpc2FibGVkO1xuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2xhc3MoJ2Nob3Nlbi1kaXNhYmxlZCcpO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS51bmJpbmQoXCJmb2N1cy5jaG9zZW5cIiwgdGhpcy5hY3RpdmF0ZV9hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcygnY2hvc2VuLWRpc2FibGVkJyk7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uYmluZChcImZvY3VzLmNob3NlblwiLCB0aGlzLmFjdGl2YXRlX2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jb250YWluZXJfbW91c2Vkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGV2dCAmJiBldnQudHlwZSA9PT0gXCJtb3VzZWRvd25cIiAmJiAhdGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoZXZ0ICE9IG51bGwpICYmICgkKGV2dC50YXJnZXQpKS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtY2xvc2VcIikpKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCh0aGlzLmNvbnRhaW5lclswXS5vd25lckRvY3VtZW50KS5iaW5kKCdjbGljay5jaG9zZW4nLCB0aGlzLmNsaWNrX3Rlc3RfYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19tdWx0aXBsZSAmJiBldnQgJiYgKCgkKGV2dC50YXJnZXQpWzBdID09PSB0aGlzLnNlbGVjdGVkX2l0ZW1bMF0pIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcImEuY2hvc2VuLXNpbmdsZVwiKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c190b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGVfZmllbGQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmNvbnRhaW5lcl9tb3VzZXVwID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJBQkJSXCIgJiYgIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19yZXNldChldnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9yZXN1bHRzX21vdXNld2hlZWwgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBkZWx0YTtcbiAgICAgIGlmIChldnQub3JpZ2luYWxFdmVudCkge1xuICAgICAgICBkZWx0YSA9IGV2dC5vcmlnaW5hbEV2ZW50LmRlbHRhWSB8fCAtZXZ0Lm9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YSB8fCBldnQub3JpZ2luYWxFdmVudC5kZXRhaWw7XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICAgICAgZGVsdGEgPSBkZWx0YSAqIDQwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChkZWx0YSArIHRoaXMuc2VhcmNoX3Jlc3VsdHMuc2Nyb2xsVG9wKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmJsdXJfdGVzdCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2ZV9maWVsZCAmJiB0aGlzLmNvbnRhaW5lci5oYXNDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2xvc2VfZmllbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcy5jb250YWluZXJbMF0ub3duZXJEb2N1bWVudCkudW5iaW5kKFwiY2xpY2suY2hvc2VuXCIsIHRoaXMuY2xpY2tfdGVzdF9hY3Rpb24pO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLmFjdGl2YXRlX2ZpZWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGRDbGFzcyhcImNob3Nlbi1jb250YWluZXItYWN0aXZlXCIpO1xuICAgICAgdGhpcy5hY3RpdmVfZmllbGQgPSB0cnVlO1xuICAgICAgdGhpcy5zZWFyY2hfZmllbGQudmFsKHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCgpKTtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5mb2N1cygpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnRlc3RfYWN0aXZlX2NsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgYWN0aXZlX2NvbnRhaW5lcjtcbiAgICAgIGFjdGl2ZV9jb250YWluZXIgPSAkKGV2dC50YXJnZXQpLmNsb3Nlc3QoJy5jaG9zZW4tY29udGFpbmVyJyk7XG4gICAgICBpZiAoYWN0aXZlX2NvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5jb250YWluZXJbMF0gPT09IGFjdGl2ZV9jb250YWluZXJbMF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlX2ZpZWxkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlX2ZpZWxkKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gbnVsbDtcbiAgICAgIHRoaXMucmVzdWx0c19kYXRhID0gU2VsZWN0UGFyc2VyLnNlbGVjdF90b19hcnJheSh0aGlzLmZvcm1fZmllbGQpO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hfY2hvaWNlcy5maW5kKFwibGkuc2VhcmNoLWNob2ljZVwiKS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zaW5nbGVfc2V0X3NlbGVjdGVkX3RleHQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZV9zZWFyY2ggfHwgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnMubGVuZ3RoIDw9IHRoaXMuZGlzYWJsZV9zZWFyY2hfdGhyZXNob2xkKSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLWNvbnRhaW5lci1zaW5nbGUtbm9zZWFyY2hcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hfZmllbGRbMF0ucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi1jb250YWluZXItc2luZ2xlLW5vc2VhcmNoXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQodGhpcy5yZXN1bHRzX29wdGlvbl9idWlsZCh7XG4gICAgICAgIGZpcnN0OiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9kaXNhYmxlZCgpO1xuICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2luZyA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kb19oaWdobGlnaHQgPSBmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGhpZ2hfYm90dG9tLCBoaWdoX3RvcCwgbWF4SGVpZ2h0LCB2aXNpYmxlX2JvdHRvbSwgdmlzaWJsZV90b3A7XG4gICAgICBpZiAoZWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSBlbDtcbiAgICAgICAgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0LmFkZENsYXNzKFwiaGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIG1heEhlaWdodCA9IHBhcnNlSW50KHRoaXMuc2VhcmNoX3Jlc3VsdHMuY3NzKFwibWF4SGVpZ2h0XCIpLCAxMCk7XG4gICAgICAgIHZpc2libGVfdG9wID0gdGhpcy5zZWFyY2hfcmVzdWx0cy5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmlzaWJsZV9ib3R0b20gPSBtYXhIZWlnaHQgKyB2aXNpYmxlX3RvcDtcbiAgICAgICAgaGlnaF90b3AgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgpO1xuICAgICAgICBoaWdoX2JvdHRvbSA9IGhpZ2hfdG9wICsgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm91dGVySGVpZ2h0KCk7XG4gICAgICAgIGlmIChoaWdoX2JvdHRvbSA+PSB2aXNpYmxlX2JvdHRvbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcCgoaGlnaF9ib3R0b20gLSBtYXhIZWlnaHQpID4gMCA/IGhpZ2hfYm90dG9tIC0gbWF4SGVpZ2h0IDogMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGlnaF90b3AgPCB2aXNpYmxlX3RvcCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLnNjcm9sbFRvcChoaWdoX3RvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2hpZ2hsaWdodC5yZW1vdmVDbGFzcyhcImhpZ2hsaWdodGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2hpZ2hsaWdodCA9IG51bGw7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLm1heF9zZWxlY3RlZF9vcHRpb25zIDw9IHRoaXMuY2hvaWNlc19jb3VudCgpKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZENsYXNzKFwiY2hvc2VuLXdpdGgtZHJvcFwiKTtcbiAgICAgIHRoaXMucmVzdWx0c19zaG93aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLmZvY3VzKCk7XG4gICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgdGhpcy53aW5ub3dfcmVzdWx0cygpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOnNob3dpbmdfZHJvcGRvd25cIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnVwZGF0ZV9yZXN1bHRzX2NvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hfcmVzdWx0cy5odG1sKGNvbnRlbnQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdHNfaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0c19zaG93aW5nKSB7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcImNob3Nlbi13aXRoLWRyb3BcIik7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOmhpZGluZ19kcm9wZG93blwiLCB7XG4gICAgICAgICAgY2hvc2VuOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93aW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X3RhYl9pbmRleCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgdGk7XG4gICAgICBpZiAodGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4KSB7XG4gICAgICAgIHRpID0gdGhpcy5mb3JtX2ZpZWxkLnRhYkluZGV4O1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkWzBdLnRhYkluZGV4ID0gdGk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2V0X2xhYmVsX2JlaGF2aW9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5mb3JtX2ZpZWxkX2xhYmVsID0gdGhpcy5mb3JtX2ZpZWxkX2pxLnBhcmVudHMoXCJsYWJlbFwiKTtcbiAgICAgIGlmICghdGhpcy5mb3JtX2ZpZWxkX2xhYmVsLmxlbmd0aCAmJiB0aGlzLmZvcm1fZmllbGQuaWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZm9ybV9maWVsZF9sYWJlbCA9ICQoXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5mb3JtX2ZpZWxkLmlkICsgXCInXVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZvcm1fZmllbGRfbGFiZWwubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtX2ZpZWxkX2xhYmVsLmJpbmQoJ2NsaWNrLmNob3NlbicsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRhaW5lcl9tb3VzZWRvd24oZXZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2YXRlX2ZpZWxkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSAmJiB0aGlzLmNob2ljZXNfY291bnQoKSA8IDEgJiYgIXRoaXMuYWN0aXZlX2ZpZWxkKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkLnZhbCh0aGlzLmRlZmF1bHRfdGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5hZGRDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZC52YWwoXCJcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9maWVsZC5yZW1vdmVDbGFzcyhcImRlZmF1bHRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2V1cCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHRhcmdldCA9ICQoZXZ0LnRhcmdldCkuaGFzQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpID8gJChldnQudGFyZ2V0KSA6ICQoZXZ0LnRhcmdldCkucGFyZW50cyhcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAodGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnJlc3VsdF9oaWdobGlnaHQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zZWFyY2hfcmVzdWx0c19tb3VzZW92ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiKSA/ICQoZXZ0LnRhcmdldCkgOiAkKGV2dC50YXJnZXQpLnBhcmVudHMoXCIuYWN0aXZlLXJlc3VsdFwiKS5maXJzdCgpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfZG9faGlnaGxpZ2h0KHRhcmdldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2VhcmNoX3Jlc3VsdHNfbW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICgkKGV2dC50YXJnZXQpLmhhc0NsYXNzKFwiYWN0aXZlLXJlc3VsdFwiIHx8ICQoZXZ0LnRhcmdldCkucGFyZW50cygnLmFjdGl2ZS1yZXN1bHQnKS5maXJzdCgpKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRfY2xlYXJfaGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2J1aWxkID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIGNob2ljZSwgY2xvc2VfbGluayxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgY2hvaWNlID0gJCgnPGxpIC8+Jywge1xuICAgICAgICBcImNsYXNzXCI6IFwic2VhcmNoLWNob2ljZVwiXG4gICAgICB9KS5odG1sKFwiPHNwYW4+XCIgKyAodGhpcy5jaG9pY2VfbGFiZWwoaXRlbSkpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgY2hvaWNlLmFkZENsYXNzKCdzZWFyY2gtY2hvaWNlLWRpc2FibGVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZV9saW5rID0gJCgnPGEgLz4nLCB7XG4gICAgICAgICAgXCJjbGFzc1wiOiAnc2VhcmNoLWNob2ljZS1jbG9zZScsXG4gICAgICAgICAgJ2RhdGEtb3B0aW9uLWFycmF5LWluZGV4JzogaXRlbS5hcnJheV9pbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgY2xvc2VfbGluay5iaW5kKCdjbGljay5jaG9zZW4nLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayhldnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hvaWNlLmFwcGVuZChjbG9zZV9saW5rKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9jb250YWluZXIuYmVmb3JlKGNob2ljZSk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3lfbGlua19jbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlX2Rlc3Ryb3koJChldnQudGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuY2hvaWNlX2Rlc3Ryb3kgPSBmdW5jdGlvbihsaW5rKSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRfZGVzZWxlY3QobGlua1swXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9wdGlvbi1hcnJheS1pbmRleFwiKSkpIHtcbiAgICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlICYmIHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCAmJiB0aGlzLnNlYXJjaF9maWVsZC52YWwoKS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnBhcmVudHMoJ2xpJykuZmlyc3QoKS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUucmVzdWx0c19yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZXNldF9zaW5nbGVfc2VsZWN0X29wdGlvbnMoKTtcbiAgICAgIHRoaXMuZm9ybV9maWVsZC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0KCk7XG4gICAgICB0aGlzLnNob3dfc2VhcmNoX2ZpZWxkX2RlZmF1bHQoKTtcbiAgICAgIHRoaXMucmVzdWx0c19yZXNldF9jbGVhbnVwKCk7XG4gICAgICB0aGlzLmZvcm1fZmllbGRfanEudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZV9maWVsZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5yZXN1bHRzX3Jlc2V0X2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudF9zZWxlY3RlZEluZGV4ID0gdGhpcy5mb3JtX2ZpZWxkLnNlbGVjdGVkSW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJhYmJyXCIpLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9zZWxlY3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBoaWdoLCBpdGVtO1xuICAgICAgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBoaWdoID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0O1xuICAgICAgICB0aGlzLnJlc3VsdF9jbGVhcl9oaWdobGlnaHQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUgJiYgdGhpcy5tYXhfc2VsZWN0ZWRfb3B0aW9ucyA8PSB0aGlzLmNob2ljZXNfY291bnQoKSkge1xuICAgICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm1heHNlbGVjdGVkXCIsIHtcbiAgICAgICAgICAgIGNob3NlbjogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc19tdWx0aXBsZSkge1xuICAgICAgICAgIGhpZ2gucmVtb3ZlQ2xhc3MoXCJhY3RpdmUtcmVzdWx0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRfc2luZ2xlX3NlbGVjdF9vcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGlnaC5hZGRDbGFzcyhcInJlc3VsdC1zZWxlY3RlZFwiKTtcbiAgICAgICAgaXRlbSA9IHRoaXMucmVzdWx0c19kYXRhW2hpZ2hbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1vcHRpb24tYXJyYXktaW5kZXhcIildO1xuICAgICAgICBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkLm9wdGlvbnNbaXRlbS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfb3B0aW9uX2NvdW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICB0aGlzLmNob2ljZV9idWlsZChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNpbmdsZV9zZXRfc2VsZWN0ZWRfdGV4dCh0aGlzLmNob2ljZV9sYWJlbChpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSAmJiB0aGlzLmlzX211bHRpcGxlKSkge1xuICAgICAgICAgIHRoaXMucmVzdWx0c19oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93X3NlYXJjaF9maWVsZF9kZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzX211bHRpcGxlIHx8IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4ICE9PSB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICAgIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hhbmdlXCIsIHtcbiAgICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW2l0ZW0ub3B0aW9uc19pbmRleF0udmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRfc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9ybV9maWVsZC5zZWxlY3RlZEluZGV4O1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuc2luZ2xlX3NldF9zZWxlY3RlZF90ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgICAgICB0ZXh0ID0gdGhpcy5kZWZhdWx0X3RleHQ7XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gdGhpcy5kZWZhdWx0X3RleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmFkZENsYXNzKFwiY2hvc2VuLWRlZmF1bHRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNpbmdsZV9kZXNlbGVjdF9jb250cm9sX2J1aWxkKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRfaXRlbS5yZW1vdmVDbGFzcyhcImNob3Nlbi1kZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwic3BhblwiKS5odG1sKHRleHQpO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnJlc3VsdF9kZXNlbGVjdCA9IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIHJlc3VsdF9kYXRhO1xuICAgICAgcmVzdWx0X2RhdGEgPSB0aGlzLnJlc3VsdHNfZGF0YVtwb3NdO1xuICAgICAgaWYgKCF0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICByZXN1bHRfZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcm1fZmllbGQub3B0aW9uc1tyZXN1bHRfZGF0YS5vcHRpb25zX2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkX29wdGlvbl9jb3VudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcpIHtcbiAgICAgICAgICB0aGlzLndpbm5vd19yZXN1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtX2ZpZWxkX2pxLnRyaWdnZXIoXCJjaGFuZ2VcIiwge1xuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHRoaXMuZm9ybV9maWVsZC5vcHRpb25zW3Jlc3VsdF9kYXRhLm9wdGlvbnNfaW5kZXhdLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlYXJjaF9maWVsZF9zY2FsZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5zaW5nbGVfZGVzZWxlY3RfY29udHJvbF9idWlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbmdsZV9kZXNlbGVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRfaXRlbS5maW5kKFwiYWJiclwiKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZF9pdGVtLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuYWZ0ZXIoXCI8YWJiciBjbGFzcz1cXFwic2VhcmNoLWNob2ljZS1jbG9zZVxcXCI+PC9hYmJyPlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkX2l0ZW0uYWRkQ2xhc3MoXCJjaG9zZW4tc2luZ2xlLXdpdGgtZGVzZWxlY3RcIik7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUuZ2V0X3NlYXJjaF90ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJCgnPGRpdi8+JykudGV4dCgkLnRyaW0odGhpcy5zZWFyY2hfZmllbGQudmFsKCkpKS5odG1sKCk7XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUud2lubm93X3Jlc3VsdHNfc2V0X2hpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRvX2hpZ2gsIHNlbGVjdGVkX3Jlc3VsdHM7XG4gICAgICBzZWxlY3RlZF9yZXN1bHRzID0gIXRoaXMuaXNfbXVsdGlwbGUgPyB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIucmVzdWx0LXNlbGVjdGVkLmFjdGl2ZS1yZXN1bHRcIikgOiBbXTtcbiAgICAgIGRvX2hpZ2ggPSBzZWxlY3RlZF9yZXN1bHRzLmxlbmd0aCA/IHNlbGVjdGVkX3Jlc3VsdHMuZmlyc3QoKSA6IHRoaXMuc2VhcmNoX3Jlc3VsdHMuZmluZChcIi5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICBpZiAoZG9faGlnaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQoZG9faGlnaCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUubm9fcmVzdWx0cyA9IGZ1bmN0aW9uKHRlcm1zKSB7XG4gICAgICB2YXIgbm9fcmVzdWx0c19odG1sO1xuICAgICAgbm9fcmVzdWx0c19odG1sID0gJCgnPGxpIGNsYXNzPVwibm8tcmVzdWx0c1wiPicgKyB0aGlzLnJlc3VsdHNfbm9uZV9mb3VuZCArICcgXCI8c3Bhbj48L3NwYW4+XCI8L2xpPicpO1xuICAgICAgbm9fcmVzdWx0c19odG1sLmZpbmQoXCJzcGFuXCIpLmZpcnN0KCkuaHRtbCh0ZXJtcyk7XG4gICAgICB0aGlzLnNlYXJjaF9yZXN1bHRzLmFwcGVuZChub19yZXN1bHRzX2h0bWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybV9maWVsZF9qcS50cmlnZ2VyKFwiY2hvc2VuOm5vX3Jlc3VsdHNcIiwge1xuICAgICAgICBjaG9zZW46IHRoaXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLm5vX3Jlc3VsdHNfY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaF9yZXN1bHRzLmZpbmQoXCIubm8tcmVzdWx0c1wiKS5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2Fycm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9zaWI7XG4gICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgdGhpcy5yZXN1bHRfaGlnaGxpZ2h0KSB7XG4gICAgICAgIG5leHRfc2liID0gdGhpcy5yZXN1bHRfaGlnaGxpZ2h0Lm5leHRBbGwoXCJsaS5hY3RpdmUtcmVzdWx0XCIpLmZpcnN0KCk7XG4gICAgICAgIGlmIChuZXh0X3NpYikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdF9kb19oaWdobGlnaHQobmV4dF9zaWIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzX3Nob3coKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXl1cF9hcnJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByZXZfc2licztcbiAgICAgIGlmICghdGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0c19zaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVzdWx0X2hpZ2hsaWdodCkge1xuICAgICAgICBwcmV2X3NpYnMgPSB0aGlzLnJlc3VsdF9oaWdobGlnaHQucHJldkFsbChcImxpLmFjdGl2ZS1yZXN1bHRcIik7XG4gICAgICAgIGlmIChwcmV2X3NpYnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2RvX2hpZ2hsaWdodChwcmV2X3NpYnMuZmlyc3QoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hvaWNlc19jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzX2hpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0X2NsZWFyX2hpZ2hsaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENob3Nlbi5wcm90b3R5cGUua2V5ZG93bl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV4dF9hdmFpbGFibGVfZGVzdHJveTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSkge1xuICAgICAgICB0aGlzLmNob2ljZV9kZXN0cm95KHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmZpbmQoXCJhXCIpLmZpcnN0KCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9iYWNrc3Ryb2tlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0X2F2YWlsYWJsZV9kZXN0cm95ID0gdGhpcy5zZWFyY2hfY29udGFpbmVyLnNpYmxpbmdzKFwibGkuc2VhcmNoLWNob2ljZVwiKS5sYXN0KCk7XG4gICAgICAgIGlmIChuZXh0X2F2YWlsYWJsZV9kZXN0cm95Lmxlbmd0aCAmJiAhbmV4dF9hdmFpbGFibGVfZGVzdHJveS5oYXNDbGFzcyhcInNlYXJjaC1jaG9pY2UtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdfYmFja3N0cm9rZSA9IG5leHRfYXZhaWxhYmxlX2Rlc3Ryb3k7XG4gICAgICAgICAgaWYgKHRoaXMuc2luZ2xlX2JhY2tzdHJva2VfZGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlkb3duX2JhY2tzdHJva2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlLmFkZENsYXNzKFwic2VhcmNoLWNob2ljZS1mb2N1c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5jbGVhcl9iYWNrc3Ryb2tlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nX2JhY2tzdHJva2UpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nX2JhY2tzdHJva2UucmVtb3ZlQ2xhc3MoXCJzZWFyY2gtY2hvaWNlLWZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlID0gbnVsbDtcbiAgICB9O1xuXG4gICAgQ2hvc2VuLnByb3RvdHlwZS5rZXlkb3duX2NoZWNrZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBzdHJva2UsIF9yZWYxO1xuICAgICAgc3Ryb2tlID0gKF9yZWYxID0gZXZ0LndoaWNoKSAhPSBudWxsID8gX3JlZjEgOiBldnQua2V5Q29kZTtcbiAgICAgIHRoaXMuc2VhcmNoX2ZpZWxkX3NjYWxlKCk7XG4gICAgICBpZiAoc3Ryb2tlICE9PSA4ICYmIHRoaXMucGVuZGluZ19iYWNrc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJfYmFja3N0cm9rZSgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdHJva2UpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHRoaXMuYmFja3N0cm9rZV9sZW5ndGggPSB0aGlzLnNlYXJjaF9maWVsZC52YWwoKS5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBpZiAodGhpcy5yZXN1bHRzX3Nob3dpbmcgJiYgIXRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X3NlbGVjdChldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm1vdXNlX29uX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLnJlc3VsdHNfc2hvd2luZykge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVfc2VhcmNoKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5rZXl1cF9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMua2V5ZG93bl9hcnJvdygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDaG9zZW4ucHJvdG90eXBlLnNlYXJjaF9maWVsZF9zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpdiwgZl93aWR0aCwgaCwgc3R5bGUsIHN0eWxlX2Jsb2NrLCBzdHlsZXMsIHcsIF9pLCBfbGVuO1xuICAgICAgaWYgKHRoaXMuaXNfbXVsdGlwbGUpIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIHcgPSAwO1xuICAgICAgICBzdHlsZV9ibG9jayA9IFwicG9zaXRpb246YWJzb2x1dGU7IGxlZnQ6IC0xMDAwcHg7IHRvcDogLTEwMDBweDsgZGlzcGxheTpub25lO1wiO1xuICAgICAgICBzdHlsZXMgPSBbJ2ZvbnQtc2l6ZScsICdmb250LXN0eWxlJywgJ2ZvbnQtd2VpZ2h0JywgJ2ZvbnQtZmFtaWx5JywgJ2xpbmUtaGVpZ2h0JywgJ3RleHQtdHJhbnNmb3JtJywgJ2xldHRlci1zcGFjaW5nJ107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc3R5bGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc3R5bGUgPSBzdHlsZXNbX2ldO1xuICAgICAgICAgIHN0eWxlX2Jsb2NrICs9IHN0eWxlICsgXCI6XCIgKyB0aGlzLnNlYXJjaF9maWVsZC5jc3Moc3R5bGUpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgZGl2ID0gJCgnPGRpdiAvPicsIHtcbiAgICAgICAgICAnc3R5bGUnOiBzdHlsZV9ibG9ja1xuICAgICAgICB9KTtcbiAgICAgICAgZGl2LnRleHQodGhpcy5zZWFyY2hfZmllbGQudmFsKCkpO1xuICAgICAgICAkKCdib2R5JykuYXBwZW5kKGRpdik7XG4gICAgICAgIHcgPSBkaXYud2lkdGgoKSArIDI1O1xuICAgICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICAgIGZfd2lkdGggPSB0aGlzLmNvbnRhaW5lci5vdXRlcldpZHRoKCk7XG4gICAgICAgIGlmICh3ID4gZl93aWR0aCAtIDEwKSB7XG4gICAgICAgICAgdyA9IGZfd2lkdGggLSAxMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hfZmllbGQuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiB3ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIENob3NlbjtcblxuICB9KShBYnN0cmFjdENob3Nlbik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogbW9kYWwuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNtb2RhbHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gTU9EQUwgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEdDX01vZGFsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgICAgICAgPSBvcHRpb25zXG4gICAgdGhpcy4kYm9keSAgICAgICAgICAgICAgID0gJChkb2N1bWVudC5ib2R5KVxuICAgIHRoaXMuJGVsZW1lbnQgICAgICAgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRkaWFsb2cgICAgICAgICAgICAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5tb2RhbC1kaWFsb2cnKVxuICAgIHRoaXMuJGJhY2tkcm9wICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLmlzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5vcmlnaW5hbEJvZHlQYWQgICAgID0gbnVsbFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgICB0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdGUpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcbiAgICAgICAgLmxvYWQodGhpcy5vcHRpb25zLnJlbW90ZSwgJC5wcm94eShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQuYnMubW9kYWwnKVxuICAgICAgICB9LCB0aGlzKSlcbiAgICB9XG4gIH1cblxuICBHQ19Nb2RhbC5WRVJTSU9OICA9ICczLjMuNidcblxuICBHQ19Nb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXG4gIEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBHQ19Nb2RhbC5ERUZBVUxUUyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGUgPSAkLkV2ZW50KCdzaG93LmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KSxcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMjUwLCAkKHdpbmRvdykuaGVpZ2h0KCkgLSAyMDApLFxuICAgICAgICBtaW5IZWlnaHQgPSAyNTA7XG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSk7XG5cbiAgICBpZiAodGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAuZmluZCgnLm1vZGFsLWJvZHknKVxuICAgICAgICAuY3NzKCdtaW4taGVpZ2h0JywgbWluSGVpZ2h0ICsgJ3B4JylcbiAgICAgICAgLmNzcygnbWF4LWhlaWdodCcsIG1heEhlaWdodCArICdweCcpO1xuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9uKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub25lKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhhdC4kZWxlbWVudCkpIHRoYXQuaWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGF0LiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJylcblxuICAgICAgaWYgKCF0aGF0LiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgICB0aGF0LiRlbGVtZW50LmFwcGVuZFRvKHRoYXQuJGJvZHkpIC8vIGRvbid0IG1vdmUgbW9kYWxzIGRvbSBwb3NpdGlvblxuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKVxuXG4gICAgICB0aGF0LmFkanVzdERpYWxvZygpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2djLXZpc2libGUtYnV0LWhpZGRlbicpO1xuICAgICAgdGhhdC4kZWxlbWVudC5hZGRDbGFzcygnaW4nKS5hZGRDbGFzcygnc2hvdycpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXG5cbiAgICAgIHZhciBlID0gJC5FdmVudCgnc2hvd24uYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICAgIHRyYW5zaXRpb24gP1xuICAgICAgICB0aGF0LiRkaWFsb2cgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cbiAgICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcihlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICB9KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlKSBlLnByZXZlbnREZWZhdWx0KClcblxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKCF0aGlzLmlzU2hvd24gfHwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZTtcblxuICAgIHRoaXMuZXNjYXBlKCk7XG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgICQoZG9jdW1lbnQpLm9mZignZm9jdXNpbi5icy5tb2RhbCcpO1xuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2luJylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdzaG93JylcbiAgICAgICAgLm9mZignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAgIC5vZmYoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcpXG4gICAgICAgIC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgdGhpcy4kZGlhbG9nLm9mZignbW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgJC5wcm94eSh0aGlzLmhpZGVHQ19Nb2RhbCwgdGhpcykpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChHQ19Nb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICB0aGlzLmhpZGVHQ19Nb2RhbCgpXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKCdmb2N1c2luLmJzLm1vZGFsJykgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdICE9PSBlLnRhcmdldFxuICAgICAgICAgICAgJiYgIXRoaXMuJGVsZW1lbnQuaGFzKGUudGFyZ2V0KS5sZW5ndGhcbiAgICAgICAgICAgICYmICEkKGUudGFyZ2V0LnBhcmVudE5vZGUpLmhhc0NsYXNzKCdja2VfZGlhbG9nX3VpX2lucHV0X3NlbGVjdCcpXG4gICAgICAgICAgICAmJiAhJChlLnRhcmdldC5wYXJlbnROb2RlKS5oYXNDbGFzcygnY2tlX2RpYWxvZ191aV9pbnB1dF90ZXh0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93bikge1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYnMubW9kYWwnLCAkLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLCB0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuaGlkZUdDX01vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRib2R5LnJlbW92ZUNsYXNzKCdtb2RhbC1vcGVuJylcbiAgICAgIHRoYXQucmVzZXRBZGp1c3RtZW50cygpXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcbiAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuLmJzLm1vZGFsJylcbiAgICB9KVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgdGhpcy4kYmFja2Ryb3AgPSBudWxsXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuYmFja2Ryb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcblxuICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlKVxuICAgICAgICAuYXBwZW5kVG8odGhpcy4kYm9keSlcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICB0aGlzLm9wdGlvbnMuYmFja2Ryb3AgPT0gJ3N0YXRpYydcbiAgICAgICAgICA/IHRoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKVxuICAgICAgICAgIDogdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuXG4gICAgICBpZiAoZG9BbmltYXRlKSB0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcblxuICAgICAgdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJykuYWRkQ2xhc3MoJ3Nob3cnKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgIGRvQW5pbWF0ZSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2spXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2soKVxuXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duICYmIHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICB0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcygnaW4nKS5yZW1vdmVDbGFzcygnc2hvdycpLmNzcygnZGlzcGxheScsICdub25lJyk7XG5cbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKEdDX01vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5hZGp1c3REaWFsb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6IHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgIW1vZGFsSXNPdmVyZmxvd2luZyA/IHRoaXMuc2Nyb2xsYmFyV2lkdGggOiAnJ1xuICAgIH0pXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICBwYWRkaW5nTGVmdDogJycsXG4gICAgICBwYWRkaW5nUmlnaHQ6ICcnXG4gICAgfSlcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZnVsbFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBpZiAoIWZ1bGxXaW5kb3dXaWR0aCkgeyAvLyB3b3JrYXJvdW5kIGZvciBtaXNzaW5nIHdpbmRvdy5pbm5lcldpZHRoIGluIElFOFxuICAgICAgdmFyIGRvY3VtZW50RWxlbWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGZ1bGxXaW5kb3dXaWR0aCA9IGRvY3VtZW50RWxlbWVudFJlY3QucmlnaHQgLSBNYXRoLmFicyhkb2N1bWVudEVsZW1lbnRSZWN0LmxlZnQpXG4gICAgfVxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgZnVsbFdpbmRvd1dpZHRoXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IHRoaXMubWVhc3VyZVNjcm9sbGJhcigpXG4gIH1cblxuICBHQ19Nb2RhbC5wcm90b3R5cGUuc2V0U2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgfHwgJydcbiAgICBpZiAodGhpcy5ib2R5SXNPdmVyZmxvd2luZykgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCBib2R5UGFkICsgdGhpcy5zY3JvbGxiYXJXaWR0aClcbiAgfVxuXG4gIEdDX01vZGFsLnByb3RvdHlwZS5yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsIHRoaXMub3JpZ2luYWxCb2R5UGFkKVxuICB9XG5cbiAgR0NfTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxuICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxuICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5vZmZzZXRXaWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cblxuICAvLyBNT0RBTCBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIEdDX1BsdWdpbihvcHRpb24sIF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMubW9kYWwnKVxuICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgR0NfTW9kYWwuREVGQVVMVFMsICR0aGlzLmRhdGEoKSwgdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb24pXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMubW9kYWwnLCAoZGF0YSA9IG5ldyBHQ19Nb2RhbCh0aGlzLCBvcHRpb25zKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dKF9yZWxhdGVkVGFyZ2V0KVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxuXG4gICQuZm4uZ2NfbW9kYWwgICAgICAgICAgICAgPSBHQ19QbHVnaW5cbiAgJC5mbi5nY19tb2RhbC5Db25zdHJ1Y3RvciA9IEdDX01vZGFsXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBocmVmID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSkpIC8vIHN0cmlwIGZvciBpZTdcbiAgICAgIHZhciBvcHRpb24gPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHtyZW1vdGU6ICEvIy8udGVzdChocmVmKSAmJiBocmVmfSwgJHRhcmdldC5kYXRhKCksICR0aGlzLmRhdGEoKSlcblxuICAgICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcbiAgICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgR0NfUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKTtcbiAgICB9KTtcblxuICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMjUwLCAkKHdpbmRvdykuaGVpZ2h0KCkgLSAyMDApLFxuICAgICAgICAgIG1pbkhlaWdodCA9IDI1MDtcbiAgICAgICQoJy5nYy1jb250YWluZXInKVxuICAgICAgICAgIC5maW5kKCcubW9kYWwtYm9keScpXG4gICAgICAgICAgLmNzcygnbWF4LWhlaWdodCcsIG1heEhlaWdodCArICdweCcpXG4gICAgICAgICAgLmNzcygnbWluLWhlaWdodCcsIG1pbkhlaWdodCArICdweCcpO1xuICAgIH0pO1xuXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLypcbiAqIHByaW50VGhpcyB2MS41XG4gKiBAZGVzYyBQcmludGluZyBwbHVnLWluIGZvciBqUXVlcnlcbiAqIEBhdXRob3IgSmFzb24gRGF5XG4gKlxuICogUmVzb3VyY2VzIChiYXNlZCBvbikgOlxuICogICAgICAgICAgICAgIGpQcmludEFyZWE6IGh0dHA6Ly9wbHVnaW5zLmpxdWVyeS5jb20vcHJvamVjdC9qUHJpbnRBcmVhXG4gKiAgICAgICAgICAgICAganFQcmludDogaHR0cHM6Ly9naXRodWIuY29tL3Blcm1hbmVudHRvdXJpc3QvanF1ZXJ5LmpxcHJpbnRcbiAqICAgICAgICAgICAgICBCZW4gTmFkYWw6IGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMTU5MS1Bc2stQmVuLVByaW50LVBhcnQtT2YtQS1XZWItUGFnZS1XaXRoLWpRdWVyeS5odG1cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2VuY2U6XG4gKiAgICAgICAgICAgICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiAoYykgSmFzb24gRGF5IDIwMTVcbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgJChcIiNteVNlbGVjdG9yXCIpLnByaW50VGhpcyh7XG4gKiAgICAgIGRlYnVnOiBmYWxzZSwgICAgICAgICAgICAgICAqIHNob3cgdGhlIGlmcmFtZSBmb3IgZGVidWdnaW5nXG4gKiAgICAgIGltcG9ydENTUzogdHJ1ZSwgICAgICAgICAgICAqIGltcG9ydCBwYWdlIENTU1xuICogICAgICBpbXBvcnRTdHlsZTogZmFsc2UsICAgICAgICAgKiBpbXBvcnQgc3R5bGUgdGFnc1xuICogICAgICBwcmludENvbnRhaW5lcjogdHJ1ZSwgICAgICAgKiBncmFiIG91dGVyIGNvbnRhaW5lciBhcyB3ZWxsIGFzIHRoZSBjb250ZW50cyBvZiB0aGUgc2VsZWN0b3JcbiAqICAgICAgbG9hZENTUzogXCJwYXRoL3RvL215LmNzc1wiLCAgKiBwYXRoIHRvIGFkZGl0aW9uYWwgY3NzIGZpbGUgLSB1cyBhbiBhcnJheSBbXSBmb3IgbXVsdGlwbGVcbiAqICAgICAgcGFnZVRpdGxlOiBcIlwiLCAgICAgICAgICAgICAgKiBhZGQgdGl0bGUgdG8gcHJpbnQgcGFnZVxuICogICAgICByZW1vdmVJbmxpbmU6IGZhbHNlLCAgICAgICAgKiByZW1vdmUgYWxsIGlubGluZSBzdHlsZXMgZnJvbSBwcmludCBlbGVtZW50c1xuICogICAgICBwcmludERlbGF5OiAzMzMsICAgICAgICAgICAgKiB2YXJpYWJsZSBwcmludCBkZWxheVxuICogICAgICBoZWFkZXI6IG51bGwsICAgICAgICAgICAgICAgKiBwcmVmaXggdG8gaHRtbFxuICogICAgICBmb3JtVmFsdWVzOiB0cnVlICAgICAgICAgICAgKiBwcmVzZXJ2ZSBpbnB1dC9mb3JtIHZhbHVlc1xuICogIH0pO1xuICpcbiAqIE5vdGVzOlxuICogIC0gdGhlIGxvYWRDU1Mgd2lsbCBsb2FkIGFkZGl0aW9uYWwgY3NzICh3aXRoIG9yIHdpdGhvdXQgQG1lZGlhIHByaW50KSBpbnRvIHRoZSBpZnJhbWUsIGFkanVzdGluZyBsYXlvdXRcbiAqL1xuKGZ1bmN0aW9uKCQpIHtcblxudmFyIG9wdDtcbiQuZm4ucHJpbnRUaGlzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdCA9ICQuZXh0ZW5kKHt9LCAkLmZuLnByaW50VGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgdmFyICRlbGVtZW50ID0gdGhpcyBpbnN0YW5jZW9mIGpRdWVyeSA/IHRoaXMgOiAkKHRoaXMpO1xuXG4gICAgdmFyIHN0ckZyYW1lTmFtZSA9IFwicHJpbnRUaGlzLVwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIGlmICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09IGRvY3VtZW50LmRvbWFpbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llL2kpKSB7XG4gICAgICAgIC8vIFVnbHkgSUUgaGFja3MgZHVlIHRvIElFIG5vdCBpbmhlcml0aW5nIGRvY3VtZW50LmRvbWFpbiBmcm9tIHBhcmVudFxuICAgICAgICAvLyBjaGVja3MgaWYgZG9jdW1lbnQuZG9tYWluIGlzIHNldCBieSBjb21wYXJpbmcgdGhlIGhvc3QgbmFtZSBhZ2FpbnN0IGRvY3VtZW50LmRvbWFpblxuICAgICAgICB2YXIgaWZyYW1lU3JjID0gXCJqYXZhc2NyaXB0OmRvY3VtZW50LndyaXRlKFxcXCI8aGVhZD48c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cXFxcXFxcIlwiICsgZG9jdW1lbnQuZG9tYWluICsgXCJcXFxcXFxcIjs8L3NjcmlwdD48L2hlYWQ+PGJvZHk+PC9ib2R5PlxcXCIpXCI7XG4gICAgICAgIHZhciBwcmludEkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgcHJpbnRJLm5hbWUgPSBcInByaW50SWZyYW1lXCI7XG4gICAgICAgIHByaW50SS5pZCA9IHN0ckZyYW1lTmFtZTtcbiAgICAgICAgcHJpbnRJLmNsYXNzTmFtZSA9IFwiTVNJRVwiO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByaW50SSk7XG4gICAgICAgIHByaW50SS5zcmMgPSBpZnJhbWVTcmM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlciBicm93c2VycyBpbmhlcml0IGRvY3VtZW50LmRvbWFpbiwgYW5kIElFIHdvcmtzIGlmIGRvY3VtZW50LmRvbWFpbiBpcyBub3QgZXhwbGljaXRseSBzZXRcbiAgICAgICAgdmFyICRmcmFtZSA9ICQoXCI8aWZyYW1lIGlkPSdcIiArIHN0ckZyYW1lTmFtZSArIFwiJyBuYW1lPSdwcmludElmcmFtZScgLz5cIik7XG4gICAgICAgICRmcmFtZS5hcHBlbmRUbyhcImJvZHlcIik7XG4gICAgfVxuXG5cbiAgICB2YXIgJGlmcmFtZSA9ICQoXCIjXCIgKyBzdHJGcmFtZU5hbWUpO1xuXG4gICAgLy8gc2hvdyBmcmFtZSBpZiBpbiBkZWJ1ZyBtb2RlXG4gICAgaWYgKCFvcHQuZGVidWcpICRpZnJhbWUuY3NzKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgd2lkdGg6IFwiMHB4XCIsXG4gICAgICAgIGhlaWdodDogXCIwcHhcIixcbiAgICAgICAgbGVmdDogXCItNjAwcHhcIixcbiAgICAgICAgdG9wOiBcIi02MDBweFwiXG4gICAgfSk7XG5cblxuICAgIC8vICRpZnJhbWUucmVhZHkoKSBhbmQgJGlmcmFtZS5sb2FkIHdlcmUgaW5jb25zaXN0ZW50IGJldHdlZW4gYnJvd3NlcnNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIEFkZCBkb2N0eXBlIHRvIGZpeCB0aGUgc3R5bGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHByaW50aW5nIGFuZCByZW5kZXJcbiAgICAgICAgZnVuY3Rpb24gc2V0RG9jVHlwZSgkaWZyYW1lLGRvY3R5cGUpe1xuICAgICAgICAgICAgdmFyIHdpbiwgZG9jO1xuICAgICAgICAgICAgd2luID0gJGlmcmFtZS5nZXQoMCk7XG4gICAgICAgICAgICB3aW4gPSB3aW4uY29udGVudFdpbmRvdyB8fCB3aW4uY29udGVudERvY3VtZW50IHx8IHdpbjtcbiAgICAgICAgICAgIGRvYyA9IHdpbi5kb2N1bWVudCB8fCB3aW4uY29udGVudERvY3VtZW50IHx8IHdpbjtcbiAgICAgICAgICAgIGRvYy5vcGVuKCk7XG4gICAgICAgICAgICBkb2Mud3JpdGUoZG9jdHlwZSk7XG4gICAgICAgICAgICBkb2MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihvcHQuZG9jdHlwZVN0cmluZyl7XG4gICAgICAgICAgICBzZXREb2NUeXBlKCRpZnJhbWUsb3B0LmRvY3R5cGVTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRkb2MgPSAkaWZyYW1lLmNvbnRlbnRzKCksXG4gICAgICAgICAgICAkaGVhZCA9ICRkb2MuZmluZChcImhlYWRcIiksXG4gICAgICAgICAgICAkYm9keSA9ICRkb2MuZmluZChcImJvZHlcIik7XG5cbiAgICAgICAgLy8gYWRkIGJhc2UgdGFnIHRvIGVuc3VyZSBlbGVtZW50cyB1c2UgdGhlIHBhcmVudCBkb21haW5cbiAgICAgICAgJGhlYWQuYXBwZW5kKCc8YmFzZSBocmVmPVwiJyArIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGRvY3VtZW50LmxvY2F0aW9uLmhvc3QgKyAnXCI+Jyk7XG5cbiAgICAgICAgLy8gaW1wb3J0IHBhZ2Ugc3R5bGVzaGVldHNcbiAgICAgICAgaWYgKG9wdC5pbXBvcnRDU1MpICQoXCJsaW5rW3JlbD1zdHlsZXNoZWV0XVwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhyZWYgPSAkKHRoaXMpLmF0dHIoXCJocmVmXCIpO1xuICAgICAgICAgICAgaWYgKGhyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWEgPSAkKHRoaXMpLmF0dHIoXCJtZWRpYVwiKSB8fCBcImFsbFwiO1xuICAgICAgICAgICAgICAgICRoZWFkLmFwcGVuZChcIjxsaW5rIHR5cGU9J3RleHQvY3NzJyByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J1wiICsgaHJlZiArIFwiJyBtZWRpYT0nXCIgKyBtZWRpYSArIFwiJz5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW1wb3J0IHN0eWxlIHRhZ3NcbiAgICAgICAgaWYgKG9wdC5pbXBvcnRTdHlsZSkgJChcInN0eWxlXCIpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmNsb25lKCkuYXBwZW5kVG8oJGhlYWQpO1xuICAgICAgICAgICAgLy8kaGVhZC5hcHBlbmQoJCh0aGlzKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vYWRkIHRpdGxlIG9mIHRoZSBwYWdlXG4gICAgICAgIGlmIChvcHQucGFnZVRpdGxlKSAkaGVhZC5hcHBlbmQoXCI8dGl0bGU+XCIgKyBvcHQucGFnZVRpdGxlICsgXCI8L3RpdGxlPlwiKTtcblxuICAgICAgICAvLyBpbXBvcnQgYWRkaXRpb25hbCBzdHlsZXNoZWV0KHMpXG4gICAgICAgIGlmIChvcHQubG9hZENTUykge1xuICAgICAgICAgICBpZiggJC5pc0FycmF5KG9wdC5sb2FkQ1NTKSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKG9wdC5sb2FkQ1NTLCBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAkaGVhZC5hcHBlbmQoXCI8bGluayB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSdcIiArIHRoaXMgKyBcIic+XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkaGVhZC5hcHBlbmQoXCI8bGluayB0eXBlPSd0ZXh0L2NzcycgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSdcIiArIG9wdC5sb2FkQ1NTICsgXCInPlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByaW50IGhlYWRlclxuICAgICAgICBpZiAob3B0LmhlYWRlcikgJGJvZHkuYXBwZW5kKG9wdC5oZWFkZXIpO1xuXG4gICAgICAgIC8vIGdyYWIgJC5zZWxlY3RvciBhcyBjb250YWluZXJcbiAgICAgICAgaWYgKG9wdC5wcmludENvbnRhaW5lcikgJGJvZHkuYXBwZW5kKCRlbGVtZW50Lm91dGVyKCkpO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHByaW50IGludGVyaW9yIGVsZW1lbnRzIG9mIGNvbnRhaW5lclxuICAgICAgICBlbHNlICRlbGVtZW50LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkYm9keS5hcHBlbmQoJCh0aGlzKS5odG1sKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYXB0dXJlIGZvcm0vZmllbGQgdmFsdWVzXG4gICAgICAgIGlmIChvcHQuZm9ybVZhbHVlcykge1xuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGlucHV0c1xuICAgICAgICAgICAgdmFyICRpbnB1dCA9ICRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpZiAoJGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICRpbnB1dC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWUgPSAkKHRoaXMpLmF0dHIoJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRjaGVja2VyID0gJHRoaXMuaXMoJzpjaGVja2JveCcpIHx8ICR0aGlzLmlzKCc6cmFkaW8nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dCA9ICRkb2MuZmluZCgnaW5wdXRbbmFtZT1cIicgKyAkbmFtZSArICdcIl0nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vb3JkZXIgbWF0dGVycyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICghJGNoZWNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dC52YWwoJHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdGhpcy5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzLmlzKCc6Y2hlY2tib3gnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpZnJhbWVJbnB1dC5hdHRyKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHRoaXMuaXMoJzpyYWRpbycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvYy5maW5kKCdpbnB1dFtuYW1lPVwiJyArICRuYW1lICsgJ1wiXVt2YWx1ZT0nICsgJHZhbHVlICsgJ10nKS5hdHRyKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHNlbGVjdHNcbiAgICAgICAgICAgIHZhciAkc2VsZWN0ID0gJGVsZW1lbnQuZmluZCgnc2VsZWN0Jyk7XG4gICAgICAgICAgICBpZiAoJHNlbGVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAkc2VsZWN0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAkbmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICRkb2MuZmluZCgnc2VsZWN0W25hbWU9XCInICsgJG5hbWUgKyAnXCJdJykudmFsKCR2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHRleHRhcmVhc1xuICAgICAgICAgICAgdmFyICR0ZXh0YXJlYSA9ICRlbGVtZW50LmZpbmQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICBpZiAoJHRleHRhcmVhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICR0ZXh0YXJlYS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJG5hbWUgPSAkKHRoaXMpLmF0dHIoJ25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICR2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAkZG9jLmZpbmQoJ3RleHRhcmVhW25hbWU9XCInICsgJG5hbWUgKyAnXCJdJykudmFsKCR2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZW5kIGNhcHR1cmUgZm9ybS9maWVsZCB2YWx1ZXNcblxuICAgICAgICAvLyByZW1vdmUgaW5saW5lIHN0eWxlc1xuICAgICAgICBpZiAob3B0LnJlbW92ZUlubGluZSkge1xuICAgICAgICAgICAgLy8gJC5yZW1vdmVBdHRyIGF2YWlsYWJsZSBqUXVlcnkgMS43K1xuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbigkLnJlbW92ZUF0dHIpKSB7XG4gICAgICAgICAgICAgICAgJGRvYy5maW5kKFwiYm9keSAqXCIpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJGRvYy5maW5kKFwiYm9keSAqXCIpLmF0dHIoXCJzdHlsZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoJGlmcmFtZS5oYXNDbGFzcyhcIk1TSUVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgaWZyYW1lIHdhcyBjcmVhdGVkIHdpdGggdGhlIHVnbHkgaGFja1xuICAgICAgICAgICAgICAgIC8vIGFuZCBwZXJmb3JtIGFub3RoZXIgdWdseSBoYWNrIG91dCBvZiBuZWNjZXNzaXR5XG4gICAgICAgICAgICAgICAgd2luZG93LmZyYW1lc1tcInByaW50SWZyYW1lXCJdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJGhlYWQuYXBwZW5kKFwiPHNjcmlwdD4gIHdpbmRvdy5wcmludCgpOyA8L3NjcmlwdD5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHByb3BlciBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKFwicHJpbnRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgJGlmcmFtZVswXS5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKFwicHJpbnRcIiwgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRpZnJhbWVbMF0uY29udGVudFdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAkaWZyYW1lWzBdLmNvbnRlbnRXaW5kb3cucHJpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vcmVtb3ZlIGlmcmFtZSBhZnRlciBwcmludFxuICAgICAgICAgICAgaWYgKCFvcHQuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkaWZyYW1lLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sIG9wdC5wcmludERlbGF5KTtcblxuICAgIH0sIDMzMyk7XG5cbn07XG5cbi8vIGRlZmF1bHRzXG4kLmZuLnByaW50VGhpcy5kZWZhdWx0cyA9IHtcbiAgICBkZWJ1ZzogZmFsc2UsICAgICAgICAgICAvLyBzaG93IHRoZSBpZnJhbWUgZm9yIGRlYnVnZ2luZ1xuICAgIGltcG9ydENTUzogdHJ1ZSwgICAgICAgIC8vIGltcG9ydCBwYXJlbnQgcGFnZSBjc3NcbiAgICBpbXBvcnRTdHlsZTogZmFsc2UsICAgICAvLyBpbXBvcnQgc3R5bGUgdGFnc1xuICAgIHByaW50Q29udGFpbmVyOiB0cnVlLCAgIC8vIHByaW50IG91dGVyIGNvbnRhaW5lci8kLnNlbGVjdG9yXG4gICAgbG9hZENTUzogXCJcIiwgICAgICAgICAgICAvLyBsb2FkIGFuIGFkZGl0aW9uYWwgY3NzIGZpbGUgLSBsb2FkIG11bHRpcGxlIHN0eWxlc2hlZXRzIHdpdGggYW4gYXJyYXkgW11cbiAgICBwYWdlVGl0bGU6IFwiXCIsICAgICAgICAgIC8vIGFkZCB0aXRsZSB0byBwcmludCBwYWdlXG4gICAgcmVtb3ZlSW5saW5lOiBmYWxzZSwgICAgLy8gcmVtb3ZlIGFsbCBpbmxpbmUgc3R5bGVzXG4gICAgcHJpbnREZWxheTogMzMzLCAgICAgICAgLy8gdmFyaWFibGUgcHJpbnQgZGVsYXlcbiAgICBoZWFkZXI6IG51bGwsICAgICAgICAgICAvLyBwcmVmaXggdG8gaHRtbFxuICAgIGZvcm1WYWx1ZXM6IHRydWUsICAgICAgICAvLyBwcmVzZXJ2ZSBpbnB1dC9mb3JtIHZhbHVlc1xuICAgIGRvY3R5cGVTdHJpbmc6ICc8IURPQ1RZUEUgaHRtbD4nIC8vIGh0bWwgZG9jdHlwZVxufTtcbn0pKGpRdWVyeSk7XG5cbi8vICQuc2VsZWN0b3IgY29udGFpbmVyXG5qUXVlcnkuZm4ub3V0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJCgkKFwiPGRpdj48L2Rpdj5cIikuaHRtbCh0aGlzLmNsb25lKCkpKS5odG1sKClcbn0iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogdHJhbnNpdGlvbi5qcyB2My4zLjVcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RyYW5zaXRpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZCgpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9vdHN0cmFwJylcblxuICAgICAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICAgICAgICBpZiAoZWwuc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuZDogdHJhbnNFbmRFdmVudE5hbWVzW25hbWVdIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZVxuICAgICAgICB2YXIgJGVsID0gdGhpc1xuICAgICAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgaWYgKCFjYWxsZWQpICQoJGVsKS50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCkgfVxuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkdXJhdGlvbilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRW5kKClcblxuICAgICAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICAgICAkLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kID0ge1xuICAgICAgICAgICAgYmluZFR5cGU6ICQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxcbiAgICAgICAgICAgIGRlbGVnYXRlVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxufShqUXVlcnkpOyIsInZhciBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycycpO1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdpZkNvbmQnLCBmdW5jdGlvbiAodjEsIG9wZXJhdG9yLCB2Miwgb3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxID09IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxID09PSB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPCB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICByZXR1cm4gKHYxIDw9IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICh2MSA+IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHJldHVybiAodjEgPj0gdjIpID8gb3B0aW9ucy5mbih0aGlzKSA6IG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgcmV0dXJuICh2MSAmJiB2MikgPyBvcHRpb25zLmZuKHRoaXMpIDogb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICByZXR1cm4gKHYxIHx8IHYyKSA/IG9wdGlvbnMuZm4odGhpcykgOiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLkhhbmRsZWJhcnMgPSBIYW5kbGViYXJzO1xuXG4iLCIvKiEgalF1ZXJ5IFRpbWVwaWNrZXIgQWRkb24gLSB2MS42LjMgLSAyMDE2LTA0LTIwXHJcbiogaHR0cDovL3RyZW50cmljaGFyZHNvbi5jb20vZXhhbXBsZXMvdGltZXBpY2tlclxyXG4qIENvcHlyaWdodCAoYykgMjAxNiBUcmVudCBSaWNoYXJkc29uOyBMaWNlbnNlZCBNSVQgKi9cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0ZGVmaW5lKFsnanF1ZXJ5JywgJ2pxdWVyeS11aSddLCBmYWN0b3J5KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xyXG5cdH1cclxufShmdW5jdGlvbiAoJCkge1xyXG5cclxuXHQvKlxyXG5cdCogTGV0cyBub3QgcmVkZWZpbmUgdGltZXBpY2tlciwgUHJldmVudCBcIlVuY2F1Z2h0IFJhbmdlRXJyb3I6IE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcclxuXHQqL1xyXG4gICAgJC51aSA9ICQudWkgfHwge307XHJcblx0JC51aS50aW1lcGlja2VyID0gJC51aS50aW1lcGlja2VyIHx8IHt9O1xyXG5cdGlmICgkLnVpLnRpbWVwaWNrZXIudmVyc2lvbikge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0LypcclxuXHQqIEV4dGVuZCBqUXVlcnlVSSwgZ2V0IGl0IHN0YXJ0ZWQgd2l0aCBvdXIgdmVyc2lvbiBudW1iZXJcclxuXHQqL1xyXG5cdCQuZXh0ZW5kKCQudWksIHtcclxuXHRcdHRpbWVwaWNrZXI6IHtcclxuXHRcdFx0dmVyc2lvbjogXCIxLjYuM1wiXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8qXHJcblx0KiBUaW1lcGlja2VyIG1hbmFnZXIuXHJcblx0KiBVc2UgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCAkLnRpbWVwaWNrZXIsIHRvIGludGVyYWN0IHdpdGggdGhlIHRpbWUgcGlja2VyLlxyXG5cdCogU2V0dGluZ3MgZm9yIChncm91cHMgb2YpIHRpbWUgcGlja2VycyBhcmUgbWFpbnRhaW5lZCBpbiBhbiBpbnN0YW5jZSBvYmplY3QsXHJcblx0KiBhbGxvd2luZyBtdWx0aXBsZSBkaWZmZXJlbnQgc2V0dGluZ3Mgb24gdGhlIHNhbWUgcGFnZS5cclxuXHQqL1xyXG5cdHZhciBUaW1lcGlja2VyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5yZWdpb25hbCA9IFtdOyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UgY29kZVxyXG5cdFx0dGhpcy5yZWdpb25hbFsnJ10gPSB7IC8vIERlZmF1bHQgcmVnaW9uYWwgc2V0dGluZ3NcclxuXHRcdFx0Y3VycmVudFRleHQ6ICdOb3cnLFxyXG5cdFx0XHRjbG9zZVRleHQ6ICdEb25lJyxcclxuXHRcdFx0YW1OYW1lczogWydBTScsICdBJ10sXHJcblx0XHRcdHBtTmFtZXM6IFsnUE0nLCAnUCddLFxyXG5cdFx0XHR0aW1lRm9ybWF0OiAnSEg6bW0nLFxyXG5cdFx0XHR0aW1lU3VmZml4OiAnJyxcclxuXHRcdFx0dGltZU9ubHlUaXRsZTogJ0Nob29zZSBUaW1lJyxcclxuXHRcdFx0dGltZVRleHQ6ICdUaW1lJyxcclxuXHRcdFx0aG91clRleHQ6ICdIb3VyJyxcclxuXHRcdFx0bWludXRlVGV4dDogJ01pbnV0ZScsXHJcblx0XHRcdHNlY29uZFRleHQ6ICdTZWNvbmQnLFxyXG5cdFx0XHRtaWxsaXNlY1RleHQ6ICdNaWxsaXNlY29uZCcsXHJcblx0XHRcdG1pY3Jvc2VjVGV4dDogJ01pY3Jvc2Vjb25kJyxcclxuXHRcdFx0dGltZXpvbmVUZXh0OiAnVGltZSBab25lJyxcclxuXHRcdFx0aXNSVEw6IGZhbHNlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5fZGVmYXVsdHMgPSB7IC8vIEdsb2JhbCBkZWZhdWx0cyBmb3IgYWxsIHRoZSBkYXRldGltZSBwaWNrZXIgaW5zdGFuY2VzXHJcblx0XHRcdHNob3dCdXR0b25QYW5lbDogdHJ1ZSxcclxuXHRcdFx0dGltZU9ubHk6IGZhbHNlLFxyXG5cdFx0XHR0aW1lT25seVNob3dEYXRlOiBmYWxzZSxcclxuXHRcdFx0c2hvd0hvdXI6IG51bGwsXHJcblx0XHRcdHNob3dNaW51dGU6IG51bGwsXHJcblx0XHRcdHNob3dTZWNvbmQ6IG51bGwsXHJcblx0XHRcdHNob3dNaWxsaXNlYzogbnVsbCxcclxuXHRcdFx0c2hvd01pY3Jvc2VjOiBudWxsLFxyXG5cdFx0XHRzaG93VGltZXpvbmU6IG51bGwsXHJcblx0XHRcdHNob3dUaW1lOiB0cnVlLFxyXG5cdFx0XHRzdGVwSG91cjogMSxcclxuXHRcdFx0c3RlcE1pbnV0ZTogMSxcclxuXHRcdFx0c3RlcFNlY29uZDogMSxcclxuXHRcdFx0c3RlcE1pbGxpc2VjOiAxLFxyXG5cdFx0XHRzdGVwTWljcm9zZWM6IDEsXHJcblx0XHRcdGhvdXI6IDAsXHJcblx0XHRcdG1pbnV0ZTogMCxcclxuXHRcdFx0c2Vjb25kOiAwLFxyXG5cdFx0XHRtaWxsaXNlYzogMCxcclxuXHRcdFx0bWljcm9zZWM6IDAsXHJcblx0XHRcdHRpbWV6b25lOiBudWxsLFxyXG5cdFx0XHRob3VyTWluOiAwLFxyXG5cdFx0XHRtaW51dGVNaW46IDAsXHJcblx0XHRcdHNlY29uZE1pbjogMCxcclxuXHRcdFx0bWlsbGlzZWNNaW46IDAsXHJcblx0XHRcdG1pY3Jvc2VjTWluOiAwLFxyXG5cdFx0XHRob3VyTWF4OiAyMyxcclxuXHRcdFx0bWludXRlTWF4OiA1OSxcclxuXHRcdFx0c2Vjb25kTWF4OiA1OSxcclxuXHRcdFx0bWlsbGlzZWNNYXg6IDk5OSxcclxuXHRcdFx0bWljcm9zZWNNYXg6IDk5OSxcclxuXHRcdFx0bWluRGF0ZVRpbWU6IG51bGwsXHJcblx0XHRcdG1heERhdGVUaW1lOiBudWxsLFxyXG5cdFx0XHRtYXhUaW1lOiBudWxsLFxyXG5cdFx0XHRtaW5UaW1lOiBudWxsLFxyXG5cdFx0XHRvblNlbGVjdDogbnVsbCxcclxuXHRcdFx0aG91ckdyaWQ6IDAsXHJcblx0XHRcdG1pbnV0ZUdyaWQ6IDAsXHJcblx0XHRcdHNlY29uZEdyaWQ6IDAsXHJcblx0XHRcdG1pbGxpc2VjR3JpZDogMCxcclxuXHRcdFx0bWljcm9zZWNHcmlkOiAwLFxyXG5cdFx0XHRhbHdheXNTZXRUaW1lOiB0cnVlLFxyXG5cdFx0XHRzZXBhcmF0b3I6ICcgJyxcclxuXHRcdFx0YWx0RmllbGRUaW1lT25seTogdHJ1ZSxcclxuXHRcdFx0YWx0VGltZUZvcm1hdDogbnVsbCxcclxuXHRcdFx0YWx0U2VwYXJhdG9yOiBudWxsLFxyXG5cdFx0XHRhbHRUaW1lU3VmZml4OiBudWxsLFxyXG5cdFx0XHRhbHRSZWRpcmVjdEZvY3VzOiB0cnVlLFxyXG5cdFx0XHRwaWNrZXJUaW1lRm9ybWF0OiBudWxsLFxyXG5cdFx0XHRwaWNrZXJUaW1lU3VmZml4OiBudWxsLFxyXG5cdFx0XHRzaG93VGltZXBpY2tlcjogdHJ1ZSxcclxuXHRcdFx0dGltZXpvbmVMaXN0OiBudWxsLFxyXG5cdFx0XHRhZGRTbGlkZXJBY2Nlc3M6IGZhbHNlLFxyXG5cdFx0XHRzbGlkZXJBY2Nlc3NBcmdzOiBudWxsLFxyXG5cdFx0XHRjb250cm9sVHlwZTogJ3NsaWRlcicsXHJcblx0XHRcdG9uZUxpbmU6IGZhbHNlLFxyXG5cdFx0XHRkZWZhdWx0VmFsdWU6IG51bGwsXHJcblx0XHRcdHBhcnNlOiAnc3RyaWN0JyxcclxuXHRcdFx0YWZ0ZXJJbmplY3Q6IG51bGxcclxuXHRcdH07XHJcblx0XHQkLmV4dGVuZCh0aGlzLl9kZWZhdWx0cywgdGhpcy5yZWdpb25hbFsnJ10pO1xyXG5cdH07XHJcblxyXG5cdCQuZXh0ZW5kKFRpbWVwaWNrZXIucHJvdG90eXBlLCB7XHJcblx0XHQkaW5wdXQ6IG51bGwsXHJcblx0XHQkYWx0SW5wdXQ6IG51bGwsXHJcblx0XHQkdGltZU9iajogbnVsbCxcclxuXHRcdGluc3Q6IG51bGwsXHJcblx0XHRob3VyX3NsaWRlcjogbnVsbCxcclxuXHRcdG1pbnV0ZV9zbGlkZXI6IG51bGwsXHJcblx0XHRzZWNvbmRfc2xpZGVyOiBudWxsLFxyXG5cdFx0bWlsbGlzZWNfc2xpZGVyOiBudWxsLFxyXG5cdFx0bWljcm9zZWNfc2xpZGVyOiBudWxsLFxyXG5cdFx0dGltZXpvbmVfc2VsZWN0OiBudWxsLFxyXG5cdFx0bWF4VGltZTogbnVsbCxcclxuXHRcdG1pblRpbWU6IG51bGwsXHJcblx0XHRob3VyOiAwLFxyXG5cdFx0bWludXRlOiAwLFxyXG5cdFx0c2Vjb25kOiAwLFxyXG5cdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRtaWNyb3NlYzogMCxcclxuXHRcdHRpbWV6b25lOiBudWxsLFxyXG5cdFx0aG91ck1pbk9yaWdpbmFsOiBudWxsLFxyXG5cdFx0bWludXRlTWluT3JpZ2luYWw6IG51bGwsXHJcblx0XHRzZWNvbmRNaW5PcmlnaW5hbDogbnVsbCxcclxuXHRcdG1pbGxpc2VjTWluT3JpZ2luYWw6IG51bGwsXHJcblx0XHRtaWNyb3NlY01pbk9yaWdpbmFsOiBudWxsLFxyXG5cdFx0aG91ck1heE9yaWdpbmFsOiBudWxsLFxyXG5cdFx0bWludXRlTWF4T3JpZ2luYWw6IG51bGwsXHJcblx0XHRzZWNvbmRNYXhPcmlnaW5hbDogbnVsbCxcclxuXHRcdG1pbGxpc2VjTWF4T3JpZ2luYWw6IG51bGwsXHJcblx0XHRtaWNyb3NlY01heE9yaWdpbmFsOiBudWxsLFxyXG5cdFx0YW1wbTogJycsXHJcblx0XHRmb3JtYXR0ZWREYXRlOiAnJyxcclxuXHRcdGZvcm1hdHRlZFRpbWU6ICcnLFxyXG5cdFx0Zm9ybWF0dGVkRGF0ZVRpbWU6ICcnLFxyXG5cdFx0dGltZXpvbmVMaXN0OiBudWxsLFxyXG5cdFx0dW5pdHM6IFsnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2VjJywgJ21pY3Jvc2VjJ10sXHJcblx0XHRzdXBwb3J0OiB7fSxcclxuXHRcdGNvbnRyb2w6IG51bGwsXHJcblxyXG5cdFx0LypcclxuXHRcdCogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHRpbWUgcGlja2VyLlxyXG5cdFx0KiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBhcyBkZWZhdWx0cyAoYW5vbnltb3VzIG9iamVjdClcclxuXHRcdCogQHJldHVybiB7T2JqZWN0fSB0aGUgbWFuYWdlciBvYmplY3RcclxuXHRcdCovXHJcblx0XHRzZXREZWZhdWx0czogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0XHRcdGV4dGVuZFJlbW92ZSh0aGlzLl9kZWZhdWx0cywgc2V0dGluZ3MgfHwge30pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogQ3JlYXRlIGEgbmV3IFRpbWVwaWNrZXIgaW5zdGFuY2VcclxuXHRcdCovXHJcblx0XHRfbmV3SW5zdDogZnVuY3Rpb24gKCRpbnB1dCwgb3B0cykge1xyXG5cdFx0XHR2YXIgdHBfaW5zdCA9IG5ldyBUaW1lcGlja2VyKCksXHJcblx0XHRcdFx0aW5saW5lU2V0dGluZ3MgPSB7fSxcclxuXHRcdFx0XHRmbnMgPSB7fSxcclxuXHRcdFx0XHRvdmVycmlkZXMsIGk7XHJcblxyXG5cdFx0XHRmb3IgKHZhciBhdHRyTmFtZSBpbiB0aGlzLl9kZWZhdWx0cykge1xyXG5cdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcclxuXHRcdFx0XHRcdHZhciBhdHRyVmFsdWUgPSAkaW5wdXQuYXR0cigndGltZTonICsgYXR0ck5hbWUpO1xyXG5cdFx0XHRcdFx0aWYgKGF0dHJWYWx1ZSkge1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlubGluZVNldHRpbmdzW2F0dHJOYW1lXSA9IGV2YWwoYXR0clZhbHVlKTtcclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5saW5lU2V0dGluZ3NbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvdmVycmlkZXMgPSB7XHJcblx0XHRcdFx0YmVmb3JlU2hvdzogZnVuY3Rpb24gKGlucHV0LCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLmJlZm9yZVNob3cpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5iZWZvcmVTaG93LmNhbGwoJGlucHV0WzBdLCBpbnB1dCwgZHBfaW5zdCwgdHBfaW5zdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvbkNoYW5nZU1vbnRoWWVhcjogZnVuY3Rpb24gKHllYXIsIG1vbnRoLCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHQvLyBVcGRhdGUgdGhlIHRpbWUgYXMgd2VsbCA6IHRoaXMgcHJldmVudHMgdGhlIHRpbWUgZnJvbSBkaXNhcHBlYXJpbmcgZnJvbSB0aGUgJGlucHV0IGZpZWxkLlxyXG5cdFx0XHRcdFx0Ly8gdHBfaW5zdC5fdXBkYXRlRGF0ZVRpbWUoZHBfaW5zdCk7XHJcblx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLm9uQ2hhbmdlTW9udGhZZWFyKSkge1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNoYW5nZU1vbnRoWWVhci5jYWxsKCRpbnB1dFswXSwgeWVhciwgbW9udGgsIGRwX2luc3QsIHRwX2luc3QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBkcF9pbnN0KSB7XHJcblx0XHRcdFx0XHRpZiAodHBfaW5zdC50aW1lRGVmaW5lZCA9PT0gdHJ1ZSAmJiAkaW5wdXQudmFsKCkgIT09ICcnKSB7XHJcblx0XHRcdFx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGRwX2luc3QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCQuaXNGdW5jdGlvbih0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlKSkge1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ldm50cy5vbkNsb3NlLmNhbGwoJGlucHV0WzBdLCBkYXRlVGV4dCwgZHBfaW5zdCwgdHBfaW5zdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRmb3IgKGkgaW4gb3ZlcnJpZGVzKSB7XHJcblx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0Zm5zW2ldID0gb3B0c1tpXSB8fCB0aGlzLl9kZWZhdWx0c1tpXSB8fCBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgdGhpcy5fZGVmYXVsdHMsIGlubGluZVNldHRpbmdzLCBvcHRzLCBvdmVycmlkZXMsIHtcclxuXHRcdFx0XHRldm50czogZm5zLFxyXG5cdFx0XHRcdHRpbWVwaWNrZXI6IHRwX2luc3QgLy8gYWRkIHRpbWVwaWNrZXIgYXMgYSBwcm9wZXJ0eSBvZiBkYXRlcGlja2VyOiAkLmRhdGVwaWNrZXIuX2dldChkcF9pbnN0LCAndGltZXBpY2tlcicpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dHBfaW5zdC5hbU5hbWVzID0gJC5tYXAodHBfaW5zdC5fZGVmYXVsdHMuYW1OYW1lcywgZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0XHRcdHJldHVybiB2YWwudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRwX2luc3QucG1OYW1lcyA9ICQubWFwKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMsIGZ1bmN0aW9uICh2YWwpIHtcclxuXHRcdFx0XHRyZXR1cm4gdmFsLnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gZGV0ZWN0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcclxuXHRcdFx0dHBfaW5zdC5zdXBwb3J0ID0gZGV0ZWN0U3VwcG9ydChcclxuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQgK1xyXG5cdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLnBpY2tlclRpbWVGb3JtYXQgPyB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IDogJycpICtcclxuXHRcdFx0XHRcdCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0ID8gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZUZvcm1hdCA6ICcnKSk7XHJcblxyXG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBzdHJpbmcgLSBrZXkgdG8gb3VyIHRoaXMuX2NvbnRyb2xzXHJcblx0XHRcdGlmICh0eXBlb2YodHBfaW5zdC5fZGVmYXVsdHMuY29udHJvbFR5cGUpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZSA9PT0gJ3NsaWRlcicgJiYgdHlwZW9mKCQudWkuc2xpZGVyKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlID0gJ3NlbGVjdCc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRwX2luc3QuY29udHJvbCA9IHRwX2luc3QuX2NvbnRyb2xzW3RwX2luc3QuX2RlZmF1bHRzLmNvbnRyb2xUeXBlXTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBjb250cm9sVHlwZSBpcyBhbiBvYmplY3QgYW5kIG11c3QgaW1wbGVtZW50IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWUgbWV0aG9kc1xyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0cF9pbnN0LmNvbnRyb2wgPSB0cF9pbnN0Ll9kZWZhdWx0cy5jb250cm9sVHlwZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcHJlcCB0aGUgdGltZXpvbmUgb3B0aW9uc1xyXG5cdFx0XHR2YXIgdGltZXpvbmVMaXN0ID0gWy03MjAsIC02NjAsIC02MDAsIC01NzAsIC01NDAsIC00ODAsIC00MjAsIC0zNjAsIC0zMDAsIC0yNzAsIC0yNDAsIC0yMTAsIC0xODAsIC0xMjAsIC02MCxcclxuXHRcdFx0XHRcdDAsIDYwLCAxMjAsIDE4MCwgMjEwLCAyNDAsIDI3MCwgMzAwLCAzMzAsIDM0NSwgMzYwLCAzOTAsIDQyMCwgNDgwLCA1MjUsIDU0MCwgNTcwLCA2MDAsIDYzMCwgNjYwLCA2OTAsIDcyMCwgNzY1LCA3ODAsIDg0MF07XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3QgIT09IG51bGwpIHtcclxuXHRcdFx0XHR0aW1lem9uZUxpc3QgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Q7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHR6bCA9IHRpbWV6b25lTGlzdC5sZW5ndGgsIHR6aSA9IDAsIHR6diA9IG51bGw7XHJcblx0XHRcdGlmICh0emwgPiAwICYmIHR5cGVvZiB0aW1lem9uZUxpc3RbMF0gIT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0Zm9yICg7IHR6aSA8IHR6bDsgdHppKyspIHtcclxuXHRcdFx0XHRcdHR6diA9IHRpbWV6b25lTGlzdFt0emldO1xyXG5cdFx0XHRcdFx0dGltZXpvbmVMaXN0W3R6aV0gPSB7IHZhbHVlOiB0enYsIGxhYmVsOiAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcodHp2LCB0cF9pbnN0LnN1cHBvcnQuaXNvODYwMSkgfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmVMaXN0ID0gdGltZXpvbmVMaXN0O1xyXG5cclxuXHRcdFx0Ly8gc2V0IHRoZSBkZWZhdWx0IHVuaXRzXHJcblx0XHRcdHRwX2luc3QudGltZXpvbmUgPSB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSAhPT0gbnVsbCA/ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZSkgOlxyXG5cdFx0XHRcdFx0XHRcdCgobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xKTtcclxuXHRcdFx0dHBfaW5zdC5ob3VyID0gdHBfaW5zdC5fZGVmYXVsdHMuaG91ciA8IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyTWluIDpcclxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyID4gdHBfaW5zdC5fZGVmYXVsdHMuaG91ck1heCA/IHRwX2luc3QuX2RlZmF1bHRzLmhvdXJNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5ob3VyO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbnV0ZSA9IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZSA8IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbnV0ZU1pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWludXRlID4gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWludXRlTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWludXRlO1xyXG5cdFx0XHR0cF9pbnN0LnNlY29uZCA9IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZCA8IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA/IHRwX2luc3QuX2RlZmF1bHRzLnNlY29uZE1pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kID4gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMuc2Vjb25kO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWMgPCB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlY01pbiA/IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWluIDpcclxuXHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYyA+IHRwX2luc3QuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID8gdHBfaW5zdC5fZGVmYXVsdHMubWlsbGlzZWNNYXggOiB0cF9pbnN0Ll9kZWZhdWx0cy5taWxsaXNlYztcclxuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjIDwgdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWNNaW4gPyB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01pbiA6XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWMgPiB0cF9pbnN0Ll9kZWZhdWx0cy5taWNyb3NlY01heCA/IHRwX2luc3QuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IDogdHBfaW5zdC5fZGVmYXVsdHMubWljcm9zZWM7XHJcblx0XHRcdHRwX2luc3QuYW1wbSA9ICcnO1xyXG5cdFx0XHR0cF9pbnN0LiRpbnB1dCA9ICRpbnB1dDtcclxuXHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCkge1xyXG5cdFx0XHRcdHRwX2luc3QuJGFsdElucHV0ID0gJCh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZCk7XHJcblx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLmFsdFJlZGlyZWN0Rm9jdXMgPT09IHRydWUpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuJGFsdElucHV0LmNzcyh7XHJcblx0XHRcdFx0XHRcdGN1cnNvcjogJ3BvaW50ZXInXHJcblx0XHRcdFx0XHR9KS5mb2N1cyhmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdCRpbnB1dC50cmlnZ2VyKFwiZm9jdXNcIik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlID09PSAwIHx8IHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lID09PSAwKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPT09IDAgfHwgdHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZVRpbWUgPT09IDApIHtcclxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGF0ZXBpY2tlciBuZWVkcyBtaW5EYXRlL21heERhdGUsIHRpbWVwaWNrZXIgbmVlZHMgbWluRGF0ZVRpbWUvbWF4RGF0ZVRpbWUuLlxyXG5cdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5taW5EYXRlLmdldFRpbWUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lICE9PSB1bmRlZmluZWQgJiYgdHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZSA9IG5ldyBEYXRlKHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGVUaW1lLmdldFRpbWUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJiB0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbmV3IERhdGUodHBfaW5zdC5fZGVmYXVsdHMubWF4RGF0ZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZSAhPT0gdW5kZWZpbmVkICYmIHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGUgPSBuZXcgRGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlVGltZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRwX2luc3QuJGlucHV0LmJpbmQoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHRwX2luc3QuX29uRm9jdXMoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHBfaW5zdDtcclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogYWRkIG91ciBzbGlkZXJzIHRvIHRoZSBjYWxlbmRhclxyXG5cdFx0Ki9cclxuXHRcdF9hZGRUaW1lUGlja2VyOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgY3VyckRUID0gJC50cmltKCh0aGlzLiRhbHRJbnB1dCAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5KSA/IHRoaXMuJGlucHV0LnZhbCgpICsgJyAnICsgdGhpcy4kYWx0SW5wdXQudmFsKCkgOiB0aGlzLiRpbnB1dC52YWwoKSk7XHJcblxyXG5cdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGhpcy5fcGFyc2VUaW1lKGN1cnJEVCk7XHJcblx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUoZHBfaW5zdCwgZmFsc2UpO1xyXG5cdFx0XHR0aGlzLl9pbmplY3RUaW1lUGlja2VyKCk7XHJcblx0XHRcdHRoaXMuX2FmdGVySW5qZWN0KCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIHBhcnNlIHRoZSB0aW1lIHN0cmluZyBmcm9tIGlucHV0IHZhbHVlIG9yIF9zZXRUaW1lXHJcblx0XHQqL1xyXG5cdFx0X3BhcnNlVGltZTogZnVuY3Rpb24gKHRpbWVTdHJpbmcsIHdpdGhEYXRlKSB7XHJcblx0XHRcdGlmICghdGhpcy5pbnN0KSB7XHJcblx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHdpdGhEYXRlIHx8ICF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xyXG5cdFx0XHRcdHZhciBkcF9kYXRlRm9ybWF0ID0gJC5kYXRlcGlja2VyLl9nZXQodGhpcy5pbnN0LCAnZGF0ZUZvcm1hdCcpO1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZHBfZGF0ZUZvcm1hdCwgdGhpcy5fZGVmYXVsdHMudGltZUZvcm1hdCwgdGltZVN0cmluZywgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcodGhpcy5pbnN0KSwgdGhpcy5fZGVmYXVsdHMpO1xyXG5cdFx0XHRcdFx0aWYgKCFwYXJzZVJlcy50aW1lT2JqKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdCQuZXh0ZW5kKHRoaXMsIHBhcnNlUmVzLnRpbWVPYmopO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdFx0JC50aW1lcGlja2VyLmxvZyhcIkVycm9yIHBhcnNpbmcgdGhlIGRhdGUvdGltZSBzdHJpbmc6IFwiICsgZXJyICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlL3RpbWUgc3RyaW5nID0gXCIgKyB0aW1lU3RyaW5nICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG50aW1lRm9ybWF0ID0gXCIgKyB0aGlzLl9kZWZhdWx0cy50aW1lRm9ybWF0ICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XCJcXG5kYXRlRm9ybWF0ID0gXCIgKyBkcF9kYXRlRm9ybWF0KTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHRpbWVPYmogPSAkLmRhdGVwaWNrZXIucGFyc2VUaW1lKHRoaXMuX2RlZmF1bHRzLnRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIHRoaXMuX2RlZmF1bHRzKTtcclxuXHRcdFx0XHRpZiAoIXRpbWVPYmopIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JC5leHRlbmQodGhpcywgdGltZU9iaik7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogSGFuZGxlIGNhbGxiYWNrIG9wdGlvbiBhZnRlciBpbmplY3RpbmcgdGltZXBpY2tlclxyXG5cdFx0Ki9cclxuXHRcdF9hZnRlckluamVjdDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBvID0gdGhpcy5pbnN0LnNldHRpbmdzO1xyXG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKG8uYWZ0ZXJJbmplY3QpKSB7XHJcblx0XHRcdFx0by5hZnRlckluamVjdC5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGdlbmVyYXRlIGFuZCBpbmplY3QgaHRtbCBmb3IgdGltZXBpY2tlciBpbnRvIHVpIGRhdGVwaWNrZXJcclxuXHRcdCovXHJcblx0XHRfaW5qZWN0VGltZVBpY2tlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgJGRwID0gdGhpcy5pbnN0LmRwRGl2LFxyXG5cdFx0XHRcdG8gPSB0aGlzLmluc3Quc2V0dGluZ3MsXHJcblx0XHRcdFx0dHBfaW5zdCA9IHRoaXMsXHJcblx0XHRcdFx0bGl0ZW0gPSAnJyxcclxuXHRcdFx0XHR1aXRlbSA9ICcnLFxyXG5cdFx0XHRcdHNob3cgPSBudWxsLFxyXG5cdFx0XHRcdG1heCA9IHt9LFxyXG5cdFx0XHRcdGdyaWRTaXplID0ge30sXHJcblx0XHRcdFx0c2l6ZSA9IG51bGwsXHJcblx0XHRcdFx0aSA9IDAsXHJcblx0XHRcdFx0bCA9IDA7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IGRpc3BsYXlpbmcgdHdpY2VcclxuXHRcdFx0aWYgKCRkcC5maW5kKFwiZGl2LnVpLXRpbWVwaWNrZXItZGl2XCIpLmxlbmd0aCA9PT0gMCAmJiBvLnNob3dUaW1lcGlja2VyKSB7XHJcblx0XHRcdFx0dmFyIG5vRGlzcGxheSA9ICcgdWlfdHBpY2tlcl91bml0X2hpZGUnLFxyXG5cdFx0XHRcdFx0aHRtbCA9ICc8ZGl2IGNsYXNzPVwidWktdGltZXBpY2tlci1kaXYnICsgKG8uaXNSVEwgPyAnIHVpLXRpbWVwaWNrZXItcnRsJyA6ICcnKSArIChvLm9uZUxpbmUgJiYgby5jb250cm9sVHlwZSA9PT0gJ3NlbGVjdCcgPyAnIHVpLXRpbWVwaWNrZXItb25lTGluZScgOiAnJykgKyAnXCI+PGRsPicgKyAnPGR0IGNsYXNzPVwidWlfdHBpY2tlcl90aW1lX2xhYmVsJyArICgoby5zaG93VGltZSkgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZVRleHQgKyAnPC9kdD4nICtcclxuXHRcdFx0XHRcdFx0XHRcdCc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWUgJysgKChvLnNob3dUaW1lKSA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48aW5wdXQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWVfaW5wdXRcIiAnICsgKG8udGltZUlucHV0ID8gJycgOiAnZGlzYWJsZWQnKSArICcvPjwvZGQ+JztcclxuXHJcblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBtYXJrdXBcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy51bml0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpdGVtID0gdGhpcy51bml0c1tpXTtcclxuXHRcdFx0XHRcdHVpdGVtID0gbGl0ZW0uc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBsaXRlbS5zdWJzdHIoMSk7XHJcblx0XHRcdFx0XHRzaG93ID0gb1snc2hvdycgKyB1aXRlbV0gIT09IG51bGwgPyBvWydzaG93JyArIHVpdGVtXSA6IHRoaXMuc3VwcG9ydFtsaXRlbV07XHJcblxyXG5cdFx0XHRcdFx0Ly8gQWRkZWQgYnkgUGV0ZXIgTWVkZWlyb3M6XHJcblx0XHRcdFx0XHQvLyAtIEZpZ3VyZSBvdXQgd2hhdCB0aGUgaG91ci9taW51dGUvc2Vjb25kIG1heCBzaG91bGQgYmUgYmFzZWQgb24gdGhlIHN0ZXAgdmFsdWVzLlxyXG5cdFx0XHRcdFx0Ly8gLSBFeGFtcGxlOiBpZiBzdGVwTWludXRlIGlzIDE1LCB0aGVuIG1pbk1heCBpcyA0NS5cclxuXHRcdFx0XHRcdG1heFtsaXRlbV0gPSBwYXJzZUludCgob1tsaXRlbSArICdNYXgnXSAtICgob1tsaXRlbSArICdNYXgnXSAtIG9bbGl0ZW0gKyAnTWluJ10pICUgb1snc3RlcCcgKyB1aXRlbV0pKSwgMTApO1xyXG5cdFx0XHRcdFx0Z3JpZFNpemVbbGl0ZW1dID0gMDtcclxuXHJcblx0XHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyXycgKyBsaXRlbSArICdfbGFiZWwnICsgKHNob3cgPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG9bbGl0ZW0gKyAnVGV4dCddICsgJzwvZHQ+JyArXHJcblx0XHRcdFx0XHRcdFx0XHQnPGRkIGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48ZGl2IGNsYXNzPVwidWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicgKyAoc2hvdyA/ICcnIDogbm9EaXNwbGF5KSArICdcIj48L2Rpdj4nO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzaG93ICYmIG9bbGl0ZW0gKyAnR3JpZCddID4gMCkge1xyXG5cdFx0XHRcdFx0XHRodG1sICs9ICc8ZGl2IHN0eWxlPVwicGFkZGluZy1sZWZ0OiAxcHhcIj48dGFibGUgY2xhc3M9XCJ1aS10cGlja2VyLWdyaWQtbGFiZWxcIj48dHI+JztcclxuXHJcblx0XHRcdFx0XHRcdGlmIChsaXRlbSA9PT0gJ2hvdXInKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaCA9IG9bbGl0ZW0gKyAnTWluJ107IGggPD0gbWF4W2xpdGVtXTsgaCArPSBwYXJzZUludChvW2xpdGVtICsgJ0dyaWQnXSwgMTApKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRncmlkU2l6ZVtsaXRlbV0rKztcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB0bXBoID0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUodGhpcy5zdXBwb3J0LmFtcG0gPyAnaGh0JyA6ICdISCcsIHtob3VyOiBofSwgbyk7XHJcblx0XHRcdFx0XHRcdFx0XHRodG1sICs9ICc8dGQgZGF0YS1mb3I9XCInICsgbGl0ZW0gKyAnXCI+JyArIHRtcGggKyAnPC90ZD4nO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBtID0gb1tsaXRlbSArICdNaW4nXTsgbSA8PSBtYXhbbGl0ZW1dOyBtICs9IHBhcnNlSW50KG9bbGl0ZW0gKyAnR3JpZCddLCAxMCkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGdyaWRTaXplW2xpdGVtXSsrO1xyXG5cdFx0XHRcdFx0XHRcdFx0aHRtbCArPSAnPHRkIGRhdGEtZm9yPVwiJyArIGxpdGVtICsgJ1wiPicgKyAoKG0gPCAxMCkgPyAnMCcgOiAnJykgKyBtICsgJzwvdGQ+JztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGh0bWwgKz0gJzwvdHI+PC90YWJsZT48L2Rpdj4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aHRtbCArPSAnPC9kZD4nO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVGltZXpvbmVcclxuXHRcdFx0XHR2YXIgc2hvd1R6ID0gby5zaG93VGltZXpvbmUgIT09IG51bGwgPyBvLnNob3dUaW1lem9uZSA6IHRoaXMuc3VwcG9ydC50aW1lem9uZTtcclxuXHRcdFx0XHRodG1sICs9ICc8ZHQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lX2xhYmVsJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+JyArIG8udGltZXpvbmVUZXh0ICsgJzwvZHQ+JztcclxuXHRcdFx0XHRodG1sICs9ICc8ZGQgY2xhc3M9XCJ1aV90cGlja2VyX3RpbWV6b25lJyArIChzaG93VHogPyAnJyA6IG5vRGlzcGxheSkgKyAnXCI+PC9kZD4nO1xyXG5cclxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGVsZW1lbnRzIGZyb20gc3RyaW5nXHJcblx0XHRcdFx0aHRtbCArPSAnPC9kbD48L2Rpdj4nO1xyXG5cdFx0XHRcdHZhciAkdHAgPSAkKGh0bWwpO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB3ZSBvbmx5IHdhbnQgdGltZSBwaWNrZXIuLi5cclxuXHRcdFx0XHRpZiAoby50aW1lT25seSA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0JHRwLnByZXBlbmQoJzxkaXYgY2xhc3M9XCJ1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsXCI+JyArICc8ZGl2IGNsYXNzPVwidWktZGF0ZXBpY2tlci10aXRsZVwiPicgKyBvLnRpbWVPbmx5VGl0bGUgKyAnPC9kaXY+JyArICc8L2Rpdj4nKTtcclxuXHRcdFx0XHRcdCRkcC5maW5kKCcudWktZGF0ZXBpY2tlci1oZWFkZXIsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyJykuaGlkZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gYWRkIHNsaWRlcnMsIGFkanVzdCBncmlkcywgYWRkIGV2ZW50c1xyXG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB0cF9pbnN0LnVuaXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdFx0bGl0ZW0gPSB0cF9pbnN0LnVuaXRzW2ldO1xyXG5cdFx0XHRcdFx0dWl0ZW0gPSBsaXRlbS5zdWJzdHIoMCwgMSkudG9VcHBlckNhc2UoKSArIGxpdGVtLnN1YnN0cigxKTtcclxuXHRcdFx0XHRcdHNob3cgPSBvWydzaG93JyArIHVpdGVtXSAhPT0gbnVsbCA/IG9bJ3Nob3cnICsgdWl0ZW1dIDogdGhpcy5zdXBwb3J0W2xpdGVtXTtcclxuXHJcblx0XHRcdFx0XHQvLyBhZGQgdGhlIHNsaWRlclxyXG5cdFx0XHRcdFx0dHBfaW5zdFtsaXRlbSArICdfc2xpZGVyJ10gPSB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsICR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnX3NsaWRlcicpLCBsaXRlbSwgdHBfaW5zdFtsaXRlbV0sIG9bbGl0ZW0gKyAnTWluJ10sIG1heFtsaXRlbV0sIG9bJ3N0ZXAnICsgdWl0ZW1dKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhZGp1c3QgdGhlIGdyaWQgYW5kIGFkZCBjbGljayBldmVudFxyXG5cdFx0XHRcdFx0aWYgKHNob3cgJiYgb1tsaXRlbSArICdHcmlkJ10gPiAwKSB7XHJcblx0XHRcdFx0XHRcdHNpemUgPSAxMDAgKiBncmlkU2l6ZVtsaXRlbV0gKiBvW2xpdGVtICsgJ0dyaWQnXSAvIChtYXhbbGl0ZW1dIC0gb1tsaXRlbSArICdNaW4nXSk7XHJcblx0XHRcdFx0XHRcdCR0cC5maW5kKCcudWlfdHBpY2tlcl8nICsgbGl0ZW0gKyAnIHRhYmxlJykuY3NzKHtcclxuXHRcdFx0XHRcdFx0XHR3aWR0aDogc2l6ZSArIFwiJVwiLFxyXG5cdFx0XHRcdFx0XHRcdG1hcmdpbkxlZnQ6IG8uaXNSVEwgPyAnMCcgOiAoKHNpemUgLyAoLTIgKiBncmlkU2l6ZVtsaXRlbV0pKSArIFwiJVwiKSxcclxuXHRcdFx0XHRcdFx0XHRtYXJnaW5SaWdodDogby5pc1JUTCA/ICgoc2l6ZSAvICgtMiAqIGdyaWRTaXplW2xpdGVtXSkpICsgXCIlXCIpIDogJzAnLFxyXG5cdFx0XHRcdFx0XHRcdGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnXHJcblx0XHRcdFx0XHRcdH0pLmZpbmQoXCJ0ZFwiKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyICR0ID0gJCh0aGlzKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0aCA9ICR0Lmh0bWwoKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0biA9IHBhcnNlSW50KGgucmVwbGFjZSgvW14wLTldL2cpLCAxMCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGFwID0gaC5yZXBsYWNlKC9bXmFwbV0vaWcpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRmID0gJHQuZGF0YSgnZm9yJyk7IC8vIGxvc2VzIHNjb3BlLCBzbyB3ZSB1c2UgZGF0YS1mb3JcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoZiA9PT0gJ2hvdXInKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChhcC5pbmRleE9mKCdwJykgIT09IC0xICYmIG4gPCAxMikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG4gKz0gMTI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFwLmluZGV4T2YoJ2EnKSAhPT0gLTEgJiYgbiA9PT0gMTIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG4gPSAwO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCB0cF9pbnN0W2YgKyAnX3NsaWRlciddLCBsaXRlbSwgbik7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25UaW1lQ2hhbmdlKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHRcdFx0XHRcdFx0XHR9KS5jc3Moe1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3Vyc29yOiAncG9pbnRlcicsXHJcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogKDEwMCAvIGdyaWRTaXplW2xpdGVtXSkgKyAnJScsXHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG5cdFx0XHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9IC8vIGVuZCBpZiBncmlkID4gMFxyXG5cdFx0XHRcdH0gLy8gZW5kIGZvciBsb29wXHJcblxyXG5cdFx0XHRcdC8vIEFkZCB0aW1lem9uZSBvcHRpb25zXHJcblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QgPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZXpvbmUnKS5hcHBlbmQoJzxzZWxlY3Q+PC9zZWxlY3Q+JykuZmluZChcInNlbGVjdFwiKTtcclxuXHRcdFx0XHQkLmZuLmFwcGVuZC5hcHBseSh0aGlzLnRpbWV6b25lX3NlbGVjdCxcclxuXHRcdFx0XHQkLm1hcChvLnRpbWV6b25lTGlzdCwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJChcIjxvcHRpb24gLz5cIikudmFsKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgPyB2YWwudmFsdWUgOiB2YWwpLnRleHQodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiA/IHZhbC5sYWJlbCA6IHZhbCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YodGhpcy50aW1lem9uZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aGlzLnRpbWV6b25lICE9PSBcIlwiKSB7XHJcblx0XHRcdFx0XHR2YXIgbG9jYWxfdGltZXpvbmUgPSAobmV3IERhdGUodGhpcy5pbnN0LnNlbGVjdGVkWWVhciwgdGhpcy5pbnN0LnNlbGVjdGVkTW9udGgsIHRoaXMuaW5zdC5zZWxlY3RlZERheSwgMTIpKS5nZXRUaW1lem9uZU9mZnNldCgpICogLTE7XHJcblx0XHRcdFx0XHRpZiAobG9jYWxfdGltZXpvbmUgPT09IHRoaXMudGltZXpvbmUpIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudGltZXpvbmVfc2VsZWN0LnZhbCh0aGlzLnRpbWV6b25lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZih0aGlzLmhvdXIpICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMuaG91ciAhPT0gbnVsbCAmJiB0aGlzLmhvdXIgIT09IFwiXCIpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QudmFsKG8udGltZXpvbmUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c2VsZWN0TG9jYWxUaW1lem9uZSh0cF9pbnN0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy50aW1lem9uZV9zZWxlY3QuY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XHJcblx0XHRcdFx0XHR0cF9pbnN0Ll9hZnRlckluamVjdCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdC8vIEVuZCB0aW1lem9uZSBvcHRpb25zXHJcblxyXG5cdFx0XHRcdC8vIGluamVjdCB0aW1lcGlja2VyIGludG8gZGF0ZXBpY2tlclxyXG5cdFx0XHRcdHZhciAkYnV0dG9uUGFuZWwgPSAkZHAuZmluZCgnLnVpLWRhdGVwaWNrZXItYnV0dG9ucGFuZScpO1xyXG5cdFx0XHRcdGlmICgkYnV0dG9uUGFuZWwubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHQkYnV0dG9uUGFuZWwuYmVmb3JlKCR0cCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdCRkcC5hcHBlbmQoJHRwKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuJHRpbWVPYmogPSAkdHAuZmluZCgnLnVpX3RwaWNrZXJfdGltZV9pbnB1dCcpO1xyXG5cdFx0XHRcdHRoaXMuJHRpbWVPYmouY2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHZhciB0aW1lRm9ybWF0ID0gdHBfaW5zdC5pbnN0LnNldHRpbmdzLnRpbWVGb3JtYXQ7XHJcblx0XHRcdFx0XHR2YXIgcGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgdGhpcy52YWx1ZSk7XHJcblx0XHRcdFx0XHR2YXIgdXBkYXRlID0gbmV3IERhdGUoKTtcclxuXHRcdFx0XHRcdGlmIChwYXJzZWRUaW1lKSB7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRIb3VycyhwYXJzZWRUaW1lLmhvdXIpO1xyXG5cdFx0XHRcdFx0XHR1cGRhdGUuc2V0TWludXRlcyhwYXJzZWRUaW1lLm1pbnV0ZSk7XHJcblx0XHRcdFx0XHRcdHVwZGF0ZS5zZXRTZWNvbmRzKHBhcnNlZFRpbWUuc2Vjb25kKTtcclxuXHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl9zZXRUaW1lKHRwX2luc3QuaW5zdCwgdXBkYXRlKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0cF9pbnN0LmZvcm1hdHRlZFRpbWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuYmx1cigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5pbnN0ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgdGltZURlZmluZWQgPSB0aGlzLnRpbWVEZWZpbmVkO1xyXG5cdFx0XHRcdFx0dGhpcy5fb25UaW1lQ2hhbmdlKCk7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWVEZWZpbmVkID0gdGltZURlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvbjogaHR0cDovL3RyZW50cmljaGFyZHNvbi5jb20vMjAxMS8xMS8xMS9qcXVlcnktdWktc2xpZGVycy1hbmQtdG91Y2gtYWNjZXNzaWJpbGl0eS9cclxuXHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuYWRkU2xpZGVyQWNjZXNzKSB7XHJcblx0XHRcdFx0XHR2YXIgc2xpZGVyQWNjZXNzQXJncyA9IHRoaXMuX2RlZmF1bHRzLnNsaWRlckFjY2Vzc0FyZ3MsXHJcblx0XHRcdFx0XHRcdHJ0bCA9IHRoaXMuX2RlZmF1bHRzLmlzUlRMO1xyXG5cdFx0XHRcdFx0c2xpZGVyQWNjZXNzQXJncy5pc1JUTCA9IHJ0bDtcclxuXHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgLy8gZml4IGZvciBpbmxpbmUgbW9kZVxyXG5cdFx0XHRcdFx0XHRpZiAoJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzJykubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0JHRwLmZpbmQoJy51aS1zbGlkZXI6dmlzaWJsZScpLnNsaWRlckFjY2VzcyhzbGlkZXJBY2Nlc3NBcmdzKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZml4IGFueSBncmlkcyBzaW5jZSBzbGlkZXJzIGFyZSBzaG9ydGVyXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNsaWRlckFjY2Vzc1dpZHRoID0gJHRwLmZpbmQoJy51aS1zbGlkZXItYWNjZXNzOmVxKDApJykub3V0ZXJXaWR0aCh0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoc2xpZGVyQWNjZXNzV2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdCR0cC5maW5kKCd0YWJsZTp2aXNpYmxlJykuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciAkZyA9ICQodGhpcyksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkV2lkdGggPSAkZy5vdXRlcldpZHRoKCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2xkTWFyZ2luTGVmdCA9ICRnLmNzcyhydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnKS50b1N0cmluZygpLnJlcGxhY2UoJyUnLCAnJyksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3V2lkdGggPSBvbGRXaWR0aCAtIHNsaWRlckFjY2Vzc1dpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ld01hcmdpbkxlZnQgPSAoKG9sZE1hcmdpbkxlZnQgKiBuZXdXaWR0aCkgLyBvbGRXaWR0aCkgKyAnJScsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3NzID0geyB3aWR0aDogbmV3V2lkdGgsIG1hcmdpblJpZ2h0OiAwLCBtYXJnaW5MZWZ0OiAwIH07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNzc1tydGwgPyAnbWFyZ2luUmlnaHQnIDogJ21hcmdpbkxlZnQnXSA9IG5ld01hcmdpbkxlZnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCRnLmNzcyhjc3MpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCAxMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIGVuZCBzbGlkZUFjY2VzcyBpbnRlZ3JhdGlvblxyXG5cclxuXHRcdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKHRoaXMuaW5zdCwgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogVGhpcyBmdW5jdGlvbiB0cmllcyB0byBsaW1pdCB0aGUgYWJpbGl0eSB0byBnbyBvdXRzaWRlIHRoZVxyXG5cdFx0KiBtaW4vbWF4IGRhdGUgcmFuZ2VcclxuXHRcdCovXHJcblx0XHRfbGltaXRNaW5NYXhEYXRlVGltZTogZnVuY3Rpb24gKGRwX2luc3QsIGFkanVzdFNsaWRlcnMpIHtcclxuXHRcdFx0dmFyIG8gPSB0aGlzLl9kZWZhdWx0cyxcclxuXHRcdFx0XHRkcF9kYXRlID0gbmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSk7XHJcblxyXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IC8vIE5vIHRpbWUgc28gbm90aGluZyB0byBjaGVjayBoZXJlXHJcblxyXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IG51bGwgJiYgJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJykgIT09IHVuZGVmaW5lZCAmJiBkcF9kYXRlKSB7XHJcblx0XHRcdFx0dmFyIG1pbkRhdGVUaW1lID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ21pbkRhdGVUaW1lJyksXHJcblx0XHRcdFx0XHRtaW5EYXRlVGltZURhdGUgPSBuZXcgRGF0ZShtaW5EYXRlVGltZS5nZXRGdWxsWWVhcigpLCBtaW5EYXRlVGltZS5nZXRNb250aCgpLCBtaW5EYXRlVGltZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5ob3VyTWluT3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5taW51dGVNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLnNlY29uZE1pbk9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWwgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91ck1pbk9yaWdpbmFsID0gby5ob3VyTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGVNaW5PcmlnaW5hbCA9IG8ubWludXRlTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNaW5PcmlnaW5hbCA9IG8uc2Vjb25kTWluO1xyXG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01pbk9yaWdpbmFsID0gby5taWxsaXNlY01pbjtcclxuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbCA9IG8ubWljcm9zZWNNaW47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtaW5EYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IG1pbkRhdGVUaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyIDw9IHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1pbjtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gbWluRGF0ZVRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPD0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW47XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluID0gbWluRGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA8PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNaW4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjIDw9IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSBtaW5EYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjIDwgdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW47XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4gPSB0aGlzLm1pbGxpc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4gPSB0aGlzLm1pY3Jvc2VjTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbiA9IHRoaXMubWludXRlTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluID0gdGhpcy5taWxsaXNlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01pbiA9IHRoaXMubWljcm9zZWNNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbiA9IHRoaXMuaG91ck1pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWluID0gdGhpcy5taW51dGVNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1pbiA9IHRoaXMuc2Vjb25kTWluT3JpZ2luYWw7XHJcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01pbiA9IHRoaXMubWlsbGlzZWNNaW5PcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluID0gdGhpcy5taWNyb3NlY01pbk9yaWdpbmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSBudWxsICYmICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpICE9PSB1bmRlZmluZWQgJiYgZHBfZGF0ZSkge1xyXG5cdFx0XHRcdHZhciBtYXhEYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGRwX2luc3QsICdtYXhEYXRlVGltZScpLFxyXG5cdFx0XHRcdFx0bWF4RGF0ZVRpbWVEYXRlID0gbmV3IERhdGUobWF4RGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSwgbWF4RGF0ZVRpbWUuZ2V0TW9udGgoKSwgbWF4RGF0ZVRpbWUuZ2V0RGF0ZSgpLCAwLCAwLCAwLCAwKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuaG91ck1heE9yaWdpbmFsID09PSBudWxsIHx8IHRoaXMubWludXRlTWF4T3JpZ2luYWwgPT09IG51bGwgfHwgdGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9PT0gbnVsbCB8fCB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWwgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91ck1heE9yaWdpbmFsID0gby5ob3VyTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGVNYXhPcmlnaW5hbCA9IG8ubWludXRlTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmRNYXhPcmlnaW5hbCA9IG8uc2Vjb25kTWF4O1xyXG5cdFx0XHRcdFx0dGhpcy5taWxsaXNlY01heE9yaWdpbmFsID0gby5taWxsaXNlY01heDtcclxuXHRcdFx0XHRcdHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbCA9IG8ubWljcm9zZWNNYXg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoZHBfaW5zdC5zZXR0aW5ncy50aW1lT25seSB8fCBtYXhEYXRlVGltZURhdGUuZ2V0VGltZSgpID09PSBkcF9kYXRlLmdldFRpbWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IG1heERhdGVUaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5ob3VyID49IHRoaXMuX2RlZmF1bHRzLmhvdXJNYXgpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ob3VyID0gdGhpcy5fZGVmYXVsdHMuaG91ck1heDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5taW51dGUgPj0gdGhpcy5fZGVmYXVsdHMubWludXRlTWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5taW51dGUgPSB0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4ID0gbWF4RGF0ZVRpbWUuZ2V0U2Vjb25kcygpO1xyXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlY29uZCA+PSB0aGlzLl9kZWZhdWx0cy5zZWNvbmRNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2Vjb25kID0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4O1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pbGxpc2VjID49IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSB0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSBtYXhEYXRlVGltZS5nZXRNaWNyb3NlY29uZHMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm1pY3Jvc2VjID4gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm1pY3Jvc2VjID0gdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXg7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggPSB0aGlzLm1pbGxpc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWljcm9zZWNNYXggPSB0aGlzLm1pY3Jvc2VjTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCA9IHRoaXMubWludXRlTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4ID0gdGhpcy5taWxsaXNlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCA9IHRoaXMubWljcm9zZWNNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1heCA9IHRoaXMuaG91ck1heE9yaWdpbmFsO1xyXG5cdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4ID0gdGhpcy5taW51dGVNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCA9IHRoaXMuc2Vjb25kTWF4T3JpZ2luYWw7XHJcblx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taWxsaXNlY01heCA9IHRoaXMubWlsbGlzZWNNYXhPcmlnaW5hbDtcclxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4ID0gdGhpcy5taWNyb3NlY01heE9yaWdpbmFsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRwX2luc3Quc2V0dGluZ3MubWluVGltZSE9PW51bGwpIHtcclxuXHRcdFx0XHR2YXIgdGVtcE1pblRpbWU9bmV3IERhdGUoXCIwMS8wMS8xOTcwIFwiICsgZHBfaW5zdC5zZXR0aW5ncy5taW5UaW1lKTtcclxuXHRcdFx0XHRpZiAodGhpcy5ob3VyPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuaG91cj10aGlzLl9kZWZhdWx0cy5ob3VyTWluPXRlbXBNaW5UaW1lLmdldEhvdXJzKCk7XHJcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5ob3VyPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKSAmJiB0aGlzLm1pbnV0ZTx0ZW1wTWluVGltZS5nZXRNaW51dGVzKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMubWludXRlPXRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPHRlbXBNaW5UaW1lLmdldEhvdXJzKCkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMuaG91ck1pbj10ZW1wTWluVGltZS5nZXRIb3VycygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49dGVtcE1pblRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9kZWZhdWx0cy5ob3VyTWluPT09dGVtcE1pblRpbWUuZ2V0SG91cnMoKT09PXRoaXMuaG91ciAmJiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW48dGVtcE1pblRpbWUuZ2V0TWludXRlcygpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1pbj10ZW1wTWluVGltZS5nZXRNaW51dGVzKCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNaW49MDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkcF9pbnN0LnNldHRpbmdzLm1heFRpbWUhPT1udWxsKSB7XHJcblx0XHRcdFx0dmFyIHRlbXBNYXhUaW1lPW5ldyBEYXRlKFwiMDEvMDEvMTk3MCBcIiArIGRwX2luc3Quc2V0dGluZ3MubWF4VGltZSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuaG91cj50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XHJcblx0XHRcdFx0XHR0aGlzLmhvdXI9dGhpcy5fZGVmYXVsdHMuaG91ck1heD10ZW1wTWF4VGltZS5nZXRIb3VycygpO1xyXG5cdFx0XHRcdFx0dGhpcy5taW51dGU9dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuaG91cj09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCkgJiYgdGhpcy5taW51dGU+dGVtcE1heFRpbWUuZ2V0TWludXRlcygpKSB7XHJcblx0XHRcdFx0XHR0aGlzLm1pbnV0ZT10aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD50ZW1wTWF4VGltZS5nZXRIb3VycygpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRzLmhvdXJNYXg9dGVtcE1heFRpbWUuZ2V0SG91cnMoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PXRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZGVmYXVsdHMuaG91ck1heD09PXRlbXBNYXhUaW1lLmdldEhvdXJzKCk9PT10aGlzLmhvdXIgJiYgdGhpcy5fZGVmYXVsdHMubWludXRlTWF4PnRlbXBNYXhUaW1lLmdldE1pbnV0ZXMoKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kZWZhdWx0cy5taW51dGVNYXg9dGVtcE1heFRpbWUuZ2V0TWludXRlcygpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGVmYXVsdHMubWludXRlTWF4PTU5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGFkanVzdFNsaWRlcnMgIT09IHVuZGVmaW5lZCAmJiBhZGp1c3RTbGlkZXJzID09PSB0cnVlKSB7XHJcblx0XHRcdFx0dmFyIGhvdXJNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtICgodGhpcy5fZGVmYXVsdHMuaG91ck1heCAtIHRoaXMuX2RlZmF1bHRzLmhvdXJNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcEhvdXIpKSwgMTApLFxyXG5cdFx0XHRcdFx0bWluTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pbnV0ZU1heCAtICgodGhpcy5fZGVmYXVsdHMubWludXRlTWF4IC0gdGhpcy5fZGVmYXVsdHMubWludXRlTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaW51dGUpKSwgMTApLFxyXG5cdFx0XHRcdFx0c2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLnNlY29uZE1heCAtICgodGhpcy5fZGVmYXVsdHMuc2Vjb25kTWF4IC0gdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKSwgMTApLFxyXG5cdFx0XHRcdFx0bWlsbGlzZWNNYXggPSBwYXJzZUludCgodGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNYXggLSAoKHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWF4IC0gdGhpcy5fZGVmYXVsdHMubWlsbGlzZWNNaW4pICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbGxpc2VjKSksIDEwKSxcclxuXHRcdFx0XHRcdG1pY3Jvc2VjTWF4ID0gcGFyc2VJbnQoKHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWF4IC0gKCh0aGlzLl9kZWZhdWx0cy5taWNyb3NlY01heCAtIHRoaXMuX2RlZmF1bHRzLm1pY3Jvc2VjTWluKSAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYykpLCAxMCk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLmhvdXJfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLmhvdXJfc2xpZGVyLCAnaG91cicsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5ob3VyTWluLCBtYXg6IGhvdXJNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyIH0pO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJywgdGhpcy5ob3VyIC0gKHRoaXMuaG91ciAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBIb3VyKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLm1pbnV0ZV9zbGlkZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHsgbWluOiB0aGlzLl9kZWZhdWx0cy5taW51dGVNaW4sIG1heDogbWluTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWludXRlIH0pO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWludXRlX3NsaWRlciwgJ21pbnV0ZScsIHRoaXMubWludXRlIC0gKHRoaXMubWludXRlICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pbnV0ZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zZWNvbmRfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMuc2Vjb25kTWluLCBtYXg6IHNlY01heCwgc3RlcDogdGhpcy5fZGVmYXVsdHMuc3RlcFNlY29uZCB9KTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLnNlY29uZF9zbGlkZXIsICdzZWNvbmQnLCB0aGlzLnNlY29uZCAtICh0aGlzLnNlY29uZCAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBTZWNvbmQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMubWlsbGlzZWNfc2xpZGVyKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wub3B0aW9ucyh0aGlzLCB0aGlzLm1pbGxpc2VjX3NsaWRlciwgJ21pbGxpc2VjJywgeyBtaW46IHRoaXMuX2RlZmF1bHRzLm1pbGxpc2VjTWluLCBtYXg6IG1pbGxpc2VjTWF4LCBzdGVwOiB0aGlzLl9kZWZhdWx0cy5zdGVwTWlsbGlzZWMgfSk7XHJcblx0XHRcdFx0XHR0aGlzLmNvbnRyb2wudmFsdWUodGhpcywgdGhpcy5taWxsaXNlY19zbGlkZXIsICdtaWxsaXNlYycsIHRoaXMubWlsbGlzZWMgLSAodGhpcy5taWxsaXNlYyAlIHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWxsaXNlYykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5taWNyb3NlY19zbGlkZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC5vcHRpb25zKHRoaXMsIHRoaXMubWljcm9zZWNfc2xpZGVyLCAnbWljcm9zZWMnLCB7IG1pbjogdGhpcy5fZGVmYXVsdHMubWljcm9zZWNNaW4sIG1heDogbWljcm9zZWNNYXgsIHN0ZXA6IHRoaXMuX2RlZmF1bHRzLnN0ZXBNaWNyb3NlYyB9KTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJywgdGhpcy5taWNyb3NlYyAtICh0aGlzLm1pY3Jvc2VjICUgdGhpcy5fZGVmYXVsdHMuc3RlcE1pY3Jvc2VjKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0KiB3aGVuIGEgc2xpZGVyIG1vdmVzLCBzZXQgdGhlIGludGVybmFsIHRpbWUuLi5cclxuXHRcdCogb24gdGltZSBjaGFuZ2UgaXMgYWxzbyBjYWxsZWQgd2hlbiB0aGUgdGltZSBpcyB1cGRhdGVkIGluIHRoZSB0ZXh0IGZpZWxkXHJcblx0XHQqL1xyXG5cdFx0X29uVGltZUNoYW5nZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBob3VyID0gKHRoaXMuaG91cl9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuaG91cl9zbGlkZXIsICdob3VyJykgOiBmYWxzZSxcclxuXHRcdFx0XHRtaW51dGUgPSAodGhpcy5taW51dGVfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pbnV0ZV9zbGlkZXIsICdtaW51dGUnKSA6IGZhbHNlLFxyXG5cdFx0XHRcdHNlY29uZCA9ICh0aGlzLnNlY29uZF9zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMuc2Vjb25kX3NsaWRlciwgJ3NlY29uZCcpIDogZmFsc2UsXHJcblx0XHRcdFx0bWlsbGlzZWMgPSAodGhpcy5taWxsaXNlY19zbGlkZXIpID8gdGhpcy5jb250cm9sLnZhbHVlKHRoaXMsIHRoaXMubWlsbGlzZWNfc2xpZGVyLCAnbWlsbGlzZWMnKSA6IGZhbHNlLFxyXG5cdFx0XHRcdG1pY3Jvc2VjID0gKHRoaXMubWljcm9zZWNfc2xpZGVyKSA/IHRoaXMuY29udHJvbC52YWx1ZSh0aGlzLCB0aGlzLm1pY3Jvc2VjX3NsaWRlciwgJ21pY3Jvc2VjJykgOiBmYWxzZSxcclxuXHRcdFx0XHR0aW1lem9uZSA9ICh0aGlzLnRpbWV6b25lX3NlbGVjdCkgPyB0aGlzLnRpbWV6b25lX3NlbGVjdC52YWwoKSA6IGZhbHNlLFxyXG5cdFx0XHRcdG8gPSB0aGlzLl9kZWZhdWx0cyxcclxuXHRcdFx0XHRwaWNrZXJUaW1lRm9ybWF0ID0gby5waWNrZXJUaW1lRm9ybWF0IHx8IG8udGltZUZvcm1hdCxcclxuXHRcdFx0XHRwaWNrZXJUaW1lU3VmZml4ID0gby5waWNrZXJUaW1lU3VmZml4IHx8IG8udGltZVN1ZmZpeDtcclxuXHJcblx0XHRcdGlmICh0eXBlb2YoaG91cikgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0aG91ciA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YobWludXRlKSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRtaW51dGUgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mKHNlY29uZCkgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0c2Vjb25kID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHR5cGVvZihtaWxsaXNlYykgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0bWlsbGlzZWMgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodHlwZW9mKG1pY3Jvc2VjKSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRtaWNyb3NlYyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0eXBlb2YodGltZXpvbmUpID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdHRpbWV6b25lID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdGhvdXIgPSBwYXJzZUludChob3VyLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRtaW51dGUgPSBwYXJzZUludChtaW51dGUsIDEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdHNlY29uZCA9IHBhcnNlSW50KHNlY29uZCwgMTApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRtaWxsaXNlYyA9IHBhcnNlSW50KG1pbGxpc2VjLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdG1pY3Jvc2VjID0gcGFyc2VJbnQobWljcm9zZWMsIDEwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0dGltZXpvbmUgPSB0aW1lem9uZS50b1N0cmluZygpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYW1wbSA9IG9baG91ciA8IDEyID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcclxuXHJcblx0XHRcdC8vIElmIHRoZSB1cGRhdGUgd2FzIGRvbmUgaW4gdGhlIGlucHV0IGZpZWxkLCB0aGUgaW5wdXQgZmllbGQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkLlxyXG5cdFx0XHQvLyBJZiB0aGUgdXBkYXRlIHdhcyBkb25lIHVzaW5nIHRoZSBzbGlkZXJzLCB1cGRhdGUgdGhlIGlucHV0IGZpZWxkLlxyXG5cdFx0XHR2YXIgaGFzQ2hhbmdlZCA9IChcclxuXHRcdFx0XHRcdFx0aG91ciAhPT0gcGFyc2VJbnQodGhpcy5ob3VyLDEwKSB8fCAvLyBzbGlkZXJzIHNob3VsZCBhbGwgYmUgbnVtZXJpY1xyXG5cdFx0XHRcdFx0XHRtaW51dGUgIT09IHBhcnNlSW50KHRoaXMubWludXRlLDEwKSB8fFxyXG5cdFx0XHRcdFx0XHRzZWNvbmQgIT09IHBhcnNlSW50KHRoaXMuc2Vjb25kLDEwKSB8fFxyXG5cdFx0XHRcdFx0XHRtaWxsaXNlYyAhPT0gcGFyc2VJbnQodGhpcy5taWxsaXNlYywxMCkgfHxcclxuXHRcdFx0XHRcdFx0bWljcm9zZWMgIT09IHBhcnNlSW50KHRoaXMubWljcm9zZWMsMTApIHx8XHJcblx0XHRcdFx0XHRcdCh0aGlzLmFtcG0ubGVuZ3RoID4gMCAmJiAoaG91ciA8IDEyKSAhPT0gKCQuaW5BcnJheSh0aGlzLmFtcG0udG9VcHBlckNhc2UoKSwgdGhpcy5hbU5hbWVzKSAhPT0gLTEpKSB8fFxyXG5cdFx0XHRcdFx0XHQodGhpcy50aW1lem9uZSAhPT0gbnVsbCAmJiB0aW1lem9uZSAhPT0gdGhpcy50aW1lem9uZS50b1N0cmluZygpKSAvLyBjb3VsZCBiZSBudW1lcmljIG9yIFwiRVNUXCIgZm9ybWF0LCBzbyB1c2UgdG9TdHJpbmcoKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdGlmIChoYXNDaGFuZ2VkKSB7XHJcblxyXG5cdFx0XHRcdGlmIChob3VyICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5ob3VyID0gaG91cjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pbnV0ZSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdHRoaXMubWludXRlID0gbWludXRlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoc2Vjb25kICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zZWNvbmQgPSBzZWNvbmQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtaWxsaXNlYyAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdHRoaXMubWlsbGlzZWMgPSBtaWxsaXNlYztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG1pY3Jvc2VjICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0dGhpcy5taWNyb3NlYyA9IG1pY3Jvc2VjO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGltZXpvbmUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHR0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIXRoaXMuaW5zdCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0WzBdKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2xpbWl0TWluTWF4RGF0ZVRpbWUodGhpcy5pbnN0LCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5zdXBwb3J0LmFtcG0pIHtcclxuXHRcdFx0XHR0aGlzLmFtcG0gPSBhbXBtO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgdGltZXBpY2tlclxyXG5cdFx0XHR0aGlzLmZvcm1hdHRlZFRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0VGltZShvLnRpbWVGb3JtYXQsIHRoaXMsIG8pO1xyXG5cdFx0XHRpZiAodGhpcy4kdGltZU9iaikge1xyXG5cdFx0XHRcdGlmIChwaWNrZXJUaW1lRm9ybWF0ID09PSBvLnRpbWVGb3JtYXQpIHtcclxuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKHRoaXMuZm9ybWF0dGVkVGltZSArIHBpY2tlclRpbWVTdWZmaXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuJHRpbWVPYmoudmFsKCQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHBpY2tlclRpbWVGb3JtYXQsIHRoaXMsIG8pICsgcGlja2VyVGltZVN1ZmZpeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0aGlzLiR0aW1lT2JqWzBdLnNldFNlbGVjdGlvblJhbmdlKSB7XHJcblx0XHRcdFx0XHR2YXIgc1BvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uU3RhcnQ7XHJcblx0XHRcdFx0XHR2YXIgZVBvcyA9IHRoaXMuJHRpbWVPYmpbMF0uc2VsZWN0aW9uRW5kO1xyXG5cdFx0XHRcdFx0dGhpcy4kdGltZU9ialswXS5zZXRTZWxlY3Rpb25SYW5nZShzUG9zLCBlUG9zKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudGltZURlZmluZWQgPSB0cnVlO1xyXG5cdFx0XHRpZiAoaGFzQ2hhbmdlZCkge1xyXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZURhdGVUaW1lKCk7XHJcblx0XHRcdFx0Ly90aGlzLiRpbnB1dC5mb2N1cygpOyAvLyBtYXkgYXV0b21hdGljYWxseSBvcGVuIHRoZSBwaWNrZXIgb24gc2V0RGF0ZVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGNhbGwgY3VzdG9tIG9uU2VsZWN0LlxyXG5cdFx0KiBiaW5kIHRvIHNsaWRlcnMgc2xpZGVzdG9wLCBhbmQgZ3JpZCBjbGljay5cclxuXHRcdCovXHJcblx0XHRfb25TZWxlY3RIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBvblNlbGVjdCA9IHRoaXMuX2RlZmF1bHRzLm9uU2VsZWN0IHx8IHRoaXMuaW5zdC5zZXR0aW5ncy5vblNlbGVjdDtcclxuXHRcdFx0dmFyIGlucHV0RWwgPSB0aGlzLiRpbnB1dCA/IHRoaXMuJGlucHV0WzBdIDogbnVsbDtcclxuXHRcdFx0aWYgKG9uU2VsZWN0ICYmIGlucHV0RWwpIHtcclxuXHRcdFx0XHRvblNlbGVjdC5hcHBseShpbnB1dEVsLCBbdGhpcy5mb3JtYXR0ZWREYXRlVGltZSwgdGhpc10pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIHVwZGF0ZSBvdXIgaW5wdXQgd2l0aCB0aGUgbmV3IGRhdGUgdGltZS4uXHJcblx0XHQqL1xyXG5cdFx0X3VwZGF0ZURhdGVUaW1lOiBmdW5jdGlvbiAoZHBfaW5zdCkge1xyXG5cdFx0XHRkcF9pbnN0ID0gdGhpcy5pbnN0IHx8IGRwX2luc3Q7XHJcblx0XHRcdHZhciBkdFRtcCA9IChkcF9pbnN0LmN1cnJlbnRZZWFyID4gMD9cclxuXHRcdFx0XHRcdFx0XHRuZXcgRGF0ZShkcF9pbnN0LmN1cnJlbnRZZWFyLCBkcF9pbnN0LmN1cnJlbnRNb250aCwgZHBfaW5zdC5jdXJyZW50RGF5KSA6XHJcblx0XHRcdFx0XHRcdFx0bmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxyXG5cdFx0XHRcdGR0ID0gJC5kYXRlcGlja2VyLl9kYXlsaWdodFNhdmluZ0FkanVzdChkdFRtcCksXHJcblx0XHRcdFx0Ly9kdCA9ICQuZGF0ZXBpY2tlci5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHBfaW5zdC5zZWxlY3RlZFllYXIsIGRwX2luc3Quc2VsZWN0ZWRNb250aCwgZHBfaW5zdC5zZWxlY3RlZERheSkpLFxyXG5cdFx0XHRcdC8vZHQgPSAkLmRhdGVwaWNrZXIuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRwX2luc3QuY3VycmVudFllYXIsIGRwX2luc3QuY3VycmVudE1vbnRoLCBkcF9pbnN0LmN1cnJlbnREYXkpKSxcclxuXHRcdFx0XHRkYXRlRm10ID0gJC5kYXRlcGlja2VyLl9nZXQoZHBfaW5zdCwgJ2RhdGVGb3JtYXQnKSxcclxuXHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhkcF9pbnN0KSxcclxuXHRcdFx0XHR0aW1lQXZhaWxhYmxlID0gZHQgIT09IG51bGwgJiYgdGhpcy50aW1lRGVmaW5lZDtcclxuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlID0gJC5kYXRlcGlja2VyLmZvcm1hdERhdGUoZGF0ZUZtdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcclxuXHRcdFx0dmFyIGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWREYXRlO1xyXG5cclxuXHRcdFx0Ly8gaWYgYSBzbGlkZXIgd2FzIGNoYW5nZWQgYnV0IGRhdGVwaWNrZXIgZG9lc24ndCBoYXZlIGEgdmFsdWUgeWV0LCBzZXQgaXRcclxuXHRcdFx0aWYgKGRwX2luc3QubGFzdFZhbCA9PT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50WWVhciA9IGRwX2luc3Quc2VsZWN0ZWRZZWFyO1xyXG4gICAgICAgICAgICAgICAgZHBfaW5zdC5jdXJyZW50TW9udGggPSBkcF9pbnN0LnNlbGVjdGVkTW9udGg7XHJcbiAgICAgICAgICAgICAgICBkcF9pbnN0LmN1cnJlbnREYXkgPSBkcF9pbnN0LnNlbGVjdGVkRGF5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHQqIHJlbW92ZSBmb2xsb3dpbmcgbGluZXMgdG8gZm9yY2UgZXZlcnkgY2hhbmdlcyBpbiBkYXRlIHBpY2tlciB0byBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlXHJcblx0XHRcdCogQnVnIGRlc2NyaXB0aW9uczogd2hlbiBhbiBpbnB1dCBmaWVsZCBoYXMgYSBkZWZhdWx0IHZhbHVlLCBhbmQgY2xpY2sgb24gdGhlIGZpZWxkIHRvIHBvcCB1cCB0aGUgZGF0ZSBwaWNrZXIuXHJcblx0XHRcdCogSWYgdGhlIHVzZXIgbWFudWFsbHkgZW1wdHkgdGhlIHZhbHVlIGluIHRoZSBpbnB1dCBmaWVsZCwgdGhlIGRhdGUgcGlja2VyIHdpbGwgbmV2ZXIgY2hhbmdlIHNlbGVjdGVkIHZhbHVlLlxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvL2lmIChkcF9pbnN0Lmxhc3RWYWwgIT09IHVuZGVmaW5lZCAmJiAoZHBfaW5zdC5sYXN0VmFsLmxlbmd0aCA+IDAgJiYgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoID09PSAwKSkge1xyXG5cdFx0XHQvL1x0cmV0dXJuO1xyXG5cdFx0XHQvL31cclxuXHJcblx0XHRcdGlmICh0aGlzLl9kZWZhdWx0cy50aW1lT25seSA9PT0gdHJ1ZSAmJiB0aGlzLl9kZWZhdWx0cy50aW1lT25seVNob3dEYXRlID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdGZvcm1hdHRlZERhdGVUaW1lID0gdGhpcy5mb3JtYXR0ZWRUaW1lO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCh0aGlzLl9kZWZhdWx0cy50aW1lT25seSAhPT0gdHJ1ZSAmJiAodGhpcy5fZGVmYXVsdHMuYWx3YXlzU2V0VGltZSB8fCB0aW1lQXZhaWxhYmxlKSkgfHwgKHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSB0cnVlICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5U2hvd0RhdGUgPT09IHRydWUpKSB7XHJcblx0XHRcdFx0Zm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yICsgdGhpcy5mb3JtYXR0ZWRUaW1lICsgdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5mb3JtYXR0ZWREYXRlVGltZSA9IGZvcm1hdHRlZERhdGVUaW1lO1xyXG5cclxuXHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy5zaG93VGltZXBpY2tlcikge1xyXG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLmZvcm1hdHRlZERhdGUpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuJGFsdElucHV0ICYmIHRoaXMuX2RlZmF1bHRzLnRpbWVPbmx5ID09PSBmYWxzZSAmJiB0aGlzLl9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ID09PSB0cnVlKSB7XHJcblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkVGltZSk7XHJcblx0XHRcdFx0dGhpcy4kaW5wdXQudmFsKHRoaXMuZm9ybWF0dGVkRGF0ZSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy4kYWx0SW5wdXQpIHtcclxuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xyXG5cdFx0XHRcdHZhciBhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICcnLFxyXG5cdFx0XHRcdFx0YWx0U2VwYXJhdG9yID0gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yICE9PSBudWxsID8gdGhpcy5fZGVmYXVsdHMuYWx0U2VwYXJhdG9yIDogdGhpcy5fZGVmYXVsdHMuc2VwYXJhdG9yLFxyXG5cdFx0XHRcdFx0YWx0VGltZVN1ZmZpeCA9IHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggIT09IG51bGwgPyB0aGlzLl9kZWZhdWx0cy5hbHRUaW1lU3VmZml4IDogdGhpcy5fZGVmYXVsdHMudGltZVN1ZmZpeDtcclxuXHJcblx0XHRcdFx0aWYgKCF0aGlzLl9kZWZhdWx0cy50aW1lT25seSkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCkge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9ICQuZGF0ZXBpY2tlci5mb3JtYXREYXRlKHRoaXMuX2RlZmF1bHRzLmFsdEZvcm1hdCwgKGR0ID09PSBudWxsID8gbmV3IERhdGUoKSA6IGR0KSwgZm9ybWF0Q2ZnKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRoaXMuZm9ybWF0dGVkRGF0ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoYWx0Rm9ybWF0dGVkRGF0ZVRpbWUpIHtcclxuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gYWx0U2VwYXJhdG9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lICs9ICQuZGF0ZXBpY2tlci5mb3JtYXRUaW1lKHRoaXMuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQsIHRoaXMsIHRoaXMuX2RlZmF1bHRzKSArIGFsdFRpbWVTdWZmaXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gdGhpcy5mb3JtYXR0ZWRUaW1lICsgYWx0VGltZVN1ZmZpeDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy4kYWx0SW5wdXQudmFsKGFsdEZvcm1hdHRlZERhdGVUaW1lKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLiRpbnB1dC52YWwoZm9ybWF0dGVkRGF0ZVRpbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLiRpbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xyXG5cdFx0fSxcclxuXHJcblx0XHRfb25Gb2N1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAoIXRoaXMuJGlucHV0LnZhbCgpICYmIHRoaXMuX2RlZmF1bHRzLmRlZmF1bHRWYWx1ZSkge1xyXG5cdFx0XHRcdHRoaXMuJGlucHV0LnZhbCh0aGlzLl9kZWZhdWx0cy5kZWZhdWx0VmFsdWUpO1xyXG5cdFx0XHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KHRoaXMuJGlucHV0LmdldCgwKSksXHJcblx0XHRcdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdFx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHRcdFx0aWYgKHRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpKSB7XHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LypcclxuXHRcdCogU21hbGwgYWJzdHJhY3Rpb24gdG8gY29udHJvbCB0eXBlc1xyXG5cdFx0KiBXZSBjYW4gYWRkIG1vcmUsIGp1c3QgYmUgc3VyZSB0byBmb2xsb3cgdGhlIHBhdHRlcm46IGNyZWF0ZSwgb3B0aW9ucywgdmFsdWVcclxuXHRcdCovXHJcblx0XHRfY29udHJvbHM6IHtcclxuXHRcdFx0Ly8gc2xpZGVyIG1ldGhvZHNcclxuXHRcdFx0c2xpZGVyOiB7XHJcblx0XHRcdFx0Y3JlYXRlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwsIG1pbiwgbWF4LCBzdGVwKSB7XHJcblx0XHRcdFx0XHR2YXIgcnRsID0gdHBfaW5zdC5fZGVmYXVsdHMuaXNSVEw7IC8vIGlmIHJ0bCBnbyAtNjAtPjAgaW5zdGVhZCBvZiAwLT42MFxyXG5cdFx0XHRcdFx0cmV0dXJuIG9iai5wcm9wKCdzbGlkZScsIG51bGwpLnNsaWRlcih7XHJcblx0XHRcdFx0XHRcdG9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcclxuXHRcdFx0XHRcdFx0dmFsdWU6IHJ0bCA/IHZhbCAqIC0xIDogdmFsLFxyXG5cdFx0XHRcdFx0XHRtaW46IHJ0bCA/IG1heCAqIC0xIDogbWluLFxyXG5cdFx0XHRcdFx0XHRtYXg6IHJ0bCA/IG1pbiAqIC0xIDogbWF4LFxyXG5cdFx0XHRcdFx0XHRzdGVwOiBzdGVwLFxyXG5cdFx0XHRcdFx0XHRzbGlkZTogZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xyXG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuY29udHJvbC52YWx1ZSh0cF9pbnN0LCAkKHRoaXMpLCB1bml0LCBydGwgPyB1aS52YWx1ZSAqIC0xIDogdWkudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRzdG9wOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XHJcblx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fb25TZWxlY3RIYW5kbGVyKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0b3B0aW9uczogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgb3B0cywgdmFsKSB7XHJcblx0XHRcdFx0XHRpZiAodHBfaW5zdC5fZGVmYXVsdHMuaXNSVEwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihvcHRzKSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAob3B0cyA9PT0gJ21pbicgfHwgb3B0cyA9PT0gJ21heCcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzLCB2YWwgKiAtMSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5hYnMob2JqLnNsaWRlcihvcHRzKSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBtaW4gPSBvcHRzLm1pbixcclxuXHRcdFx0XHRcdFx0XHRtYXggPSBvcHRzLm1heDtcclxuXHRcdFx0XHRcdFx0b3B0cy5taW4gPSBvcHRzLm1heCA9IG51bGw7XHJcblx0XHRcdFx0XHRcdGlmIChtaW4gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdG9wdHMubWF4ID0gbWluICogLTE7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0b3B0cy5taW4gPSBtYXggKiAtMTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnICYmIHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKG9wdHMsIHZhbCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcihvcHRzKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCB2YWwpIHtcclxuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5pc1JUTCkge1xyXG5cdFx0XHRcdFx0XHRpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnLCB2YWwgKiAtMSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGguYWJzKG9iai5zbGlkZXIoJ3ZhbHVlJykpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBvYmouc2xpZGVyKCd2YWx1ZScsIHZhbCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqLnNsaWRlcigndmFsdWUnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIHNlbGVjdCBtZXRob2RzXHJcblx0XHRcdHNlbGVjdDoge1xyXG5cdFx0XHRcdGNyZWF0ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsLCBtaW4sIG1heCwgc3RlcCkge1xyXG5cdFx0XHRcdFx0dmFyIHNlbCA9ICc8c2VsZWN0IGNsYXNzPVwidWktdGltZXBpY2tlci1zZWxlY3QgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXCIgZGF0YS11bml0PVwiJyArIHVuaXQgKyAnXCIgZGF0YS1taW49XCInICsgbWluICsgJ1wiIGRhdGEtbWF4PVwiJyArIG1heCArICdcIiBkYXRhLXN0ZXA9XCInICsgc3RlcCArICdcIj4nLFxyXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5waWNrZXJUaW1lRm9ybWF0IHx8IHRwX2luc3QuX2RlZmF1bHRzLnRpbWVGb3JtYXQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IG1pbjsgaSA8PSBtYXg7IGkgKz0gc3RlcCkge1xyXG5cdFx0XHRcdFx0XHRzZWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIicgKyAoaSA9PT0gdmFsID8gJyBzZWxlY3RlZCcgOiAnJykgKyAnPic7XHJcblx0XHRcdFx0XHRcdGlmICh1bml0ID09PSAnaG91cicpIHtcclxuXHRcdFx0XHRcdFx0XHRzZWwgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoJC50cmltKGZvcm1hdC5yZXBsYWNlKC9bXmh0IF0vaWcsICcnKSksIHtob3VyOiBpfSwgdHBfaW5zdC5fZGVmYXVsdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYgKHVuaXQgPT09ICdtaWxsaXNlYycgfHwgdW5pdCA9PT0gJ21pY3Jvc2VjJyB8fCBpID49IDEwKSB7IHNlbCArPSBpOyB9XHJcblx0XHRcdFx0XHRcdGVsc2Uge3NlbCArPSAnMCcgKyBpLnRvU3RyaW5nKCk7IH1cclxuXHRcdFx0XHRcdFx0c2VsICs9ICc8L29wdGlvbj4nO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VsICs9ICc8L3NlbGVjdD4nO1xyXG5cclxuXHRcdFx0XHRcdG9iai5jaGlsZHJlbignc2VsZWN0JykucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdFx0JChzZWwpLmFwcGVuZFRvKG9iaikuY2hhbmdlKGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHRcdFx0XHRcdFx0dHBfaW5zdC5fYWZ0ZXJJbmplY3QoKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBvYmo7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRvcHRpb25zOiBmdW5jdGlvbiAodHBfaW5zdCwgb2JqLCB1bml0LCBvcHRzLCB2YWwpIHtcclxuXHRcdFx0XHRcdHZhciBvID0ge30sXHJcblx0XHRcdFx0XHRcdCR0ID0gb2JqLmNoaWxkcmVuKCdzZWxlY3QnKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2Yob3B0cykgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0XHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAkdC5kYXRhKG9wdHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdG9bb3B0c10gPSB2YWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHsgbyA9IG9wdHM7IH1cclxuXHRcdFx0XHRcdHJldHVybiB0cF9pbnN0LmNvbnRyb2wuY3JlYXRlKHRwX2luc3QsIG9iaiwgJHQuZGF0YSgndW5pdCcpLCAkdC52YWwoKSwgby5taW4+PTAgPyBvLm1pbiA6ICR0LmRhdGEoJ21pbicpLCBvLm1heCB8fCAkdC5kYXRhKCdtYXgnKSwgby5zdGVwIHx8ICR0LmRhdGEoJ3N0ZXAnKSk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHR2YWx1ZTogZnVuY3Rpb24gKHRwX2luc3QsIG9iaiwgdW5pdCwgdmFsKSB7XHJcblx0XHRcdFx0XHR2YXIgJHQgPSBvYmouY2hpbGRyZW4oJ3NlbGVjdCcpO1xyXG5cdFx0XHRcdFx0aWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkdC52YWwodmFsKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAkdC52YWwoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gLy8gZW5kIF9jb250cm9sc1xyXG5cclxuXHR9KTtcclxuXHJcblx0JC5mbi5leHRlbmQoe1xyXG5cdFx0LypcclxuXHRcdCogc2hvcnRoYW5kIGp1c3QgdG8gdXNlIHRpbWVwaWNrZXIuXHJcblx0XHQqL1xyXG5cdFx0dGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcclxuXHRcdFx0byA9IG8gfHwge307XHJcblx0XHRcdHZhciB0bXBfYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdFx0XHRpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0dG1wX2FyZ3NbMF0gPSAkLmV4dGVuZChvLCB7XHJcblx0XHRcdFx0XHR0aW1lT25seTogdHJ1ZVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHQkLmZuLmRhdGV0aW1lcGlja2VyLmFwcGx5KCQodGhpcyksIHRtcF9hcmdzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qXHJcblx0XHQqIGV4dGVuZCB0aW1lcGlja2VyIHRvIGRhdGVwaWNrZXJcclxuXHRcdCovXHJcblx0XHRkYXRldGltZXBpY2tlcjogZnVuY3Rpb24gKG8pIHtcclxuXHRcdFx0byA9IG8gfHwge307XHJcblx0XHRcdHZhciB0bXBfYXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdGlmICh0eXBlb2YobykgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0aWYgKG8gPT09ICdnZXREYXRlJyAgfHwgKG8gPT09ICdvcHRpb24nICYmIHRtcF9hcmdzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgKHRtcF9hcmdzWzFdKSA9PT0gJ3N0cmluZycpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gJC5mbi5kYXRlcGlja2VyLmFwcGx5KCQodGhpc1swXSksIHRtcF9hcmdzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XHJcblx0XHRcdFx0XHRcdCR0LmRhdGVwaWNrZXIuYXBwbHkoJHQsIHRtcF9hcmdzKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdHZhciAkdCA9ICQodGhpcyk7XHJcblx0XHRcdFx0XHQkdC5kYXRlcGlja2VyKCQudGltZXBpY2tlci5fbmV3SW5zdCgkdCwgbykuX2RlZmF1bHRzKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvKlxyXG5cdCogUHVibGljIFV0aWxpdHkgdG8gcGFyc2UgZGF0ZSBhbmQgdGltZVxyXG5cdCovXHJcbiAgICAkLmRhdGVwaWNrZXIgPSAkLmRhdGVwaWNrZXIgfHwge307XHJcblx0JC5kYXRlcGlja2VyLnBhcnNlRGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XHJcblx0XHR2YXIgcGFyc2VSZXMgPSBwYXJzZURhdGVUaW1lSW50ZXJuYWwoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKTtcclxuXHRcdGlmIChwYXJzZVJlcy50aW1lT2JqKSB7XHJcblx0XHRcdHZhciB0ID0gcGFyc2VSZXMudGltZU9iajtcclxuXHRcdFx0cGFyc2VSZXMuZGF0ZS5zZXRIb3Vycyh0LmhvdXIsIHQubWludXRlLCB0LnNlY29uZCwgdC5taWxsaXNlYyk7XHJcblx0XHRcdHBhcnNlUmVzLmRhdGUuc2V0TWljcm9zZWNvbmRzKHQubWljcm9zZWMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXJzZVJlcy5kYXRlO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBQdWJsaWMgdXRpbGl0eSB0byBwYXJzZSB0aW1lXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIucGFyc2VUaW1lID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvID0gZXh0ZW5kUmVtb3ZlKGV4dGVuZFJlbW92ZSh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pLFxyXG5cdFx0XHRpc284NjAxID0gKHRpbWVGb3JtYXQucmVwbGFjZSgvXFwnLio/XFwnL2csICcnKS5pbmRleE9mKCdaJykgIT09IC0xKTtcclxuXHJcblx0XHQvLyBTdHJpY3QgcGFyc2UgcmVxdWlyZXMgdGhlIHRpbWVTdHJpbmcgdG8gbWF0Y2ggdGhlIHRpbWVGb3JtYXQgZXhhY3RseVxyXG5cdFx0dmFyIHN0cmljdFBhcnNlID0gZnVuY3Rpb24gKGYsIHMsIG8pIHtcclxuXHJcblx0XHRcdC8vIHBhdHRlcm4gZm9yIHN0YW5kYXJkIGFuZCBsb2NhbGl6ZWQgQU0vUE0gbWFya2Vyc1xyXG5cdFx0XHR2YXIgZ2V0UGF0dGVybkFtcG0gPSBmdW5jdGlvbiAoYW1OYW1lcywgcG1OYW1lcykge1xyXG5cdFx0XHRcdHZhciBtYXJrZXJzID0gW107XHJcblx0XHRcdFx0aWYgKGFtTmFtZXMpIHtcclxuXHRcdFx0XHRcdCQubWVyZ2UobWFya2VycywgYW1OYW1lcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChwbU5hbWVzKSB7XHJcblx0XHRcdFx0XHQkLm1lcmdlKG1hcmtlcnMsIHBtTmFtZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXJrZXJzID0gJC5tYXAobWFya2VycywgZnVuY3Rpb24gKHZhbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5yZXBsYWNlKC9bLiorP3woKVxcW1xcXXt9XFxcXF0vZywgJ1xcXFwkJicpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybiAnKCcgKyBtYXJrZXJzLmpvaW4oJ3wnKSArICcpPyc7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyBmaWd1cmUgb3V0IHBvc2l0aW9uIG9mIHRpbWUgZWxlbWVudHMuLiBjYXVzZSBqcyBjYW50IGRvIG5hbWVkIGNhcHR1cmVzXHJcblx0XHRcdHZhciBnZXRGb3JtYXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAodGltZUZvcm1hdCkge1xyXG5cdFx0XHRcdHZhciBmaW5kcyA9IHRpbWVGb3JtYXQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGh7MSwyfXxtezEsMn18c3sxLDJ9fGx7MX18Y3sxfXx0ezEsMn18enwnLio/JykvZyksXHJcblx0XHRcdFx0XHRvcmRlcnMgPSB7XHJcblx0XHRcdFx0XHRcdGg6IC0xLFxyXG5cdFx0XHRcdFx0XHRtOiAtMSxcclxuXHRcdFx0XHRcdFx0czogLTEsXHJcblx0XHRcdFx0XHRcdGw6IC0xLFxyXG5cdFx0XHRcdFx0XHRjOiAtMSxcclxuXHRcdFx0XHRcdFx0dDogLTEsXHJcblx0XHRcdFx0XHRcdHo6IC0xXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRpZiAoZmluZHMpIHtcclxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKG9yZGVyc1tmaW5kc1tpXS50b1N0cmluZygpLmNoYXJBdCgwKV0gPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0b3JkZXJzW2ZpbmRzW2ldLnRvU3RyaW5nKCkuY2hhckF0KDApXSA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBvcmRlcnM7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgcmVnc3RyID0gJ14nICsgZi50b1N0cmluZygpXHJcblx0XHRcdFx0XHQucmVwbGFjZSgvKFtoSF17MSwyfXxtbT98c3M/fFt0VF17MSwyfXxbelpdfFtsY118Jy4qPycpL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBtbCA9IG1hdGNoLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKG1hdGNoLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnaCc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbWwgPT09IDEgPyAnKFxcXFxkP1xcXFxkKScgOiAnKFxcXFxkeycgKyBtbCArICd9KSc7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbCc6XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJyhcXFxcZD9cXFxcZD9cXFxcZCknO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2MnOlxyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICcoXFxcXGQ/XFxcXGQ/XFxcXGQpJztcclxuXHRcdFx0XHRcdFx0XHRjYXNlICd6JzpcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAnKHp8Wy0rXVxcXFxkXFxcXGQ6P1xcXFxkXFxcXGR8XFxcXFMrKT8nO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3QnOlxyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFBhdHRlcm5BbXBtKG8uYW1OYW1lcywgby5wbU5hbWVzKTtcclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiAgICAvLyBsaXRlcmFsIGVzY2FwZWQgaW4gcXVvdGVzXHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJygnICsgbWF0Y2gucmVwbGFjZSgvXFwnL2csIFwiXCIpLnJlcGxhY2UoLyhcXC58XFwkfFxcXnxcXFxcfFxcL3xcXCh8XFwpfFxcW3xcXF18XFw/fFxcK3xcXCopL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiBcIlxcXFxcIiArIG07IH0pICsgJyk/JztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQucmVwbGFjZSgvXFxzL2csICdcXFxccz8nKSArXHJcblx0XHRcdFx0XHRvLnRpbWVTdWZmaXggKyAnJCcsXHJcblx0XHRcdFx0b3JkZXIgPSBnZXRGb3JtYXRQb3NpdGlvbnMoZiksXHJcblx0XHRcdFx0YW1wbSA9ICcnLFxyXG5cdFx0XHRcdHRyZWc7XHJcblxyXG5cdFx0XHR0cmVnID0gcy5tYXRjaChuZXcgUmVnRXhwKHJlZ3N0ciwgJ2knKSk7XHJcblxyXG5cdFx0XHR2YXIgcmVzVGltZSA9IHtcclxuXHRcdFx0XHRob3VyOiAwLFxyXG5cdFx0XHRcdG1pbnV0ZTogMCxcclxuXHRcdFx0XHRzZWNvbmQ6IDAsXHJcblx0XHRcdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRcdFx0bWljcm9zZWM6IDBcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICh0cmVnKSB7XHJcblx0XHRcdFx0aWYgKG9yZGVyLnQgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRpZiAodHJlZ1tvcmRlci50XSA9PT0gdW5kZWZpbmVkIHx8IHRyZWdbb3JkZXIudF0ubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGFtcG0gPSAnJztcclxuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gJyc7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbXBtID0gJC5pbkFycmF5KHRyZWdbb3JkZXIudF0udG9VcHBlckNhc2UoKSwgJC5tYXAoby5hbU5hbWVzLCBmdW5jdGlvbiAoeCxpKSB7IHJldHVybiB4LnRvVXBwZXJDYXNlKCk7IH0pKSAhPT0gLTEgPyAnQU0nIDogJ1BNJztcclxuXHRcdFx0XHRcdFx0cmVzVGltZS5hbXBtID0gb1thbXBtID09PSAnQU0nID8gJ2FtTmFtZXMnIDogJ3BtTmFtZXMnXVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChvcmRlci5oICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0aWYgKGFtcG0gPT09ICdBTScgJiYgdHJlZ1tvcmRlci5oXSA9PT0gJzEyJykge1xyXG5cdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSAwOyAvLyAxMmFtID0gMCBob3VyXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpZiAoYW1wbSA9PT0gJ1BNJyAmJiB0cmVnW29yZGVyLmhdICE9PSAnMTInKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzVGltZS5ob3VyID0gcGFyc2VJbnQodHJlZ1tvcmRlci5oXSwgMTApICsgMTI7IC8vIDEycG0gPSAxMiBob3VyLCBhbnkgb3RoZXIgcG0gPSBob3VyICsgMTJcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRyZXNUaW1lLmhvdXIgPSBOdW1iZXIodHJlZ1tvcmRlci5oXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChvcmRlci5tICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5taW51dGUgPSBOdW1iZXIodHJlZ1tvcmRlci5tXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvcmRlci5zICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5zZWNvbmQgPSBOdW1iZXIodHJlZ1tvcmRlci5zXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChvcmRlci5sICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0cmVzVGltZS5taWxsaXNlYyA9IE51bWJlcih0cmVnW29yZGVyLmxdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKG9yZGVyLmMgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRyZXNUaW1lLm1pY3Jvc2VjID0gTnVtYmVyKHRyZWdbb3JkZXIuY10pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3JkZXIueiAhPT0gLTEgJiYgdHJlZ1tvcmRlci56XSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRyZXNUaW1lLnRpbWV6b25lID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKHRyZWdbb3JkZXIuel0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdHJldHVybiByZXNUaW1lO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07Ly8gZW5kIHN0cmljdFBhcnNlXHJcblxyXG5cdFx0Ly8gRmlyc3QgdHJ5IEpTIERhdGUsIGlmIHRoYXQgZmFpbHMsIHVzZSBzdHJpY3RQYXJzZVxyXG5cdFx0dmFyIGxvb3NlUGFyc2UgPSBmdW5jdGlvbiAoZiwgcywgbykge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciBkID0gbmV3IERhdGUoJzIwMTItMDEtMDEgJyArIHMpO1xyXG5cdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcclxuXHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMjAxMi0wMS0wMVQnICsgcyk7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4oZC5nZXRUaW1lKCkpKSB7XHJcblx0XHRcdFx0XHRcdGQgPSBuZXcgRGF0ZSgnMDEvMDEvMjAxMiAnICsgcyk7XHJcblx0XHRcdFx0XHRcdGlmIChpc05hTihkLmdldFRpbWUoKSkpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBcIlVuYWJsZSB0byBwYXJzZSB0aW1lIHdpdGggbmF0aXZlIERhdGU6IFwiICsgcztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGhvdXI6IGQuZ2V0SG91cnMoKSxcclxuXHRcdFx0XHRcdG1pbnV0ZTogZC5nZXRNaW51dGVzKCksXHJcblx0XHRcdFx0XHRzZWNvbmQ6IGQuZ2V0U2Vjb25kcygpLFxyXG5cdFx0XHRcdFx0bWlsbGlzZWM6IGQuZ2V0TWlsbGlzZWNvbmRzKCksXHJcblx0XHRcdFx0XHRtaWNyb3NlYzogZC5nZXRNaWNyb3NlY29uZHMoKSxcclxuXHRcdFx0XHRcdHRpbWV6b25lOiBkLmdldFRpbWV6b25lT2Zmc2V0KCkgKiAtMVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdFx0Y2F0Y2ggKGVycikge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3RyaWN0UGFyc2UoZiwgcywgbyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhdGNoIChlcnIyKSB7XHJcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKFwiVW5hYmxlIHRvIHBhcnNlIFxcbnRpbWVTdHJpbmc6IFwiICsgcyArIFwiXFxudGltZUZvcm1hdDogXCIgKyBmKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fTsgLy8gZW5kIGxvb3NlUGFyc2VcclxuXHJcblx0XHRpZiAodHlwZW9mIG8ucGFyc2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRyZXR1cm4gby5wYXJzZSh0aW1lRm9ybWF0LCB0aW1lU3RyaW5nLCBvKTtcclxuXHRcdH1cclxuXHRcdGlmIChvLnBhcnNlID09PSAnbG9vc2UnKSB7XHJcblx0XHRcdHJldHVybiBsb29zZVBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cmljdFBhcnNlKHRpbWVGb3JtYXQsIHRpbWVTdHJpbmcsIG8pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFB1YmxpYyB1dGlsaXR5IHRvIGZvcm1hdCB0aGUgdGltZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgZm9ybWF0IG9mIHRoZSB0aW1lXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRpbWUgT2JqZWN0IG5vdCBhIERhdGUgZm9yIHRpbWV6b25lc1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZXNzZW50aWFsbHkgdGhlIHJlZ2lvbmFsW10uLiBhbU5hbWVzLCBwbU5hbWVzLCBhbXBtXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gdGhlIGZvcm1hdHRlZCB0aW1lXHJcblx0ICovXHJcblx0JC5kYXRlcGlja2VyLmZvcm1hdFRpbWUgPSBmdW5jdGlvbiAoZm9ybWF0LCB0aW1lLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC50aW1lcGlja2VyLl9kZWZhdWx0cywgb3B0aW9ucyk7XHJcblx0XHR0aW1lID0gJC5leHRlbmQoe1xyXG5cdFx0XHRob3VyOiAwLFxyXG5cdFx0XHRtaW51dGU6IDAsXHJcblx0XHRcdHNlY29uZDogMCxcclxuXHRcdFx0bWlsbGlzZWM6IDAsXHJcblx0XHRcdG1pY3Jvc2VjOiAwLFxyXG5cdFx0XHR0aW1lem9uZTogbnVsbFxyXG5cdFx0fSwgdGltZSk7XHJcblxyXG5cdFx0dmFyIHRtcHRpbWUgPSBmb3JtYXQsXHJcblx0XHRcdGFtcG1OYW1lID0gb3B0aW9ucy5hbU5hbWVzWzBdLFxyXG5cdFx0XHRob3VyID0gcGFyc2VJbnQodGltZS5ob3VyLCAxMCk7XHJcblxyXG5cdFx0aWYgKGhvdXIgPiAxMSkge1xyXG5cdFx0XHRhbXBtTmFtZSA9IG9wdGlvbnMucG1OYW1lc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHR0bXB0aW1lID0gdG1wdGltZS5yZXBsYWNlKC8oPzpISD98aGg/fG1tP3xzcz98W3RUXXsxLDJ9fFt6Wl18W2xjXXwnLio/JykvZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcblx0XHRcdHN3aXRjaCAobWF0Y2gpIHtcclxuXHRcdFx0Y2FzZSAnSEgnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgaG91cikuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdIJzpcclxuXHRcdFx0XHRyZXR1cm4gaG91cjtcclxuXHRcdFx0Y2FzZSAnaGgnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgY29udmVydDI0dG8xMihob3VyKSkuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdoJzpcclxuXHRcdFx0XHRyZXR1cm4gY29udmVydDI0dG8xMihob3VyKTtcclxuXHRcdFx0Y2FzZSAnbW0nOlxyXG5cdFx0XHRcdHJldHVybiAoJzAnICsgdGltZS5taW51dGUpLnNsaWNlKC0yKTtcclxuXHRcdFx0Y2FzZSAnbSc6XHJcblx0XHRcdFx0cmV0dXJuIHRpbWUubWludXRlO1xyXG5cdFx0XHRjYXNlICdzcyc6XHJcblx0XHRcdFx0cmV0dXJuICgnMCcgKyB0aW1lLnNlY29uZCkuc2xpY2UoLTIpO1xyXG5cdFx0XHRjYXNlICdzJzpcclxuXHRcdFx0XHRyZXR1cm4gdGltZS5zZWNvbmQ7XHJcblx0XHRcdGNhc2UgJ2wnOlxyXG5cdFx0XHRcdHJldHVybiAoJzAwJyArIHRpbWUubWlsbGlzZWMpLnNsaWNlKC0zKTtcclxuXHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0cmV0dXJuICgnMDAnICsgdGltZS5taWNyb3NlYykuc2xpY2UoLTMpO1xyXG5cdFx0XHRjYXNlICd6JzpcclxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgZmFsc2UpO1xyXG5cdFx0XHRjYXNlICdaJzpcclxuXHRcdFx0XHRyZXR1cm4gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKHRpbWUudGltZXpvbmUgPT09IG51bGwgPyBvcHRpb25zLnRpbWV6b25lIDogdGltZS50aW1lem9uZSwgdHJ1ZSk7XHJcblx0XHRcdGNhc2UgJ1QnOlxyXG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0Y2FzZSAnVFQnOlxyXG5cdFx0XHRcdHJldHVybiBhbXBtTmFtZS50b1VwcGVyQ2FzZSgpO1xyXG5cdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdGNhc2UgJ3R0JzpcclxuXHRcdFx0XHRyZXR1cm4gYW1wbU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSgvJy9nLCBcIlwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHRtcHRpbWU7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIHRoZSBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGRvZXNuJ3QgY2xvc2Ugb24gc2VsZWN0XHJcblx0Ly8gaW5zcGlyZWQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI1MjUxMi9qcXVlcnktZGF0ZXBpY2tlci1wcmV2ZW50LWNsb3NpbmctcGlja2VyLXdoZW4tY2xpY2tpbmctYS1kYXRlLzE3NjIzNzgjMTc2MjM3OFxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX3NlbGVjdERhdGUgPSAkLmRhdGVwaWNrZXIuX3NlbGVjdERhdGU7XHJcblx0JC5kYXRlcGlja2VyLl9zZWxlY3REYXRlID0gZnVuY3Rpb24gKGlkLCBkYXRlU3RyKSB7XHJcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QoJChpZClbMF0pLFxyXG5cdFx0XHR0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyksXHJcblx0XHRcdHdhc19pbmxpbmU7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QgJiYgaW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlcikge1xyXG5cdFx0XHR0cF9pbnN0Ll9saW1pdE1pbk1heERhdGVUaW1lKGluc3QsIHRydWUpO1xyXG5cdFx0XHR3YXNfaW5saW5lID0gaW5zdC5pbmxpbmU7XHJcblx0XHRcdGluc3QuaW5saW5lID0gaW5zdC5zdGF5X29wZW4gPSB0cnVlO1xyXG5cdFx0XHQvL1RoaXMgd2F5IHRoZSBvblNlbGVjdCBoYW5kbGVyIGNhbGxlZCBmcm9tIGNhbGVuZGFycGlja2VyIGdldCB0aGUgZnVsbCBkYXRlVGltZVxyXG5cdFx0XHR0aGlzLl9iYXNlX3NlbGVjdERhdGUoaWQsIGRhdGVTdHIpO1xyXG5cdFx0XHRpbnN0LmlubGluZSA9IHdhc19pbmxpbmU7XHJcblx0XHRcdGluc3Quc3RheV9vcGVuID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2Jhc2Vfc2VsZWN0RGF0ZShpZCwgZGF0ZVN0cik7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIHNlY29uZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IHRyaWdnZXJzIGFuIGV2ZW50IHdoZW4gY2hhbmdpbmcgdGhlIGlucHV0IGZpZWxkXHJcblx0KiBhbmQgZG9lcyBub3QgcmVkcmF3IHRoZSBkYXRlcGlja2VyIG9uIGV2ZXJ5IHNlbGVjdERhdGUgZXZlbnRcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV91cGRhdGVEYXRlcGlja2VyID0gJC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyO1xyXG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uIChpbnN0KSB7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgcG9wdXAgdGhlIGRhdGVwaWNrZXIgaWYgdGhlcmUgaXMgYW5vdGhlciBpbnN0YW5jZSBhbHJlYWR5IG9wZW5lZFxyXG5cdFx0dmFyIGlucHV0ID0gaW5zdC5pbnB1dFswXTtcclxuXHRcdGlmICgkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9jdXJJbnN0ICE9PSBpbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9sYXN0SW5wdXQgIT09IGlucHV0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mKGluc3Quc3RheV9vcGVuKSAhPT0gJ2Jvb2xlYW4nIHx8IGluc3Quc3RheV9vcGVuID09PSBmYWxzZSkge1xyXG5cclxuXHRcdFx0dGhpcy5fYmFzZV91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xyXG5cclxuXHRcdFx0Ly8gUmVsb2FkIHRoZSB0aW1lIGNvbnRyb2wgd2hlbiBjaGFuZ2luZyBzb21ldGhpbmcgaW4gdGhlIGlucHV0IHRleHQgZmllbGQuXHJcblx0XHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiB0aGlyZCBiYWQgaGFjayA6LyBvdmVycmlkZSBkYXRlcGlja2VyIHNvIGl0IGFsbG93cyBzcGFjZXMgYW5kIGNvbG9uIGluIHRoZSBpbnB1dCBmaWVsZFxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX2RvS2V5UHJlc3MgPSAkLmRhdGVwaWNrZXIuX2RvS2V5UHJlc3M7XHJcblx0JC5kYXRlcGlja2VyLl9kb0tleVByZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHR2YXIgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpLFxyXG5cdFx0XHR0cF9pbnN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2NvbnN0cmFpbklucHV0JykpIHtcclxuXHRcdFx0XHR2YXIgYW1wbSA9IHRwX2luc3Quc3VwcG9ydC5hbXBtLFxyXG5cdFx0XHRcdFx0dHogPSB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXpvbmUgOiB0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUsXHJcblx0XHRcdFx0XHRkYXRlQ2hhcnMgPSAkLmRhdGVwaWNrZXIuX3Bvc3NpYmxlQ2hhcnMoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgJ2RhdGVGb3JtYXQnKSksXHJcblx0XHRcdFx0XHRkYXRldGltZUNoYXJzID0gdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdC50b1N0cmluZygpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW2htc10vZywgJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVFQvZywgYW1wbSA/ICdBUE0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVHQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvdFQvZywgYW1wbSA/ICdBYVBwTW0nIDogJycpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvVC9nLCBhbXBtID8gJ0FQJyA6ICcnKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3R0L2csIGFtcG0gPyAnYXBtJyA6ICcnKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL3QvZywgYW1wbSA/ICdhcCcgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIgXCIgKyB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMudGltZVN1ZmZpeCArXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQodHogPyB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lem9uZUxpc3Quam9pbignJykgOiAnJykgK1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KHRwX2luc3QuX2RlZmF1bHRzLmFtTmFtZXMuam9pbignJykpICsgKHRwX2luc3QuX2RlZmF1bHRzLnBtTmFtZXMuam9pbignJykpICtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGVDaGFycyxcclxuXHRcdFx0XHRcdGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUgPT09IHVuZGVmaW5lZCA/IGV2ZW50LmtleUNvZGUgOiBldmVudC5jaGFyQ29kZSk7XHJcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmN0cmxLZXkgfHwgKGNociA8ICcgJyB8fCAhZGF0ZUNoYXJzIHx8IGRhdGV0aW1lQ2hhcnMuaW5kZXhPZihjaHIpID4gLTEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVByZXNzKGV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogRm91cnRoIGJhZCBoYWNrIDovIG92ZXJyaWRlIF91cGRhdGVBbHRlcm5hdGUgZnVuY3Rpb24gdXNlZCBpbiBpbmxpbmUgbW9kZSB0byBpbml0IGFsdEZpZWxkXHJcblx0KiBVcGRhdGUgYW55IGFsdGVybmF0ZSBmaWVsZCB0byBzeW5jaHJvbmlzZSB3aXRoIHRoZSBtYWluIGZpZWxkLlxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZSA9ICQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlO1xyXG5cdCQuZGF0ZXBpY2tlci5fdXBkYXRlQWx0ZXJuYXRlID0gZnVuY3Rpb24gKGluc3QpIHtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgYWx0RmllbGQgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZDtcclxuXHRcdFx0aWYgKGFsdEZpZWxkKSB7IC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXHJcblx0XHRcdFx0dmFyIGFsdEZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdEZvcm1hdCB8fCB0cF9pbnN0Ll9kZWZhdWx0cy5kYXRlRm9ybWF0LFxyXG5cdFx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCksXHJcblx0XHRcdFx0XHRmb3JtYXRDZmcgPSAkLmRhdGVwaWNrZXIuX2dldEZvcm1hdENvbmZpZyhpbnN0KSxcclxuXHRcdFx0XHRcdGFsdEZvcm1hdHRlZERhdGVUaW1lID0gJycsXHJcblx0XHRcdFx0XHRhbHRTZXBhcmF0b3IgPSB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRTZXBhcmF0b3IgOiB0cF9pbnN0Ll9kZWZhdWx0cy5zZXBhcmF0b3IsXHJcblx0XHRcdFx0XHRhbHRUaW1lU3VmZml4ID0gdHBfaW5zdC5fZGVmYXVsdHMuYWx0VGltZVN1ZmZpeCA/IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVTdWZmaXggOiB0cF9pbnN0Ll9kZWZhdWx0cy50aW1lU3VmZml4LFxyXG5cdFx0XHRcdFx0YWx0VGltZUZvcm1hdCA9IHRwX2luc3QuX2RlZmF1bHRzLmFsdFRpbWVGb3JtYXQgIT09IG51bGwgPyB0cF9pbnN0Ll9kZWZhdWx0cy5hbHRUaW1lRm9ybWF0IDogdHBfaW5zdC5fZGVmYXVsdHMudGltZUZvcm1hdDtcclxuXHJcblx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgKz0gJC5kYXRlcGlja2VyLmZvcm1hdFRpbWUoYWx0VGltZUZvcm1hdCwgdHBfaW5zdCwgdHBfaW5zdC5fZGVmYXVsdHMpICsgYWx0VGltZVN1ZmZpeDtcclxuXHRcdFx0XHRpZiAoIXRwX2luc3QuX2RlZmF1bHRzLnRpbWVPbmx5ICYmICF0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGaWVsZFRpbWVPbmx5ICYmIGRhdGUgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQpIHtcclxuXHRcdFx0XHRcdFx0YWx0Rm9ybWF0dGVkRGF0ZVRpbWUgPSAkLmRhdGVwaWNrZXIuZm9ybWF0RGF0ZSh0cF9pbnN0Ll9kZWZhdWx0cy5hbHRGb3JtYXQsIGRhdGUsIGZvcm1hdENmZykgKyBhbHRTZXBhcmF0b3IgKyBhbHRGb3JtYXR0ZWREYXRlVGltZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhbHRGb3JtYXR0ZWREYXRlVGltZSA9IHRwX2luc3QuZm9ybWF0dGVkRGF0ZSArIGFsdFNlcGFyYXRvciArIGFsdEZvcm1hdHRlZERhdGVUaW1lO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQkKGFsdEZpZWxkKS52YWwoIGluc3QuaW5wdXQudmFsKCkgPyBhbHRGb3JtYXR0ZWREYXRlVGltZSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0JC5kYXRlcGlja2VyLl9iYXNlX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogT3ZlcnJpZGUga2V5IHVwIGV2ZW50IHRvIHN5bmMgbWFudWFsIGlucHV0IGNoYW5nZXMuXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZG9LZXlVcCA9ICQuZGF0ZXBpY2tlci5fZG9LZXlVcDtcclxuXHQkLmRhdGVwaWNrZXIuX2RvS2V5VXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdHZhciBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXHJcblx0XHRcdHRwX2luc3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCAndGltZXBpY2tlcicpO1xyXG5cclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdGlmICh0cF9pbnN0Ll9kZWZhdWx0cy50aW1lT25seSAmJiAoaW5zdC5pbnB1dC52YWwoKSAhPT0gaW5zdC5sYXN0VmFsKSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdFx0XHQkLnRpbWVwaWNrZXIubG9nKGVycik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuICQuZGF0ZXBpY2tlci5fYmFzZV9kb0tleVVwKGV2ZW50KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgXCJUb2RheVwiIGJ1dHRvbiB0byBhbHNvIGdyYWIgdGhlIHRpbWUgYW5kIHNldCBpdCB0byBpbnB1dCBmaWVsZC5cclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nb3RvVG9kYXkgPSAkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheTtcclxuXHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheSA9IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KCQoaWQpWzBdKTtcclxuXHRcdHRoaXMuX2Jhc2VfZ290b1RvZGF5KGlkKTtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAoIXRwX2luc3QpIHtcclxuXHRcdCAgcmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0em9mZnNldCA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0cF9pbnN0LnRpbWV6b25lKTtcclxuXHRcdHZhciBub3cgPSBuZXcgRGF0ZSgpO1xyXG5cdFx0bm93LnNldE1pbnV0ZXMobm93LmdldE1pbnV0ZXMoKSArIG5vdy5nZXRUaW1lem9uZU9mZnNldCgpICsgcGFyc2VJbnQodHpvZmZzZXQsIDEwKSk7XHJcblx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIG5vdyk7XHJcblx0XHR0aGlzLl9zZXREYXRlKGluc3QsIG5vdyk7XHJcblx0XHR0cF9pbnN0Ll9vblNlbGVjdEhhbmRsZXIoKTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogRGlzYWJsZSAmIGVuYWJsZSB0aGUgVGltZSBpbiB0aGUgZGF0ZXRpbWVwaWNrZXJcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fZGlzYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xyXG5cdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5zaG93VGltZXBpY2tlciA9IGZhbHNlO1xyXG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQkLmRhdGVwaWNrZXIuX2VuYWJsZVRpbWVwaWNrZXJEYXRlcGlja2VyID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHQkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpOyAvLyBJbml0IHNlbGVjdGVkW1llYXJ8TW9udGh8RGF5XVxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0aW5zdC5zZXR0aW5ncy5zaG93VGltZXBpY2tlciA9IHRydWU7XHJcblx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLnNob3dUaW1lcGlja2VyID0gdHJ1ZTtcclxuXHRcdFx0dHBfaW5zdC5fYWRkVGltZVBpY2tlcihpbnN0KTsgLy8gQ291bGQgYmUgZGlzYWJsZWQgb24gcGFnZSBsb2FkXHJcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBDcmVhdGUgb3VyIG93biBzZXQgdGltZSBmdW5jdGlvblxyXG5cdCovXHJcblx0JC5kYXRlcGlja2VyLl9zZXRUaW1lID0gZnVuY3Rpb24gKGluc3QsIGRhdGUpIHtcclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblx0XHRpZiAodHBfaW5zdCkge1xyXG5cdFx0XHR2YXIgZGVmYXVsdHMgPSB0cF9pbnN0Ll9kZWZhdWx0cztcclxuXHJcblx0XHRcdC8vIGNhbGxpbmcgX3NldFRpbWUgd2l0aCBubyBkYXRlIHNldHMgdGltZSB0byBkZWZhdWx0c1xyXG5cdFx0XHR0cF9pbnN0LmhvdXIgPSBkYXRlID8gZGF0ZS5nZXRIb3VycygpIDogZGVmYXVsdHMuaG91cjtcclxuXHRcdFx0dHBfaW5zdC5taW51dGUgPSBkYXRlID8gZGF0ZS5nZXRNaW51dGVzKCkgOiBkZWZhdWx0cy5taW51dGU7XHJcblx0XHRcdHRwX2luc3Quc2Vjb25kID0gZGF0ZSA/IGRhdGUuZ2V0U2Vjb25kcygpIDogZGVmYXVsdHMuc2Vjb25kO1xyXG5cdFx0XHR0cF9pbnN0Lm1pbGxpc2VjID0gZGF0ZSA/IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgOiBkZWZhdWx0cy5taWxsaXNlYztcclxuXHRcdFx0dHBfaW5zdC5taWNyb3NlYyA9IGRhdGUgPyBkYXRlLmdldE1pY3Jvc2Vjb25kcygpIDogZGVmYXVsdHMubWljcm9zZWM7XHJcblxyXG5cdFx0XHQvL2NoZWNrIGlmIHdpdGhpbiBtaW4vbWF4IHRpbWVzLi5cclxuXHRcdFx0dHBfaW5zdC5fbGltaXRNaW5NYXhEYXRlVGltZShpbnN0LCB0cnVlKTtcclxuXHJcblx0XHRcdHRwX2luc3QuX29uVGltZUNoYW5nZSgpO1xyXG5cdFx0XHR0cF9pbnN0Ll91cGRhdGVEYXRlVGltZShpbnN0KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogQ3JlYXRlIG5ldyBwdWJsaWMgbWV0aG9kIHRvIHNldCBvbmx5IHRpbWUsIGNhbGxhYmxlIGFzICQoKS5kYXRlcGlja2VyKCdzZXRUaW1lJywgZGF0ZSlcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fc2V0VGltZURhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBkYXRlLCB3aXRoRGF0ZSkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcclxuXHRcdFx0dmFyIHRwX2RhdGU7XHJcblx0XHRcdGlmIChkYXRlKSB7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHR0cF9pbnN0Ll9wYXJzZVRpbWUoZGF0ZSwgd2l0aERhdGUpO1xyXG5cdFx0XHRcdFx0dHBfZGF0ZSA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0XHR0cF9kYXRlLnNldEhvdXJzKHRwX2luc3QuaG91ciwgdHBfaW5zdC5taW51dGUsIHRwX2luc3Quc2Vjb25kLCB0cF9pbnN0Lm1pbGxpc2VjKTtcclxuXHRcdFx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cF9kYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xyXG5cdFx0XHRcdFx0dHBfZGF0ZS5zZXRNaWNyb3NlY29uZHMoZGF0ZS5nZXRNaWNyb3NlY29uZHMoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICh0cF9kYXRlLnRvU3RyaW5nKCkgPT09ICdJbnZhbGlkIERhdGUnKSB7XHJcblx0XHRcdFx0XHR0cF9kYXRlID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9zZXRUaW1lKGluc3QsIHRwX2RhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBzZXREYXRlKCkgdG8gYWxsb3cgc2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3RcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fc2V0RGF0ZURhdGVwaWNrZXI7XHJcblx0JC5kYXRlcGlja2VyLl9zZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIF9kYXRlKSB7XHJcblx0XHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcclxuXHRcdHZhciBkYXRlID0gX2RhdGU7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YoX2RhdGUpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRkYXRlID0gbmV3IERhdGUoX2RhdGUpO1xyXG5cdFx0XHRpZiAoIWRhdGUuZ2V0VGltZSgpKSB7XHJcblx0XHRcdFx0dGhpcy5fYmFzZV9zZXREYXRlRGF0ZXBpY2tlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdGRhdGUgPSAkKHRhcmdldCkuZGF0ZXBpY2tlcignZ2V0RGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdHZhciB0cF9kYXRlO1xyXG5cdFx0aWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHRwX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XHJcblx0XHRcdHRwX2RhdGUuc2V0TWljcm9zZWNvbmRzKGRhdGUuZ2V0TWljcm9zZWNvbmRzKCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHBfZGF0ZSA9IGRhdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgeW91IGFyZSB1c2luZyB0aGUgdGltZXpvbmUgb3B0aW9uLCBqYXZhc2NyaXB0J3MgRGF0ZVxyXG5cdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxyXG5cdFx0Ly8gYWRqdXN0IGl0IGFjY29yZGluZ2x5LiAgSWYgbm90IHVzaW5nIHRpbWV6b25lIG9wdGlvbiB0aGlzIHdvbid0IG1hdHRlci4uXHJcblx0XHQvLyBJZiBhIHRpbWV6b25lIGlzIGRpZmZlcmVudCBpbiB0cCwga2VlcCB0aGUgdGltZXpvbmUgYXMgaXNcclxuXHRcdGlmICh0cF9pbnN0ICYmIHRwX2RhdGUpIHtcclxuXHRcdFx0Ly8gbG9vayBvdXQgZm9yIERTVCBpZiB0eiB3YXNuJ3Qgc3BlY2lmaWVkXHJcblx0XHRcdGlmICghdHBfaW5zdC5zdXBwb3J0LnRpbWV6b25lICYmIHRwX2luc3QuX2RlZmF1bHRzLnRpbWV6b25lID09PSBudWxsKSB7XHJcblx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IHRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRhdGUgPSAkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QoZGF0ZSwgJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0U3RyaW5nKC1kYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpLCB0cF9pbnN0LnRpbWV6b25lKTtcclxuXHRcdFx0dHBfZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdCh0cF9kYXRlLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLXRwX2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSksIHRwX2luc3QudGltZXpvbmUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XHJcblx0XHR0aGlzLl9iYXNlX3NldERhdGVEYXRlcGlja2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzLl9zZXRUaW1lRGF0ZXBpY2tlcih0YXJnZXQsIHRwX2RhdGUsIHRydWUpO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBnZXREYXRlKCkgdG8gYWxsb3cgZ2V0dGluZyB0aW1lIHRvbyB3aXRoaW4gRGF0ZSBvYmplY3RcclxuXHQqL1xyXG5cdCQuZGF0ZXBpY2tlci5fYmFzZV9nZXREYXRlRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fZ2V0RGF0ZURhdGVwaWNrZXI7XHJcblx0JC5kYXRlcGlja2VyLl9nZXREYXRlRGF0ZXBpY2tlciA9IGZ1bmN0aW9uICh0YXJnZXQsIG5vRGVmYXVsdCkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0cF9pbnN0ID0gdGhpcy5fZ2V0KGluc3QsICd0aW1lcGlja2VyJyk7XHJcblxyXG5cdFx0aWYgKHRwX2luc3QpIHtcclxuXHRcdFx0Ly8gaWYgaXQgaGFzbid0IHlldCBiZWVuIGRlZmluZWQsIGdyYWIgZnJvbSBmaWVsZFxyXG5cdFx0XHRpZiAoaW5zdC5sYXN0VmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QsIG5vRGVmYXVsdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkYXRlID0gdGhpcy5fZ2V0RGF0ZShpbnN0KTtcclxuXHJcblx0XHRcdHZhciBjdXJyRFQgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKHRwX2luc3QuJGFsdElucHV0ICYmIHRwX2luc3QuX2RlZmF1bHRzLmFsdEZpZWxkVGltZU9ubHkpIHtcclxuXHRcdFx0XHRjdXJyRFQgPSB0cF9pbnN0LiRpbnB1dC52YWwoKSArICcgJyArIHRwX2luc3QuJGFsdElucHV0LnZhbCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRwX2luc3QuJGlucHV0LmdldCgwKS50YWdOYW1lICE9PSAnSU5QVVQnICYmIHRwX2luc3QuJGFsdElucHV0KSB7XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogaW4gY2FzZSB0aGUgZGF0ZXRpbWVwaWNrZXIgaGFzIGJlZW4gYXBwbGllZCB0byBhIG5vbi1pbnB1dCB0YWcgZm9yIGlubGluZSBVSSxcclxuXHRcdFx0XHQgKiBhbmQgdGhlIHVzZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZSBwbHVnaW4gdG8gZGlzcGxheSBvbmx5IHRpbWUgaW4gYWx0SW5wdXQsXHJcblx0XHRcdFx0ICogcGljayBjdXJyZW50IGRhdGUgdGltZSBmcm9tIHRoZSBhbHRJbnB1dCAoYW5kIGhvcGUgZm9yIHRoZSBiZXN0LCBmb3Igbm93LCB1bnRpbCBcIkVSMVwiIGlzIGFwcGxpZWQpXHJcblx0XHRcdFx0ICpcclxuXHRcdFx0XHQgKiBAdG9kbyBFUjEuIFNpbmNlIGFsdElucHV0IGNhbiBoYXZlIGEgdG90YWxseSBkaWZmZXJlbmNlIGZvcm1hdCwgY29udmVydCBpdCB0byBzdGFuZGFyZCBmb3JtYXQgYnkgcmVhZGluZyBpbnB1dCBmb3JtYXQgZnJvbSBcImFsdEZvcm1hdFwiIGFuZCBcImFsdFRpbWVGb3JtYXRcIiBvcHRpb24gdmFsdWVzXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kYWx0SW5wdXQudmFsKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y3VyckRUID0gdHBfaW5zdC4kaW5wdXQudmFsKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkYXRlICYmIHRwX2luc3QuX3BhcnNlVGltZShjdXJyRFQsICFpbnN0LnNldHRpbmdzLnRpbWVPbmx5KSkge1xyXG5cdFx0XHRcdGRhdGUuc2V0SG91cnModHBfaW5zdC5ob3VyLCB0cF9pbnN0Lm1pbnV0ZSwgdHBfaW5zdC5zZWNvbmQsIHRwX2luc3QubWlsbGlzZWMpO1xyXG5cdFx0XHRcdGRhdGUuc2V0TWljcm9zZWNvbmRzKHRwX2luc3QubWljcm9zZWMpO1xyXG5cclxuXHRcdFx0XHQvLyBUaGlzIGlzIGltcG9ydGFudCBpZiB5b3UgYXJlIHVzaW5nIHRoZSB0aW1lem9uZSBvcHRpb24sIGphdmFzY3JpcHQncyBEYXRlXHJcblx0XHRcdFx0Ly8gb2JqZWN0IHdpbGwgb25seSByZXR1cm4gdGhlIHRpbWV6b25lIG9mZnNldCBmb3IgdGhlIGN1cnJlbnQgbG9jYWxlLCBzbyB3ZVxyXG5cdFx0XHRcdC8vIGFkanVzdCBpdCBhY2NvcmRpbmdseS4gIElmIG5vdCB1c2luZyB0aW1lem9uZSBvcHRpb24gdGhpcyB3b24ndCBtYXR0ZXIuLlxyXG5cdFx0XHRcdGlmICh0cF9pbnN0LnRpbWV6b25lICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdC8vIGxvb2sgb3V0IGZvciBEU1QgaWYgdHogd2Fzbid0IHNwZWNpZmllZFxyXG5cdFx0XHRcdFx0aWYgKCF0cF9pbnN0LnN1cHBvcnQudGltZXpvbmUgJiYgdHBfaW5zdC5fZGVmYXVsdHMudGltZXpvbmUgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dHBfaW5zdC50aW1lem9uZSA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIC0xO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZGF0ZSA9ICQudGltZXBpY2tlci50aW1lem9uZUFkanVzdChkYXRlLCB0cF9pbnN0LnRpbWV6b25lLCAkLnRpbWVwaWNrZXIudGltZXpvbmVPZmZzZXRTdHJpbmcoLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLl9iYXNlX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgbm9EZWZhdWx0KTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgcGFyc2VEYXRlKCkgYmVjYXVzZSBVSSAxLjguMTQgdGhyb3dzIGFuIGVycm9yIGFib3V0IFwiRXh0cmEgY2hhcmFjdGVyc1wiXHJcblx0KiBBbiBvcHRpb24gaW4gZGF0YXBpY2tlciB0byBpZ25vcmUgZXh0cmEgZm9ybWF0IGNoYXJhY3RlcnMgd291bGQgYmUgbmljZXIuXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfcGFyc2VEYXRlID0gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZTtcclxuXHQkLmRhdGVwaWNrZXIucGFyc2VEYXRlID0gZnVuY3Rpb24gKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XHJcblx0XHR2YXIgZGF0ZTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGRhdGUgPSB0aGlzLl9iYXNlX3BhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncyk7XHJcblx0XHR9IGNhdGNoIChlcnIpIHtcclxuXHRcdFx0Ly8gSGFjayEgIFRoZSBlcnJvciBtZXNzYWdlIGVuZHMgd2l0aCBhIGNvbG9uLCBhIHNwYWNlLCBhbmRcclxuXHRcdFx0Ly8gdGhlIFwiZXh0cmFcIiBjaGFyYWN0ZXJzLiAgV2UgcmVseSBvbiB0aGF0IGluc3RlYWQgb2ZcclxuXHRcdFx0Ly8gYXR0ZW1wdGluZyB0byBwZXJmZWN0bHkgcmVwcm9kdWNlIHRoZSBwYXJzaW5nIGFsZ29yaXRobS5cclxuXHRcdFx0aWYgKGVyci5pbmRleE9mKFwiOlwiKSA+PSAwKSB7XHJcblx0XHRcdFx0ZGF0ZSA9IHRoaXMuX2Jhc2VfcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIChlcnIubGVuZ3RoIC0gZXJyLmluZGV4T2YoJzonKSAtIDIpKSwgc2V0dGluZ3MpO1xyXG5cdFx0XHRcdCQudGltZXBpY2tlci5sb2coXCJFcnJvciBwYXJzaW5nIHRoZSBkYXRlIHN0cmluZzogXCIgKyBlcnIgKyBcIlxcbmRhdGUgc3RyaW5nID0gXCIgKyB2YWx1ZSArIFwiXFxuZGF0ZSBmb3JtYXQgPSBcIiArIGZvcm1hdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgZXJyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGF0ZTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogb3ZlcnJpZGUgZm9ybWF0RGF0ZSB0byBzZXQgZGF0ZSB3aXRoIHRpbWUgdG8gdGhlIGlucHV0XHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2VfZm9ybWF0RGF0ZSA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZTtcclxuXHQkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUgPSBmdW5jdGlvbiAoaW5zdCwgZGF5LCBtb250aCwgeWVhcikge1xyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdHRwX2luc3QuX3VwZGF0ZURhdGVUaW1lKGluc3QpO1xyXG5cdFx0XHRyZXR1cm4gdHBfaW5zdC4kaW5wdXQudmFsKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fYmFzZV9mb3JtYXREYXRlKGluc3QpO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBvdmVycmlkZSBvcHRpb25zIHNldHRlciB0byBhZGQgdGltZSB0byBtYXhEYXRlKFRpbWUpIGFuZCBtaW5EYXRlKFRpbWUpLiBNYXhEYXRlXHJcblx0Ki9cclxuXHQkLmRhdGVwaWNrZXIuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciA9ICQuZGF0ZXBpY2tlci5fb3B0aW9uRGF0ZXBpY2tlcjtcclxuXHQkLmRhdGVwaWNrZXIuX29wdGlvbkRhdGVwaWNrZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xyXG5cdFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCksXHJcblx0XHRcdG5hbWVfY2xvbmU7XHJcblx0XHRpZiAoIWluc3QpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRwX2luc3QgPSB0aGlzLl9nZXQoaW5zdCwgJ3RpbWVwaWNrZXInKTtcclxuXHRcdGlmICh0cF9pbnN0KSB7XHJcblx0XHRcdHZhciBtaW4gPSBudWxsLFxyXG5cdFx0XHRcdG1heCA9IG51bGwsXHJcblx0XHRcdFx0b25zZWxlY3QgPSBudWxsLFxyXG5cdFx0XHRcdG92ZXJyaWRlcyA9IHRwX2luc3QuX2RlZmF1bHRzLmV2bnRzLFxyXG5cdFx0XHRcdGZucyA9IHt9LFxyXG5cdFx0XHRcdHByb3AsXHJcblx0XHRcdFx0cmV0LFxyXG5cdFx0XHRcdG9sZFZhbCxcclxuXHRcdFx0XHQkdGFyZ2V0O1xyXG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7IC8vIGlmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBzdHJpbmdcclxuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ21pbkRhdGUnIHx8IG5hbWUgPT09ICdtaW5EYXRlVGltZScpIHtcclxuXHRcdFx0XHRcdG1pbiA9IHZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ21heERhdGUnIHx8IG5hbWUgPT09ICdtYXhEYXRlVGltZScpIHtcclxuXHRcdFx0XHRcdG1heCA9IHZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZSA9PT0gJ29uU2VsZWN0Jykge1xyXG5cdFx0XHRcdFx0b25zZWxlY3QgPSB2YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiAodmFsdWUpID09PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gb3ZlcnJpZGVzW25hbWVdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm5zW25hbWVdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRuYW1lX2Nsb25lID0ge307IC8vZW1wdHkgcmVzdWx0cyBpbiBleGl0aW5nIGZ1bmN0aW9uIGFmdGVyIG92ZXJyaWRlcyB1cGRhdGVkXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgeyAvL2lmIG1pbi9tYXggd2FzIHNldCB3aXRoIHRoZSBKU09OXHJcblx0XHRcdFx0aWYgKG5hbWUubWluRGF0ZSkge1xyXG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5taW5EYXRlVGltZSkge1xyXG5cdFx0XHRcdFx0bWluID0gbmFtZS5taW5EYXRlVGltZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKG5hbWUubWF4RGF0ZSkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobmFtZS5tYXhEYXRlVGltZSkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbmFtZS5tYXhEYXRlVGltZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChwcm9wIGluIG92ZXJyaWRlcykge1xyXG5cdFx0XHRcdFx0aWYgKG92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBuYW1lW3Byb3BdKSB7XHJcblx0XHRcdFx0XHRcdGZuc1twcm9wXSA9IG5hbWVbcHJvcF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAocHJvcCBpbiBmbnMpIHtcclxuXHRcdFx0XHRpZiAoZm5zLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0XHRcdFx0XHRvdmVycmlkZXNbcHJvcF0gPSBmbnNbcHJvcF07XHJcblx0XHRcdFx0XHRpZiAoIW5hbWVfY2xvbmUpIHsgbmFtZV9jbG9uZSA9ICQuZXh0ZW5kKHt9LCBuYW1lKTsgfVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVfY2xvbmVbcHJvcF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChuYW1lX2Nsb25lICYmIGlzRW1wdHlPYmplY3QobmFtZV9jbG9uZSkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdGlmIChtaW4pIHsgLy9pZiBtaW4gd2FzIHNldFxyXG5cdFx0XHRcdGlmIChtaW4gPT09IDApIHtcclxuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1pbiA9IG5ldyBEYXRlKG1pbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1pbkRhdGUgPSBtaW47XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMubWluRGF0ZVRpbWUgPSBtaW47XHJcblx0XHRcdH0gZWxzZSBpZiAobWF4KSB7IC8vaWYgbWF4IHdhcyBzZXRcclxuXHRcdFx0XHRpZiAobWF4ID09PSAwKSB7XHJcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRtYXggPSBuZXcgRGF0ZShtYXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cF9pbnN0Ll9kZWZhdWx0cy5tYXhEYXRlID0gbWF4O1xyXG5cdFx0XHRcdHRwX2luc3QuX2RlZmF1bHRzLm1heERhdGVUaW1lID0gbWF4O1xyXG5cdFx0XHR9IGVsc2UgaWYgKG9uc2VsZWN0KSB7XHJcblx0XHRcdFx0dHBfaW5zdC5fZGVmYXVsdHMub25TZWxlY3QgPSBvbnNlbGVjdDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRGF0ZXBpY2tlciB3aWxsIG92ZXJyaWRlIG91ciBkYXRlIHdoZW4gd2UgY2FsbCBfYmFzZV9vcHRpb25EYXRlcGlja2VyIHdoZW5cclxuXHRcdFx0Ly8gY2FsbGluZyBtaW5EYXRlL21heERhdGUsIHNvIHdlIHdpbGwgZmlyc3QgZ3JhYiB0aGUgdmFsdWUsIGNhbGxcclxuXHRcdFx0Ly8gX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlciwgdGhlbiBzZXQgb3VyIHZhbHVlIGJhY2suXHJcblx0XHRcdGlmKG1pbiB8fCBtYXgpe1xyXG5cdFx0XHRcdCR0YXJnZXQgPSAkKHRhcmdldCk7XHJcblx0XHRcdFx0b2xkVmFsID0gJHRhcmdldC5kYXRldGltZXBpY2tlcignZ2V0RGF0ZScpO1xyXG5cdFx0XHRcdHJldCA9IHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcclxuXHRcdFx0XHQkdGFyZ2V0LmRhdGV0aW1lcGlja2VyKCdzZXREYXRlJywgb2xkVmFsKTtcclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fYmFzZV9vcHRpb25EYXRlcGlja2VyLmNhbGwoJC5kYXRlcGlja2VyLCB0YXJnZXQsIG5hbWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2Vfb3B0aW9uRGF0ZXBpY2tlci5jYWxsKCQuZGF0ZXBpY2tlciwgdGFyZ2V0LCBuYW1lX2Nsb25lIHx8IG5hbWUsIHZhbHVlKTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogalF1ZXJ5IGlzRW1wdHlPYmplY3QgZG9lcyBub3QgY2hlY2sgaGFzT3duUHJvcGVydHkgLSBpZiBzb21lb25lIGhhcyBhZGRlZCB0byB0aGUgb2JqZWN0IHByb3RvdHlwZSxcclxuXHQqIGl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBhbGwgb2JqZWN0c1xyXG5cdCovXHJcblx0dmFyIGlzRW1wdHlPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgcHJvcDtcclxuXHRcdGZvciAocHJvcCBpbiBvYmopIHtcclxuXHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIGpRdWVyeSBleHRlbmQgbm93IGlnbm9yZXMgbnVsbHMhXHJcblx0Ki9cclxuXHR2YXIgZXh0ZW5kUmVtb3ZlID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuXHRcdCQuZXh0ZW5kKHRhcmdldCwgcHJvcHMpO1xyXG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xyXG5cdFx0XHRpZiAocHJvcHNbbmFtZV0gPT09IG51bGwgfHwgcHJvcHNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRhcmdldFtuYW1lXSA9IHByb3BzW25hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBEZXRlcm1pbmUgYnkgdGhlIHRpbWUgZm9ybWF0IHdoaWNoIHVuaXRzIGFyZSBzdXBwb3J0ZWRcclxuXHQqIFJldHVybnMgYW4gb2JqZWN0IG9mIGJvb2xlYW5zIGZvciBlYWNoIHVuaXRcclxuXHQqL1xyXG5cdHZhciBkZXRlY3RTdXBwb3J0ID0gZnVuY3Rpb24gKHRpbWVGb3JtYXQpIHtcclxuXHRcdHZhciB0ZiA9IHRpbWVGb3JtYXQucmVwbGFjZSgvJy4qPycvZywgJycpLnRvTG93ZXJDYXNlKCksIC8vIHJlbW92ZXMgbGl0ZXJhbHNcclxuXHRcdFx0aXNJbiA9IGZ1bmN0aW9uIChmLCB0KSB7IC8vIGRvZXMgdGhlIGZvcm1hdCBjb250YWluIHRoZSB0b2tlbj9cclxuXHRcdFx0XHRcdHJldHVybiBmLmluZGV4T2YodCkgIT09IC0xID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0XHRcdH07XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGhvdXI6IGlzSW4odGYsICdoJyksXHJcblx0XHRcdFx0bWludXRlOiBpc0luKHRmLCAnbScpLFxyXG5cdFx0XHRcdHNlY29uZDogaXNJbih0ZiwgJ3MnKSxcclxuXHRcdFx0XHRtaWxsaXNlYzogaXNJbih0ZiwgJ2wnKSxcclxuXHRcdFx0XHRtaWNyb3NlYzogaXNJbih0ZiwgJ2MnKSxcclxuXHRcdFx0XHR0aW1lem9uZTogaXNJbih0ZiwgJ3onKSxcclxuXHRcdFx0XHRhbXBtOiBpc0luKHRmLCAndCcpICYmIGlzSW4odGltZUZvcm1hdCwgJ2gnKSxcclxuXHRcdFx0XHRpc284NjAxOiBpc0luKHRpbWVGb3JtYXQsICdaJylcclxuXHRcdFx0fTtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCogQ29udmVydHMgMjQgaG91ciBmb3JtYXQgaW50byAxMiBob3VyXHJcblx0KiBSZXR1cm5zIDEyIGhvdXIgd2l0aG91dCBsZWFkaW5nIDBcclxuXHQqL1xyXG5cdHZhciBjb252ZXJ0MjR0bzEyID0gZnVuY3Rpb24gKGhvdXIpIHtcclxuXHRcdGhvdXIgJT0gMTI7XHJcblxyXG5cdFx0aWYgKGhvdXIgPT09IDApIHtcclxuXHRcdFx0aG91ciA9IDEyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBTdHJpbmcoaG91cik7XHJcblx0fTtcclxuXHJcblx0dmFyIGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nID0gZnVuY3Rpb24gKHNldHRpbmdzLCBwcm9wZXJ0eSkge1xyXG5cdFx0cmV0dXJuIHNldHRpbmdzICYmIHNldHRpbmdzW3Byb3BlcnR5XSA/IHNldHRpbmdzW3Byb3BlcnR5XSA6ICQudGltZXBpY2tlci5fZGVmYXVsdHNbcHJvcGVydHldO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBTcGxpdHMgZGF0ZXRpbWUgc3RyaW5nIGludG8gZGF0ZSBhbmQgdGltZSBzdWJzdHJpbmdzLlxyXG5cdCogVGhyb3dzIGV4Y2VwdGlvbiB3aGVuIGRhdGUgY2FuJ3QgYmUgcGFyc2VkXHJcblx0KiBSZXR1cm5zIHtkYXRlU3RyaW5nOiBkYXRlU3RyaW5nLCB0aW1lU3RyaW5nOiB0aW1lU3RyaW5nfVxyXG5cdCovXHJcblx0dmFyIHNwbGl0RGF0ZVRpbWUgPSBmdW5jdGlvbiAoZGF0ZVRpbWVTdHJpbmcsIHRpbWVTZXR0aW5ncykge1xyXG5cdFx0Ly8gVGhlIGlkZWEgaXMgdG8gZ2V0IHRoZSBudW1iZXIgc2VwYXJhdG9yIG9jY3VycmVuY2VzIGluIGRhdGV0aW1lIGFuZCB0aGUgdGltZSBmb3JtYXQgcmVxdWVzdGVkIChzaW5jZSB0aW1lIGhhc1xyXG5cdFx0Ly8gZmV3ZXIgdW5rbm93bnMsIG1vc3RseSBudW1iZXJzIGFuZCBhbS9wbSkuIFdlIHdpbGwgdXNlIHRoZSB0aW1lIHBhdHRlcm4gdG8gc3BsaXQuXHJcblx0XHR2YXIgc2VwYXJhdG9yID0gY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcodGltZVNldHRpbmdzLCAnc2VwYXJhdG9yJyksXHJcblx0XHRcdGZvcm1hdCA9IGNvbXB1dGVFZmZlY3RpdmVTZXR0aW5nKHRpbWVTZXR0aW5ncywgJ3RpbWVGb3JtYXQnKSxcclxuXHRcdFx0dGltZVBhcnRzID0gZm9ybWF0LnNwbGl0KHNlcGFyYXRvciksIC8vIGhvdyBtYW55IG9jY3VycmVuY2VzIG9mIHNlcGFyYXRvciBtYXkgYmUgaW4gb3VyIGZvcm1hdD9cclxuXHRcdFx0dGltZVBhcnRzTGVuID0gdGltZVBhcnRzLmxlbmd0aCxcclxuXHRcdFx0YWxsUGFydHMgPSBkYXRlVGltZVN0cmluZy5zcGxpdChzZXBhcmF0b3IpLFxyXG5cdFx0XHRhbGxQYXJ0c0xlbiA9IGFsbFBhcnRzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoYWxsUGFydHNMZW4gPiAxKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZGF0ZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIGFsbFBhcnRzTGVuIC0gdGltZVBhcnRzTGVuKS5qb2luKHNlcGFyYXRvciksXHJcblx0XHRcdFx0dGltZVN0cmluZzogYWxsUGFydHMuc3BsaWNlKDAsIHRpbWVQYXJ0c0xlbikuam9pbihzZXBhcmF0b3IpXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0ZGF0ZVN0cmluZzogZGF0ZVRpbWVTdHJpbmcsXHJcblx0XHRcdHRpbWVTdHJpbmc6ICcnXHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBkYXRldGltZSBpbnRlcnZhbFxyXG5cdCogUmV0dXJuczoge2RhdGU6IERhdGUsIHRpbWVPYmo6IE9iamVjdH0sIHdoZXJlXHJcblx0KiAgIGRhdGUgLSBwYXJzZWQgZGF0ZSB3aXRob3V0IHRpbWUgKHR5cGUgRGF0ZSlcclxuXHQqICAgdGltZU9iaiA9IHtob3VyOiAsIG1pbnV0ZTogLCBzZWNvbmQ6ICwgbWlsbGlzZWM6ICwgbWljcm9zZWM6IH0gLSBwYXJzZWQgdGltZS4gT3B0aW9uYWxcclxuXHQqL1xyXG5cdHZhciBwYXJzZURhdGVUaW1lSW50ZXJuYWwgPSBmdW5jdGlvbiAoZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgZGF0ZVRpbWVTdHJpbmcsIGRhdGVTZXR0aW5ncywgdGltZVNldHRpbmdzKSB7XHJcblx0XHR2YXIgZGF0ZSxcclxuXHRcdFx0cGFydHMsXHJcblx0XHRcdHBhcnNlZFRpbWU7XHJcblxyXG5cdFx0cGFydHMgPSBzcGxpdERhdGVUaW1lKGRhdGVUaW1lU3RyaW5nLCB0aW1lU2V0dGluZ3MpO1xyXG5cdFx0ZGF0ZSA9ICQuZGF0ZXBpY2tlci5fYmFzZV9wYXJzZURhdGUoZGF0ZUZvcm1hdCwgcGFydHMuZGF0ZVN0cmluZywgZGF0ZVNldHRpbmdzKTtcclxuXHJcblx0XHRpZiAocGFydHMudGltZVN0cmluZyA9PT0gJycpIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRkYXRlOiBkYXRlXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkVGltZSA9ICQuZGF0ZXBpY2tlci5wYXJzZVRpbWUodGltZUZvcm1hdCwgcGFydHMudGltZVN0cmluZywgdGltZVNldHRpbmdzKTtcclxuXHJcblx0XHRpZiAoIXBhcnNlZFRpbWUpIHtcclxuXHRcdFx0dGhyb3cgJ1dyb25nIHRpbWUgZm9ybWF0JztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRkYXRlOiBkYXRlLFxyXG5cdFx0XHR0aW1lT2JqOiBwYXJzZWRUaW1lXHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBJbnRlcm5hbCBmdW5jdGlvbiB0byBzZXQgdGltZXpvbmVfc2VsZWN0IHRvIHRoZSBsb2NhbCB0aW1lem9uZVxyXG5cdCovXHJcblx0dmFyIHNlbGVjdExvY2FsVGltZXpvbmUgPSBmdW5jdGlvbiAodHBfaW5zdCwgZGF0ZSkge1xyXG5cdFx0aWYgKHRwX2luc3QgJiYgdHBfaW5zdC50aW1lem9uZV9zZWxlY3QpIHtcclxuXHRcdFx0dmFyIG5vdyA9IGRhdGUgfHwgbmV3IERhdGUoKTtcclxuXHRcdFx0dHBfaW5zdC50aW1lem9uZV9zZWxlY3QudmFsKC1ub3cuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQqIENyZWF0ZSBhIFNpbmdsZXRvbiBJbnN0YW5jZVxyXG5cdCovXHJcblx0JC50aW1lcGlja2VyID0gbmV3IFRpbWVwaWNrZXIoKTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB0aW1lem9uZSBvZmZzZXQgYXMgc3RyaW5nIGZyb20gYSBkYXRlIG9iamVjdCAoZWcgJyswNTMwJyBmb3IgVVRDKzUuNSlcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHpNaW51dGVzIGlmIG5vdCBhIG51bWJlciwgbGVzcyB0aGFuIC03MjAgKC0xMjAwKSwgb3IgZ3JlYXRlciB0aGFuIDg0MCAoKzE0MDApIHRoaXMgdmFsdWUgaXMgcmV0dXJuZWRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzbzg2MDEgaWYgdHJ1ZSBmb3JtYXRzIGluIGFjY29yZGFuY2UgdG8gaXNvODYwMSBcIisxMjo0NVwiXHJcblx0ICogQHJldHVybiB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldFN0cmluZyA9IGZ1bmN0aW9uICh0ek1pbnV0ZXMsIGlzbzg2MDEpIHtcclxuXHRcdGlmIChpc05hTih0ek1pbnV0ZXMpIHx8IHR6TWludXRlcyA+IDg0MCB8fCB0ek1pbnV0ZXMgPCAtNzIwKSB7XHJcblx0XHRcdHJldHVybiB0ek1pbnV0ZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9mZiA9IHR6TWludXRlcyxcclxuXHRcdFx0bWludXRlcyA9IG9mZiAlIDYwLFxyXG5cdFx0XHRob3VycyA9IChvZmYgLSBtaW51dGVzKSAvIDYwLFxyXG5cdFx0XHRpc28gPSBpc284NjAxID8gJzonIDogJycsXHJcblx0XHRcdHR6ID0gKG9mZiA+PSAwID8gJysnIDogJy0nKSArICgnMCcgKyBNYXRoLmFicyhob3VycykpLnNsaWNlKC0yKSArIGlzbyArICgnMCcgKyBNYXRoLmFicyhtaW51dGVzKSkuc2xpY2UoLTIpO1xyXG5cclxuXHRcdGlmICh0eiA9PT0gJyswMDowMCcpIHtcclxuXHRcdFx0cmV0dXJuICdaJztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0ejtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG51bWJlciBpbiBtaW51dGVzIHRoYXQgcmVwcmVzZW50cyBhIHRpbWV6b25lIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gdHpTdHJpbmcgZm9ybWF0dGVkIGxpa2UgXCIrMDUwMFwiLCBcIi0xMjQ1XCIsIFwiWlwiXHJcblx0ICogQHJldHVybiB7bnVtYmVyfSB0aGUgb2Zmc2V0IG1pbnV0ZXMgb3IgdGhlIG9yaWdpbmFsIHN0cmluZyBpZiBpdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGF0aW9uc1xyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlciA9IGZ1bmN0aW9uICh0elN0cmluZykge1xyXG5cdFx0dmFyIG5vcm1hbGl6ZWQgPSB0elN0cmluZy50b1N0cmluZygpLnJlcGxhY2UoJzonLCAnJyk7IC8vIGV4Y3VzZSBhbnkgaXNvODYwMSwgZW5kIHVwIHdpdGggXCIrMTI0NVwiXHJcblxyXG5cdFx0aWYgKG5vcm1hbGl6ZWQudG9VcHBlckNhc2UoKSA9PT0gJ1onKSB7IC8vIGlmIGlzbzg2MDEgd2l0aCBaLCBpdHMgMCBtaW51dGUgb2Zmc2V0XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghL14oXFwtfFxcKylcXGR7NH0kLy50ZXN0KG5vcm1hbGl6ZWQpKSB7IC8vIHBvc3NpYmx5IGEgdXNlciBkZWZpbmVkIHR6LCBzbyBqdXN0IGdpdmUgaXQgYmFja1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQodHpTdHJpbmcsIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gKChub3JtYWxpemVkLnN1YnN0cigwLCAxKSA9PT0gJy0nID8gLTEgOiAxKSAqIC8vIHBsdXMgb3IgbWludXNcclxuXHRcdFx0XHRcdCgocGFyc2VJbnQobm9ybWFsaXplZC5zdWJzdHIoMSwgMiksIDEwKSAqIDYwKSArIC8vIGhvdXJzIChjb252ZXJ0ZWQgdG8gbWludXRlcylcclxuXHRcdFx0XHRcdHBhcnNlSW50KG5vcm1hbGl6ZWQuc3Vic3RyKDMsIDIpLCAxMCkpKTsgLy8gbWludXRlc1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIE5vIHdheSB0byBzZXQgdGltZXpvbmUgaW4ganMgRGF0ZSwgc28gd2UgbXVzdCBhZGp1c3QgdGhlIG1pbnV0ZXMgdG8gY29tcGVuc2F0ZS4gKHRoaW5rIHNldERhdGUsIGdldERhdGUpXHJcblx0ICogQHBhcmFtICB7RGF0ZX0gZGF0ZVxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZnJvbVRpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXHJcblx0ICogQHBhcmFtICB7c3RyaW5nfSB0b1RpbWV6b25lIGZvcm1hdHRlZCBsaWtlIFwiKzA1MDBcIiwgXCItMTI0NVwiXHJcblx0ICogQHJldHVybiB7RGF0ZX1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIudGltZXpvbmVBZGp1c3QgPSBmdW5jdGlvbiAoZGF0ZSwgZnJvbVRpbWV6b25lLCB0b1RpbWV6b25lKSB7XHJcblx0XHR2YXIgZnJvbVR6ID0gJC50aW1lcGlja2VyLnRpbWV6b25lT2Zmc2V0TnVtYmVyKGZyb21UaW1lem9uZSk7XHJcblx0XHR2YXIgdG9UeiA9ICQudGltZXBpY2tlci50aW1lem9uZU9mZnNldE51bWJlcih0b1RpbWV6b25lKTtcclxuXHRcdGlmICghaXNOYU4odG9UeikpIHtcclxuXHRcdFx0ZGF0ZS5zZXRNaW51dGVzKGRhdGUuZ2V0TWludXRlcygpICsgKC1mcm9tVHopIC0gKC10b1R6KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGF0ZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWxscyBgdGltZXBpY2tlcigpYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xyXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXHJcblx0ICogbi5iLiBUaGUgaW5wdXQgdmFsdWUgbXVzdCBiZSBjb3JyZWN0bHkgZm9ybWF0dGVkIChyZWZvcm1hdHRpbmcgaXMgbm90IHN1cHBvcnRlZClcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXHJcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0aW1lcGlja2VyKCkgY2FsbFxyXG5cdCAqIEByZXR1cm4ge2pRdWVyeX1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIudGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuICQudGltZXBpY2tlci5oYW5kbGVSYW5nZSgndGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGRhdGV0aW1lcGlja2VyYCBvbiB0aGUgYHN0YXJ0VGltZWAgYW5kIGBlbmRUaW1lYCBlbGVtZW50cywgYW5kIGNvbmZpZ3VyZXMgdGhlbSB0b1xyXG5cdCAqIGVuZm9yY2UgZGF0ZSByYW5nZSBsaW1pdHMuXHJcblx0ICogQHBhcmFtICB7RWxlbWVudH0gc3RhcnRUaW1lXHJcblx0ICogQHBhcmFtICB7RWxlbWVudH0gZW5kVGltZVxyXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgYHRpbWVwaWNrZXIoKWAgY2FsbC4gQWxzbyBzdXBwb3J0cyBgcmVmb3JtYXRgLFxyXG5cdCAqICAgYSBib29sZWFuIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlcyB0byB0aGUgYGRhdGVGb3JtYXRgLlxyXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbWV0aG9kIENhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIHR5cGUgb2YgcGlja2VyIHRvIGJlIGFkZGVkXHJcblx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci5kYXRldGltZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucykge1xyXG5cdFx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlKCdkYXRldGltZXBpY2tlcicsIHN0YXJ0VGltZSwgZW5kVGltZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbHMgYGRhdGVwaWNrZXJgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXHJcblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBzdGFydFRpbWVcclxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbmRUaW1lXHJcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBgdGltZXBpY2tlcigpYCBjYWxsLiBBbHNvIHN1cHBvcnRzIGByZWZvcm1hdGAsXHJcblx0ICogICBhIGJvb2xlYW4gdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZvcm1hdCB0aGUgaW5wdXQgdmFsdWVzIHRvIHRoZSBgZGF0ZUZvcm1hdGAuXHJcblx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdCAqL1xyXG5cdCQudGltZXBpY2tlci5kYXRlUmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XHJcblx0XHQkLnRpbWVwaWNrZXIuaGFuZGxlUmFuZ2UoJ2RhdGVwaWNrZXInLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxzIGBtZXRob2RgIG9uIHRoZSBgc3RhcnRUaW1lYCBhbmQgYGVuZFRpbWVgIGVsZW1lbnRzLCBhbmQgY29uZmlndXJlcyB0aGVtIHRvXHJcblx0ICogZW5mb3JjZSBkYXRlIHJhbmdlIGxpbWl0cy5cclxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZCBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSB0eXBlIG9mIHBpY2tlciB0byBiZSBhZGRlZFxyXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IHN0YXJ0VGltZVxyXG5cdCAqIEBwYXJhbSAge0VsZW1lbnR9IGVuZFRpbWVcclxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIGB0aW1lcGlja2VyKClgIGNhbGwuIEFsc28gc3VwcG9ydHMgYHJlZm9ybWF0YCxcclxuXHQgKiAgIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZm9ybWF0IHRoZSBpbnB1dCB2YWx1ZXMgdG8gdGhlIGBkYXRlRm9ybWF0YC5cclxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9XHJcblx0ICovXHJcblx0JC50aW1lcGlja2VyLmhhbmRsZVJhbmdlID0gZnVuY3Rpb24gKG1ldGhvZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gJC5leHRlbmQoe30sIHtcclxuXHRcdFx0bWluSW50ZXJ2YWw6IDAsIC8vIG1pbiBhbGxvd2VkIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xyXG5cdFx0XHRtYXhJbnRlcnZhbDogMCwgLy8gbWF4IGFsbG93ZWQgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdHN0YXJ0OiB7fSwgICAgICAvLyBvcHRpb25zIGZvciBzdGFydCBwaWNrZXJcclxuXHRcdFx0ZW5kOiB7fSAgICAgICAgIC8vIG9wdGlvbnMgZm9yIGVuZCBwaWNrZXJcclxuXHRcdH0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdC8vIGZvciB0aGUgbWVhbiB0aW1lIHRoaXMgZml4ZXMgYW4gaXNzdWUgd2l0aCBjYWxsaW5nIGdldERhdGUgd2l0aCB0aW1lcGlja2VyKClcclxuXHRcdHZhciB0aW1lT25seSA9IGZhbHNlO1xyXG5cdFx0aWYobWV0aG9kID09PSAndGltZXBpY2tlcicpe1xyXG5cdFx0XHR0aW1lT25seSA9IHRydWU7XHJcblx0XHRcdG1ldGhvZCA9ICdkYXRldGltZXBpY2tlcic7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2hlY2tEYXRlcyhjaGFuZ2VkLCBvdGhlcikge1xyXG5cdFx0XHR2YXIgc3RhcnRkdCA9IHN0YXJ0VGltZVttZXRob2RdKCdnZXREYXRlJyksXHJcblx0XHRcdFx0ZW5kZHQgPSBlbmRUaW1lW21ldGhvZF0oJ2dldERhdGUnKSxcclxuXHRcdFx0XHRjaGFuZ2VkZHQgPSBjaGFuZ2VkW21ldGhvZF0oJ2dldERhdGUnKTtcclxuXHJcblx0XHRcdGlmIChzdGFydGR0ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0dmFyIG1pbkRhdGUgPSBuZXcgRGF0ZShzdGFydGR0LmdldFRpbWUoKSksXHJcblx0XHRcdFx0XHRtYXhEYXRlID0gbmV3IERhdGUoc3RhcnRkdC5nZXRUaW1lKCkpO1xyXG5cclxuXHRcdFx0XHRtaW5EYXRlLnNldE1pbGxpc2Vjb25kcyhtaW5EYXRlLmdldE1pbGxpc2Vjb25kcygpICsgb3B0aW9ucy5taW5JbnRlcnZhbCk7XHJcblx0XHRcdFx0bWF4RGF0ZS5zZXRNaWxsaXNlY29uZHMobWF4RGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWF4SW50ZXJ2YWwpO1xyXG5cclxuXHRcdFx0XHRpZiAob3B0aW9ucy5taW5JbnRlcnZhbCA+IDAgJiYgbWluRGF0ZSA+IGVuZGR0KSB7IC8vIG1pbkludGVydmFsIGNoZWNrXHJcblx0XHRcdFx0XHRlbmRUaW1lW21ldGhvZF0oJ3NldERhdGUnLCBtaW5EYXRlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAob3B0aW9ucy5tYXhJbnRlcnZhbCA+IDAgJiYgbWF4RGF0ZSA8IGVuZGR0KSB7IC8vIG1heCBpbnRlcnZhbCBjaGVja1xyXG5cdFx0XHRcdFx0ZW5kVGltZVttZXRob2RdKCdzZXREYXRlJywgbWF4RGF0ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHN0YXJ0ZHQgPiBlbmRkdCkge1xyXG5cdFx0XHRcdFx0b3RoZXJbbWV0aG9kXSgnc2V0RGF0ZScsIGNoYW5nZWRkdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2VsZWN0ZWQoY2hhbmdlZCwgb3RoZXIsIG9wdGlvbikge1xyXG5cdFx0XHRpZiAoIWNoYW5nZWQudmFsKCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGRhdGUgPSBjaGFuZ2VkW21ldGhvZF0uY2FsbChjaGFuZ2VkLCAnZ2V0RGF0ZScpO1xyXG5cdFx0XHRpZiAoZGF0ZSAhPT0gbnVsbCAmJiBvcHRpb25zLm1pbkludGVydmFsID4gMCkge1xyXG5cdFx0XHRcdGlmIChvcHRpb24gPT09ICdtaW5EYXRlJykge1xyXG5cdFx0XHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIG9wdGlvbnMubWluSW50ZXJ2YWwpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAob3B0aW9uID09PSAnbWF4RGF0ZScpIHtcclxuXHRcdFx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBvcHRpb25zLm1pbkludGVydmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChkYXRlLmdldFRpbWUpIHtcclxuXHRcdFx0XHRvdGhlclttZXRob2RdLmNhbGwob3RoZXIsICdvcHRpb24nLCBvcHRpb24sIGRhdGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0JC5mblttZXRob2RdLmNhbGwoc3RhcnRUaW1lLCAkLmV4dGVuZCh7XHJcblx0XHRcdHRpbWVPbmx5OiB0aW1lT25seSxcclxuXHRcdFx0b25DbG9zZTogZnVuY3Rpb24gKGRhdGVUZXh0LCBpbnN0KSB7XHJcblx0XHRcdFx0Y2hlY2tEYXRlcygkKHRoaXMpLCBlbmRUaW1lKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XHJcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgZW5kVGltZSwgJ21pbkRhdGUnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgb3B0aW9ucywgb3B0aW9ucy5zdGFydCkpO1xyXG5cdFx0JC5mblttZXRob2RdLmNhbGwoZW5kVGltZSwgJC5leHRlbmQoe1xyXG5cdFx0XHR0aW1lT25seTogdGltZU9ubHksXHJcblx0XHRcdG9uQ2xvc2U6IGZ1bmN0aW9uIChkYXRlVGV4dCwgaW5zdCkge1xyXG5cdFx0XHRcdGNoZWNrRGF0ZXMoJCh0aGlzKSwgc3RhcnRUaW1lKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uIChzZWxlY3RlZERhdGVUaW1lKSB7XHJcblx0XHRcdFx0c2VsZWN0ZWQoJCh0aGlzKSwgc3RhcnRUaW1lLCAnbWF4RGF0ZScpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCBvcHRpb25zLCBvcHRpb25zLmVuZCkpO1xyXG5cclxuXHRcdGNoZWNrRGF0ZXMoc3RhcnRUaW1lLCBlbmRUaW1lKTtcclxuXHJcblx0XHRzZWxlY3RlZChzdGFydFRpbWUsIGVuZFRpbWUsICdtaW5EYXRlJyk7XHJcblx0XHRzZWxlY3RlZChlbmRUaW1lLCBzdGFydFRpbWUsICdtYXhEYXRlJyk7XHJcblxyXG5cdFx0cmV0dXJuICQoW3N0YXJ0VGltZS5nZXQoMCksIGVuZFRpbWUuZ2V0KDApXSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogTG9nIGVycm9yIG9yIGRhdGEgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGVycm9yIG9yIGRlYnVnZ2luZ1xyXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZXJyIHBhc3MgYW55IHR5cGUgb2JqZWN0IHRvIGxvZyB0byB0aGUgY29uc29sZSBkdXJpbmcgZXJyb3Igb3IgZGVidWdnaW5nXHJcblx0ICogQHJldHVybiB7dm9pZH1cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIubG9nID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gT2xkZXIgSUUgKDksIG1heWJlIDEwKSB0aHJvdyBlcnJvciBvbiBhY2Nlc3NpbmcgYHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseWAsIHNvIGNoZWNrIGZpcnN0LlxyXG5cdFx0aWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZyAmJiB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkpIHtcclxuXHRcdFx0d2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCAqIEFkZCB1dGlsIG9iamVjdCB0byBhbGxvdyBhY2Nlc3MgdG8gcHJpdmF0ZSBtZXRob2RzIGZvciB0ZXN0YWJpbGl0eS5cclxuXHQgKi9cclxuXHQkLnRpbWVwaWNrZXIuX3V0aWwgPSB7XHJcblx0XHRfZXh0ZW5kUmVtb3ZlOiBleHRlbmRSZW1vdmUsXHJcblx0XHRfaXNFbXB0eU9iamVjdDogaXNFbXB0eU9iamVjdCxcclxuXHRcdF9jb252ZXJ0MjR0bzEyOiBjb252ZXJ0MjR0bzEyLFxyXG5cdFx0X2RldGVjdFN1cHBvcnQ6IGRldGVjdFN1cHBvcnQsXHJcblx0XHRfc2VsZWN0TG9jYWxUaW1lem9uZTogc2VsZWN0TG9jYWxUaW1lem9uZSxcclxuXHRcdF9jb21wdXRlRWZmZWN0aXZlU2V0dGluZzogY29tcHV0ZUVmZmVjdGl2ZVNldHRpbmcsXHJcblx0XHRfc3BsaXREYXRlVGltZTogc3BsaXREYXRlVGltZSxcclxuXHRcdF9wYXJzZURhdGVUaW1lSW50ZXJuYWw6IHBhcnNlRGF0ZVRpbWVJbnRlcm5hbFxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0KiBNaWNyb3NlY29uZCBzdXBwb3J0XHJcblx0Ki9cclxuXHRpZiAoIURhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcykge1xyXG5cdFx0RGF0ZS5wcm90b3R5cGUubWljcm9zZWNvbmRzID0gMDtcclxuXHRcdERhdGUucHJvdG90eXBlLmdldE1pY3Jvc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWljcm9zZWNvbmRzOyB9O1xyXG5cdFx0RGF0ZS5wcm90b3R5cGUuc2V0TWljcm9zZWNvbmRzID0gZnVuY3Rpb24gKG0pIHtcclxuXHRcdFx0dGhpcy5zZXRNaWxsaXNlY29uZHModGhpcy5nZXRNaWxsaXNlY29uZHMoKSArIE1hdGguZmxvb3IobSAvIDEwMDApKTtcclxuXHRcdFx0dGhpcy5taWNyb3NlY29uZHMgPSBtICUgMTAwMDtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LypcclxuXHQqIEtlZXAgdXAgd2l0aCB0aGUgdmVyc2lvblxyXG5cdCovXHJcblx0JC50aW1lcGlja2VyLnZlcnNpb24gPSBcIjEuNi4zXCI7XHJcblxyXG59KSk7XHJcbiIsInJlcXVpcmUoJy4uL2RhdGFncmlkL2pxdWVyeS5nY3J1ZC5kYXRhZ3JpZC5qcycpO1xualF1ZXJ5KGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiBHcm9jZXJ5Q1JVRE9uRG9jdW1lbnRSZWFkeSgpIHtcbiAgICBqUXVlcnkoJy5nYy1jb250YWluZXInKS5ncm9jZXJ5Q3J1ZCgpO1xufSk7XG4iLCJ2YXIgJCA9IGpRdWVyeSxcbiAgICBpMThuID0gcmVxdWlyZSgnLi4vLi4vc2VjdGlvbnMvaTE4bicpLmkxOG4sXG4gICAgYWpheEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvYWpheC1oZWxwZXInKS5hamF4SGVscGVyLFxuICAgIGpRdWVyeVBsdWdpbnMgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24galF1ZXJ5UGx1Z2luc0luaXQoKSB7XG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuc2V0RGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIGNvbnN0cmFpbklucHV0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QnV0dG9uUGFuZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlTW9udGg6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlWWVhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbG9zZVRleHQ6IGkxOG4udCgnY2FsZW5kYXJfY2xvc2VfdGV4dCcpLFxuICAgICAgICAgICAgICAgIHByZXZUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX3ByZXZfdGV4dCcpLFxuICAgICAgICAgICAgICAgIG5leHRUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX25leHRfdGV4dCcpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0OiBpMThuLnQoJ2NhbGVuZGFyX2N1cnJlbnRfdGV4dCcpLFxuICAgICAgICAgICAgICAgIG1vbnRoTmFtZXM6IGkxOG4udCgnY2FsZW5kYXJfbW9udGhfbmFtZXMnKSxcbiAgICAgICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IGkxOG4udCgnY2FsZW5kYXJfbW9udGhfbmFtZXNfc2hvcnQnKSxcbiAgICAgICAgICAgICAgICBkYXlOYW1lczogaTE4bi50KCdjYWxlbmRhcl9kYXlfbmFtZXMnKSxcbiAgICAgICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBpMThuLnQoJ2NhbGVuZGFyX2RheV9uYW1lc19zaG9ydCcpLFxuICAgICAgICAgICAgICAgIGRheU5hbWVzTWluOiBpMThuLnQoJ2NhbGVuZGFyX2RheV9uYW1lc19taW4nKSxcbiAgICAgICAgICAgICAgICB3ZWVrSGVhZGVyOiBpMThuLnQoJ2NhbGVuZGFyX3dlZWtfaGVhZGVyJylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkLnRpbWVwaWNrZXIuc2V0RGVmYXVsdHMoe1xuICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQ6ICdISDptbTpzcycsXG4gICAgICAgICAgICAgICAgdGltZVRleHQ6IGkxOG4udCgndGltZV90ZXh0JyksXG4gICAgICAgICAgICAgICAgaG91clRleHQ6IGkxOG4udCgndGltZV9ob3VyX3RleHQnKSxcbiAgICAgICAgICAgICAgICBtaW51dGVUZXh0OiBpMThuLnQoJ3RpbWVfbWludXRlX3RleHQnKSxcbiAgICAgICAgICAgICAgICBzZWNvbmRUZXh0OiBpMThuLnQoJ3RpbWVfc2Vjb25kX3RleHQnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRhdGVwaWNrZXI6IGZ1bmN0aW9uIGRhdGVwaWNrZXIoJHNlbGVjdG9yLCBnY0luc3RhbmNlKSB7XG4gICAgICAgICAgICAkc2VsZWN0b3IuZGF0ZXBpY2tlcih7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogKGdjSW5zdGFuY2UgIT09IHVuZGVmaW5lZCA/IGdjSW5zdGFuY2UuZGF0ZUZvcm1hdCA6ICd5eS1tbS1kZCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6IGZ1bmN0aW9uIGRhdGV0aW1lcGlja2VyKCRzZWxlY3RvciwgZ2NJbnN0YW5jZSkge1xuICAgICAgICAgICAgJHNlbGVjdG9yLmRhdGV0aW1lcGlja2VyKHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiAoZ2NJbnN0YW5jZSAhPT0gdW5kZWZpbmVkID8gZ2NJbnN0YW5jZS5kYXRlRm9ybWF0IDogJ3l5LW1tLWRkJylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0ZWRpdG9yOiBmdW5jdGlvbiB0ZXh0ZWRpdG9yKCRzZWxlY3Rvcikge1xuICAgICAgICAgICAgJHNlbGVjdG9yLmNrZWRpdG9yKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVRleHRlZGl0b3I6IGZ1bmN0aW9uIHRleHRlZGl0b3IoZmllbGROYW1lLCBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIENLRURJVE9SLmluc3RhbmNlc1tmaWVsZE5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIENLRURJVE9SLmluc3RhbmNlc1tmaWVsZE5hbWVdLnNldERhdGEoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3lUZXh0ZWRpdG9yOiBmdW5jdGlvbiBkZXN0cm95VGV4dGVkaXRvcihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQ0tFRElUT1IuaW5zdGFuY2VzW2ZpZWxkTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgQ0tFRElUT1IuaW5zdGFuY2VzW2ZpZWxkTmFtZV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hhYmxlU2VsZWN0OiBmdW5jdGlvbiBzZWFyY2hhYmxlU2VsZWN0KCRzZWxlY3RvciwgaXNSZWFkT25seSA9IGZhbHNlLCBteVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAkc2VsZWN0b3IuY2hvc2VuKCdkZXN0cm95Jyk7XG5cbiAgICAgICAgICAgIC8vIFRpbWVvdXQgYXMganF1ZXJ5IENob3NlbiBpcyBkeW5hbWljYWxseSBjaGVja2luZyBmb3Igc2VsZWN0IHdpZHRoXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVPdXRmb3JTZWFyY2hhYmxlU2VsZWN0KCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92aW5nIGhpZGRlbiBjbGFzcyBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIHdpZHRoIHdpdGggY2hvc2VuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlbGVjdG9yLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNlbGVjdG9yLmNob3Nlbih7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X3NpbmdsZV9kZXNlbGVjdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLmNoYW5nZShmdW5jdGlvbiBvbkNob3NlbkNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG15UmVhY3RDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15UmVhY3RDb21wb25lbnQubGlua2VkQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICQodGhpcykudmFsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGJhY2sgdGhlIGhpZGRlbiBjbGFzcyBmb3IgcmVhZCBPbmx5XG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Rvci5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Rvci5uZXh0KCkuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3Rvci5uZXh0KCkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hhYmxlU2VsZWN0VXBkYXRlOiBmdW5jdGlvbiBzZWFyY2hhYmxlU2VsZWN0VXBkYXRlKCRzZWxlY3RvciwgaXNSZWFkT25seSkge1xuICAgICAgICAgICAgaWYgKGlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAkc2VsZWN0b3IubmV4dCgpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNlbGVjdG9yLnRyaWdnZXIoJ2Nob3Nlbjp1cGRhdGVkJyk7XG4gICAgICAgICAgICAgICAgJHNlbGVjdG9yLm5leHQoKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaGFibGVBamF4U2VsZWN0OiBmdW5jdGlvbiBzZWFyY2hhYmxlQWpheFNlbGVjdCgkc2VsZWN0b3IsIGdjSW5zdGFuY2UpIHtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lT3V0U2VhcmNoYWJsZUFqYXhTZWxlY3QoKSB7XG4gICAgICAgICAgICAgICAgJHNlbGVjdG9yLnNlbGVjdDIoe1xuICAgICAgICAgICAgICAgICAgICBhamF4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFqYXhIZWxwZXIuZ2V0VXJsLmFwcGx5KGdjSW5zdGFuY2UsIFsnYWpheC1zZWFyY2gnXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheTogMjUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24gZ2V0RGF0YVBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3ZhbHVlOiBwYXJhbXMudGVybSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfbmFtZTogJ2NvdW50cnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYXJhbXMucGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1Jlc3VsdHM6IGZ1bmN0aW9uIGFqYXhQcm9jZXNzUmVzdWx0cyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucGFnZSA9IHBhcmFtcy5wYWdlIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogZGF0YS5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZTogKHBhcmFtcy5wYWdlICogMzApIDwgZGF0YS50b3RhbF9jb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NsZWFyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBhbiBvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVNYXJrdXA6IGZ1bmN0aW9uIGVzY2FwZU1hcmt1cE1ha2VJdFdvcmsobWFya3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya3VwO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUmVzdWx0OiBmdW5jdGlvbiB0ZW1wbGF0ZVJlc3VsdChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50aXRsZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVTZWxlY3Rpb246IGZ1bmN0aW9uIHRlbXBsYXRlU2VsZWN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRpdGxlIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJHNlbGVjdG9yLnNlbGVjdDIoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ0dSJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0dyZWVjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaGFibGVBamF4U2VsZWN0VXBkYXRlOiBmdW5jdGlvbiBzZWFyY2hhYmxlQWpheFNlbGVjdFVwZGF0ZSgkc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICRzZWxlY3Rvci50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLmpRdWVyeVBsdWdpbnMgPSBqUXVlcnlQbHVnaW5zO1xuIiwiXG5cbmNsYXNzIFBlclBhZ2VEcm9wZG93biBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBkZWZhdWx0UGVyUGFnZSwgcGFnaW5nT3B0aW9ucyB9ID0gdGhpcy5wcm9wcztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPHNlbGVjdCBuYW1lPVwicGVyX3BhZ2VcIiBjbGFzc05hbWU9XCJwZXJfcGFnZSBmb3JtLWNvbnRyb2xcIiBkZWZhdWx0VmFsdWU9e2RlZmF1bHRQZXJQYWdlfT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2luZ09wdGlvbnMubWFwKGZ1bmN0aW9uIFBlclBhZ2VEcm9wRG93bkZvckVhY2goZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gdmFsdWU9e2ZpZWxkVmFsdWV9IGtleT17ZmllbGRWYWx1ZX0+e2ZpZWxkVmFsdWV9PC9vcHRpb24+O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGVyUGFnZURyb3Bkb3duO1xuIiwidmFyIENvbnN0YW50cyA9IHtcbiAgICBQQUdJTkc6IHtcbiAgICAgICAgQ0xBU1NfUEVSX1BBR0U6ICdwZXJfcGFnZSdcbiAgICB9LFxuXG4gICAgUkVTUE9OU0U6IHtcbiAgICAgICAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxuICAgICAgICBGQUlMVVJFOiAnZmFpbHVyZSdcbiAgICB9LFxuXG4gICAgRklFTERfVFlQRV9SRUxBVElPTjogJ3JlbGF0aW9uYWwnLFxuICAgIEZJRUxEX1RZUEVfUkVMQVRJT05fTkFUSVZFOiAncmVsYXRpb25hbF9uYXRpdmUnLFxuICAgIEZJRUxEX1RZUEVfUkVMQVRJT05fTl9UT19OOiAncmVsYXRpb25hbF9uX24nLFxuICAgIEZJRUxEX1RZUEVfREVQRU5ERURfUkVMQVRJT046ICdkZXBlbmRlZF9yZWxhdGlvbmFsJyxcbiAgICBGSUVMRF9UWVBFX05BVElWRV9SRUxBVElPTl9OX1RPX046ICduYXRpdmVfcmVsYXRpb25hbF9uX24nLFxuICAgIEZJRUxEX1RZUEVfREFURTogJ2RhdGUnLFxuICAgIEZJRUxEX1RZUEVfREFURVRJTUU6ICdkYXRldGltZScsXG4gICAgRklFTERfVFlQRV9USU1FU1RBTVA6ICd0aW1lc3RhbXAnLFxuICAgIFNFTEVDVE9SX1NUUklOR19WQVJJQUJMRVM6ICcuc3RyaW5nLXZhcmlhYmxlcycsXG4gICAgU0VMRUNUT1JfR1JJRF9UQUJMRTogJy5ncm9jZXJ5LWNydWQtdGFibGUnLFxuICAgIFNFTEVDVE9SX1BBR0VfTlVNQkVSX0lOUFVUOiAnLnBhZ2UtbnVtYmVyLWlucHV0JyxcbiAgICBTRUxFQ1RPUl9ISURERU5fUEFHRV9OVU1CRVI6ICcucGFnZS1udW1iZXItaGlkZGVuJyxcbiAgICBTRUxFQ1RPUl9BQ1RJVkU6ICcuYWN0aXZlJyxcbiAgICBTRUxFQ1RPUl9WSVNJQkxFX0NPTFVNTl9DSEVDS0JPWDogJ2lucHV0W3R5cGU9Y2hlY2tib3hdJyxcbiAgICBTRUxFQ1RPUl9EQVRBR1JJRF9DT05UQUlORVI6ICcuZ2MtZ3JpZC1jb250YWluZXInLFxuICAgIFNFTEVDVE9SX0hFQURFUl9UT09MUzogJy5oZWFkZXItdG9vbHMnLFxuICAgIFNFTEVDVE9SX1NFVFRJTkdTOiAnLmdjLXNldHRpbmdzLWNvbnRhaW5lcicsXG4gICAgU0VMRUNUT1JfTU9EQUxfRk9STTogJy5nYy1mb3JtLW9wZXJhdGlvbi1tb2RhbCcsXG4gICAgU0VMRUNUT1JfTU9EQUxfQUREX0ZPUk1fQ09OVEFJTkVSOiAnLmdjLWluc2VydC1tb2RhbCcsXG4gICAgU0VMRUNUT1JfTU9EQUxfRURJVF9GT1JNX0NPTlRBSU5FUjogJy5nYy11cGRhdGUtbW9kYWwnLFxuICAgIFNFTEVDVE9SX01PREFMX1JFQURfRk9STV9DT05UQUlORVI6ICcuZ2MtcmVhZC1tb2RhbCcsXG4gICAgU0VMRUNUT1JfU0VBUkNIX1JPVzogJy5nYy1zZWFyY2gtcm93JyxcblxuICAgIFNFTEVDVE9SX1NFQVJDSF9GSUVMRF9JTlBVVDogJy5nYy1zZWFyY2hhYmxlLWlucHV0JyxcblxuICAgIFNFTEVDVE9SX0ZPUk06ICdmb3JtJyxcbiAgICBTRUxFQ1RPUl9DT0xVTU5TX1RSOiAnLmhlYWRlci1jb2x1bW5zJyxcblxuICAgIENMQVNTX0RJU0FCTEVEOiAnZGlzYWJsZWQnLFxuICAgIENMQVNTX0NPTFVNTl9PTl9IT1ZFUjogJ2JnLWluZm8nLFxuICAgIENMQVNTX1BBR0lOR19QUkVWSU9VUzogJ3BhZ2luZy1wcmV2aW91cycsXG4gICAgQ0xBU1NfUEFHSU5HX05FWFQ6ICdwYWdpbmctbmV4dCcsXG4gICAgQ0xBU1NfUEFHSU5HX0ZJUlNUOiAncGFnaW5nLWZpcnN0JyxcbiAgICBDTEFTU19QQUdJTkdfTEFTVDogJ3BhZ2luZy1sYXN0JyxcbiAgICBDTEFTU19QRVJfUEFHRTogJ3Blcl9wYWdlJyxcblxuICAgIEFDVElPTl9EQVRBR1JJRDogJ2RhdGFncmlkJyxcbiAgICBBQ1RJT05fUFJJTlQ6ICdwcmludCcsXG4gICAgQUNUSU9OX0FERF9GT1JNOiAnYWRkLWZvcm0nLFxuICAgIEFDVElPTl9FRElUX0ZPUk06ICdlZGl0LWZvcm0nLFxuICAgIEFDVElPTl9DTE9ORV9GT1JNOiAnY2xvbmUtZm9ybScsXG4gICAgQUNUSU9OX1JFQURfRk9STTogJ3JlYWQtZm9ybScsXG4gICAgQUNUSU9OX0lOU0VSVDogJ2luc2VydCcsXG4gICAgQUNUSU9OX0NMT05FOiAnY2xvbmUnLFxuICAgIEFDVElPTl9VUERBVEU6ICd1cGRhdGUnLFxuICAgIEFDVElPTl9SRUFEOiAncmVhZCcsXG4gICAgQUNUSU9OX1JFTU9WRV9PTkU6ICdyZW1vdmUtb25lJyxcbiAgICBBQ1RJT05fUkVNT1ZFX01VTFRJUExFOiAncmVtb3ZlLW11bHRpcGxlJyxcbiAgICBBQ1RJT05fSU5JVF9EQVRBOiAnaW5pdGlhbCcsXG5cbiAgICBTRUxFQ1RPUl9CVVRUT05fQUREOiAnLmJ1dHRvbi1hZGQnLFxuXG4gICAgRklFTERfTkFNRV9BQ1RJT046ICdhY3Rpb24nLFxuXG4gICAgSEFORExFQkFSU19URU1QTEFURV9ST1c6ICcuZ2MtdGFibGUtcm93JyxcbiAgICBIQU5ETEVCQVJTX1RFTVBMQVRFX0hFQURFUl9DT0xVTU5TOiAnLmdjLXRhYmxlLWhlYWRlci1jb2x1bW5zJyxcbiAgICBIQU5ETEVCQVJTX1RFTVBMQVRFX0NBUFRJT05fVElUTEU6ICcuZ2MtdGFibGUtdGl0bGUtY2FwdGlvbicsXG4gICAgSEFORExFQkFSU19BRERfQlVUVE9OOiAnLmdjLWFkZC1idXR0b24nLFxuICAgIEhBTkRMRUJBUlNfQUNUSU9OU19USVRMRTogJy5nYy1oZWFkZXItYWN0aW9ucy10aXRsZScsXG4gICAgSEFORExFQkFSU19FWFBPUlRfQlVUVE9OOiAnLmdjLWV4cG9ydC1idXR0b24nLFxuICAgIEhBTkRMRUJBUlNfUFJJTlRfQlVUVE9OOiAnLmdjLXByaW50LWJ1dHRvbicsXG4gICAgSEFORExFQkFSU19JTlNFUlRfTU9EQUw6ICcuZ2MtaW5zZXJ0LW1vZGFsLXRlbXBsYXRlJyxcbiAgICBIQU5ETEVCQVJTX1JFQURfTU9EQUw6ICcuZ2MtcmVhZC1tb2RhbC10ZW1wbGF0ZScsXG4gICAgSEFORExFQkFSU19SRUFEX0ZJRUxEX1JPVzogJy5nYy1yZWFkLWZpZWxkLXJvdycsXG4gICAgSEFORExFQkFSU19FUlJPUjogJy5nYy1lcnJvcicsXG4gICAgSEFORExFQkFSU19TRVRUSU5HU19CVVRUT05TOiAnLmdjLXNldHRpbmdzLWJ1dHRvbnMtdGVtcGxhdGUnLFxuICAgIEhBTkRMRUJBUlNfREVMRVRFX1NJTkdMRV9NT0RBTDogJy5nYy1jb25maXJtLWRlbGV0ZS1zaW5nbGUnLFxuICAgIEhBTkRMRUJBUlNfREVMRVRFX01VVExJUExFX01PREFMOiAnLmdjLWNvbmZpcm0tZGVsZXRlLW11bHRpcGxlJyxcbiAgICBIQU5ETEVCQVJTX1BSSU5UX0NPTlRBSU5FUjogJy5nYy1wcmludC10ZW1wbGF0ZScsXG4gICAgSEFORExFQkFSU19QUklOVF9IRUFERVI6ICcuZ2MtcHJpbnQtaGVhZGVyJyxcblxuICAgIFNFTEVDVE9SX1BBR0lOR19QUkVWSU9VUzogJy5wYWdpbmctcHJldmlvdXMnLFxuICAgIFNFTEVDVE9SX1BBR0lOR19ORVhUOiAnLnBhZ2luZy1uZXh0JyxcbiAgICBTRUxFQ1RPUl9QQUdJTkdfRklSU1Q6ICcucGFnaW5nLWZpcnN0JyxcbiAgICBTRUxFQ1RPUl9QQUdJTkdfTEFTVDogJy5wYWdpbmctbGFzdCcsXG5cbiAgICBDQU5DRUxfQlVUVE9OOiAnLmdjLWNhbmNlbC1idXR0b24nLFxuXG4gICAgU0VMRUNUT1JfREVMRVRFX0JVVFRPTjogJy5nYy1kZWxldGUtc2luZ2xlJyxcbiAgICBTRUxFQ1RPUl9ERUxFVEVfQ09ORklSTUFUSU9OX0JVVFRPTjogJy5kZWxldGUtc2luZ2xlLWNvbmZpcm1hdGlvbi1idXR0b24nLFxuICAgIFNFTEVDVE9SX0RFTEVURV9GT1JNX01PREFMOiAnLmRlbGV0ZS1zaW5nbGUtY29uZmlybWF0aW9uJyxcblxuICAgIFNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9GT1JNX01PREFMOiAnLmdjLWRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24nLFxuICAgIFNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9DT05GSVJNQVRJT05fQlVUVE9OOiAnLmRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24tYnV0dG9uJyxcblxuICAgIFNFTEVDVE9SX0RFTEVURV9DSEVDS0JPWDogJ2lucHV0LmdjLXNlbGVjdC1yb3cnLFxuICAgIFNFTEVDVE9SX0RFTEVURV9DSEVDS0JPWF9DSEVDS0VEOiAnaW5wdXQuZ2Mtc2VsZWN0LXJvdzpjaGVja2VkJyxcblxuICAgIFNFTEVDVE9SX0VESVRfQlVUVE9OOiAnLmdjLWVkaXQtYnV0dG9uJyxcbiAgICBTRUxFQ1RPUl9SRUFEX0JVVFRPTjogJy5nYy1yZWFkLWJ1dHRvbicsXG5cbiAgICBTRUxFQ1RPUl9NT0RBTF9CT0RZOiAnLm1vZGFsLWJvZHknLFxuXG4gICAgU0VMRUNUT1JfVFlQRV9EQVRFX0lOUFVUOiAnLmdjLWRhdGUnLFxuICAgIFNFTEVDVE9SX1RZUEVfREFURVRJTUVfSU5QVVQ6ICcuZ2MtZGF0ZXRpbWUnXG59O1xuXG5leHBvcnRzLkNvbnN0YW50cyA9IENvbnN0YW50cztcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgUmVsYXRpb25OdG9OID0gcmVxdWlyZSgnLi4vdHlwZXMvcmVsYXRpb24tbi1uJykuUmVsYXRpb25OdG9OLFxuICAgIFJlbGF0aW9uID0gcmVxdWlyZSgnLi4vdHlwZXMvcmVsYXRpb24nKS5SZWxhdGlvbixcbiAgICBFbnVtID0gcmVxdWlyZSgnLi4vdHlwZXMvZW51bScpLkVudW0sXG4gICAgRHJvcGRvd24gPSByZXF1aXJlKCcuLi90eXBlcy9kcm9wZG93bicpLkRyb3Bkb3duLFxuICAgIE11bHRpcGxlU2VsZWN0ID0gcmVxdWlyZSgnLi4vdHlwZXMvbXVsdGlwbGUtc2VsZWN0JykuTXVsdGlwbGVTZWxlY3QsXG4gICAgQ2hlY2tib3hCb29sZWFuID0gcmVxdWlyZSgnLi4vdHlwZXMvY2hlY2tib3gtYm9vbGVhbicpLkNoZWNrYm94Qm9vbGVhbixcbiAgICBEYXRlQW5kVGltZSA9IHJlcXVpcmUoJy4uL3R5cGVzL2RhdGUtYW5kLXRpbWUnKS5EYXRlQW5kVGltZSxcbiAgICBVcGxvYWQgPSByZXF1aXJlKCcuLi90eXBlcy91cGxvYWQnKS5VcGxvYWQsXG4gICAgVGV4dGVkaXRvciA9IHJlcXVpcmUoJy4uL3R5cGVzL3RleHRlZGl0b3InKS5UZXh0ZWRpdG9yLFxuICAgIENhbGxiYWNrQ29sdW1uID0gcmVxdWlyZSgnLi4vdHlwZXMvY2FsbGJhY2stY29sdW1uJykuQ2FsbGJhY2tDb2x1bW4sXG4gICAgQ29sdW1uID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGluaXRDYWNoZWREYXRhOiBmdW5jdGlvbiBpbml0Q2FjaGVkRGF0YSgpIHtcbiAgICAgICAgICAgIFJlbGF0aW9uTnRvTi5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIFJlbGF0aW9uLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgRW51bS5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIERhdGVBbmRUaW1lLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgVXBsb2FkLmluaXREYXRhLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgRHJvcGRvd24uaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBDaGVja2JveEJvb2xlYW4uaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBNdWx0aXBsZVNlbGVjdC5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIFRleHRlZGl0b3IuaW5pdERhdGEuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBDYWxsYmFja0NvbHVtbi5pbml0RGF0YS5hcHBseSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Um93c0RhdGE6IGZ1bmN0aW9uIGdldFJvd3NEYXRhKGRhdGFPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciByb3dEYXRhID0ge307XG5cbiAgICAgICAgICAgIHJvd0RhdGEuYmFja2VuZEFjdGlvbkJ1dHRvbnMgPSBkYXRhT2JqZWN0Lmdyb2NlcnlfY3J1ZF9leHRyYXMuYWN0aW9uQnV0dG9ucztcbiAgICAgICAgICAgIHJvd0RhdGEucHJpbWFyeUtleVZhbHVlID0gZGF0YU9iamVjdC5ncm9jZXJ5X2NydWRfZXh0cmFzLnByaW1hcnlLZXlWYWx1ZTtcblxuICAgICAgICAgICAgcm93RGF0YS5jb2x1bW5zRGF0YSA9IFtdO1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMudmlzaWJsZUNvbHVtbnMsIGZ1bmN0aW9uIGVhY2hWaXNpYmxlQ29sdW1ucyhjb2x1bW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd1ZhbHVlID0gZGF0YU9iamVjdFtjb2x1bW5OYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgaXNIdG1sID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHJvd1ZhbHVlID09PSBudWxsIHx8IHJvd1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFJlbGF0aW9uTnRvTi5pc050b04uYXBwbHkodGhpcywgW2NvbHVtbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dWYWx1ZSA9IFJlbGF0aW9uTnRvTi50cmFuc2Zvcm1EYXRhLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lLCByb3dWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXBsb2FkLmlzVXBsb2FkVHlwZS5hcHBseSh0aGlzLCBbY29sdW1uTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1ZhbHVlID0gVXBsb2FkLmZvcm1hdFVwbG9hZC5hcHBseSh0aGlzLCBbY29sdW1uTmFtZSwgcm93VmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgaXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKERyb3Bkb3duLmlzRHJvcGRvd24uYXBwbHkodGhpcywgW2NvbHVtbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dWYWx1ZSA9IERyb3Bkb3duLmZvcm1hdFZhbHVlLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lLCByb3dWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQ2hlY2tib3hCb29sZWFuLmlzQ2hlY2tib3hCb29sZWFuLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSBDaGVja2JveEJvb2xlYW4uZm9ybWF0VmFsdWUuYXBwbHkodGhpcywgW3Jvd1ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIGlzSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChSZWxhdGlvbi5pc1JlbGF0aW9uYWwuYXBwbHkodGhpcywgW2NvbHVtbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICByb3dWYWx1ZSA9IFJlbGF0aW9uLnRyYW5zZm9ybURhdGEuYXBwbHkodGhpcywgW2NvbHVtbk5hbWUsIHJvd1ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChNdWx0aXBsZVNlbGVjdC5pc1RoaXNUeXBlLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93VmFsdWUgPSBNdWx0aXBsZVNlbGVjdC50cmFuc2Zvcm1EYXRhLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lLCByb3dWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVGV4dGVkaXRvci5pc1RoaXNUeXBlLmFwcGx5KHRoaXMsIFtjb2x1bW5OYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKENhbGxiYWNrQ29sdW1uLmlzVGhpc1R5cGUuYXBwbHkodGhpcywgW2NvbHVtbk5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0h0bWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvd0RhdGEuY29sdW1uc0RhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByb3dWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNIdG1sOiBpc0h0bWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiByb3dEYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuQ29sdW1uID0gQ29sdW1uOyIsInZhciBHcmlkID0gcmVxdWlyZSgnLi9kYXRhZ3JpZC5ncmlkLmpzJykuR3JpZCxcbiAgICBqUXVlcnlQbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9qcXVlcnkvanF1ZXJ5LXBsdWdpbnMnKS5qUXVlcnlQbHVnaW5zLFxuICAgIGxvY2FsU3RvcmFnZUhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvbG9jYWwtc3RvcmFnZS1oZWxwZXInKS5sb2NhbFN0b3JhZ2VIZWxwZXIsXG4gICAgSGFuZGxlYmFycyA9IHJlcXVpcmUoJ2hhbmRsZWJhcnMnKSxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgRGF0YWdyaWRDb2x1bW5zID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIHNldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbiBzZXRWaXNpYmxlQ29sdW1ucygpIHtcbiAgICAgICAgICAgIGxldCB2aXNpYmxlQ29sdW1uc0NhY2hlLFxuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zO1xuXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1uc0NhY2hlID0gRGF0YWdyaWRDb2x1bW5zLmdldENhY2hlRm9yVmlzaWJsZUNvbHVtbnMuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh2aXNpYmxlQ29sdW1uc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRvZG86IEhhbmRsZSBKU09OLnBhcnNlXG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnNDYWNoZSA9IEpTT04ucGFyc2UodmlzaWJsZUNvbHVtbnNDYWNoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aXNpYmxlQ29sdW1uc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSBEYXRhZ3JpZENvbHVtbnMuZmlsdGVyVmlzaWJsZUNvbHVtbnMuYXBwbHkodGhpcywgW3Zpc2libGVDb2x1bW5zQ2FjaGVdKTtcblxuICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugd2UgZG9uJ3QgaGF2ZSBhbnkgdmlzaWJsZSBjb2x1bW5zIHRoZW4gYWRkIGFsbCB0aGUgY29sdW1ucyBhcyBjaGVja2VkXG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGVDb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBEYXRhZ3JpZENvbHVtbnMudHJpZ2dlckNvbHVtbnNSZW5kZXIuYXBwbHkodGhpcywgW3Zpc2libGVDb2x1bW5zXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlclZpc2libGVDb2x1bW5zOiBmdW5jdGlvbiBmaWx0ZXJWaXNpYmxlQ29sdW1ucyh2aXNpYmxlQ29sdW1ucykge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkVmlzaWJsZUNvbHVtbnMgPSB0aGlzLmNvbHVtbnMuZmlsdGVyKChjb2x1bW4pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2x1bW4uY29sdW1uTmFtZSkgPiAtMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFZpc2libGVDb2x1bW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkVmlzaWJsZUNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZFZpc2libGVDb2x1bW5zO1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZU9iamVjdEZpZWxkVHlwZXM6IGZ1bmN0aW9uIHRlbXBsYXRlT2JqZWN0RmllbGRUeXBlcyhjb2x1bW4pIHtcbiAgICAgICAgICAgIGxldCBmaWVsZCxcbiAgICAgICAgICAgICAgICBpc0VudW0sXG4gICAgICAgICAgICAgICAgaXNEYXRlLFxuICAgICAgICAgICAgICAgIGlzRGF0ZXRpbWUsXG4gICAgICAgICAgICAgICAgaXNEcm9wZG93bixcbiAgICAgICAgICAgICAgICBpc1JlbGF0aW9uYWwsXG4gICAgICAgICAgICAgICAgaXNOdG9OUmVsYXRpb25hbCxcbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGUsXG4gICAgICAgICAgICAgICAgaXNBamF4U2VhcmNoYWJsZSxcbiAgICAgICAgICAgICAgICBpc0Jvb2xlYW47XG5cbiAgICAgICAgICAgIGZpZWxkID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzW2NvbHVtbi5jb2x1bW5OYW1lXTtcblxuICAgICAgICAgICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZmluZCBjb2x1bW4gbmFtZTogXCInICsgY29sdW1uLmNvbHVtbk5hbWUgKyAnXCIgaW4gZmllbGRUeXBlcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICdUaGlzIGlzIHVzdWFsbHkgYW4gZXJyb3IgdGhhdCB5b3Ugd2lsbCBzZWUgd2hlbiB5b3VcXCd2ZSBhZGRlZCBhIGZpZWxkIG5hbWUgdGhhdCBkb2VzblxcJ3QgZXhpc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdpbiB0aGUgZGF0YWJhc2UuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlzRW51bSA9IChcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ2VudW0nIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdlbnVtX3NlYXJjaGFibGUnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNEYXRlID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZGF0ZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0RhdGV0aW1lID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZGF0ZXRpbWUnIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICd0aW1lc3RhbXAnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNEcm9wZG93biA9IChcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ2Ryb3Bkb3duJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZHJvcGRvd25fc2VhcmNoJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnbXVsdGlzZWxlY3Rfc2VhcmNoYWJsZScgfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ211bHRpc2VsZWN0X25hdGl2ZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc1JlbGF0aW9uYWwgPSAoXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdyZWxhdGlvbmFsJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAncmVsYXRpb25hbF9uYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdkZXBlbmRlZF9yZWxhdGlvbmFsJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzTnRvTlJlbGF0aW9uYWwgPSAoXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdyZWxhdGlvbmFsX25fbicgfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ25hdGl2ZV9yZWxhdGlvbmFsX25fbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc1NlYXJjaGFibGUgPSAoXG4gICAgICAgICAgICAgICAgZmllbGQuZGF0YVR5cGUgPT09ICdyZWxhdGlvbmFsX25fbicgfHxcbiAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ3JlbGF0aW9uYWwnIHx8XG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kYXRhVHlwZSA9PT0gJ2RlcGVuZGVkX3JlbGF0aW9uYWwnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuZGVwZW5kZWRGcm9tLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpc0FqYXhTZWFyY2hhYmxlID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnZGVwZW5kZWRfcmVsYXRpb25hbCcgJiZcbiAgICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLmRlcGVuZGVkRnJvbS5sZW5ndGggPiAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaXNCb29sZWFuID0gKFxuICAgICAgICAgICAgICAgIGZpZWxkLmRhdGFUeXBlID09PSAnY2hlY2tib3hfYm9vbGVhbidcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGNvbHVtbi5jb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogY29sdW1uLmRpc3BsYXlBcyxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmZvOiBmaWVsZCxcbiAgICAgICAgICAgICAgICBpc0VudW0sXG4gICAgICAgICAgICAgICAgaXNEcm9wZG93bixcbiAgICAgICAgICAgICAgICBpc1JlbGF0aW9uYWwsXG4gICAgICAgICAgICAgICAgaXNOdG9OUmVsYXRpb25hbCxcbiAgICAgICAgICAgICAgICBpc0RhdGUsXG4gICAgICAgICAgICAgICAgaXNEYXRldGltZSxcbiAgICAgICAgICAgICAgICBpc1NlYXJjaGFibGUsXG4gICAgICAgICAgICAgICAgaXNBamF4U2VhcmNoYWJsZSxcbiAgICAgICAgICAgICAgICBpc0Jvb2xlYW4sXG4gICAgICAgICAgICAgICAga25vd25GaWVsZDogKFxuICAgICAgICAgICAgICAgICAgICBpc0VudW0gfHxcbiAgICAgICAgICAgICAgICAgICAgaXNEcm9wZG93biB8fFxuICAgICAgICAgICAgICAgICAgICBpc1JlbGF0aW9uYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNOdG9OUmVsYXRpb25hbCB8fFxuICAgICAgICAgICAgICAgICAgICBpc0RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNEYXRldGltZSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0Jvb2xlYW5cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGhhc09yZGVyaW5nOiAoXG4gICAgICAgICAgICAgICAgICAgICFpc1JlbGF0aW9uYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzTnRvTlJlbGF0aW9uYWwgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzRHJvcGRvd25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyQ29sdW1uc1JlbmRlcjogZnVuY3Rpb24gdHJpZ2dlckNvbHVtbnNSZW5kZXIodmlzaWJsZUNvbHVtbnNSYXcpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zVGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVPYmplY3QsXG4gICAgICAgICAgICAgICAgc2VhcmNoQ29sdW1uc1RlbXBsYXRlLFxuICAgICAgICAgICAgICAgIGkxOG5TdHJpbmdzID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5pMThuLFxuICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zO1xuXG4gICAgICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdpZkNvbmQnLCBmdW5jdGlvbih2MSwgdjIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZih2MSA9PT0gdjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignaWZOb3QnLCBmdW5jdGlvbih2MSwgdjIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZih2MSAhPT0gdjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGVtcGxhdGVPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgdGFibGVfY29sdW1uczogW10sXG4gICAgICAgICAgICAgICAgaTE4bjogaTE4blN0cmluZ3MsXG4gICAgICAgICAgICAgICAgaGFzQWN0aW9uczogdGhpcy5kYXRhZ3JpZEhhc0FjdGlvbnMuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgc2VhcmNoQnlDb2x1bW46ICFHcmlkLmhhc0V4dGVuZGVkU2VhcmNoLmFwcGx5KHRoaXMpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodmlzaWJsZUNvbHVtbnNSYXcpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zUmF3O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IERhdGFncmlkQ29sdW1ucy5maWx0ZXJWaXNpYmxlQ29sdW1ucy5hcHBseSh0aGlzLCBbdGhpcy52aXNpYmxlQ29sdW1uc10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlbXBsYXRlT2JqZWN0LnRhYmxlX2NvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5tYXAoRGF0YWdyaWRDb2x1bW5zLnRlbXBsYXRlT2JqZWN0RmllbGRUeXBlcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSB2aXNpYmxlQ29sdW1ucy5tYXAoKGNvbHVtbikgPT4gY29sdW1uLmNvbHVtbk5hbWUpO1xuXG4gICAgICAgICAgICBjb2x1bW5zVGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoXG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuSEFORExFQkFSU19URU1QTEFURV9IRUFERVJfQ09MVU1OUykuaHRtbCgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VhcmNoQ29sdW1uc1RlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2gtY29sdW1ucycpLmh0bWwoKSwge1xuICAgICAgICAgICAgICAgIGkxOG46IGkxOG5TdHJpbmdzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaC1jb2x1bW4nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0NPTFVNTlNfVFIpLmh0bWwoY29sdW1uc1RlbXBsYXRlKHRlbXBsYXRlT2JqZWN0KSk7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLXJvdycpLmFwcGVuZChzZWFyY2hDb2x1bW5zVGVtcGxhdGUodGVtcGxhdGVPYmplY3QpKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWRhdGUnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5UGx1Z2lucy5kYXRlcGlja2VyKHRoaXMuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWRhdGUnKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaGFibGUtZGF0ZXRpbWUnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5UGx1Z2lucy5kYXRldGltZXBpY2tlcih0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1kYXRldGltZScpLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiRnYy5maW5kKCcuZ2Mtd2l0aC1zZWFyY2gtcGx1Z2luJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdCh0aGlzLiRnYy5maW5kKCcuZ2Mtd2l0aC1zZWFyY2gtcGx1Z2luJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBHcmlkLmFjdGl2YXRlT3JkZXJpbmdDb2x1bW4uYXBwbHkodGhpcyk7XG4gICAgICAgICAgICBHcmlkLmFjdGl2YXRlT3JkZXJpbmdSb3dzLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICBHcmlkLmxpc3RlbmVyQ29sdW1uV2l0aE9yZGVyaW5nLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgR3JpZC5saXN0ZW5lclNlYXJjaElucHV0LmFwcGx5KHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDYWNoZUZvclZpc2libGVDb2x1bW5zOiBmdW5jdGlvbiBzZXRDYWNoZUZvclZpc2libGVDb2x1bW5zKHZpc2libGVDb2x1bW5zKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2VIZWxwZXIuc2V0TG9jYWxTdG9yYWdlSXRlbSgnZ2NydWRWaXNpYmxlQ29sdW1uc18nICsgdGhpcy51bmlxdWVJZCwgSlNPTi5zdHJpbmdpZnkodmlzaWJsZUNvbHVtbnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2FjaGVGb3JWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24gZ2V0Q2FjaGVGb3JWaXNpYmxlQ29sdW1ucygpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2VIZWxwZXIuZ2V0TG9jYWxTdG9yYWdlSXRlbSgnZ2NydWRWaXNpYmxlQ29sdW1uc18nICsgdGhpcy51bmlxdWVJZCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuZXhwb3J0cy5EYXRhZ3JpZENvbHVtbnMgPSBEYXRhZ3JpZENvbHVtbnM7XG4iLCJ2YXIgJCA9IGpRdWVyeSxcbiAgICBsb2NhbFN0b3JhZ2VIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2xvY2FsLXN0b3JhZ2UtaGVscGVyJykubG9jYWxTdG9yYWdlSGVscGVyLFxuICAgIGFqYXhIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2FqYXgtaGVscGVyJykuYWpheEhlbHBlcixcbiAgICBEYXRhZ3JpZFBhZ2luZyA9IHJlcXVpcmUoJy4vZGF0YWdyaWQucGFnaW5nJykuRGF0YWdyaWRQYWdpbmcsXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIEdyaWQgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyOiBmdW5jdGlvbiBzZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIoaGlnaGxpZ2h0Um93SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFncmlkX29iamVjdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2NydWRfY29udGFpbmVyID0gZGF0YWdyaWRfb2JqZWN0LiRnYyxcbiAgICAgICAgICAgICAgICBhamF4X2xpc3RfdXJsID0gZ2NydWRfY29udGFpbmVyLmRhdGEoJ3VybCcpO1xuICAgICAgICAgICAgbGV0IGRhdGFUb1NlbmQ7XG5cbiAgICAgICAgICAgIERhdGFncmlkUGFnaW5nLnBhZ2luZ0NhbGN1bGF0aW9ucy5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgZGF0YVRvU2VuZCA9IEdyaWQuZ2V0RGF0YVRvU2VuZC5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnNldExvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBvcmRlcl9ieTogZGF0YVRvU2VuZC5vcmRlcl9ieSxcbiAgICAgICAgICAgICAgICBzb3J0aW5nOiBkYXRhVG9TZW5kLnNvcnRpbmdcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnNldExvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkUHJlZmVyZW5jZXMnLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcGVyX3BhZ2U6IGRhdGFUb1NlbmQucGVyX3BhZ2VcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgR3JpZC5zZXRFeHBvcnRVcmwuYXBwbHkodGhpcywgW2RhdGFUb1NlbmRdKTtcbiAgICAgICAgICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gJ2RhdGFncmlkJztcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgZGF0YVRvU2VuZFt0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dE5hbWVdID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZW5kUG9zdFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogYWpheF9saXN0X3VybCxcbiAgICAgICAgICAgICAgICBkYXRhVG9TZW5kOiBkYXRhVG9TZW5kLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gYWpheFN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5jc3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuID0ganNvblJlc3BvbnNlLmNzcmZUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRGF0YWdyaWQoanNvblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgR3JpZC51cGRhdGVHcmlkRGV0YWlscy5hcHBseSh0aGlzLCBbIGpzb25SZXNwb25zZSwgaGlnaGxpZ2h0Um93SWQgXSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2s6IGZ1bmN0aW9uIGRhdGFncmlkRXJyb3JDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlSGVscGVyLnJlbW92ZUxvY2FsU3RvcmFnZUl0ZW0oJ2djcnVkSW5pdGlhbERhdGFfJyArIHRoaXMudW5pcXVlSWQpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEV4cG9ydFVybDogZnVuY3Rpb24gc2V0RXhwb3J0VXJsKGRhdGFfdG9fc2VuZCkge1xuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZCgnLmdjLWV4cG9ydCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLFxuICAgICAgICAgICAgICAgICAgICBhamF4SGVscGVyLmdldFVybC5hcHBseSh0aGlzLCBbJ2V4cG9ydCcsIGRhdGFfdG9fc2VuZF0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VhcmNoRGF0YTogZnVuY3Rpb24gZ2V0U2VhcmNoRGF0YSgpIHtcbiAgICAgICAgICAgIGNvbnN0ICRzZWFyY2hfYWxsX2lucHV0ID0gdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24gPiBpbnB1dC5nYy1zZWFyY2gtaW5wdXQnKTtcblxuICAgICAgICAgICAgbGV0IHNlYXJjaF9maWVsZHMgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWFyY2hfdGV4dHMgPSBbXSxcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSB7fTtcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlYXJjaC1yb3cnKS5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1pbnB1dCwuZ2Mtc2VhcmNoYWJsZS1zZWxlY3QnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWFyY2hhYmxlSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlYXJjaFZhbHVlID0gJCh0aGlzKS52YWwoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2ZpZWxkcy5wdXNoKCQodGhpcykuYXR0cignbmFtZScpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3RleHRzLnB1c2goc2VhcmNoVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoLXJvdycpLmZpbmQoJ2lucHV0LmdjLXNlYXJjaGFibGUtY2hlY2tib3gnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWFyY2hhYmxlSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX2ZpZWxkcy5wdXNoKCQodGhpcykuYXR0cignbmFtZScpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3RleHRzLnB1c2goJzEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHNlYXJjaF9maWVsZHMubGVuZ3RoID4gMCAmJiAkc2VhcmNoX2FsbF9pbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgJHNlYXJjaF9hbGxfaW5wdXQudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAkc2VhcmNoX2FsbF9pbnB1dC50cmlnZ2VyKCdibHVyJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkc2VhcmNoX2FsbF9pbnB1dC5sZW5ndGggPiAwICYmICRzZWFyY2hfYWxsX2lucHV0LnZhbCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vTGV0J3MgdGFrZSBhZHZhbnRhZ2UgdGhhdCBKYXZhU2NyaXB0IGlzIG5vdCBzdHJvbmcgdHlwZSFcbiAgICAgICAgICAgICAgICBzZWFyY2hfZmllbGRzID0gJyc7XG4gICAgICAgICAgICAgICAgc2VhcmNoX3RleHRzID0gJHNlYXJjaF9hbGxfaW5wdXQudmFsKCk7XG4gICAgICAgICAgICAgICAgc2VhcmNoLl9nY3J1ZF9zZWFyY2hfYWxsID0gJHNlYXJjaF9hbGxfaW5wdXQudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlYXJjaF9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoU2VhcmNoRmllbGRzKHNlYXJjaGZpZWxkTmFtZSwgc2VhcmNoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoW3NlYXJjaGZpZWxkTmFtZV0gPSBzZWFyY2hfdGV4dHNbc2VhcmNoSW5kZXhdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWFyY2g7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE9yZGVyQnk6IGZ1bmN0aW9uIGdldE9yZGVyQnkoKSB7XG4gICAgICAgICAgICBjb25zdCBvcmRlcl9ieSA9IHRoaXMuJGdjLmZpbmQoJy5nYy1vcmRlci1ieS1oaWRkZW4nKS52YWwoKTtcblxuICAgICAgICAgICAgaWYgKG9yZGVyX2J5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yZGVyX2J5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2MuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nLmFjdGl2ZTpmaXJzdCcpLmRhdGEoJ29yZGVyLWJ5Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNvcnRpbmc6IGZ1bmN0aW9uIGdldFNvcnRpbmcoKSB7XG4gICAgICAgICAgICBsZXQgJGNvbHVtbldpdGhPcmRlcmluZyxcbiAgICAgICAgICAgICAgICBzb3J0aW5nID0gdGhpcy4kZ2MuZmluZCgnLmdjLXNvcnRpbmctaGlkZGVuJykudmFsKCk7XG5cbiAgICAgICAgICAgIGlmIChzb3J0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRjb2x1bW5XaXRoT3JkZXJpbmcgPSB0aGlzLiRnYy5maW5kKCcuY29sdW1uLXdpdGgtb3JkZXJpbmcuYWN0aXZlOmZpcnN0Jyk7XG5cbiAgICAgICAgICAgIGlmICgkY29sdW1uV2l0aE9yZGVyaW5nLmhhc0NsYXNzKCdvcmRlcmluZy1kZXNjJykpIHtcbiAgICAgICAgICAgICAgICBzb3J0aW5nID0gJ2Rlc2MnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkY29sdW1uV2l0aE9yZGVyaW5nLmhhc0NsYXNzKCdvcmRlcmluZy1hc2MnKSkge1xuICAgICAgICAgICAgICAgIHNvcnRpbmcgPSAnYXNjJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBlclBhZ2U6IGZ1bmN0aW9uIGdldFBlclBhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2MuZmluZCgnLnBlcl9wYWdlJykudmFsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBhZ2U6IGZ1bmN0aW9uIGdldFBhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2MuZmluZCgnaW5wdXRbbmFtZT1cInBhZ2VfbnVtYmVyXCJdJykudmFsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJhc2ljT3BlcmF0b3I6IGZ1bmN0aW9uIGdldEJhc2ljT3BlcmF0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXRCYXNpY09wZXJhdG9yID0gdGhpcy4kZ2MuZmluZCgnLmdjLWhpZGRlbi1zZWFyY2gtaW5wdXRzJykuZmluZCgnaW5wdXRbbmFtZT1cImJhc2ljX29wZXJhdG9yXCJdJyk7XG5cbiAgICAgICAgICAgIGlmICgkaW5wdXRCYXNpY09wZXJhdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGlucHV0QmFzaWNPcGVyYXRvci52YWwoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEV4dGVuZGVkU2VhcmNoOiBmdW5jdGlvbiBnZXRFeHRlbmRlZFNlYXJjaCgpIHtcbiAgICAgICAgICAgIGNvbnN0ICRzZWFyY2hJbnB1dHMgPSB0aGlzLiRnYy5maW5kKCcuZ2MtaGlkZGVuLXNlYXJjaC1pbnB1dHMnKS5maW5kKCcuZ2MtZXh0ZW5kZWQtc2VhcmNoLWlucHV0Jyk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoSW5wdXRzID0ge307XG5cbiAgICAgICAgICAgIGlmICgkc2VhcmNoSW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkc2VhcmNoSW5wdXRzLmVhY2goZnVuY3Rpb24gZm9yRWFjaFNlYXJjaElucHV0cygpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dHNbJCh0aGlzKS5hdHRyKCduYW1lJyldID0gJCh0aGlzKS52YWwoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoSW5wdXRzO1xuICAgICAgICB9LFxuICAgICAgICBoYXNFeHRlbmRlZFNlYXJjaDogZnVuY3Rpb24gaGFzRXh0ZW5kZWRTZWFyY2goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ2MuZmluZCgnLmdjLWhpZGRlbi1zZWFyY2gtaW5wdXRzJykuZmluZCgnLmdjLWV4dGVuZGVkLXNlYXJjaC1pbnB1dCcpLmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERhdGFUb1NlbmQ6IGZ1bmN0aW9uIGdldERhdGFUb1NlbmQoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gR3JpZC5nZXRQYWdlLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgIHBlcl9wYWdlID0gR3JpZC5nZXRQZXJQYWdlLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgIG9yZGVyX2J5ID0gR3JpZC5nZXRPcmRlckJ5LmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgIHNvcnRpbmcgPSBHcmlkLmdldFNvcnRpbmcuYXBwbHkodGhpcyksXG4gICAgICAgICAgICAgICAgc2VhcmNoID0gR3JpZC5nZXRTZWFyY2hEYXRhLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgIGJhc2ljX29wZXJhdG9yID0gR3JpZC5nZXRCYXNpY09wZXJhdG9yLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgIGV4dGVuZGVkX3NlYXJjaCA9IEdyaWQuZ2V0RXh0ZW5kZWRTZWFyY2guYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGFnZSxcbiAgICAgICAgICAgICAgICBwZXJfcGFnZSxcbiAgICAgICAgICAgICAgICBvcmRlcl9ieSxcbiAgICAgICAgICAgICAgICBzb3J0aW5nLFxuICAgICAgICAgICAgICAgIHNlYXJjaCxcbiAgICAgICAgICAgICAgICBiYXNpY19vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBleHRlbmRlZF9zZWFyY2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlT3JkZXJpbmdSb3dzOiBmdW5jdGlvbiBhY3RpdmF0ZU9yZGVyaW5nUm93cygpIHtcbiAgICAgICAgICAgIGNvbnN0ICRhY3RpdmVfY29sdW1uID0gdGhpcy4kZ2MuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nLmFjdGl2ZTpmaXJzdCcpLFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4ID0gJGFjdGl2ZV9jb2x1bW4uaW5kZXgoKSArIDE7XG5cbiAgICAgICAgICAgIGlmICgkYWN0aXZlX2NvbHVtbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdyb2NlcnktY3J1ZC10YWJsZScpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKCd0aGVhZCB0ciB0ZDpudGgtY2hpbGQoJyArIGNvbHVtbkluZGV4ICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlR3JpZERldGFpbHM6IGZ1bmN0aW9uIHVwZGF0ZUdyaWREZXRhaWxzKGpzb25SZXNwb25zZSwgaGlnaGxpZ2h0Um93SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcl9wYWdlX3ZhbHVlID0gdGhpcy4kZ2MuZmluZCgnLnBlcl9wYWdlJykudmFsKCk7XG4gICAgICAgICAgICBsZXQgcGFnaW5nX2VuZHM7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5zZWxlY3QtYWxsLW5vbmUnKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmN1cnJlbnQtdG90YWwtcmVzdWx0cycpLmh0bWwoanNvblJlc3BvbnNlLmZpbHRlcmVkX3RvdGFsKTtcblxuICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgcGFnaW5nX2VuZHMgPSBwYXJzZUludCh0aGlzLiRnYy5maW5kKCdpbnB1dFtuYW1lPVwicGFnZV9udW1iZXJcIl0nKS52YWwoKSwgMTApICogcGVyX3BhZ2VfdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFnaW5nX2VuZHMgPiBqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5nX2VuZHMgPSBqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctZW5kcycpLmh0bWwocGFnaW5nX2VuZHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLWVuZHMnKS5odG1sKGpzb25SZXNwb25zZS5maWx0ZXJlZF90b3RhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLXN0YXJ0cycpLmh0bWwoKHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJ2lucHV0W25hbWU9XCJwYWdlX251bWJlclwiXScpLnZhbCgpLCAxMCkgLSAxKSAqIHBlcl9wYWdlX3ZhbHVlICsgMSk7XG5cbiAgICAgICAgICAgIEdyaWQuYWN0aXZhdGVPcmRlcmluZ1Jvd3MuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuZmlsdGVyZWRfdG90YWwgPCBwYXJzZUludCh0aGlzLiRnYy5maW5kKCcuZnVsbC10b3RhbCcpLmh0bWwoKSwgMTApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmZ1bGwtdG90YWwtY29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZnVsbC10b3RhbC1jb250YWluZXInKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kU2VhcmNoQ2xlYXJCdXR0b25zKCk7XG4gICAgICAgICAgICBEYXRhZ3JpZFBhZ2luZy5wYWdpbmdDYWxjdWxhdGlvbnMuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmhpZGVTaG93RGVsZXRlQnV0dG9uKCk7XG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0Um93SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCd0cltkYXRhLWlkPScgKyBoaWdobGlnaHRSb3dJZCArICddJykuYWRkQ2xhc3MoJ2ZsYXNoIGFuaW1hdGVkJyk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0UmVtb3ZlRmxhc2hpbmcoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJ3RyW2RhdGEtaWQ9JyArIGhpZ2hsaWdodFJvd0lkICsgJ10nKS5yZW1vdmVDbGFzcygnZmxhc2ggYW5pbWF0ZWQnKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5lclBhZ2luZ0J1dHRvbnM6IGZ1bmN0aW9uIGxpc3RlbmVyUGFnaW5nQnV0dG9ucygpIHtcbiAgICAgICAgICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yc19mb3JfYWxsX2J1dHRvbnMgPSBDb25zdGFudHMuU0VMRUNUT1JfUEFHSU5HX1BSRVZJT1VTICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIENvbnN0YW50cy5TRUxFQ1RPUl9QQUdJTkdfTkVYVCArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBDb25zdGFudHMuU0VMRUNUT1JfUEFHSU5HX0ZJUlNUICsgJywnICtcbiAgICAgICAgICAgICAgICAgICAgQ29uc3RhbnRzLlNFTEVDVE9SX1BBR0lOR19MQVNULFxuICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbiA9IGRhdGFncmlkX29iamVjdC4kZ2MuZmluZCgnLnBhZ2UtbnVtYmVyLWhpZGRlbicpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKHNlbGVjdG9yc19mb3JfYWxsX2J1dHRvbnMpLmNsaWNrKGZ1bmN0aW9uIGZvckVhY2hCdXR0b25zU2VsZWN0b3JzKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIC8vSWYgaXQgaXMgZGlzYWJsZWQgdGhlbiBkbyBub3RoaW5nIVxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKENvbnN0YW50cy5DTEFTU19QQUdJTkdfUFJFVklPVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwocGFyc2VJbnQocGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuLnZhbCgpLCAxMCkgLSAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuaGFzQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX1BBR0lOR19ORVhUKSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlX251bWJlcl9pbnB1dF9oaWRkZW4udmFsKHBhcnNlSW50KHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwoKSwgMTApICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkKHRoaXMpLmhhc0NsYXNzKENvbnN0YW50cy5DTEFTU19QQUdJTkdfRklSU1QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VfbnVtYmVyX2lucHV0X2hpZGRlbi52YWwoJzEnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCQodGhpcykuaGFzQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX1BBR0lOR19MQVNUKSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlX251bWJlcl9pbnB1dF9oaWRkZW4udmFsKERhdGFncmlkUGFnaW5nLmdldE1heFBhZ2luZy5hcHBseShkYXRhZ3JpZF9vYmplY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkoZGF0YWdyaWRfb2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9QQUdFX05VTUJFUl9JTlBVVCkuY2hhbmdlKGZ1bmN0aW9uIHBhZ2VOdW1iZXJJbnB1dE9uQ2hhbmdlKCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoJCh0aGlzKS52YWwoKSwgMTApKSkge1xuICAgICAgICAgICAgICAgICAgICBwYWdlX251bWJlcl9pbnB1dF9oaWRkZW4udmFsKHBhcnNlSW50KCQodGhpcykudmFsKCksIDEwKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZV9udW1iZXJfaW5wdXRfaGlkZGVuLnZhbCgnMScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KGRhdGFncmlkX29iamVjdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmF0ZU9yZGVyaW5nQ29sdW1uOiBmdW5jdGlvbiBhY3RpdmF0ZU9yZGVyaW5nQ29sdW1uKCkge1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJfYnkgPSB0aGlzLiRnYy5maW5kKCcuZ2Mtb3JkZXItYnktaGlkZGVuJykudmFsKCksXG4gICAgICAgICAgICAgICAgc29ydGluZyA9IHRoaXMuJGdjLmZpbmQoJy5nYy1zb3J0aW5nLWhpZGRlbicpLnZhbCgpO1xuICAgICAgICAgICAgaWYgKG9yZGVyX2J5ICYmIHNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nW2RhdGEtb3JkZXItYnk9XCInICsgb3JkZXJfYnkgKyAnXCJdJylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdhY3RpdmUgdGFibGUtYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoJy5jb2x1bW4td2l0aC1vcmRlcmluZ1tkYXRhLW9yZGVyLWJ5PVwiJyArIG9yZGVyX2J5ICsgJ1wiXScpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnb3JkZXJpbmctJyArIHNvcnRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5lckNvbHVtbldpdGhPcmRlcmluZzogZnVuY3Rpb24gbGlzdGVuZXJDb2x1bW5XaXRoT3JkZXJpbmcoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YWdyaWRfb2JqZWN0ID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmNvbHVtbi13aXRoLW9yZGVyaW5nJykuY2xpY2soZnVuY3Rpb24gb25Db2x1bW5PcmRlcmluZ0NsaWNrKCkge1xuICAgICAgICAgICAgICAgIGxldCBnY3J1ZF9jb250YWluZXIgPSAkKHRoaXMpLmNsb3Nlc3QoJy5nYy1jb250YWluZXInKSxcbiAgICAgICAgICAgICAgICAgICAgJHRhYmxlID0gJCh0aGlzKS5jbG9zZXN0KCcuZ3JvY2VyeS1jcnVkLXRhYmxlJyksXG4gICAgICAgICAgICAgICAgICAgIHNvcnRpbmc7XG5cbiAgICAgICAgICAgICAgICAkdGFibGUuZmluZCgndGhlYWQnKS5maW5kKCd0aC5hY3RpdmUsIHRkLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUgdGFibGUtYWN0aXZlJyk7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZpbmQoJy5jb2x1bW4td2l0aC1vcmRlcmluZycpLmVhY2goZnVuY3Rpb24gZm9yZWFjaENvbHVtbnNXaXRoT3JkZXJpbmcoKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuaHRtbCgnPGRpdj4nICsgJC50cmltKCQodGhpcykudGV4dCgpKSArICc8L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZSB0YWJsZS1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdvcmRlcmluZy1hc2MnKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGFibGUuZmluZCgndGgnKS5yZW1vdmVDbGFzcygnb3JkZXJpbmctZGVzYycpLnJlbW92ZUNsYXNzKCdvcmRlcmluZy1hc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnb3JkZXJpbmctZGVzYycpLnJlbW92ZUNsYXNzKCdvcmRlcmluZy1hc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGluZyA9ICdkZXNjJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkdGFibGUuZmluZCgndGgnKS5yZW1vdmVDbGFzcygnb3JkZXJpbmctZGVzYycpLnJlbW92ZUNsYXNzKCdvcmRlcmluZy1hc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnb3JkZXJpbmctYXNjJykucmVtb3ZlQ2xhc3MoJ29yZGVyaW5nLWRlc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgc29ydGluZyA9ICdhc2MnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdjcnVkX2NvbnRhaW5lci5maW5kKCdpbnB1dFtuYW1lPVwicGFnZV9udW1iZXJcIl0nKS52YWwoJzEnKTtcblxuICAgICAgICAgICAgICAgIGdjcnVkX2NvbnRhaW5lci5maW5kKCcuZ2Mtb3JkZXItYnktaGlkZGVuJykudmFsKCQodGhpcykuZGF0YSgnb3JkZXItYnknKSk7XG4gICAgICAgICAgICAgICAgZ2NydWRfY29udGFpbmVyLmZpbmQoJy5nYy1zb3J0aW5nLWhpZGRlbicpLnZhbChzb3J0aW5nKTtcblxuICAgICAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KGRhdGFncmlkX29iamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJTZWFyY2hJbnB1dDogZnVuY3Rpb24gbGlzdGVuZXJTZWFyY2hJbnB1dCgpIHtcbiAgICAgICAgICAgIGxldCBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1pbnB1dCcpLm9uKCdrZXl1cCBjaGFuZ2UnLCBmdW5jdGlvbiBvbkNoYW5nZVNlYXJjaElucHV0KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy9JZiB0aGUga2V5IGlzIEVudGVyIG9yIGVtcHR5LCB0aGVuIGRvbid0IHdhaXQhIEp1c3Qgc3RhcnQgc2VhcmNoaW5nLi4uXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXJUaW1lb3V0ID0gZXZlbnQua2V5Q29kZSA9PT0gOSB8fCBldmVudC5rZXlDb2RlID09PSAxMyB8fCAkKHRoaXMpLnZhbCgpID09PSAnJyA/IDEgOiAxMDAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFncmlkX29iamVjdC5zZWFyY2hfdGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRhdGFncmlkX29iamVjdC5zZWFyY2hfdGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3Quc2VhcmNoX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiBzZWFyY2hUaW1lclRpbWVvdXRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YWdyaWRfb2JqZWN0LiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG4gICAgICAgICAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KGRhdGFncmlkX29iamVjdCk7XG4gICAgICAgICAgICAgICAgfSwgdGltZXJUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2Mtc2VhcmNoYWJsZS1zZWxlY3QsLmdjLXNlYXJjaGFibGUtY2hlY2tib3gnKS5jaGFuZ2UoZnVuY3Rpb24gb25DaGFuZ2VTZWFyY2hJbnB1dCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnZS1udW1iZXItaGlkZGVuJykudmFsKCcxJyk7XG4gICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZGF0ZS1vcGVyYXRvcicpLmNoYW5nZShmdW5jdGlvbiBvbkNoYW5nZVNlYXJjaElucHV0KCkge1xuICAgICAgICAgICAgICAgIEdyaWQuc2VhcmNoQW5kT3JkZXJpbmdUcmlnZ2VyLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5HcmlkLkNMQVNTX1BFUl9QQUdFID0gJ3Blcl9wYWdlJztcblxuZXhwb3J0cy5HcmlkID0gR3JpZDtcbiIsInZhciAkID0galF1ZXJ5LFxuICAgIGFqYXhIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2FqYXgtaGVscGVyJykuYWpheEhlbHBlcixcbiAgICBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycycpLFxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIEdyaWQgPSByZXF1aXJlKCcuL2RhdGFncmlkLmdyaWQnKS5HcmlkLFxuICAgIERhdGFncmlkSGVhZGVyQWN0aW9ucyA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBsaXN0ZW5lclByaW50QnV0dG9uOiBmdW5jdGlvbiBsaXN0ZW5lclByaW50QnV0dG9uKCkge1xuICAgICAgICAgICAgdmFyIHByaW50Q29udGFpbmVySHRtbCA9IEhhbmRsZWJhcnMuY29tcGlsZShcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5IQU5ETEVCQVJTX1BSSU5UX0NPTlRBSU5FUikuaHRtbCgpXG4gICAgICAgICAgICApKCk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1wcmludCcpLmNsaWNrKGZ1bmN0aW9uIHByaW50QnV0dG9uT25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFUb1NlbmQgPSBHcmlkLmdldERhdGFUb1NlbmQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kR2V0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYWpheEhlbHBlci5nZXRVcmwuYXBwbHkodGhpcywgW0RhdGFncmlkSGVhZGVyQWN0aW9ucy5BQ1RJT05fUFJJTlQsIGRhdGFUb1NlbmRdKSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrOiBmdW5jdGlvbiBzdWNjZXNzQ2FsbGJhY2soanNvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkcHJpbnRDb250YWluZXIgPSAkKHByaW50Q29udGFpbmVySHRtbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAkcHJpbnRDb250YWluZXIuZmluZCgndGhlYWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKERhdGFncmlkSGVhZGVyQWN0aW9ucy5nZXRQcmludFRhYmxlSGVhZGVyLmFwcGx5KHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJHByaW50Q29udGFpbmVyLmZpbmQoJ3Rib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCh0aGlzLmdldFRhYmxlQm9keUZyb21SZXNwb25zZShqc29uUmVzcG9uc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KCcjdGFibGUtY29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucHJpbnRUaGlzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJpbnRUYWJsZUhlYWRlcjogZnVuY3Rpb24gZ2V0UHJpbnRUYWJsZUhlYWRlcigpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJDb2x1bW5zID0gW107XG4gICAgICAgICAgICBfLmVhY2godGhpcy52aXNpYmxlQ29sdW1ucywgZnVuY3Rpb24gZWFjaFZpc2libGVDb2x1bW5zKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJDb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5QXM6IHRoaXMuaW5kZXhlZENvbHVtbnNbY29sdW1uTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBIYW5kbGViYXJzLmNvbXBpbGUoXG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuSEFORExFQkFSU19QUklOVF9IRUFERVIpLmh0bWwoKVxuICAgICAgICAgICAgKSh7XG4gICAgICAgICAgICAgICAgaGVhZGVyQ29sdW1uczogaGVhZGVyQ29sdW1uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuRGF0YWdyaWRIZWFkZXJBY3Rpb25zLkFDVElPTl9QUklOVCA9ICdwcmludCc7XG5cbmV4cG9ydHMuRGF0YWdyaWRIZWFkZXJBY3Rpb25zID0gRGF0YWdyaWRIZWFkZXJBY3Rpb25zO1xuIiwidmFyICQgPSBqUXVlcnksXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIERhdGFncmlkUGFnaW5nID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGdldE1heFBhZ2luZzogZnVuY3Rpb24gZ2V0TWF4UGFnaW5nKCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsX3Jlc3VsdHMgPSBwYXJzZUludCh0aGlzLiRnYy5maW5kKCcuY3VycmVudC10b3RhbC1yZXN1bHRzJykuaHRtbCgpLCAxMCksXG4gICAgICAgICAgICAgICAgcGVyX3BhZ2UgPSBwYXJzZUludCh0aGlzLiRnYy5maW5kKCcuJyArIENvbnN0YW50cy5DTEFTU19QRVJfUEFHRSkudmFsKCksIDEwKSxcbiAgICAgICAgICAgICAgICBtYXhfcGFnaW5nID0gdG90YWxfcmVzdWx0cyA9PT0gMCA/IDEgOiBNYXRoLmNlaWwodG90YWxfcmVzdWx0cyAvIHBlcl9wYWdlKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1heF9wYWdpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2luZ0NhbGN1bGF0aW9uczogZnVuY3Rpb24gcGFnaW5nQ2FsY3VsYXRpb25zKCkge1xuICAgICAgICAgICAgdmFyIHBhZ2VfbnVtYmVyX3ZhbHVlID0gcGFyc2VJbnQodGhpcy4kZ2MuZmluZCgnLnBhZ2UtbnVtYmVyLWhpZGRlbicpLnZhbCgpLCAxMCksXG4gICAgICAgICAgICAgICAgbWF4X3BhZ2luZyA9IERhdGFncmlkUGFnaW5nLmdldE1heFBhZ2luZy5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VfbnVtYmVyX3ZhbHVlIDw9IDApIHtcbiAgICAgICAgICAgICAgICBwYWdlX251bWJlcl92YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2UtbnVtYmVyLWhpZGRlbicpLnZhbCgnMScpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX1BBR0VfTlVNQkVSX0lOUFVUKS52YWwoJzEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhZ2VfbnVtYmVyX3ZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1maXJzdCcpLmFkZENsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1wcmV2aW91cycpLmFkZENsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctZmlyc3QnKS5yZW1vdmVDbGFzcyhDb25zdGFudHMuQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctcHJldmlvdXMnKS5yZW1vdmVDbGFzcyhDb25zdGFudHMuQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFnZV9udW1iZXJfdmFsdWUgKyAxID4gbWF4X3BhZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdpbmctbGFzdCcpLmFkZENsYXNzKENvbnN0YW50cy5DTEFTU19ESVNBQkxFRCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1uZXh0JykuYWRkQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnBhZ2luZy1sYXN0JykucmVtb3ZlQ2xhc3MoQ29uc3RhbnRzLkNMQVNTX0RJU0FCTEVEKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcucGFnaW5nLW5leHQnKS5yZW1vdmVDbGFzcyhDb25zdGFudHMuQ0xBU1NfRElTQUJMRUQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9QQUdFX05VTUJFUl9JTlBVVCkudmFsKHBhZ2VfbnVtYmVyX3ZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VfbnVtYmVyX3ZhbHVlID4gbWF4X3BhZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5wYWdlLW51bWJlci1oaWRkZW4nKS52YWwobWF4X3BhZ2luZyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfUEFHRV9OVU1CRVJfSU5QVVQpLnZhbChtYXhfcGFnaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuRGF0YWdyaWRQYWdpbmcgPSBEYXRhZ3JpZFBhZ2luZztcbiIsInZhciAkID0galF1ZXJ5LFxuICAgIEdyaWQgPSByZXF1aXJlKCcuL2RhdGFncmlkLmdyaWQuanMnKS5HcmlkLFxuICAgIERhdGFncmlkQ29sdW1ucyA9IHJlcXVpcmUoJy4vZGF0YWdyaWQuY29sdW1ucycpLkRhdGFncmlkQ29sdW1ucyxcbiAgICBEYXRhZ3JpZFNlYXJjaCA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBsaXN0ZW5lclNlYXJjaEJ1dHRvbjogZnVuY3Rpb24gbGlzdGVuZXJTZWFyY2hCdXR0b24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YWdyaWRfb2JqZWN0ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGF0YWdyaWRTZWFyY2hBbGxJbnB1dCkge1xuICAgICAgICAgICAgICAgIERhdGFncmlkU2VhcmNoLnNlYXJjaEFsbEJ1dHRvbi5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlci1idXR0b24nKS5jbGljayhmdW5jdGlvbiBzZWFyY2hCdXR0b25PbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1maWx0ZXJpbmctbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXJlbW92ZS1maWx0ZXItYnV0dG9uJykuY2xpY2soZnVuY3Rpb24gcmVtb3ZlRmlsdGVyc0J1dHRvbk9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWhpZGRlbi1zZWFyY2gtaW5wdXRzJykuaHRtbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIERhdGFncmlkQ29sdW1ucy50cmlnZ2VyQ29sdW1uc1JlbmRlci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5nYy1yZW1vdmUtZmlsdGVyLWNvbnRhaW5lcicpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlci1idXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdidG4tc3VjY2VzcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2J0bi1vdXRsaW5lLWRhcmsnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLWZpbHRlci10ZXh0JykucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZmlsdGVyLWNvdW50ZXInKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24+aW5wdXQuZ2Mtc2VhcmNoLWlucHV0JykuY2hhbmdlKGZ1bmN0aW9uIHNlYXJjaElucHV0T25DaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgZGF0YWdyaWRfb2JqZWN0LiRnYy5maW5kKCcuc2VhcmNoLWJ1dHRvbiAuY2xlYXItYWxsLXNlYXJjaCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykudmFsKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuYWZ0ZXIoJzxpIGNsYXNzPVwiZmEgZmEtdGltZXMgY2xlYXItYWxsLXNlYXJjaFwiPjwvaT4nKTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5zZWFyY2gtYnV0dG9uIC5jbGVhci1hbGwtc2VhcmNoJykuY2xpY2soZnVuY3Rpb24gc2VhcmNoQ2xlYXJBbGxPbkNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YWdyaWRfb2JqZWN0LiRnYy5maW5kKCcuc2VhcmNoLWJ1dHRvbj5pbnB1dC5nYy1zZWFyY2gtaW5wdXQnKS52YWwoJycpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5wYWdlLW51bWJlci1oaWRkZW4nKS52YWwoJzEnKTtcbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5nYy1zZWFyY2hhYmxlLWlucHV0JykudmFsKCcnKTtcbiAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseShkYXRhZ3JpZF9vYmplY3QpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5zZWFyY2gtYnV0dG9uPmlucHV0LmdjLXNlYXJjaC1pbnB1dCcpLmJsdXIoZnVuY3Rpb24gc2VhcmNoSW5wdXRPbkJsdXIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlYXJjaF9idXR0b24gPSAkKHRoaXMpLmNsb3Nlc3QoJy5zZWFyY2gtYnV0dG9uJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSA9PT0gJycgJiYgc2VhcmNoX2J1dHRvbi5oYXNDbGFzcygnc2VhcmNoLWJ1dHRvbi1iaWcnKSkge1xuICAgICAgICAgICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGF0IHdlIGFyZSBibHVyIDopXG4gICAgICAgICAgICAgICAgICAgIGRhdGFncmlkX29iamVjdC4kZ2MuZmluZCgnLnNlYXJjaC1idXR0b24gLmNsZWFyLWFsbC1zZWFyY2gnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnZ2Mtc2VhcmNoLWlucHV0LWJpZycpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfYnV0dG9uLnJlbW92ZUNsYXNzKCdzZWFyY2gtYnV0dG9uLWJpZycpO1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hfYnV0dG9uLnJlbW92ZUNsYXNzKCdidG4tZGVmYXVsdCcpLmFkZENsYXNzKCdidG4tcHJpbWFyeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hBbGxCdXR0b246IGZ1bmN0aW9uIHNlYXJjaEFsbEJ1dHRvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5zZWFyY2gtYnV0dG9uJykuY2xpY2soZnVuY3Rpb24gc2VhcmNoQnV0dG9uT25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgIGxldCAkc2VhcmNoX2J1dHRvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgJHNlYXJjaF9idXR0b24ucmVtb3ZlQ2xhc3MoJ2J0bi1wcmltYXJ5JykuYWRkQ2xhc3MoJ2J0bi1kZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgJHNlYXJjaF9idXR0b24uZmluZCgnaW5wdXQuZ2Mtc2VhcmNoLWlucHV0JykuYWRkQ2xhc3MoJ2djLXNlYXJjaC1pbnB1dC1iaWcnKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VhcmNoX2J1dHRvbi5maW5kKCdpbnB1dC5nYy1zZWFyY2gtaW5wdXQnKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sIDQwMCk7XG5cbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdzZWFyY2gtYnV0dG9uLWJpZycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuZXhwb3J0cy5EYXRhZ3JpZFNlYXJjaCA9IERhdGFncmlkU2VhcmNoO1xuIiwidmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyksXG4gICAgaTE4biA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICB0cmFuc2xhdGlvbnM6IHt9LFxuICAgICAgICBpbml0OiBmdW5jdGlvbiBpbml0STE4bihpMThuVmFyaWFibGVzKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IGkxOG5WYXJpYWJsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHQ6IGZ1bmN0aW9uIHQodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zbGF0aW9uc1t0cmFuc2xhdGlvbl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGlvbnNbdHJhbnNsYXRpb25dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChzdHJSYXcsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBzdHJSYXc7XG4gICAgICAgICAgICBpZiAoIWFyZ3MgJiYgIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbiBlYWNoQXJncyhhcmcsIGFyZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShSZWdFeHAoJ1xcXFx7JyArIGFyZ05hbWUgKyAnXFxcXH0nLCAnZ2knKSwgYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLmkxOG4gPSBpMThuO1xuIiwidmFyIENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLkNvbnN0YW50cyxcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKS5PcGVyYXRpb25zQ29tbW9uLFxuICAgIE9wZXJhdGlvbkFkZCA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBhY3Rpb25BZGQ6IGZ1bmN0aW9uIGV2ZW50QWRkKCkge1xuICAgICAgICAgICAgT3BlcmF0aW9uc0NvbW1vbi5vcGVyYXRpb25EaXNwYXRjaC5hcHBseSh0aGlzLCBbe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9BRERfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ2luc2VydEZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnYWRkRmllbGRzJyxcbiAgICAgICAgICAgICAgICByZWFkT25seUZpZWxkczogJ3JlYWRPbmx5QWRkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja0FmdGVyUmVuZGVyOiBPcGVyYXRpb25BZGQuY2FsbGJhY2tBZnRlck1vZGFsLmJpbmQodGhpcylcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbGJhY2tBZnRlck1vZGFsOiBmdW5jdGlvbiBjYWxsYmFja0FmdGVyTW9kYWwoKSB7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKVxuICAgICAgICAgICAgICAgIC5maW5kKCdpbnB1dCwgdGV4dGFyZWEnKVxuICAgICAgICAgICAgICAgIC5maXJzdCgpXG4gICAgICAgICAgICAgICAgLmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyQWRkQnV0dG9uOiBmdW5jdGlvbiBsaXN0ZW5lckFkZEJ1dHRvbigpIHtcblxuICAgICAgICAgICAgT3BlcmF0aW9uc0NvbW1vbi5oaWRlTW9kYWxPbkNsb3NlLmFwcGx5KHRoaXMsIFtDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STV0pO1xuICAgICAgICAgICAgLy8gR0MtMTc0OiBVZ2x5IHdvcmthcm91bmQgdG8gYWxzbyBoYXZlIGFuIGV2ZW50IHRvIGFkZCBhbiBlbXB0eSBoYXNoIG9uIGVycm9yIGNsb3NlXG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLmhpZGVNb2RhbE9uQ2xvc2UuYXBwbHkodGhpcywgWycuZ2MtZXJyb3ItbW9kYWwnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0JVVFRPTl9BREQpLmNsaWNrKGZ1bmN0aW9uIGFkZEJ1dHRvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhhc2hFdmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQuYWRkSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgT3BlcmF0aW9uQWRkLmFjdGlvbkFkZC5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5leHBvcnRzLk9wZXJhdGlvbkFkZCA9IE9wZXJhdGlvbkFkZDtcbiIsImxldCBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgaGFzaGVyID0gcmVxdWlyZSgnaGFzaGVyJyksXG4gICAgT3BlcmF0aW9uc0NvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykuT3BlcmF0aW9uc0NvbW1vbixcbiAgICBPcGVyYXRpb25DbG9uZSA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBhY3Rpb25DbG9uZTogZnVuY3Rpb24gZXZlbnRFZGl0KHByaW1hcnlLZXlWYWx1ZSkge1xuXG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLm9wZXJhdGlvbkRpc3BhdGNoLmFwcGx5KHRoaXMsIFt7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBDb25zdGFudHMuQUNUSU9OX0NMT05FX0ZPUk0sXG4gICAgICAgICAgICAgICAgZmllbGRzTGlzdE5hbWU6ICdjbG9uZUZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnY2xvbmVGaWVsZHMnLFxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZXM6ICdmaWVsZFR5cGVzQ2xvbmVGb3JtJyxcbiAgICAgICAgICAgICAgICByZWFkT25seUZpZWxkczogJ3JlYWRPbmx5Q2xvbmVGaWVsZHMnLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZTogcHJpbWFyeUtleVZhbHVlXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xvbmVDbGljazogZnVuY3Rpb24gb25DbG9uZUNsaWNrKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGFzaEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGhhc2hlci5zZXRIYXNoKHRoaXMuaGFzaEV2ZW50LmNsb25lSXRlbSArICcvJyArIHByaW1hcnlLZXlWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9wZXJhdGlvbkNsb25lLmFjdGlvbkNsb25lLmFwcGx5KHRoaXMsIFtwcmltYXJ5S2V5VmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLk9wZXJhdGlvbkNsb25lID0gT3BlcmF0aW9uQ2xvbmU7XG4iLCJpbXBvcnQgRmllbGRMaXN0IGZyb20gJy4uLy4uLy4uLy4uLy4uL1JlYWN0LUNvbXBvbmVudHMvZ2NlLWNydWQtZm9ybXMvZmllbGQtbGlzdC5qc3gnO1xuaW1wb3J0IE1vZGFsVGl0bGUgZnJvbSAnLi4vLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9tb2RhbC90aXRsZS5qc3gnO1xuaW1wb3J0IEZpZWxkSW5wdXQgZnJvbSAnLi4vLi4vLi4vLi4vLi4vUmVhY3QtQ29tcG9uZW50cy9nY2UtY3J1ZC1mb3Jtcy9maWVsZC1pbnB1dC5qc3gnO1xuXG5pbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCByZWR1Y2VyIGZyb20gJy4vcmVkdWNlci5qcyc7XG5pbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyXG4gICAgJCA9IGpRdWVyeSxcbiAgICBhamF4SGVscGVyID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9hamF4LWhlbHBlcicpLmFqYXhIZWxwZXIsXG4gICAgR3JpZCA9IHJlcXVpcmUoJy4vLi4vZGF0YWdyaWQvZGF0YWdyaWQuZ3JpZC5qcycpLkdyaWQsXG4gICAgalF1ZXJ5UGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvanF1ZXJ5L2pxdWVyeS1wbHVnaW5zJykualF1ZXJ5UGx1Z2lucyxcbiAgICBpMThuID0gcmVxdWlyZSgnLi8uLi9pMThuJykuaTE4bixcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgT3BlcmF0aW9uc0NvbW1vbiA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBnZXRGb3JtRG9tQ29udGFpbmVyOiBmdW5jdGlvbiBnZXRGb3JtRG9tQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJGZvcm1Eb21Db250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGZvcm1Eb21Db250YWluZXIgPSB0aGlzLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0ZPUk0pLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0JPRFkpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGZvcm1Eb21Db250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE1vZGFsVGl0bGVEb206IGZ1bmN0aW9uIGdldE1vZGFsVGl0bGVEb20oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kbW9kYWxUaXRsZURvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbW9kYWxUaXRsZURvbSA9IHRoaXMuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSkuZmluZCgnLm1vZGFsLWhlYWRlcicpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG1vZGFsVGl0bGVEb207XG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdGlvbkRpc3BhdGNoOiBmdW5jdGlvbiBvcGVyYXRpb25EaXNwYXRjaChvcHRpb25zUmF3KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9BRERfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ2luc2VydEZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnYWRkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiAnZmllbGRUeXBlc0FkZEZvcm0nLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHlGaWVsZHM6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tBZnRlclJlbmRlcjogZnVuY3Rpb24gY2FsbGJhY2tBZnRlclJlbmRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdGlvbnNSYXcpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWNoZSAmJiB0aGlzW29wdGlvbnMuZmllbGRzTGlzdE5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLnNob3dNb2RhbC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLmNvbGxlY3REYXRhQW5kRGlzcGF0Y2guYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheUFzOiBmdW5jdGlvbihmaWVsZE5hbWUsIGZpZWxkTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIF8uZmluZChmaWVsZExpc3QsIChjb2x1bW4pID0+IChjb2x1bW4ubmFtZSA9PT0gZmllbGROYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxlY3REYXRhQW5kRGlzcGF0Y2g6IGZ1bmN0aW9uIGNvbGxlY3REYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogb3B0aW9ucy5hY3Rpb25cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByaW1hcnlLZXlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQucGtfdmFsdWUgPSBvcHRpb25zLnByaW1hcnlLZXlWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZW5kR2V0UmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICBkYXRhVG9TZW5kOiBkYXRhVG9TZW5kLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NDYWxsYmFjazogZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrKGpzb25SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZExpc3QgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRMaXN0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRPbmx5RmllbGRMaXN0ID0gb3B0aW9ucy5yZWFkT25seUZpZWxkcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMucmVhZE9ubHlGaWVsZHNdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbb3B0aW9ucy5maWVsZHNMaXN0TmFtZV0gPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4gPSBqc29uUmVzcG9uc2UuY3NyZlRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGZpZWxkTGlzdCwgZnVuY3Rpb24ganNvblJlc3BvbnNlRm9yRWFjaChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGZpbmQgZmllbGQgbmFtZTogXCInICsgZmllbGROYW1lICsgJ1wiIGluIGZpZWxkVHlwZXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhpcyBpcyB1c3VhbGx5IGFuIGVycm9yIHRoYXQgeW91IHdpbGwgc2VlIHdoZW4geW91XFwndmUgYWRkZWQgYSBmaWVsZCBuYW1lIHRoYXQgZG9lc25cXCd0IGV4aXN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaW4gdGhlIGRhdGFiYXNlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29wdGlvbnMuZmllbGRzTGlzdE5hbWVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlBczogT3BlcmF0aW9uc0NvbW1vbi5kaXNwbGF5QXMuYXBwbHkodGhpcywgW2ZpZWxkTmFtZSwgZmllbGRMaXN0XSkuZGlzcGxheUFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWU6IGpzb25SZXNwb25zZS5kYXRhW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRUeXBlOiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXS5kYXRhVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFZhbHVlczogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0ucGVybWl0dGVkVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0uZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dEZWZhdWx0VmFsdWU6IChvcHRpb25zLmFjdGlvbiA9PT0gJ2FkZC1mb3JtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOdWxsYWJsZTogdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0uaXNOdWxsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlcXVpcmVkOiB0aGlzLmNhY2hlZEluaXRpYWxEYXRhW29wdGlvbnMuZmllbGRUeXBlc11bZmllbGROYW1lXS5pc1JlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVhZE9ubHk6IHJlYWRPbmx5RmllbGRMaXN0W2ZpZWxkTmFtZV0gfHwgb3B0aW9ucy5pc1JlYWRPbmx5IHx8IHRoaXMuY2FjaGVkSW5pdGlhbERhdGFbb3B0aW9ucy5maWVsZFR5cGVzXVtmaWVsZE5hbWVdLmlzUmVhZE9ubHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogKHRoaXMuY2FjaGVkSW5pdGlhbERhdGFbb3B0aW9ucy5maWVsZFR5cGVzXVtmaWVsZE5hbWVdLm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5jYWNoZWRJbml0aWFsRGF0YVtvcHRpb25zLmZpZWxkVHlwZXNdW2ZpZWxkTmFtZV0ub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LiBiaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLnNob3dNb2RhbC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dNb2RhbDogZnVuY3Rpb24gc2hvd01vZGFsKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01PREFMX0ZPUk0pXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0ZPUk0pLmRhdGEoJ2FjdGlvbicsIG9wdGlvbnMuYWN0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSlcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfRk9STSlcbiAgICAgICAgICAgICAgICAuZGF0YSgncHJpbWFyeS1rZXktdmFsdWUnLCBvcHRpb25zLnByaW1hcnlLZXlWYWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMucHJpbWFyeUtleVZhbHVlIDogJycpO1xuXG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBvcHRpb25zLmFjdGlvbixcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHRoaXNbb3B0aW9ucy5maWVsZHNMaXN0TmFtZV1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWN0aW9uID09PSAncmVhZC1mb3JtJykge1xuICAgICAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoJy5vcHRpb25zLW9uLXNhdmUnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNhdmUtY2hhbmdlcycpLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLm9wdGlvbnMtb24tc2F2ZScpLnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuc2F2ZS1jaGFuZ2VzJykuc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrQWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGl0bGU6IGZ1bmN0aW9uIGdldFRpdGxlKHRpdGxlVHlwZSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViamVjdFNpbmdsZSA9IHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuc3ViamVjdC5zdWJqZWN0X3NpbmdsZTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aXRsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5BQ1RJT05fQUREX0ZPUk06XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpMThuLmZvcm1hdChpMThuLnQoJ2FkZF9pdGVtJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RTaW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuQUNUSU9OX0VESVRfRk9STTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkxOG4uZm9ybWF0KGkxOG4udCgnZWRpdF9pdGVtJyksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RTaW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5BQ1RJT05fUkVBRF9GT1JNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTE4bi5mb3JtYXQoaTE4bi50KCd2aWV3X2l0ZW0nKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogc3ViamVjdFNpbmdsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLkFDVElPTl9DTE9ORV9GT1JNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTE4bi5mb3JtYXQoaTE4bi50KCdhZGRfaXRlbScpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0U2luZ2xlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5pdFJlZHV4U3RvcmU6IGZ1bmN0aW9uIGluaXRSZWR1eFN0b3JlKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fKCkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWVsZExpc3QgPSBmdW5jdGlvbiByZW5kZXJGaWVsZExpc3QoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IE9wZXJhdGlvbnNDb21tb24uZ2V0VGl0bGUuYXBwbHkodGhpcywgW2N1cnJlbnRTdGF0ZS50eXBlXSksXG4gICAgICAgICAgICAgICAgICAgIHsgRmllbGRSb3dXcmFwcGVyLCBNb2RhbFRpdGxlV3JhcHBlciB9ID0gdGhpcy5jb21wb25lbnRzO1xuXG4gICAgICAgICAgICAgICAgUmVhY3RET00ucmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICA8TW9kYWxUaXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgTW9kYWxUaXRsZVdyYXBwZXI9e01vZGFsVGl0bGVXcmFwcGVyfVxuICAgICAgICAgICAgICAgICAgICAvPiwgT3BlcmF0aW9uc0NvbW1vbi5nZXRNb2RhbFRpdGxlRG9tLmFwcGx5KHRoaXMpKTtcbiAgICAgICAgICAgICAgICBSZWFjdERPTS5yZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgIDxGaWVsZExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uYWxPbkNvbXBvbmVudERpZE1vdW50PXtmdW5jdGlvbiByZWxhdGlvbmFsT25Db21wb25lbnREaWRNb3VudChjb21wb25lbnREb21FbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5UGx1Z2lucy5zZWFyY2hhYmxlU2VsZWN0KCQoY29tcG9uZW50RG9tRWxlbWVudCkuZmluZCgnc2VsZWN0JyksIG9wdGlvbnMuaXNSZWFkT25seSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25hbE9uQ29tcG9uZW50RGlkVXBkYXRlPXsoY29tcG9uZW50RG9tRWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeVBsdWdpbnMuc2VhcmNoYWJsZVNlbGVjdFVwZGF0ZSgkKGNvbXBvbmVudERvbUVsZW1lbnQpLmZpbmQoJ3NlbGVjdCcpLCBvcHRpb25zLmlzUmVhZE9ubHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG49e2kxOG4udHJhbnNsYXRpb25zfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzPXtjdXJyZW50U3RhdGUuZmllbGRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2NydWRJbnN0YW5jZT17dGhpc31cbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YT17KGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkgPT4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhIZWxwZXIuc2VuZEFqYXhSZXF1ZXN0LmFwcGx5KHRoaXMsIFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2RlcGVuZGVkLXJlbGF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkX25hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaF92YWx1ZTogZmllbGRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuJGdjLmRhdGEoJ3VybCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEuaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ2dldCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBGaWVsZElucHV0Q29tcG9uZW50PXtGaWVsZElucHV0fVxuICAgICAgICAgICAgICAgICAgICAgICAgRmllbGRSb3dXcmFwcGVyPXtGaWVsZFJvd1dyYXBwZXJ9XG4gICAgICAgICAgICAgICAgICAgIC8+LCBPcGVyYXRpb25zQ29tbW9uLmdldEZvcm1Eb21Db250YWluZXIuYXBwbHkodGhpcykpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5yZW5kZXJGaWVsZExpc3QpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlTW9kYWxPbkNsb3NlOiBmdW5jdGlvbiBoaWRlTW9kYWxPbkNsb3NlKHNlbGVjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKHNlbGVjdG9yU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5vbignaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gb25Nb2RhbEhpZGVPbkNsb3NlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIuc2V0SGFzaCgnIScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJTdWJtaXRGb3JtOiBmdW5jdGlvbiBsaXN0ZW5lckluc2VydEZvcm0oKSB7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKVxuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9GT1JNKVxuICAgICAgICAgICAgICAgIC5zdWJtaXQoZnVuY3Rpb24gU3VibWl0QWRkRm9ybShldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVRvU2VuZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEFjdGlvbiA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YSgnYWN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4SGVscGVyLmdldFBvc3REYXRhRnJvbUZvcm0uYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9NT0RBTF9GT1JNKS5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9GT1JNKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fQUREX0ZPUk0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9JTlNFUlQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEFjdGlvbiA9PT0gQ29uc3RhbnRzLkFDVElPTl9FRElUX0ZPUk0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQuYWN0aW9uID0gQ29uc3RhbnRzLkFDVElPTl9VUERBVEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kLnBrX3ZhbHVlID0gJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdwcmltYXJ5LWtleS12YWx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRBY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fQ0xPTkVfRk9STSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRvU2VuZC5hY3Rpb24gPSBDb25zdGFudHMuQUNUSU9OX0NMT05FO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUG9zdFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcm93VG9IaWdobGlnaHQsIGVycm9ycztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uUmVzcG9uc2UuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuID0ganNvblJlc3BvbnNlLmNzcmZUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd1RvSGlnaGxpZ2h0ID0gZGF0YVRvU2VuZC5hY3Rpb24gPT09IENvbnN0YW50cy5BQ1RJT05fSU5TRVJUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGpzb25SZXNwb25zZS5pbnNlcnRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhVG9TZW5kLnBrX3ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4kZ2MuZmluZCgnLmNsb3NlLW1vZGFsLW9uLXNhdmUnKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTU9EQUxfRk9STSkuZ2NfbW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzLCBbcm93VG9IaWdobGlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChqc29uUmVzcG9uc2UuZXJyb3JzLCBmdW5jdGlvbiBmb3JFYWNoRXJyb3JzKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBfLnVuaW9uKGVycm9ycywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoJy5nYy1lcnJvci1ib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCctICcgKyBlcnJvcnMuam9pbignPGJyLz4tICcpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZXJyb3ItbW9kYWwnKS5nY19tb2RhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLk9wZXJhdGlvbnNDb21tb24gPSBPcGVyYXRpb25zQ29tbW9uO1xuIiwidmFyICQgPSBqUXVlcnksXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcbiAgICBHcmlkID0gcmVxdWlyZSgnLi8uLi9kYXRhZ3JpZC9kYXRhZ3JpZC5ncmlkLmpzJykuR3JpZCxcbiAgICBDb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5Db25zdGFudHMsXG4gICAgT3BlcmF0aW9uc0NvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykuT3BlcmF0aW9uc0NvbW1vbixcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25EZWxldGUgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgYWN0aW9uRGVsZXRlOiBmdW5jdGlvbiBhY3Rpb25EZWxldGUocHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlybWF0aW9uVGFibGU7XG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9ERUxFVEVfQ09ORklSTUFUSU9OX0JVVFRPTilcbiAgICAgICAgICAgICAgICAuZGF0YSgnZGVsZXRlLWlkJywgcHJpbWFyeUtleVZhbHVlKTtcblxuICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGUgPSBPcGVyYXRpb25EZWxldGUuY29uZmlybWF0aW9uVGFibGUuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgICAgIFtwcmltYXJ5S2V5VmFsdWVdXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZCgnLmRlbGV0ZS1zaW5nbGUtY29uZmlybWF0aW9uJylcbiAgICAgICAgICAgICAgICAuZmluZCgnLmNvbnRlbnQtdG8tZGVsZXRlJylcbiAgICAgICAgICAgICAgICAuaHRtbChjb25maXJtYXRpb25UYWJsZSk7XG5cbiAgICAgICAgICAgIHRoaXMuJGdjLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9GT1JNX01PREFMKS5nY19tb2RhbCgpO1xuICAgICAgICAgICAgdGhpcy4kZ2NcbiAgICAgICAgICAgICAgICAuZmluZChDb25zdGFudHMuU0VMRUNUT1JfREVMRVRFX0ZPUk1fTU9EQUwpXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLkNBTkNFTF9CVVRUT04pLmZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGU6IGZ1bmN0aW9uIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGUoKSB7XG4gICAgICAgICAgICAvL1NlbGVjdCBBbGwvTm9uZVxuICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLnNlbGVjdC1hbGwtbm9uZScpLmNsaWNrKGZ1bmN0aW9uIHNlbGVjdEFsbE5vbmVPbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCQoZXZlbnQuY3VycmVudFRhcmdldCkuaXMoJzpjaGVja2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3cnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWxlY3RSb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NoZWNrZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KCd0cicpLmFkZENsYXNzKCd3YXJuaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZCgnLmdjLXNlbGVjdC1yb3cnKS5lYWNoKGZ1bmN0aW9uIGZvckVhY2hTZWxlY3RSb3coKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdCgndHInKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnd2FybmluZycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVTaG93RGVsZXRlQnV0dG9uKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZGVsZXRlLXNlbGVjdGVkLWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uIGRlbGV0ZVNlbGVjdGVkQnV0dG9uT25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsZUlkcyA9IE9wZXJhdGlvbkRlbGV0ZS5nZXRNdWx0aXBsZURlbGV0ZUlkcy5hcHBseSh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnYy5maW5kKCcuZ2MtZGVsZXRlLWNvdW50JykuaHRtbChtdWx0aXBsZUlkcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uVGFibGUgPSBPcGVyYXRpb25EZWxldGUuY29uZmlybWF0aW9uVGFibGUuYXBwbHkodGhpcywgW211bHRpcGxlSWRzXSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmdjLWRlbGV0ZS1tdWx0aXBsZS1jb25maXJtYXRpb24nKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmNvbnRlbnQtdG8tZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgLmh0bWwoY29uZmlybWF0aW9uVGFibGUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kZ2MuZmluZChDb25zdGFudHMuU0VMRUNUT1JfTVVMVElQTEVfREVMRVRFX0ZPUk1fTU9EQUwpLmdjX21vZGFsKCk7XG5cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlybWF0aW9uVGFibGU6IGZ1bmN0aW9uIGNvbmZpcm1hdGlvblRhYmxlKGRhdGFJZHMpIHtcbiAgICAgICAgICAgIHZhciAkdGFibGUgPSB0aGlzLiRnYy5maW5kKCcuZ3JvY2VyeS1jcnVkLXRhYmxlJyksXG4gICAgICAgICAgICAgICAgJGhlYWRlclRyID0gJHRhYmxlLmZpbmQoJy5oZWFkZXItY29sdW1ucycpLmNsb25lKCksXG4gICAgICAgICAgICAgICAgdGFibGVPdXRwdXQsXG4gICAgICAgICAgICAgICAgZGF0YVJvd3MgPSAnJztcblxuICAgICAgICAgICAgXy5lYWNoKGRhdGFJZHMsIGZ1bmN0aW9uIGZvcmVhY2hEYXRhSWRzKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIHZhciAkdHIgPSAkdGFibGUuZmluZCgndHJbZGF0YS1pZD1cIicgKyBkYXRhSWQgKyAnXCJdJykuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoJHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR0ci5maW5kKCd0ZC5nYy1yb3ctY2hlY2tib3gnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkdHIuZmluZCgndGQuZ2MtYWN0aW9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICR0ci5maW5kKCd0ZCcpLnJlbW92ZUNsYXNzKCk7XG4gICAgICAgICAgICAgICAgZGF0YVJvd3MgKz0gJzx0cj4nICsgJHRyLmh0bWwoKSArICc8L3RyPic7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgJGhlYWRlclRyLmZpbmQoJy5oZWFkZXItYWN0aW9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgJGhlYWRlclRyLmZpbmQoJ3RoPmknKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICRoZWFkZXJUci5maW5kKCd0aCcpLnJlbW92ZUNsYXNzKCk7XG5cbiAgICAgICAgICAgIHRhYmxlT3V0cHV0ID0gJzx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkIHRhYmxlLWhvdmVyXCI+JztcbiAgICAgICAgICAgIHRhYmxlT3V0cHV0ICs9ICc8dHI+JyArICRoZWFkZXJUci5odG1sKCkgKyAnPC90cj4nO1xuICAgICAgICAgICAgdGFibGVPdXRwdXQgKz0gZGF0YVJvd3M7XG4gICAgICAgICAgICB0YWJsZU91dHB1dCArPSAnPC90YWJsZT4nO1xuXG4gICAgICAgICAgICByZXR1cm4gdGFibGVPdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRGVsZXRlQ2xpY2s6IGZ1bmN0aW9uIG9uRGVsZXRlQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBPcGVyYXRpb25EZWxldGUuYWN0aW9uRGVsZXRlLmFwcGx5KHRoaXMsIFtwcmltYXJ5S2V5VmFsdWVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbDogZnVuY3Rpb24gbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9DT05GSVJNQVRJT05fQlVUVE9OKVxuICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBkZWxldGVDb25maXJtYXRpb25DbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVRvU2VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXlWYWx1ZTogJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKCdkZWxldGUtaWQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRU1PVkVfT05FXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVG9TZW5kW3RoaXMuY2FjaGVkSW5pdGlhbERhdGEuY3NyZlRva2VuLmlucHV0TmFtZV0gPSB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kUG9zdFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiRnYy5kYXRhKCd1cmwnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgJGZ1bGxUb3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09IENvbnN0YW50cy5SRVNQT05TRS5TVUNDRVNTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRmdWxsVG90YWwgPSB0aGlzLiRnYy5maW5kKCcuZnVsbC10b3RhbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX0RFTEVURV9GT1JNX01PREFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgPSAocGFyc2VJbnQoJGZ1bGxUb3RhbC50ZXh0KCksIDEwKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZnVsbFRvdGFsLmh0bWwoJycgKyB0b3RhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBzZWFyY2hBbmRPcmRlcmluZ1RpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmlkLnNlYXJjaEFuZE9yZGVyaW5nVHJpZ2dlci5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyRGVsZXRlTXVsdGlwbGVNb2RhbDogZnVuY3Rpb24gbGlzdGVuZXJEZWxldGVTaW5nbGVNb2RhbCgpIHtcbiAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9DT05GSVJNQVRJT05fQlVUVE9OKVxuICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbiBkZWxldGVNdWx0aXBsZUNvbmZpcm1hdGlvbkNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YVRvU2VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltYXJ5S2V5czogT3BlcmF0aW9uRGVsZXRlLmdldE11bHRpcGxlRGVsZXRlSWRzLmFwcGx5KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRU1PVkVfTVVMVElQTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZHNUb0RlbGV0ZSA9IGRhdGFUb1NlbmQucHJpbWFyeUtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVRvU2VuZFt0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbi5pbnB1dE5hbWVdID0gdGhpcy5jYWNoZWRJbml0aWFsRGF0YS5jc3JmVG9rZW4uaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBvc3RSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUb1NlbmQ6IGRhdGFUb1NlbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2s6IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhqc29uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvblJlc3BvbnNlLmNzcmZUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmNzcmZUb2tlbiA9IGpzb25SZXNwb25zZS5jc3JmVG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoQ29uc3RhbnRzLlNFTEVDVE9SX01VTFRJUExFX0RFTEVURV9GT1JNX01PREFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdjX21vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGdjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgnLmZ1bGwtdG90YWwnKS5odG1sKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHRoaXMuJGdjLmZpbmQoJy5mdWxsLXRvdGFsJykudGV4dCgpLCAxMCkgLSBpZHNUb0RlbGV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JpZC5zZWFyY2hBbmRPcmRlcmluZ1RyaWdnZXIuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TXVsdGlwbGVEZWxldGVJZHM6IGZ1bmN0aW9uIGdldE11bHRpcGxlRGVsZXRlSWRzKCkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZUlkcyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLiRnY1xuICAgICAgICAgICAgICAgIC5maW5kKENvbnN0YW50cy5TRUxFQ1RPUl9ERUxFVEVfQ0hFQ0tCT1hfQ0hFQ0tFRClcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbiBmb3JFYWNoR2V0TXVsdGlwbGVJZHMoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZUlkcy5wdXNoKCQodGhpcykuZGF0YSgnaWQnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkZWxldGVJZHM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbmVyU2VsZWN0Um93OiBmdW5jdGlvbiBsaXN0ZW5lclNlbGVjdFJvdygpIHtcbiAgICAgICAgICAgIHZhciBkYXRhZ3JpZF9vYmplY3QgPSB0aGlzO1xuXG4gICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuJGdjLmZpbmQoJy5nYy1zZWxlY3Qtcm93JykuY2xpY2soZnVuY3Rpb24gc2VsZWN0Um93T25DbGljaygpIHtcbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykuYWRkQ2xhc3MoJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykucmVtb3ZlQ2xhc3MoJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhZ3JpZF9vYmplY3QuaGlkZVNob3dEZWxldGVCdXR0b24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uRGVsZXRlID0gT3BlcmF0aW9uRGVsZXRlO1xuIiwibGV0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLkNvbnN0YW50cyxcbiAgICBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICBPcGVyYXRpb25zQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKS5PcGVyYXRpb25zQ29tbW9uLFxuICAgIE9wZXJhdGlvbkVkaXQgPSBPYmplY3QuY3JlYXRlKHtcbiAgICAgICAgYWN0aW9uRWRpdDogZnVuY3Rpb24gZXZlbnRFZGl0KHByaW1hcnlLZXlWYWx1ZSkge1xuXG4gICAgICAgICAgICBPcGVyYXRpb25zQ29tbW9uLm9wZXJhdGlvbkRpc3BhdGNoLmFwcGx5KHRoaXMsIFt7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBDb25zdGFudHMuQUNUSU9OX0VESVRfRk9STSxcbiAgICAgICAgICAgICAgICBmaWVsZHNMaXN0TmFtZTogJ3VwZGF0ZUZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRMaXN0OiAnZWRpdEZpZWxkcycsXG4gICAgICAgICAgICAgICAgZmllbGRUeXBlczogJ2ZpZWxkVHlwZXNFZGl0Rm9ybScsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHlGaWVsZHM6ICdyZWFkT25seUVkaXRGaWVsZHMnLFxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWU6IHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVkaXRDbGljazogZnVuY3Rpb24gb25FZGl0Q2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQuZWRpdEl0ZW0gKyAnLycgKyBwcmltYXJ5S2V5VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25FZGl0LmFjdGlvbkVkaXQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uRWRpdCA9IE9wZXJhdGlvbkVkaXQ7XG4iLCJ2YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIGhhc2hlciA9IHJlcXVpcmUoJ2hhc2hlcicpLFxuICAgIE9wZXJhdGlvbnNDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpLk9wZXJhdGlvbnNDb21tb24sXG4gICAgT3BlcmF0aW9uUmVhZCA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBhY3Rpb25SZWFkOiBmdW5jdGlvbiBhY3Rpb25SZWFkKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgT3BlcmF0aW9uc0NvbW1vbi5vcGVyYXRpb25EaXNwYXRjaC5hcHBseSh0aGlzLCBbe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogQ29uc3RhbnRzLkFDVElPTl9SRUFEX0ZPUk0sXG4gICAgICAgICAgICAgICAgZmllbGRzTGlzdE5hbWU6ICdyZWFkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZExpc3Q6ICdyZWFkRmllbGRzJyxcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGVzOiAnZmllbGRUeXBlc1JlYWRGb3JtJyxcbiAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSZWFkT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmltYXJ5S2V5VmFsdWU6IHByaW1hcnlLZXlWYWx1ZVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlYWRDbGljazogZnVuY3Rpb24gb25SZWFkQ2xpY2socHJpbWFyeUtleVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oYXNoRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2godGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gKyAnLycgKyBwcmltYXJ5S2V5VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBPcGVyYXRpb25SZWFkLmFjdGlvblJlYWQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuT3BlcmF0aW9uUmVhZCA9IE9wZXJhdGlvblJlYWQ7XG4iLCJleHBvcnQgZGVmYXVsdCAoc3RhdGUgPSAnJywgYWN0aW9uKSA9PiB7XG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICBmaWVsZHM6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbn1cbiIsInZhciBoYXNoZXIgPSByZXF1aXJlKCdoYXNoZXInKSxcbiAgICB0aGlzSW5jcmVhc2UgPSAwLFxuICAgIGNyb3Nzcm9hZHMgPSByZXF1aXJlKCdjcm9zc3JvYWRzJyksXG4gICAgT3BlcmF0aW9uQWRkID0gcmVxdWlyZSgnLi4vb3BlcmF0aW9ucy9hZGQnKS5PcGVyYXRpb25BZGQsXG4gICAgT3BlcmF0aW9uRWRpdCA9IHJlcXVpcmUoJy4uL29wZXJhdGlvbnMvZWRpdCcpLk9wZXJhdGlvbkVkaXQsXG4gICAgT3BlcmF0aW9uQ2xvbmUgPSByZXF1aXJlKCcuLi9vcGVyYXRpb25zL2Nsb25lJykuT3BlcmF0aW9uQ2xvbmUsXG4gICAgT3BlcmF0aW9uUmVhZCA9IHJlcXVpcmUoJy4uL29wZXJhdGlvbnMvcmVhZCcpLk9wZXJhdGlvblJlYWQsXG4gICAgUm91dGVyID0ge1xuICAgICAgICBzZXRSb3V0ZXM6IGZ1bmN0aW9uIHNldFJvdXRlcygpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGluZ1N0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAodGhpc0luY3JlYXNlID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3RyaW5nID0gdGhpc0luY3JlYXNlICsgJy8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhhc2hFdmVudCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQuYWRkSXRlbSA9IHN0YXJ0aW5nU3RyaW5nICsgJ2FkZCc7XG4gICAgICAgICAgICB0aGlzLmhhc2hFdmVudC5lZGl0SXRlbSA9IHN0YXJ0aW5nU3RyaW5nICsgJ2VkaXQnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQuY2xvbmVJdGVtID0gc3RhcnRpbmdTdHJpbmcgKyAnY2xvbmUnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gPSBzdGFydGluZ1N0cmluZyArICdyZWFkJztcbiAgICAgICAgICAgIHRoaXMuaGFzaEV2ZW50LmRlbGV0ZUl0ZW0gPSBzdGFydGluZ1N0cmluZyArICdkZWxldGUnO1xuICAgICAgICAgICAgdGhpcy5oYXNoRXZlbnQudXJsVW5pcXVlSGFzaCA9IHN0YXJ0aW5nU3RyaW5nO1xuICAgICAgICB9LFxuICAgICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlSGFzaCA9IGZ1bmN0aW9uIHBhcnNlSGFzaChuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgY3Jvc3Nyb2Fkcy5wYXJzZShuZXdIYXNoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRoaXMgbGluZSBpcyBpbiBvcmRlciB0byBjYWxsIHRoZSByb3V0ZSBhcyBtYW55IHRpbWVzIGFzIHdlIHdhbnQhXG4gICAgICAgICAgICBjcm9zc3JvYWRzLmlnbm9yZVN0YXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGFzaEV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQuYWRkSXRlbSwgZnVuY3Rpb24gb3BlcmF0aW9uQWRkUm91dGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIE9wZXJhdGlvbkFkZC5hY3Rpb25BZGQuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQuZWRpdEl0ZW0gKyAnL3twcmltYXJ5S2V5VmFsdWV9JywgZnVuY3Rpb24gb3BlcmF0aW9uRWRpdFJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25FZGl0LmFjdGlvbkVkaXQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICBjcm9zc3JvYWRzLmFkZFJvdXRlKHRoaXMuaGFzaEV2ZW50LmNsb25lSXRlbSArICcve3ByaW1hcnlLZXlWYWx1ZX0nLCBmdW5jdGlvbiBvcGVyYXRpb25DbG9uZVJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25DbG9uZS5hY3Rpb25DbG9uZS5hcHBseSh0aGlzLCBbcHJpbWFyeUtleVZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIGNyb3Nzcm9hZHMuYWRkUm91dGUodGhpcy5oYXNoRXZlbnQucmVhZEl0ZW0gKyAnL3twcmltYXJ5S2V5VmFsdWV9JywgZnVuY3Rpb24gb3BlcmF0aW9uUmVhZFJvdXRlKHByaW1hcnlLZXlWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBPcGVyYXRpb25SZWFkLmFjdGlvblJlYWQuYXBwbHkodGhpcywgW3ByaW1hcnlLZXlWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzSW5jcmVhc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBoYXNoZXIuaW5pdGlhbGl6ZWQuYWRkKHBhcnNlSGFzaCk7XG4gICAgICAgICAgICAgICAgaGFzaGVyLmNoYW5nZWQuYWRkKHBhcnNlSGFzaCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgZm9yIGhpc3RvcnkgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGhhc2hlci5pbml0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNJbmNyZWFzZSsrO1xuICAgICAgICB9XG4gICAgfTtcblxuZXhwb3J0cy5Sb3V0ZXIgPSBPYmplY3QuY3JlYXRlKFJvdXRlcik7XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIENhbGxiYWNrQ29sdW1uID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2NhbGxiYWNrX2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29sdW1uRmllbGRzW2ZpZWxkTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgaXNUaGlzVHlwZTogZnVuY3Rpb24gaXNUaGlzVHlwZShmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tDb2x1bW5GaWVsZHNbZmllbGROYW1lXTtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5DYWxsYmFja0NvbHVtbiA9IENhbGxiYWNrQ29sdW1uOyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ2hlY2tib3hCb29sZWFuID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2NoZWNrYm94X2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveEJvb2xlYW5GaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tib3hCb29sZWFuRmllbGRzRGF0YVtmaWVsZE5hbWVdID0ge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkc0RhdGFbZmllbGROYW1lXSA9IGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc0NoZWNrYm94Qm9vbGVhbjogZnVuY3Rpb24gaXNDaGVja2JveEJvb2xlYW4oZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94Qm9vbGVhbkZpZWxkcy5pbmRleE9mKGZpZWxkTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoZmllbGRWYWx1ZSkge1xuICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJzEnKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2tcIj48L2k+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59KTtcblxuZXhwb3J0cy5DaGVja2JveEJvb2xlYW4gPSBDaGVja2JveEJvb2xlYW47XG4iLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyXG4gICAgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIERhdGVBbmRUaW1lID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gQ29uc3RhbnRzLkZJRUxEX1RZUEVfREFURSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGVGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL14oZGF0ZXRpbWV8dGltZXN0YW1wKSQvaS50ZXN0KGZpZWxkRGF0YS5kYXRhVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRldGltZUZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbiBnZXRGb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRm9ybWF0dGVyID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZUZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KERhdGVBbmRUaW1lLmdldExvY2FsZSgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGVGb3JtYXR0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChteURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXlEYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0RGF0ZUxvY2FsZTogZnVuY3Rpb24gZm9ybWF0RGF0ZUxvY2FsZShyYXdEYXRlKSB7XG4gICAgICAgICAgICB2YXIgbXlEYXRlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlcjtcblxuICAgICAgICAgICAgaWYgKHJhd0RhdGUgPT09ICcwMDAwLTAwLTAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlEYXRlID0gbmV3IERhdGUocmF3RGF0ZSk7XG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSBEYXRlQW5kVGltZS5nZXRGb3JtYXR0ZXIuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICghRGF0ZUFuZFRpbWUuaXNWYWxpZERhdGUobXlEYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQobXlEYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0RGF0ZXRpbWVMb2NhbGU6IGZ1bmN0aW9uIGZvcm1hdERhdGV0aW1lTG9jYWxlKHJhd0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBteURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyO1xuXG4gICAgICAgICAgICBpZiAocmF3RGF0ZSA9PT0gJzAwMDAtMDAtMDAgMDA6MDA6MDAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBteURhdGUgPSBuZXcgRGF0ZShyYXdEYXRlKTtcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IERhdGVBbmRUaW1lLmdldEZvcm1hdHRlci5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKCFEYXRlQW5kVGltZS5pc1ZhbGlkRGF0ZShteURhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdChteURhdGUpICsgJyAnICsgbXlEYXRlLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMb2NhbGU6IGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IubGFuZ3VhZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5sYW5ndWFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZERhdGU6IGZ1bmN0aW9uIGlzVmFsaWREYXRlKG15RGF0ZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChteURhdGUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKG15RGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGF0ZXRpbWU6IGZ1bmN0aW9uIGlzTnRvTihmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGV0aW1lRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRhdGV0aW1lRmllbGRzLmluZGV4T2YoZmllbGROYW1lKSA+IC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEYXRlOiBmdW5jdGlvbiBpc050b04oZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRlRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRhdGVGaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpO1xuICAgICAgICB9XG59KTtcblxuZXhwb3J0cy5EYXRlQW5kVGltZSA9IERhdGVBbmRUaW1lOyIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgRHJvcGRvd24gPSBPYmplY3QuY3JlYXRlKHtcbiAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICBpZiAoL15kcm9wZG93bihfc2VhcmNoKT8kLy50ZXN0KGZpZWxkRGF0YS5kYXRhVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdID0ge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdID0gZmllbGREYXRhLnBlcm1pdHRlZFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIGlzRHJvcGRvd246IGZ1bmN0aW9uIGlzRHJvcGRvd24oZmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3Bkb3duRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcGRvd25GaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkge1xuICAgICAgICB2YXIgZGF0YTtcblxuICAgICAgICBpZiAoIWZpZWxkVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLmRyb3Bkb3duRmllbGRzRGF0YVtmaWVsZE5hbWVdO1xuXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChkYXRhW2ZpZWxkVmFsdWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbZmllbGRWYWx1ZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duO1xuIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBFbnVtID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgaW5pdERhdGE6IGZ1bmN0aW9uIGluaXREYXRhKCkge1xuICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ2VudW0nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnVtRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVudW1GaWVsZHNEYXRhW2ZpZWxkTmFtZV0gPSB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW51bUZpZWxkc0RhdGFbZmllbGROYW1lXSA9IGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBpc0VudW06IGZ1bmN0aW9uIGlzRW51bShmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW51bUZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVudW1GaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLkVudW0gPSBFbnVtO1xuIiwiaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbnZhciBNdWx0aXBsZVNlbGVjdCA9IE9iamVjdC5jcmVhdGUoe1xuICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXMoZmllbGREYXRhLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09ICdtdWx0aXNlbGVjdF9zZWFyY2hhYmxlJyB8fFxuICAgICAgICAgICAgICAgIGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gJ211bHRpc2VsZWN0X25hdGl2ZScpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3RGaWVsZHNbZmllbGROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdERhdGFbZmllbGROYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgXy5lYWNoKGZpZWxkRGF0YS5wZXJtaXR0ZWRWYWx1ZXMsIGZ1bmN0aW9uIGZvcmVhY2hEYXRhKGRhdGFMYWJlbCwgZGF0YUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YUluZGV4XSA9IGRhdGFMYWJlbDtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG4gICAgaXNUaGlzVHlwZTogZnVuY3Rpb24gaXNUaGlzVHlwZShmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTZWxlY3RGaWVsZHNbZmllbGROYW1lXTtcbiAgICB9LFxuICAgIHRyYW5zZm9ybURhdGE6IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZmllbGROYW1lLCBmaWVsZERhdGEpIHtcbiAgICAgICAgbGV0IGZpbmFsU3RyaW5nLFxuICAgICAgICAgICAgZmluYWxBcnJheSA9IFtdO1xuICAgICAgICBfLmVhY2goZmllbGREYXRhLnNwbGl0KCcsJyksIGZ1bmN0aW9uIGZvcmVhY2hUcmFuc2Zvcm1EYXRhKGRhdGFWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxBcnJheS5wdXNoKHRoaXMubXVsdGlwbGVTZWxlY3REYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgZmluYWxTdHJpbmcgPSBmaW5hbEFycmF5LmpvaW4oJywnKTtcblxuICAgICAgICByZXR1cm4gZmluYWxTdHJpbmc7XG4gICAgfVxufSk7XG5cbmV4cG9ydHMuTXVsdGlwbGVTZWxlY3QgPSBNdWx0aXBsZVNlbGVjdDtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIFJlbGF0aW9uTnRvTiA9IE9iamVjdC5jcmVhdGUoe1xuICAgICAgICBpbml0RGF0YTogZnVuY3Rpb24gaW5pdERhdGEoKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5jYWNoZWRJbml0aWFsRGF0YS5maWVsZFR5cGVzQ29sdW1ucywgZnVuY3Rpb24gZmllbGRUeXBlcyhmaWVsZERhdGEsIGZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09IENvbnN0YW50cy5GSUVMRF9UWVBFX1JFTEFUSU9OX05fVE9fTiB8fFxuICAgICAgICAgICAgICAgICAgICBmaWVsZERhdGEuZGF0YVR5cGUgPT09IENvbnN0YW50cy5GSUVMRF9UWVBFX05BVElWRV9SRUxBVElPTl9OX1RPX04gfHxcbiAgICAgICAgICAgICAgICAgICAgZmllbGREYXRhLmRhdGFUeXBlID09PSBDb25zdGFudHMuRklFTERfVFlQRV9TRUFSQ0hBQkxFX05fVE9fTikge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb25OdG9ORmllbGRzW2ZpZWxkTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uTnRvTkRhdGFbZmllbGROYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChmaWVsZERhdGEucGVybWl0dGVkVmFsdWVzLCBmdW5jdGlvbiBmb3JlYWNoRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uTnRvTkRhdGFbZmllbGROYW1lXVtkYXRhLmlkXSA9IGRhdGEudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNOdG9OOiBmdW5jdGlvbiBpc050b04oZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbk50b05GaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmb3JtRGF0YTogZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShmaWVsZE5hbWUsIGZpZWxkRGF0YSkge1xuICAgICAgICAgICAgdmFyIGZpbmFsU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBfLmVhY2goZmllbGREYXRhLCBmdW5jdGlvbiBmb3JlYWNoVHJhbnNmb3JtRGF0YShkYXRhVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGlvbk50b05EYXRhW2ZpZWxkTmFtZV1bZGF0YVZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU3RyaW5nICs9IHRoaXMucmVsYXRpb25OdG9ORGF0YVtmaWVsZE5hbWVdW2RhdGFWYWx1ZV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIGlmIChmaW5hbFN0cmluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZmluYWxTdHJpbmcgPSBmaW5hbFN0cmluZy5zdWJzdHIoMCwgZmluYWxTdHJpbmcubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5hbFN0cmluZztcbiAgICAgICAgfVxuICAgIH0pO1xuXG5leHBvcnRzLlJlbGF0aW9uTnRvTiA9IFJlbGF0aW9uTnRvTjtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJykuQ29uc3RhbnRzLFxuICAgIFJlbGF0aW9uID0gT2JqZWN0LmNyZWF0ZSh7XG4gICAgICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLmNhY2hlZEluaXRpYWxEYXRhLmZpZWxkVHlwZXNDb2x1bW5zLCBmdW5jdGlvbiBmaWVsZFR5cGVzKGZpZWxkRGF0YSwgZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWVsZERhdGEuZGF0YVR5cGUgPT09IENvbnN0YW50cy5GSUVMRF9UWVBFX1JFTEFUSU9OIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gQ29uc3RhbnRzLkZJRUxEX1RZUEVfUkVMQVRJT05fTkFUSVZFIHx8XG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkRGF0YS5kYXRhVHlwZSA9PT0gQ29uc3RhbnRzLkZJRUxEX1RZUEVfREVQRU5ERURfUkVMQVRJT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkRGF0YS5vcHRpb25zLmRlcGVuZGVkRnJvbS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbkRhdGFbZmllbGROYW1lXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChmaWVsZERhdGEucGVybWl0dGVkVmFsdWVzLCBmdW5jdGlvbiBmb3JlYWNoRGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uRGF0YVtmaWVsZE5hbWVdW2RhdGEuaWRdID0gZGF0YS50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBpc1JlbGF0aW9uYWw6IGZ1bmN0aW9uIGlzUmVsYXRpb25hbChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aW9uRmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpb25GaWVsZHMuaW5kZXhPZihmaWVsZE5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1EYXRhOiBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZpZWxkTmFtZSwgZmllbGREYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGlvbkRhdGFbZmllbGROYW1lXVtmaWVsZERhdGFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbkRhdGFbZmllbGROYW1lXVtmaWVsZERhdGFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmllbGREYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG5cbmV4cG9ydHMuUmVsYXRpb24gPSBSZWxhdGlvbjtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG52YXIgVGV4dGVkaXRvciA9IE9iamVjdC5jcmVhdGUoe1xuICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXMoZmllbGREYXRhLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09ICd0ZXh0ZWRpdG9yJykge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dGVkaXRvckZpZWxkc1tmaWVsZE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIGlzVGhpc1R5cGU6IGZ1bmN0aW9uIGlzVGhpc1R5cGUoZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRlZGl0b3JGaWVsZHNbZmllbGROYW1lXTtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5UZXh0ZWRpdG9yID0gVGV4dGVkaXRvcjsiLCJpbXBvcnQgXyBmcm9tICd1bmRlcnNjb3JlJztcblxudmFyIFVwbG9hZCA9IE9iamVjdC5jcmVhdGUoe1xuICAgIGluaXREYXRhOiBmdW5jdGlvbiBpbml0RGF0YSgpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuY2FjaGVkSW5pdGlhbERhdGEuZmllbGRUeXBlc0NvbHVtbnMsIGZ1bmN0aW9uIGZpZWxkVHlwZXMoZmllbGREYXRhLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERhdGEuZGF0YVR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGxvYWRGaWVsZHNEYXRhW2ZpZWxkTmFtZV0gPSBmaWVsZERhdGEub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIGlzVXBsb2FkVHlwZTogZnVuY3Rpb24gaXNVcGxvYWRUeXBlKGZpZWxkTmFtZSkge1xuICAgICAgICBpZiAodGhpcy51cGxvYWRGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMudXBsb2FkRmllbGRzLmluZGV4T2YoZmllbGROYW1lKSA+IC0xKTtcbiAgICB9LFxuICAgIGZvcm1hdFVwbG9hZDogZnVuY3Rpb24gZm9ybWF0VXBsb2FkKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSkge1xuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmICghZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsID0gdGhpcy51cGxvYWRGaWVsZHNEYXRhW2ZpZWxkTmFtZV0ucHVibGljUGF0aCArICcvJyArIGZpZWxkVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJyArIHVybCArICdcIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICsgZmllbGRWYWx1ZSArICc8L2E+JztcbiAgICB9XG59KTtcblxuZXhwb3J0cy5VcGxvYWQgPSBVcGxvYWQ7IiwiLyoqIHZpbTogZXQ6dHM9NDpzdz00OnN0cz00XG4gKiBAbGljZW5zZSBhbWRlZmluZSAxLjAuMSBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNiwgVGhlIERvam8gRm91bmRhdGlvbiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogQXZhaWxhYmxlIHZpYSB0aGUgTUlUIG9yIG5ldyBCU0QgbGljZW5zZS5cbiAqIHNlZTogaHR0cDovL2dpdGh1Yi5jb20vanJidXJrZS9hbWRlZmluZSBmb3IgZGV0YWlsc1xuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcHJvY2VzcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWZpbmUgZm9yIG5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIHRoZSBcIm1vZHVsZVwiIG9iamVjdCB0aGF0IGlzIGRlZmluZWQgYnkgTm9kZSBmb3IgdGhlXG4gKiBjdXJyZW50IG1vZHVsZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXF1aXJlRm5dLiBOb2RlJ3MgcmVxdWlyZSBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnQgbW9kdWxlLlxuICogSXQgb25seSBuZWVkcyB0byBiZSBwYXNzZWQgaW4gTm9kZSB2ZXJzaW9ucyBiZWZvcmUgMC41LCB3aGVuIG1vZHVsZS5yZXF1aXJlXG4gKiBkaWQgbm90IGV4aXN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIGRlZmluZSBmdW5jdGlvbiB0aGF0IGlzIHVzYWJsZSBmb3IgdGhlIGN1cnJlbnQgbm9kZVxuICogbW9kdWxlLlxuICovXG5mdW5jdGlvbiBhbWRlZmluZShtb2R1bGUsIHJlcXVpcmVGbikge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgZGVmaW5lQ2FjaGUgPSB7fSxcbiAgICAgICAgbG9hZGVyQ2FjaGUgPSB7fSxcbiAgICAgICAgYWxyZWFkeUNhbGxlZCA9IGZhbHNlLFxuICAgICAgICBwYXRoID0gcmVxdWlyZSgncGF0aCcpLFxuICAgICAgICBtYWtlUmVxdWlyZSwgc3RyaW5nUmVxdWlyZTtcblxuICAgIC8qKlxuICAgICAqIFRyaW1zIHRoZSAuIGFuZCAuLiBmcm9tIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICogSXQgd2lsbCBrZWVwIGEgbGVhZGluZyBwYXRoIHNlZ21lbnQgaWYgYSAuLiB3aWxsIGJlY29tZVxuICAgICAqIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQsIHRvIGhlbHAgd2l0aCBtb2R1bGUgbmFtZSBsb29rdXBzLFxuICAgICAqIHdoaWNoIGFjdCBsaWtlIHBhdGhzLCBidXQgY2FuIGJlIHJlbWFwcGVkLiBCdXQgdGhlIGVuZCByZXN1bHQsXG4gICAgICogYWxsIHBhdGhzIHRoYXQgdXNlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGxvb2sgbm9ybWFsaXplZC5cbiAgICAgKiBOT1RFOiB0aGlzIG1ldGhvZCBNT0RJRklFUyB0aGUgaW5wdXQgYXJyYXkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJ5IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1Eb3RzKGFyeSkge1xuICAgICAgICB2YXIgaSwgcGFydDtcbiAgICAgICAgZm9yIChpID0gMDsgYXJ5W2ldOyBpKz0gMSkge1xuICAgICAgICAgICAgcGFydCA9IGFyeVtpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIChhcnlbMl0gPT09ICcuLicgfHwgYXJ5WzBdID09PSAnLi4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvL0VuZCBvZiB0aGUgbGluZS4gS2VlcCBhdCBsZWFzdCBvbmUgbm9uLWRvdFxuICAgICAgICAgICAgICAgICAgICAvL3BhdGggc2VnbWVudCBhdCB0aGUgZnJvbnQgc28gaXQgY2FuIGJlIG1hcHBlZFxuICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RseSB0byBkaXNrLiBPdGhlcndpc2UsIHRoZXJlIGlzIGxpa2VseVxuICAgICAgICAgICAgICAgICAgICAvL25vIHBhdGggbWFwcGluZyBmb3IgYSBwYXRoIHN0YXJ0aW5nIHdpdGggJy4uJy5cbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBzdGlsbCBmYWlsLCBidXQgY2F0Y2hlcyB0aGUgbW9zdCByZWFzb25hYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlcyBvZiAuLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XG4gICAgICAgIHZhciBiYXNlUGFydHM7XG5cbiAgICAgICAgLy9BZGp1c3QgYW55IHJlbGF0aXZlIHBhdGhzLlxuICAgICAgICBpZiAobmFtZSAmJiBuYW1lLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAvL0lmIGhhdmUgYSBiYXNlIG5hbWUsIHRyeSB0byBub3JtYWxpemUgYWdhaW5zdCBpdCxcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlLCBhc3N1bWUgaXQgaXMgYSB0b3AtbGV2ZWwgcmVxdWlyZSB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vYmUgcmVsYXRpdmUgdG8gYmFzZVVybCBpbiB0aGUgZW5kLlxuICAgICAgICAgICAgaWYgKGJhc2VOYW1lKSB7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuc2xpY2UoMCwgYmFzZVBhcnRzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5jb25jYXQobmFtZS5zcGxpdCgnLycpKTtcbiAgICAgICAgICAgICAgICB0cmltRG90cyhiYXNlUGFydHMpO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBiYXNlUGFydHMuam9pbignLycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBub3JtYWxpemUoKSBmdW5jdGlvbiBwYXNzZWQgdG8gYSBsb2FkZXIgcGx1Z2luJ3NcbiAgICAgKiBub3JtYWxpemUgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUobmFtZSwgcmVsTmFtZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoaWQpIHtcbiAgICAgICAgZnVuY3Rpb24gbG9hZCh2YWx1ZSkge1xuICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkLmZyb21UZXh0ID0gZnVuY3Rpb24gKGlkLCB0ZXh0KSB7XG4gICAgICAgICAgICAvL1RoaXMgb25lIGlzIGRpZmZpY3VsdCBiZWNhdXNlIHRoZSB0ZXh0IGNhbi9wcm9iYWJseSB1c2VzXG4gICAgICAgICAgICAvL2RlZmluZSwgYW5kIGFueSByZWxhdGl2ZSBwYXRocyBhbmQgcmVxdWlyZXMgc2hvdWxkIGJlIHJlbGF0aXZlXG4gICAgICAgICAgICAvL3RvIHRoYXQgaWQgd2FzIGl0IHdvdWxkIGJlIGZvdW5kIG9uIGRpc2suIEJ1dCB0aGlzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwcGluZyBhIG1vZHVsZS9yZXF1aXJlIGZhaXJseSBkZWVwbHkgZnJvbSBub2RlIGNvcmUuXG4gICAgICAgICAgICAvL05vdCBzdXJlIGhvdyBiZXN0IHRvIGdvIGFib3V0IHRoYXQgeWV0LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWRlZmluZSBkb2VzIG5vdCBpbXBsZW1lbnQgbG9hZC5mcm9tVGV4dCcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsb2FkO1xuICAgIH1cblxuICAgIG1ha2VSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpIHtcbiAgICAgICAgZnVuY3Rpb24gYW1kUmVxdWlyZShkZXBzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vU3luY2hyb25vdXMsIHNpbmdsZSBtb2R1bGUgcmVxdWlyZSgnJylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcHMsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9BcnJheSBvZiBkZXBlbmRlbmNpZXMgd2l0aCBhIGNhbGxiYWNrLlxuXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IHRoZSBkZXBlbmRlbmNpZXMgdG8gbW9kdWxlcy5cbiAgICAgICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBOYW1lLCByZWxJZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL1dhaXQgZm9yIG5leHQgdGljayB0byBjYWxsIGJhY2sgdGhlIHJlcXVpcmUgY2FsbC5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBkZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW1kUmVxdWlyZS50b1VybCA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgaWYgKGZpbGVQYXRoLmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoZmlsZVBhdGgsIHBhdGguZGlybmFtZShtb2R1bGUuZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhbWRSZXF1aXJlO1xuICAgIH07XG5cbiAgICAvL0Zhdm9yIGV4cGxpY2l0IHZhbHVlLCBwYXNzZWQgaW4gaWYgdGhlIG1vZHVsZSB3YW50cyB0byBzdXBwb3J0IE5vZGUgMC40LlxuICAgIHJlcXVpcmVGbiA9IHJlcXVpcmVGbiB8fCBmdW5jdGlvbiByZXEoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUucmVxdWlyZS5hcHBseShtb2R1bGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHIsIGUsIG0sIHJlc3VsdDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGUgPSBsb2FkZXJDYWNoZVtpZF0gPSB7fTtcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHVyaTogX19maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9Pbmx5IHN1cHBvcnQgb25lIGRlZmluZSBjYWxsIHBlciBmaWxlXG4gICAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgd2l0aCBubyBtb2R1bGUgSUQgY2Fubm90IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBwZXIgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL1VzZSB0aGUgcmVhbCB2YXJpYWJsZXMgZnJvbSBub2RlXG4gICAgICAgICAgICAvL1VzZSBtb2R1bGUuZXhwb3J0cyBmb3IgZXhwb3J0cywgc2luY2VcbiAgICAgICAgICAgIC8vdGhlIGV4cG9ydHMgaW4gaGVyZSBpcyBhbWRlZmluZSBleHBvcnRzLlxuICAgICAgICAgICAgZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgICAgICAgICAgbSA9IG1vZHVsZTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIG1vZHVsZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0lmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMsIHRoZXkgYXJlIHN0cmluZ3MsIHNvIG5lZWRcbiAgICAgICAgLy90byBjb252ZXJ0IHRoZW0gdG8gZGVwZW5kZW5jeSB2YWx1ZXMuXG4gICAgICAgIGlmIChkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcihkZXBOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DYWxsIHRoZSBmYWN0b3J5IHdpdGggdGhlIHJpZ2h0IGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5LmFwcGx5KG0uZXhwb3J0cywgZGVwcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSBtLmV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJpbmdSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgaWQsIHJlbElkKSB7XG4gICAgICAgIC8vU3BsaXQgdGhlIElEIGJ5IGEgISBzbyB0aGF0XG4gICAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoJyEnKSxcbiAgICAgICAgICAgIG9yaWdpbmFsSWQgPSBpZCxcbiAgICAgICAgICAgIHByZWZpeCwgcGx1Z2luO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG5cbiAgICAgICAgICAgIC8vU3RyYWlnaHQgbW9kdWxlIGxvb2t1cC4gSWYgaXQgaXMgb25lIG9mIHRoZSBzcGVjaWFsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIC8vZGVhbCB3aXRoIGl0LCBvdGhlcndpc2UsIGRlbGVnYXRlIHRvIG5vZGUuXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdyZXF1aXJlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdleHBvcnRzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2FkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoc3lzdGVtUmVxdWlyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtUmVxdWlyZShvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vZHVsZSB3aXRoIElEOiAnICsgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVGhlcmUgaXMgYSBwbHVnaW4gaW4gcGxheS5cbiAgICAgICAgICAgIHByZWZpeCA9IGlkLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZyhpbmRleCArIDEsIGlkLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHBsdWdpbiA9IHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBwcmVmaXgsIHJlbElkKTtcblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBsdWdpbi5ub3JtYWxpemUoaWQsIG1ha2VOb3JtYWxpemUocmVsSWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9Ob3JtYWxpemUgdGhlIElEIG5vcm1hbGx5LlxuICAgICAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ubG9hZChpZCwgbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCksIG1ha2VMb2FkKGlkKSwge30pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL0NyZWF0ZSBhIGRlZmluZSBmdW5jdGlvbiBzcGVjaWZpYyB0byB0aGUgbW9kdWxlIGFza2luZyBmb3IgYW1kZWZpbmUuXG4gICAgZnVuY3Rpb24gZGVmaW5lKGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gaWQ7XG4gICAgICAgICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwcyAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ107XG4gICAgICAgIH1cblxuICAgICAgICAvL1NldCB1cCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZHVsZS4gSWYgYW4gSUQsIHRoZW4gdXNlXG4gICAgICAgIC8vaW50ZXJuYWwgY2FjaGUuIElmIG5vIElELCB0aGVuIHVzZSB0aGUgZXh0ZXJuYWwgdmFyaWFibGVzXG4gICAgICAgIC8vZm9yIHRoaXMgbm9kZSBtb2R1bGUuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgLy9QdXQgdGhlIG1vZHVsZSBpbiBkZWVwIGZyZWV6ZSB1bnRpbCB0aGVyZSBpcyBhXG4gICAgICAgICAgICAvL3JlcXVpcmUgY2FsbCBmb3IgaXQuXG4gICAgICAgICAgICBkZWZpbmVDYWNoZVtpZF0gPSBbaWQsIGRlcHMsIGZhY3RvcnldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlZmluZS5yZXF1aXJlLCB3aGljaCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgdmFsdWVzIGluIHRoZVxuICAgIC8vY2FjaGUuIFVzZWZ1bCBmb3IgQU1EIG1vZHVsZXMgdGhhdCBhbGwgaGF2ZSBJRHMgaW4gdGhlIGZpbGUsXG4gICAgLy9idXQgbmVlZCB0byBmaW5hbGx5IGV4cG9ydCBhIHZhbHVlIHRvIG5vZGUgYmFzZWQgb24gb25lIG9mIHRob3NlXG4gICAgLy9JRHMuXG4gICAgZGVmaW5lLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lLmFtZCA9IHt9O1xuXG4gICAgcmV0dXJuIGRlZmluZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbWRlZmluZTtcbiIsIiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE3IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRpZiAoaW5uZXIpIHtcblx0XHRcdFx0XHRjbGFzc2VzLnB1c2goaW5uZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvKiogQGxpY2Vuc2VcbiAqIGNyb3Nzcm9hZHMgPGh0dHA6Ly9taWxsZXJtZWRlaXJvcy5naXRodWIuY29tL2Nyb3Nzcm9hZHMuanMvPlxuICogQXV0aG9yOiBNaWxsZXIgTWVkZWlyb3MgfCBNSVQgTGljZW5zZVxuICogdjAuMTIuMiAoMjAxNS8wNy8zMSAxODozNylcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xudmFyIGZhY3RvcnkgPSBmdW5jdGlvbiAoc2lnbmFscykge1xuXG4gICAgdmFyIGNyb3Nzcm9hZHMsXG4gICAgICAgIF9oYXNPcHRpb25hbEdyb3VwQnVnLFxuICAgICAgICBVTkRFRjtcblxuICAgIC8vIEhlbHBlcnMgLS0tLS0tLS0tLS1cbiAgICAvLz09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvLyBJRSA3LTggY2FwdHVyZSBvcHRpb25hbCBncm91cHMgYXMgZW1wdHkgc3RyaW5ncyB3aGlsZSBvdGhlciBicm93c2Vyc1xuICAgIC8vIGNhcHR1cmUgYXMgYHVuZGVmaW5lZGBcbiAgICBfaGFzT3B0aW9uYWxHcm91cEJ1ZyA9ICgvdCguKyk/LykuZXhlYygndCcpWzFdID09PSAnJztcblxuICAgIGZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnIsIHZhbCkge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuaW5kZXhPZih2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9BcnJheS5pbmRleE9mIGRvZXNuJ3Qgd29yayBvbiBJRSA2LTdcbiAgICAgICAgICAgIHZhciBuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW25dID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlSZW1vdmUoYXJyLCBpdGVtKSB7XG4gICAgICAgIHZhciBpID0gYXJyYXlJbmRleE9mKGFyciwgaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2luZCh2YWwsIGtpbmQpIHtcbiAgICAgICAgcmV0dXJuICdbb2JqZWN0ICcrIGtpbmQgKyddJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsKSB7XG4gICAgICAgIHJldHVybiBpc0tpbmQodmFsLCAnUmVnRXhwJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGlzS2luZCh2YWwsICdBcnJheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8vYm9ycm93ZWQgZnJvbSBBTUQtdXRpbHNcbiAgICBmdW5jdGlvbiB0eXBlY2FzdFZhbHVlKHZhbCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09ICdudWxsJykge1xuICAgICAgICAgICAgciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgIHIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gVU5ERUYgfHwgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgciA9IFVOREVGO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJycgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgLy9pc05hTignJykgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgciA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vcGFyc2VGbG9hdChudWxsIHx8ICcnKSByZXR1cm5zIE5hTlxuICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0eXBlY2FzdEFycmF5VmFsdWVzKHZhbHVlcykge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgcmVzdWx0W25dID0gdHlwZWNhc3RWYWx1ZSh2YWx1ZXNbbl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gYm9ycm93ZWQgZnJvbSBNT1VUXG4gICAgZnVuY3Rpb24gZGVjb2RlUXVlcnlTdHJpbmcocXVlcnlTdHIsIHNob3VsZFR5cGVjYXN0KSB7XG4gICAgICAgIHZhciBxdWVyeUFyciA9IChxdWVyeVN0ciB8fCAnJykucmVwbGFjZSgnPycsICcnKS5zcGxpdCgnJicpLFxuICAgICAgICAgICAgcmVnID0gLyhbXj1dKyk9KC4rKS8sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBvYmogPSB7fSxcbiAgICAgICAgICAgIGVxdWFsSW5kZXgsIGN1ciwgcFZhbHVlLCBwTmFtZTtcblxuICAgICAgICB3aGlsZSAoKGN1ciA9IHF1ZXJ5QXJyWysraV0pKSB7XG4gICAgICAgICAgICBlcXVhbEluZGV4ID0gY3VyLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIHBOYW1lID0gY3VyLnN1YnN0cmluZygwLCBlcXVhbEluZGV4KTtcbiAgICAgICAgICAgIHBWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjdXIuc3Vic3RyaW5nKGVxdWFsSW5kZXggKyAxKSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVHlwZWNhc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcFZhbHVlID0gdHlwZWNhc3RWYWx1ZShwVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBOYW1lIGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYoaXNBcnJheShvYmpbcE5hbWVdKSl7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwTmFtZV0ucHVzaChwVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwTmFtZV0gPSBbb2JqW3BOYW1lXSwgcFZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtwTmFtZV0gPSBwVmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuXG4gICAgLy8gQ3Jvc3Nyb2FkcyAtLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENyb3Nzcm9hZHMoKSB7XG4gICAgICAgIHRoaXMuYnlwYXNzZWQgPSBuZXcgc2lnbmFscy5TaWduYWwoKTtcbiAgICAgICAgdGhpcy5yb3V0ZWQgPSBuZXcgc2lnbmFscy5TaWduYWwoKTtcbiAgICAgICAgdGhpcy5fcm91dGVzID0gW107XG4gICAgICAgIHRoaXMuX3ByZXZSb3V0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcGlwZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgfVxuXG4gICAgQ3Jvc3Nyb2Fkcy5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgZ3JlZWR5IDogZmFsc2UsXG5cbiAgICAgICAgZ3JlZWR5RW5hYmxlZCA6IHRydWUsXG5cbiAgICAgICAgaWdub3JlQ2FzZSA6IHRydWUsXG5cbiAgICAgICAgaWdub3JlU3RhdGUgOiBmYWxzZSxcblxuICAgICAgICBzaG91bGRUeXBlY2FzdCA6IGZhbHNlLFxuXG4gICAgICAgIG5vcm1hbGl6ZUZuIDogbnVsbCxcblxuICAgICAgICByZXNldFN0YXRlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZSb3V0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXRjaGVkUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2QnlwYXNzZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENyb3Nzcm9hZHMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRSb3V0ZSA6IGZ1bmN0aW9uIChwYXR0ZXJuLCBjYWxsYmFjaywgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZSA9IG5ldyBSb3V0ZShwYXR0ZXJuLCBjYWxsYmFjaywgcHJpb3JpdHksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc29ydGVkSW5zZXJ0KHJvdXRlKTtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVSb3V0ZSA6IGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUodGhpcy5fcm91dGVzLCByb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZS5fZGVzdHJveSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUFsbFJvdXRlcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5nZXROdW1Sb3V0ZXMoKTtcbiAgICAgICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXNbbl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JvdXRlcy5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlIDogZnVuY3Rpb24gKHJlcXVlc3QsIGRlZmF1bHRBcmdzKSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdCB8fCAnJztcbiAgICAgICAgICAgIGRlZmF1bHRBcmdzID0gZGVmYXVsdEFyZ3MgfHwgW107XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IGNhcmUgYWJvdXQgZGlmZmVyZW50IHJlcXVlc3RzIGlmIGlnbm9yZVN0YXRlIGlzbid0IHRydWVcbiAgICAgICAgICAgIGlmICggIXRoaXMuaWdub3JlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAocmVxdWVzdCA9PT0gdGhpcy5fcHJldk1hdGNoZWRSZXF1ZXN0IHx8XG4gICAgICAgICAgICAgICAgIHJlcXVlc3QgPT09IHRoaXMuX3ByZXZCeXBhc3NlZFJlcXVlc3QpICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvdXRlcyA9IHRoaXMuX2dldE1hdGNoZWRSb3V0ZXMocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgbiA9IHJvdXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY3VyO1xuXG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZNYXRjaGVkUmVxdWVzdCA9IHJlcXVlc3Q7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlQcmV2Um91dGVzKHJvdXRlcywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldlJvdXRlcyA9IHJvdXRlcztcbiAgICAgICAgICAgICAgICAvL3Nob3VsZCBiZSBpbmNyZW1lbnRhbCBsb29wLCBleGVjdXRlIHJvdXRlcyBpbiBvcmRlclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSByb3V0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGN1ci5yb3V0ZS5tYXRjaGVkLmRpc3BhdGNoLmFwcGx5KGN1ci5yb3V0ZS5tYXRjaGVkLCBkZWZhdWx0QXJncy5jb25jYXQoY3VyLnBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjdXIuaXNGaXJzdCA9ICFpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlZC5kaXNwYXRjaC5hcHBseSh0aGlzLnJvdXRlZCwgZGVmYXVsdEFyZ3MuY29uY2F0KFtyZXF1ZXN0LCBjdXJdKSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCeXBhc3NlZFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIHRoaXMuYnlwYXNzZWQuZGlzcGF0Y2guYXBwbHkodGhpcy5ieXBhc3NlZCwgZGVmYXVsdEFyZ3MuY29uY2F0KFtyZXF1ZXN0XSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9waXBlUGFyc2UocmVxdWVzdCwgZGVmYXVsdEFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9ub3RpZnlQcmV2Um91dGVzIDogZnVuY3Rpb24obWF0Y2hlZFJvdXRlcywgcmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBwcmV2O1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgPSB0aGlzLl9wcmV2Um91dGVzW2krK10pIHtcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHN3aXRjaGVkIGV4aXN0IHNpbmNlIHJvdXRlIG1heSBiZSBkaXNwb3NlZFxuICAgICAgICAgICAgICAgIGlmKHByZXYucm91dGUuc3dpdGNoZWQgJiYgdGhpcy5fZGlkU3dpdGNoKHByZXYucm91dGUsIG1hdGNoZWRSb3V0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYucm91dGUuc3dpdGNoZWQuZGlzcGF0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kaWRTd2l0Y2ggOiBmdW5jdGlvbiAocm91dGUsIG1hdGNoZWRSb3V0ZXMpe1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlZCA9IG1hdGNoZWRSb3V0ZXNbaSsrXSkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGlzcGF0Y2ggc3dpdGNoZWQgaWYgaXQgaXMgZ29pbmcgdG8gYSBkaWZmZXJlbnQgcm91dGVcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZC5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9waXBlUGFyc2UgOiBmdW5jdGlvbihyZXF1ZXN0LCBkZWZhdWx0QXJncykge1xuICAgICAgICAgICAgdmFyIGkgPSAwLCByb3V0ZTtcbiAgICAgICAgICAgIHdoaWxlIChyb3V0ZSA9IHRoaXMuX3BpcGVkW2krK10pIHtcbiAgICAgICAgICAgICAgICByb3V0ZS5wYXJzZShyZXF1ZXN0LCBkZWZhdWx0QXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TnVtUm91dGVzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlcy5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NvcnRlZEluc2VydCA6IGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgLy9zaW1wbGlmaWVkIGluc2VydGlvbiBzb3J0XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gdGhpcy5fcm91dGVzLFxuICAgICAgICAgICAgICAgIG4gPSByb3V0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgZG8geyAtLW47IH0gd2hpbGUgKHJvdXRlc1tuXSAmJiByb3V0ZS5fcHJpb3JpdHkgPD0gcm91dGVzW25dLl9wcmlvcml0eSk7XG4gICAgICAgICAgICByb3V0ZXMuc3BsaWNlKG4rMSwgMCwgcm91dGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRNYXRjaGVkUm91dGVzIDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgICAgICByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMsXG4gICAgICAgICAgICAgICAgbiA9IHJvdXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcm91dGU7XG4gICAgICAgICAgICAvL3Nob3VsZCBiZSBkZWNyZW1lbnQgbG9vcCBzaW5jZSBoaWdoZXIgcHJpb3JpdGllcyBhcmUgYWRkZWQgYXQgdGhlIGVuZCBvZiBhcnJheVxuICAgICAgICAgICAgd2hpbGUgKHJvdXRlID0gcm91dGVzWy0tbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKCFyZXMubGVuZ3RoIHx8IHRoaXMuZ3JlZWR5IHx8IHJvdXRlLmdyZWVkeSkgJiYgcm91dGUubWF0Y2gocmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA6IHJvdXRlLl9nZXRQYXJhbXNBcnJheShyZXF1ZXN0KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdyZWVkeUVuYWJsZWQgJiYgcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBpcGUgOiBmdW5jdGlvbiAob3RoZXJSb3V0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpcGVkLnB1c2gob3RoZXJSb3V0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVucGlwZSA6IGZ1bmN0aW9uIChvdGhlclJvdXRlcikge1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUodGhpcy5fcGlwZWQsIG90aGVyUm91dGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnW2Nyb3Nzcm9hZHMgbnVtUm91dGVzOicrIHRoaXMuZ2V0TnVtUm91dGVzKCkgKyddJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1wic3RhdGljXCIgaW5zdGFuY2VcbiAgICBjcm9zc3JvYWRzID0gbmV3IENyb3Nzcm9hZHMoKTtcbiAgICBjcm9zc3JvYWRzLlZFUlNJT04gPSAnMC4xMi4yJztcblxuICAgIGNyb3Nzcm9hZHMuTk9STV9BU19BUlJBWSA9IGZ1bmN0aW9uIChyZXEsIHZhbHMpIHtcbiAgICAgICAgcmV0dXJuIFt2YWxzLnZhbHNfXTtcbiAgICB9O1xuXG4gICAgY3Jvc3Nyb2Fkcy5OT1JNX0FTX09CSkVDVCA9IGZ1bmN0aW9uIChyZXEsIHZhbHMpIHtcbiAgICAgICAgcmV0dXJuIFt2YWxzXTtcbiAgICB9O1xuXG5cbiAgICAvLyBSb3V0ZSAtLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSb3V0ZShwYXR0ZXJuLCBjYWxsYmFjaywgcHJpb3JpdHksIHJvdXRlcikge1xuICAgICAgICB2YXIgaXNSZWdleFBhdHRlcm4gPSBpc1JlZ0V4cChwYXR0ZXJuKSxcbiAgICAgICAgICAgIHBhdHRlcm5MZXhlciA9IHJvdXRlci5wYXR0ZXJuTGV4ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5fcGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuX3BhcmFtc0lkcyA9IGlzUmVnZXhQYXR0ZXJuPyBudWxsIDogcGF0dGVybkxleGVyLmdldFBhcmFtSWRzKHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9vcHRpb25hbFBhcmFtc0lkcyA9IGlzUmVnZXhQYXR0ZXJuPyBudWxsIDogcGF0dGVybkxleGVyLmdldE9wdGlvbmFsUGFyYW1zSWRzKHBhdHRlcm4pO1xuICAgICAgICB0aGlzLl9tYXRjaFJlZ2V4cCA9IGlzUmVnZXhQYXR0ZXJuPyBwYXR0ZXJuIDogcGF0dGVybkxleGVyLmNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4sIHJvdXRlci5pZ25vcmVDYXNlKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gbmV3IHNpZ25hbHMuU2lnbmFsKCk7XG4gICAgICAgIHRoaXMuc3dpdGNoZWQgPSBuZXcgc2lnbmFscy5TaWduYWwoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZWQuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG4gICAgfVxuXG4gICAgUm91dGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGdyZWVkeSA6IGZhbHNlLFxuXG4gICAgICAgIHJ1bGVzIDogdm9pZCgwKSxcblxuICAgICAgICBtYXRjaCA6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdCB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXRjaFJlZ2V4cC50ZXN0KHJlcXVlc3QpICYmIHRoaXMuX3ZhbGlkYXRlUGFyYW1zKHJlcXVlc3QpOyAvL3ZhbGlkYXRlIHBhcmFtcyBldmVuIGlmIHJlZ2V4cCBiZWNhdXNlIG9mIGByZXF1ZXN0X2AgcnVsZS5cbiAgICAgICAgfSxcblxuICAgICAgICBfdmFsaWRhdGVQYXJhbXMgOiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcyxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0aGlzLl9nZXRQYXJhbXNPYmplY3QocmVxdWVzdCksXG4gICAgICAgICAgICAgICAga2V5O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemVfIGlzbid0IGEgdmFsaWRhdGlvbiBydWxlLi4uICgjMzkpXG4gICAgICAgICAgICAgICAgaWYoa2V5ICE9PSAnbm9ybWFsaXplXycgJiYgcnVsZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhIHRoaXMuX2lzVmFsaWRQYXJhbShyZXF1ZXN0LCBrZXksIHZhbHVlcykpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2lzVmFsaWRQYXJhbSA6IGZ1bmN0aW9uIChyZXF1ZXN0LCBwcm9wLCB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0aW9uUnVsZSA9IHRoaXMucnVsZXNbcHJvcF0sXG4gICAgICAgICAgICAgICAgdmFsID0gdmFsdWVzW3Byb3BdLFxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc1F1ZXJ5ID0gKHByb3AuaW5kZXhPZignPycpID09PSAwKTtcblxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsICYmIHRoaXMuX29wdGlvbmFsUGFyYW1zSWRzICYmIGFycmF5SW5kZXhPZih0aGlzLl9vcHRpb25hbFBhcmFtc0lkcywgcHJvcCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cCh2YWxpZGF0aW9uUnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZXNbcHJvcCArJ18nXTsgLy91c2UgcmF3IHN0cmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWRhdGlvblJ1bGUudGVzdCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh2YWxpZGF0aW9uUnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZXNbcHJvcCArJ18nXTsgLy91c2UgcmF3IHN0cmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdGhpcy5faXNWYWxpZEFycmF5UnVsZSh2YWxpZGF0aW9uUnVsZSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGlvblJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHZhbGlkYXRpb25SdWxlKHZhbCwgcmVxdWVzdCwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQ7IC8vZmFpbCBzaWxlbnRseSBpZiB2YWxpZGF0aW9uUnVsZSBpcyBmcm9tIGFuIHVuc3VwcG9ydGVkIHR5cGVcbiAgICAgICAgfSxcblxuICAgICAgICBfaXNWYWxpZEFycmF5UnVsZSA6IGZ1bmN0aW9uIChhcnIsIHZhbCkge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5fcm91dGVyLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGFyciwgdmFsKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBjb21wYXJlVmFsO1xuXG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IGFycltuXTtcbiAgICAgICAgICAgICAgICBjb21wYXJlVmFsID0gKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyk/IGl0ZW0udG9Mb3dlckNhc2UoKSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVWYWwgPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFBhcmFtc09iamVjdCA6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkVHlwZWNhc3QgPSB0aGlzLl9yb3V0ZXIuc2hvdWxkVHlwZWNhc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5fcm91dGVyLnBhdHRlcm5MZXhlci5nZXRQYXJhbVZhbHVlcyhyZXF1ZXN0LCB0aGlzLl9tYXRjaFJlZ2V4cCwgc2hvdWxkVHlwZWNhc3QpLFxuICAgICAgICAgICAgICAgIG8gPSB7fSxcbiAgICAgICAgICAgICAgICBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwYXJhbSwgdmFsO1xuICAgICAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlc1tuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFyYW1zSWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtID0gdGhpcy5fcGFyYW1zSWRzW25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhPZignPycpID09PSAwICYmIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgc3RyaW5nIHNvIGFycmF5IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9SZWdFeHAgdmFsaWRhdGlvbiBjYW4gYmUgYXBwbGllZCBwcm9wZXJseVxuICAgICAgICAgICAgICAgICAgICAgICAgb1twYXJhbSArJ18nXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHZhbHNfIGFycmF5IGFzIHdlbGwgc2luY2UgaXQgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2R1cmluZyBkaXNwYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZGVjb2RlUXVlcnlTdHJpbmcodmFsLCBzaG91bGRUeXBlY2FzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbbl0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgd2lsbCBjYXB0dXJlIG9wdGlvbmFsIGdyb3VwcyBhcyBlbXB0eSBzdHJpbmdzIHdoaWxlIG90aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJyb3dzZXJzIHdpbGwgY2FwdHVyZSBgdW5kZWZpbmVkYCBzbyBub3JtYWxpemUgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZTogI2doLTU4LCAjZ2gtNTksICNnaC02MFxuICAgICAgICAgICAgICAgICAgICBpZiAoIF9oYXNPcHRpb25hbEdyb3VwQnVnICYmIHZhbCA9PT0gJycgJiYgYXJyYXlJbmRleE9mKHRoaXMuX29wdGlvbmFsUGFyYW1zSWRzLCBwYXJhbSkgIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gdm9pZCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tuXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvW3BhcmFtXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9hbGlhcyB0byBwYXRocyBhbmQgZm9yIFJlZ0V4cCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgb1tuXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG8ucmVxdWVzdF8gPSBzaG91bGRUeXBlY2FzdD8gdHlwZWNhc3RWYWx1ZShyZXF1ZXN0KSA6IHJlcXVlc3Q7XG4gICAgICAgICAgICBvLnZhbHNfID0gdmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFBhcmFtc0FycmF5IDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBub3JtID0gdGhpcy5ydWxlcz8gdGhpcy5ydWxlcy5ub3JtYWxpemVfIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbXM7XG4gICAgICAgICAgICBub3JtID0gbm9ybSB8fCB0aGlzLl9yb3V0ZXIubm9ybWFsaXplRm47IC8vIGRlZmF1bHQgbm9ybWFsaXplXG4gICAgICAgICAgICBpZiAobm9ybSAmJiBpc0Z1bmN0aW9uKG5vcm0pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbm9ybShyZXF1ZXN0LCB0aGlzLl9nZXRQYXJhbXNPYmplY3QocmVxdWVzdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLl9nZXRQYXJhbXNPYmplY3QocmVxdWVzdCkudmFsc187XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludGVycG9sYXRlIDogZnVuY3Rpb24ocmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gdGhpcy5fcm91dGVyLnBhdHRlcm5MZXhlci5pbnRlcnBvbGF0ZSh0aGlzLl9wYXR0ZXJuLCByZXBsYWNlbWVudHMpO1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5fdmFsaWRhdGVQYXJhbXMoc3RyKSApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyYXRlZCBzdHJpbmcgZG9lc25cXCd0IHZhbGlkYXRlIGFnYWluc3QgYFJvdXRlLnJ1bGVzYC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlci5yZW1vdmVSb3V0ZSh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVzdHJveSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaGVkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMuc3dpdGNoZWQgPSB0aGlzLl9wYXR0ZXJuID0gdGhpcy5fbWF0Y2hSZWdleHAgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbUm91dGUgcGF0dGVybjpcIicrIHRoaXMuX3BhdHRlcm4gKydcIiwgbnVtTGlzdGVuZXJzOicrIHRoaXMubWF0Y2hlZC5nZXROdW1MaXN0ZW5lcnMoKSArJ10nO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cblxuICAgIC8vIFBhdHRlcm4gTGV4ZXIgLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT1cblxuICAgIENyb3Nzcm9hZHMucHJvdG90eXBlLnBhdHRlcm5MZXhlciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICAvL21hdGNoIGNoYXJzIHRoYXQgc2hvdWxkIGJlIGVzY2FwZWQgb24gc3RyaW5nIHJlZ2V4cFxuICAgICAgICAgICAgRVNDQVBFX0NIQVJTX1JFR0VYUCA9IC9bXFxcXC4rKj9cXF4kXFxbXFxdKCl7fVxcLycjXS9nLFxuXG4gICAgICAgICAgICAvL3RyYWlsaW5nIHNsYXNoZXMgKGJlZ2luL2VuZCBvZiBzdHJpbmcpXG4gICAgICAgICAgICBMT09TRV9TTEFTSEVTX1JFR0VYUCA9IC9eXFwvfFxcLyQvZyxcbiAgICAgICAgICAgIExFR0FDWV9TTEFTSEVTX1JFR0VYUCA9IC9cXC8kL2csXG5cbiAgICAgICAgICAgIC8vcGFyYW1zIC0gZXZlcnl0aGluZyBiZXR3ZWVuIGB7IH1gIG9yIGA6IDpgXG4gICAgICAgICAgICBQQVJBTVNfUkVHRVhQID0gLyg/Olxce3w6KShbXn06XSspKD86XFx9fDopL2csXG5cbiAgICAgICAgICAgIC8vdXNlZCB0byBzYXZlIHBhcmFtcyBkdXJpbmcgY29tcGlsZSAoYXZvaWQgZXNjYXBpbmcgdGhpbmdzIHRoYXRcbiAgICAgICAgICAgIC8vc2hvdWxkbid0IGJlIGVzY2FwZWQpLlxuICAgICAgICAgICAgVE9LRU5TID0ge1xuICAgICAgICAgICAgICAgICdPUycgOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9uYWwgc2xhc2hlc1xuICAgICAgICAgICAgICAgICAgICAvL3NsYXNoIGJldHdlZW4gYDo6YCBvciBgfTpgIG9yIGBcXHc6YCBvciBgOns/YCBvciBgfXs/YCBvciBgXFx3ez9gXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC8oWzp9XXxcXHcoPz1cXC8pKVxcLz8oOnwoPzpcXHtcXD8pKS9nLFxuICAgICAgICAgICAgICAgICAgICBzYXZlIDogJyQxe3tpZH19JDInLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnXFxcXC8/J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1JTJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXF1aXJlZCBzbGFzaGVzXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlZCB0byBpbnNlcnQgc2xhc2ggYmV0d2VlbiBgOntgIGFuZCBgfXtgXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC8oWzp9XSlcXC8/KFxceykvZyxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZSA6ICckMXt7aWR9fSQyJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzIDogJ1xcXFwvJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1JRJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXF1aXJlZCBxdWVyeSBzdHJpbmcgLSBldmVyeXRoaW5nIGluIGJldHdlZW4gYHs/IH1gXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC9cXHtcXD8oW159XSspXFx9L2csXG4gICAgICAgICAgICAgICAgICAgIC8vZXZlcnl0aGluZyBmcm9tIGA/YCB0aWxsIGAjYCBvciBlbmQgb2Ygc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHJlcyA6ICdcXFxcPyhbXiNdKyknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnT1EnIDoge1xuICAgICAgICAgICAgICAgICAgICAvL29wdGlvbmFsIHF1ZXJ5IHN0cmluZyAtIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiBgOj8gOmBcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogLzpcXD8oW146XSspOi9nLFxuICAgICAgICAgICAgICAgICAgICAvL2V2ZXJ5dGhpbmcgZnJvbSBgP2AgdGlsbCBgI2Agb3IgZW5kIG9mIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICByZXMgOiAnKD86XFxcXD8oW14jXSopKT8nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnT1InIDoge1xuICAgICAgICAgICAgICAgICAgICAvL29wdGlvbmFsIHJlc3QgLSBldmVyeXRoaW5nIGluIGJldHdlZW4gYDogKjpgXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC86KFteOl0rKVxcKjovZyxcbiAgICAgICAgICAgICAgICAgICAgcmVzIDogJyguKik/JyAvLyBvcHRpb25hbCBncm91cCB0byBhdm9pZCBwYXNzaW5nIGVtcHR5IHN0cmluZyBhcyBjYXB0dXJlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ1JSJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXN0IHBhcmFtIC0gZXZlcnl0aGluZyBpbiBiZXR3ZWVuIGB7ICp9YFxuICAgICAgICAgICAgICAgICAgICByZ3ggOiAvXFx7KFtefV0rKVxcKlxcfS9nLFxuICAgICAgICAgICAgICAgICAgICByZXMgOiAnKC4rKSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkL29wdGlvbmFsIHBhcmFtcyBzaG91bGQgY29tZSBhZnRlciByZXN0IHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgJ1JQJyA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXF1aXJlZCBwYXJhbXMgLSBldmVyeXRoaW5nIGJldHdlZW4gYHsgfWBcbiAgICAgICAgICAgICAgICAgICAgcmd4IDogL1xceyhbXn1dKylcXH0vZyxcbiAgICAgICAgICAgICAgICAgICAgcmVzIDogJyhbXlxcXFwvP10rKSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdPUCcgOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vb3B0aW9uYWwgcGFyYW1zIC0gZXZlcnl0aGluZyBiZXR3ZWVuIGA6IDpgXG4gICAgICAgICAgICAgICAgICAgIHJneCA6IC86KFteOl0rKTovZyxcbiAgICAgICAgICAgICAgICAgICAgcmVzIDogJyhbXlxcXFwvP10rKT9cXC8/J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIExPT1NFX1NMQVNIID0gMSxcbiAgICAgICAgICAgIFNUUklDVF9TTEFTSCA9IDIsXG4gICAgICAgICAgICBMRUdBQ1lfU0xBU0ggPSAzLFxuXG4gICAgICAgICAgICBfc2xhc2hNb2RlID0gTE9PU0VfU0xBU0g7XG5cblxuICAgICAgICBmdW5jdGlvbiBwcmVjb21waWxlVG9rZW5zKCl7XG4gICAgICAgICAgICB2YXIga2V5LCBjdXI7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBUT0tFTlMpIHtcbiAgICAgICAgICAgICAgICBpZiAoVE9LRU5TLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gVE9LRU5TW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGN1ci5pZCA9ICdfX0NSXycrIGtleSArJ19fJztcbiAgICAgICAgICAgICAgICAgICAgY3VyLnNhdmUgPSAoJ3NhdmUnIGluIGN1cik/IGN1ci5zYXZlLnJlcGxhY2UoJ3t7aWR9fScsIGN1ci5pZCkgOiBjdXIuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5yUmVzdG9yZSA9IG5ldyBSZWdFeHAoY3VyLmlkLCAnZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmVjb21waWxlVG9rZW5zKCk7XG5cblxuICAgICAgICBmdW5jdGlvbiBjYXB0dXJlVmFscyhyZWdleCwgcGF0dGVybikge1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBbXSwgbWF0Y2g7XG4gICAgICAgICAgICAvLyB2ZXJ5IGltcG9ydGFudCB0byByZXNldCBsYXN0SW5kZXggc2luY2UgUmVnRXhwIGNhbiBoYXZlIFwiZ1wiIGZsYWdcbiAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSBydW5zIG1pZ2h0IGFmZmVjdCB0aGUgcmVzdWx0LCBzcGVjaWFsbHkgaWYgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIHNhbWUgc3RyaW5nIG11bHRpcGxlIHRpbWVzIG9uIElFIDctOFxuICAgICAgICAgICAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4LmV4ZWMocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICB2YWxzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRQYXJhbUlkcyhwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwdHVyZVZhbHMoUEFSQU1TX1JFR0VYUCwgcGF0dGVybik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRPcHRpb25hbFBhcmFtc0lkcyhwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FwdHVyZVZhbHMoVE9LRU5TLk9QLnJneCwgcGF0dGVybik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuLCBpZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybiB8fCAnJztcblxuICAgICAgICAgICAgaWYocGF0dGVybil7XG4gICAgICAgICAgICAgICAgaWYgKF9zbGFzaE1vZGUgPT09IExPT1NFX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoTE9PU0VfU0xBU0hFU19SRUdFWFAsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3NsYXNoTW9kZSA9PT0gTEVHQUNZX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoTEVHQUNZX1NMQVNIRVNfUkVHRVhQLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9zYXZlIHRva2Vuc1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByZXBsYWNlVG9rZW5zKHBhdHRlcm4sICdyZ3gnLCAnc2F2ZScpO1xuICAgICAgICAgICAgICAgIC8vcmVnZXhwIGVzY2FwZVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoRVNDQVBFX0NIQVJTX1JFR0VYUCwgJ1xcXFwkJicpO1xuICAgICAgICAgICAgICAgIC8vcmVzdG9yZSB0b2tlbnNcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcmVwbGFjZVRva2VucyhwYXR0ZXJuLCAnclJlc3RvcmUnLCAncmVzJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3NsYXNoTW9kZSA9PT0gTE9PU0VfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9ICdcXFxcLz8nKyBwYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKF9zbGFzaE1vZGUgIT09IFNUUklDVF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIC8vc2luZ2xlIHNsYXNoIGlzIHRyZWF0ZWQgYXMgZW1wdHkgYW5kIGVuZCBzbGFzaCBpcyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gJ1xcXFwvPyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicrIHBhdHRlcm4gKyAnJCcsIGlnbm9yZUNhc2U/ICdpJyA6ICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VUb2tlbnMocGF0dGVybiwgcmVnZXhwTmFtZSwgcmVwbGFjZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjdXIsIGtleTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIFRPS0VOUykge1xuICAgICAgICAgICAgICAgIGlmIChUT0tFTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBUT0tFTlNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShjdXJbcmVnZXhwTmFtZV0sIGN1cltyZXBsYWNlTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGFyYW1WYWx1ZXMocmVxdWVzdCwgcmVnZXhwLCBzaG91bGRUeXBlY2FzdCkge1xuICAgICAgICAgICAgdmFyIHZhbHMgPSByZWdleHAuZXhlYyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmICh2YWxzKSB7XG4gICAgICAgICAgICAgICAgdmFscy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRUeXBlY2FzdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxzID0gdHlwZWNhc3RBcnJheVZhbHVlcyh2YWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFscztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKHBhdHRlcm4sIHJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBhbiBlbXB0eSBvYmplY3QgYmVjYXVzZSBwYXR0ZXJuIG1pZ2h0IGhhdmUganVzdFxuICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXJndW1lbnRzXG4gICAgICAgICAgICByZXBsYWNlbWVudHMgPSByZXBsYWNlbWVudHMgfHwge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZSBwYXR0ZXJuIHNob3VsZCBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlcGxhY2VGbiA9IGZ1bmN0aW9uKG1hdGNoLCBwcm9wKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IChwcm9wLnN1YnN0cigwLCAxKSA9PT0gJz8nKT8gcHJvcC5zdWJzdHIoMSkgOiBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRzW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnRzW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeVBhcnRzID0gW10sIHJlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiByZXBsYWNlbWVudHNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwID0gcmVwbGFjZW1lbnRzW3Byb3BdW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHJlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gcmVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBrZXkuc2xpY2UoLTIpID09ICdbXScgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFydHMucHVzaChlbmNvZGVVUkkoa2V5LnNsaWNlKDAsIC0yKSkgKyAnW109JyArIGVuY29kZVVSSShyZXBba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcnRzLnB1c2goZW5jb2RlVVJJKGtleSArICc9JyArIHJlcFtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFydHMucHVzaChlbmNvZGVVUkkoa2V5ICsgJz0nICsgcmVwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gJz8nICsgcXVlcnlQYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB2YWx1ZSBpcyBhIHN0cmluZyBzZWUgI2doLTU0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gU3RyaW5nKHJlcGxhY2VtZW50c1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleE9mKCcqJykgPT09IC0xICYmIHZhbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIFwiJysgdmFsICsnXCIgZm9yIHNlZ21lbnQgXCInKyBtYXRjaCArJ1wiLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoLmluZGV4T2YoJ3snKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlZ21lbnQgJysgbWF0Y2ggKycgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghIFRPS0VOUy5PUy50cmFpbCkge1xuICAgICAgICAgICAgICAgIFRPS0VOUy5PUy50cmFpbCA9IG5ldyBSZWdFeHAoJyg/OicrIFRPS0VOUy5PUy5pZCArJykrJCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoVE9LRU5TLk9TLnJneCwgVE9LRU5TLk9TLnNhdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShQQVJBTVNfUkVHRVhQLCByZXBsYWNlRm4pXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShUT0tFTlMuT1MudHJhaWwsICcnKSAvLyByZW1vdmUgdHJhaWxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKFRPS0VOUy5PUy5yUmVzdG9yZSwgJy8nKTsgLy8gYWRkIHNsYXNoIGJldHdlZW4gc2VnbWVudHNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQVBJXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJpY3QgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIF9zbGFzaE1vZGUgPSBTVFJJQ1RfU0xBU0g7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9vc2UgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIF9zbGFzaE1vZGUgPSBMT09TRV9TTEFTSDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWdhY3kgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIF9zbGFzaE1vZGUgPSBMRUdBQ1lfU0xBU0g7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UGFyYW1JZHMgOiBnZXRQYXJhbUlkcyxcbiAgICAgICAgICAgIGdldE9wdGlvbmFsUGFyYW1zSWRzIDogZ2V0T3B0aW9uYWxQYXJhbXNJZHMsXG4gICAgICAgICAgICBnZXRQYXJhbVZhbHVlcyA6IGdldFBhcmFtVmFsdWVzLFxuICAgICAgICAgICAgY29tcGlsZVBhdHRlcm4gOiBjb21waWxlUGF0dGVybixcbiAgICAgICAgICAgIGludGVycG9sYXRlIDogaW50ZXJwb2xhdGVcbiAgICAgICAgfTtcblxuICAgIH0oKSk7XG5cblxuICAgIHJldHVybiBjcm9zc3JvYWRzO1xufTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ3NpZ25hbHMnXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7IC8vTm9kZVxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzaWduYWxzJykpO1xufSBlbHNlIHtcbiAgICAvKmpzaGludCBzdWI6dHJ1ZSAqL1xuICAgIHdpbmRvd1snY3Jvc3Nyb2FkcyddID0gZmFjdG9yeSh3aW5kb3dbJ3NpZ25hbHMnXSk7XG59XG5cbn0oKSk7XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsImltcG9ydCBydW50aW1lIGZyb20gJy4vaGFuZGxlYmFycy5ydW50aW1lJztcblxuLy8gQ29tcGlsZXIgaW1wb3J0c1xuaW1wb3J0IEFTVCBmcm9tICcuL2hhbmRsZWJhcnMvY29tcGlsZXIvYXN0JztcbmltcG9ydCB7IHBhcnNlciBhcyBQYXJzZXIsIHBhcnNlIH0gZnJvbSAnLi9oYW5kbGViYXJzL2NvbXBpbGVyL2Jhc2UnO1xuaW1wb3J0IHsgQ29tcGlsZXIsIGNvbXBpbGUsIHByZWNvbXBpbGUgfSBmcm9tICcuL2hhbmRsZWJhcnMvY29tcGlsZXIvY29tcGlsZXInO1xuaW1wb3J0IEphdmFTY3JpcHRDb21waWxlciBmcm9tICcuL2hhbmRsZWJhcnMvY29tcGlsZXIvamF2YXNjcmlwdC1jb21waWxlcic7XG5pbXBvcnQgVmlzaXRvciBmcm9tICcuL2hhbmRsZWJhcnMvY29tcGlsZXIvdmlzaXRvcic7XG5cbmltcG9ydCBub0NvbmZsaWN0IGZyb20gJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCc7XG5cbmxldCBfY3JlYXRlID0gcnVudGltZS5jcmVhdGU7XG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBoYiA9IF9jcmVhdGUoKTtcblxuICBoYi5jb21waWxlID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xuICB9O1xuICBoYi5wcmVjb21waWxlID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJlY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xuICB9O1xuXG4gIGhiLkFTVCA9IEFTVDtcbiAgaGIuQ29tcGlsZXIgPSBDb21waWxlcjtcbiAgaGIuSmF2YVNjcmlwdENvbXBpbGVyID0gSmF2YVNjcmlwdENvbXBpbGVyO1xuICBoYi5QYXJzZXIgPSBQYXJzZXI7XG4gIGhiLnBhcnNlID0gcGFyc2U7XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3QuVmlzaXRvciA9IFZpc2l0b3I7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iLCJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iLCJpbXBvcnQge2NyZWF0ZUZyYW1lLCBleHRlbmQsIHRvU3RyaW5nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHRIZWxwZXJzfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMC4xMSc7XG5leHBvcnQgY29uc3QgQ09NUElMRVJfUkVWSVNJT04gPSA3O1xuXG5leHBvcnQgY29uc3QgUkVWSVNJT05fQ0hBTkdFUyA9IHtcbiAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcbiAgMjogJz09IDEuMC4wLXJjLjMnLFxuICAzOiAnPT0gMS4wLjAtcmMuNCcsXG4gIDQ6ICc9PSAxLngueCcsXG4gIDU6ICc9PSAyLjAuMC1hbHBoYS54JyxcbiAgNjogJz49IDIuMC4wLWJldGEuMScsXG4gIDc6ICc+PSA0LjAuMCdcbn07XG5cbmNvbnN0IG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IGxvZ2dlcixcbiAgbG9nOiBsb2dnZXIubG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSwgcGFydGlhbCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBleHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJHtuYW1lfVwiIGFzIHVuZGVmaW5lZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7Y3JlYXRlRnJhbWUsIGxvZ2dlcn07XG4iLCJsZXQgQVNUID0ge1xuICAvLyBQdWJsaWMgQVBJIHVzZWQgdG8gZXZhbHVhdGUgZGVyaXZlZCBhdHRyaWJ1dGVzIHJlZ2FyZGluZyBBU1Qgbm9kZXNcbiAgaGVscGVyczoge1xuICAgIC8vIGEgbXVzdGFjaGUgaXMgZGVmaW5pdGVseSBhIGhlbHBlciBpZjpcbiAgICAvLyAqIGl0IGlzIGFuIGVsaWdpYmxlIGhlbHBlciwgYW5kXG4gICAgLy8gKiBpdCBoYXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBvciBoYXNoIHNlZ21lbnRcbiAgICBoZWxwZXJFeHByZXNzaW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nKVxuICAgICAgICAgIHx8ICgobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JylcbiAgICAgICAgICAgICYmICEhKChub2RlLnBhcmFtcyAmJiBub2RlLnBhcmFtcy5sZW5ndGgpIHx8IG5vZGUuaGFzaCkpO1xuICAgIH0sXG5cbiAgICBzY29wZWRJZDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuICgvXlxcLnx0aGlzXFxiLykudGVzdChwYXRoLm9yaWdpbmFsKTtcbiAgICB9LFxuXG4gICAgLy8gYW4gSUQgaXMgc2ltcGxlIGlmIGl0IG9ubHkgaGFzIG9uZSBwYXJ0LCBhbmQgdGhhdCBwYXJ0IGlzIG5vdFxuICAgIC8vIGAuLmAgb3IgYHRoaXNgLlxuICAgIHNpbXBsZUlkOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5wYXJ0cy5sZW5ndGggPT09IDEgJiYgIUFTVC5oZWxwZXJzLnNjb3BlZElkKHBhdGgpICYmICFwYXRoLmRlcHRoO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLyBNdXN0IGJlIGV4cG9ydGVkIGFzIGFuIG9iamVjdCByYXRoZXIgdGhhbiB0aGUgcm9vdCBvZiB0aGUgbW9kdWxlIGFzIHRoZSBqaXNvbiBsZXhlclxuLy8gbXVzdCBtb2RpZnkgdGhlIG9iamVjdCB0byBvcGVyYXRlIHByb3Blcmx5LlxuZXhwb3J0IGRlZmF1bHQgQVNUO1xuIiwiaW1wb3J0IHBhcnNlciBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgV2hpdGVzcGFjZUNvbnRyb2wgZnJvbSAnLi93aGl0ZXNwYWNlLWNvbnRyb2wnO1xuaW1wb3J0ICogYXMgSGVscGVycyBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgeyBwYXJzZXIgfTtcblxubGV0IHl5ID0ge307XG5leHRlbmQoeXksIEhlbHBlcnMpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gSnVzdCByZXR1cm4gaWYgYW4gYWxyZWFkeS1jb21waWxlZCBBU1Qgd2FzIHBhc3NlZCBpbi5cbiAgaWYgKGlucHV0LnR5cGUgPT09ICdQcm9ncmFtJykgeyByZXR1cm4gaW5wdXQ7IH1cblxuICBwYXJzZXIueXkgPSB5eTtcblxuICAvLyBBbHRlcmluZyB0aGUgc2hhcmVkIG9iamVjdCBoZXJlLCBidXQgdGhpcyBpcyBvayBhcyBwYXJzZXIgaXMgYSBzeW5jIG9wZXJhdGlvblxuICB5eS5sb2NJbmZvID0gZnVuY3Rpb24obG9jSW5mbykge1xuICAgIHJldHVybiBuZXcgeXkuU291cmNlTG9jYXRpb24ob3B0aW9ucyAmJiBvcHRpb25zLnNyY05hbWUsIGxvY0luZm8pO1xuICB9O1xuXG4gIGxldCBzdHJpcCA9IG5ldyBXaGl0ZXNwYWNlQ29udHJvbChvcHRpb25zKTtcbiAgcmV0dXJuIHN0cmlwLmFjY2VwdChwYXJzZXIucGFyc2UoaW5wdXQpKTtcbn1cbiIsIi8qIGdsb2JhbCBkZWZpbmUgKi9cbmltcG9ydCB7aXNBcnJheX0gZnJvbSAnLi4vdXRpbHMnO1xuXG5sZXQgU291cmNlTm9kZTtcblxudHJ5IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicgfHwgIWRlZmluZS5hbWQpIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHRoaXMgaW4gQU1EIGVudmlyb25tZW50cy4gRm9yIHRoZXNlIGVudmlyb25tZW50cywgd2UgYXN1c21lIHRoYXRcbiAgICAvLyB0aGV5IGFyZSBydW5uaW5nIG9uIHRoZSBicm93c2VyIGFuZCB0aHVzIGhhdmUgbm8gbmVlZCBmb3IgdGhlIHNvdXJjZS1tYXAgbGlicmFyeS5cbiAgICBsZXQgU291cmNlTWFwID0gcmVxdWlyZSgnc291cmNlLW1hcCcpO1xuICAgIFNvdXJjZU5vZGUgPSBTb3VyY2VNYXAuU291cmNlTm9kZTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG4gIC8qIE5PUCAqL1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRlc3RlZCBidXQgbm90IGNvdmVyZWQgaW4gaXN0YW5idWwgZHVlIHRvIGRpc3QgYnVpbGQgICovXG5pZiAoIVNvdXJjZU5vZGUpIHtcbiAgU291cmNlTm9kZSA9IGZ1bmN0aW9uKGxpbmUsIGNvbHVtbiwgc3JjRmlsZSwgY2h1bmtzKSB7XG4gICAgdGhpcy5zcmMgPSAnJztcbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICB0aGlzLmFkZChjaHVua3MpO1xuICAgIH1cbiAgfTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbihjaHVua3MpIHtcbiAgICAgIGlmIChpc0FycmF5KGNodW5rcykpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgdGhpcy5zcmMgKz0gY2h1bmtzO1xuICAgIH0sXG4gICAgcHJlcGVuZDogZnVuY3Rpb24oY2h1bmtzKSB7XG4gICAgICBpZiAoaXNBcnJheShjaHVua3MpKSB7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3JjID0gY2h1bmtzICsgdGhpcy5zcmM7XG4gICAgfSxcbiAgICB0b1N0cmluZ1dpdGhTb3VyY2VNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtjb2RlOiB0aGlzLnRvU3RyaW5nKCl9O1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3JjO1xuICAgIH1cbiAgfTtcbn1cblxuXG5mdW5jdGlvbiBjYXN0Q2h1bmsoY2h1bmssIGNvZGVHZW4sIGxvYykge1xuICBpZiAoaXNBcnJheShjaHVuaykpIHtcbiAgICBsZXQgcmV0ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKGNvZGVHZW4ud3JhcChjaHVua1tpXSwgbG9jKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGNodW5rID09PSAnbnVtYmVyJykge1xuICAgIC8vIEhhbmRsZSBwcmltaXRpdmVzIHRoYXQgdGhlIFNvdXJjZU5vZGUgd2lsbCB0aHJvdyB1cCBvblxuICAgIHJldHVybiBjaHVuayArICcnO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuXG5mdW5jdGlvbiBDb2RlR2VuKHNyY0ZpbGUpIHtcbiAgdGhpcy5zcmNGaWxlID0gc3JjRmlsZTtcbiAgdGhpcy5zb3VyY2UgPSBbXTtcbn1cblxuQ29kZUdlbi5wcm90b3R5cGUgPSB7XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNvdXJjZS5sZW5ndGg7XG4gIH0sXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKHNvdXJjZSwgbG9jKSB7XG4gICAgdGhpcy5zb3VyY2UudW5zaGlmdCh0aGlzLndyYXAoc291cmNlLCBsb2MpKTtcbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24oc291cmNlLCBsb2MpIHtcbiAgICB0aGlzLnNvdXJjZS5wdXNoKHRoaXMud3JhcChzb3VyY2UsIGxvYykpO1xuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbigpIHtcbiAgICBsZXQgc291cmNlID0gdGhpcy5lbXB0eSgpO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICBzb3VyY2UuYWRkKFsnICAnLCBsaW5lLCAnXFxuJ10pO1xuICAgIH0pO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG5cbiAgZWFjaDogZnVuY3Rpb24oaXRlcikge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlcih0aGlzLnNvdXJjZVtpXSk7XG4gICAgfVxuICB9LFxuXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICBsZXQgbG9jID0gdGhpcy5jdXJyZW50TG9jYXRpb24gfHwge3N0YXJ0OiB7fX07XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uLCB0aGlzLnNyY0ZpbGUpO1xuICB9LFxuICB3cmFwOiBmdW5jdGlvbihjaHVuaywgbG9jID0gdGhpcy5jdXJyZW50TG9jYXRpb24gfHwge3N0YXJ0OiB7fX0pIHtcbiAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuXG4gICAgY2h1bmsgPSBjYXN0Q2h1bmsoY2h1bmssIHRoaXMsIGxvYyk7XG5cbiAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4sIHRoaXMuc3JjRmlsZSwgY2h1bmspO1xuICB9LFxuXG4gIGZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24oZm4sIHR5cGUsIHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHRoaXMuZ2VuZXJhdGVMaXN0KHBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXMud3JhcChbZm4sIHR5cGUgPyAnLicgKyB0eXBlICsgJygnIDogJygnLCBwYXJhbXMsICcpJ10pO1xuICB9LFxuXG4gIHF1b3RlZFN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuICdcIicgKyAoc3RyICsgJycpXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpICAgLy8gUGVyIEVjbWEtMjYyIDcuMyArIDcuOC40XG4gICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5JykgKyAnXCInO1xuICB9LFxuXG4gIG9iamVjdExpdGVyYWw6IGZ1bmN0aW9uKG9iaikge1xuICAgIGxldCBwYWlycyA9IFtdO1xuXG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNhc3RDaHVuayhvYmpba2V5XSwgdGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKFt0aGlzLnF1b3RlZFN0cmluZyhrZXkpLCAnOicsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmV0ID0gdGhpcy5nZW5lcmF0ZUxpc3QocGFpcnMpO1xuICAgIHJldC5wcmVwZW5kKCd7Jyk7XG4gICAgcmV0LmFkZCgnfScpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cblxuICBnZW5lcmF0ZUxpc3Q6IGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICBsZXQgcmV0ID0gdGhpcy5lbXB0eSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIHJldC5hZGQoJywnKTtcbiAgICAgIH1cblxuICAgICAgcmV0LmFkZChjYXN0Q2h1bmsoZW50cmllc1tpXSwgdGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgZ2VuZXJhdGVBcnJheTogZnVuY3Rpb24oZW50cmllcykge1xuICAgIGxldCByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChlbnRyaWVzKTtcbiAgICByZXQucHJlcGVuZCgnWycpO1xuICAgIHJldC5hZGQoJ10nKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvZGVHZW47XG5cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cblxuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuaW1wb3J0IHtpc0FycmF5LCBpbmRleE9mLCBleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBBU1QgZnJvbSAnLi9hc3QnO1xuXG5jb25zdCBzbGljZSA9IFtdLnNsaWNlO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29tcGlsZXIoKSB7fVxuXG4vLyB0aGUgZm91bmRIZWxwZXIgcmVnaXN0ZXIgd2lsbCBkaXNhbWJpZ3VhdGUgaGVscGVyIGxvb2t1cCBmcm9tIGZpbmRpbmcgYVxuLy8gZnVuY3Rpb24gaW4gYSBjb250ZXh0LiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbXVzdGFjaGUgY29tcGF0aWJpbGl0eSwgd2hpY2hcbi8vIHJlcXVpcmVzIHRoYXQgY29udGV4dCBmdW5jdGlvbnMgaW4gYmxvY2tzIGFyZSBldmFsdWF0ZWQgYnkgYmxvY2tIZWxwZXJNaXNzaW5nLFxuLy8gYW5kIHRoZW4gcHJvY2VlZCBhcyBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIHdhcyBwcm92aWRlZCB0byBibG9ja0hlbHBlck1pc3NpbmcuXG5cbkNvbXBpbGVyLnByb3RvdHlwZSA9IHtcbiAgY29tcGlsZXI6IENvbXBpbGVyLFxuXG4gIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBsZXQgbGVuID0gdGhpcy5vcGNvZGVzLmxlbmd0aDtcbiAgICBpZiAob3RoZXIub3Bjb2Rlcy5sZW5ndGggIT09IGxlbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBvcGNvZGUgPSB0aGlzLm9wY29kZXNbaV0sXG4gICAgICAgICAgb3RoZXJPcGNvZGUgPSBvdGhlci5vcGNvZGVzW2ldO1xuICAgICAgaWYgKG9wY29kZS5vcGNvZGUgIT09IG90aGVyT3Bjb2RlLm9wY29kZSB8fCAhYXJnRXF1YWxzKG9wY29kZS5hcmdzLCBvdGhlck9wY29kZS5hcmdzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2Uga25vdyB0aGF0IGxlbmd0aCBpcyB0aGUgc2FtZSBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgdGllZFxuICAgIC8vIHRvIHRoZSBvcGNvZGUgYmVoYXZpb3IgYWJvdmUuXG4gICAgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuW2ldLmVxdWFscyhvdGhlci5jaGlsZHJlbltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGd1aWQ6IDAsXG5cbiAgY29tcGlsZTogZnVuY3Rpb24ocHJvZ3JhbSwgb3B0aW9ucykge1xuICAgIHRoaXMuc291cmNlTm9kZSA9IFtdO1xuICAgIHRoaXMub3Bjb2RlcyA9IFtdO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3RyaW5nUGFyYW1zID0gb3B0aW9ucy5zdHJpbmdQYXJhbXM7XG4gICAgdGhpcy50cmFja0lkcyA9IG9wdGlvbnMudHJhY2tJZHM7XG5cbiAgICBvcHRpb25zLmJsb2NrUGFyYW1zID0gb3B0aW9ucy5ibG9ja1BhcmFtcyB8fCBbXTtcblxuICAgIC8vIFRoZXNlIGNoYW5nZXMgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIG90aGVyIGNvbXBpbGVyIGNvbXBvbmVudHNcbiAgICBsZXQga25vd25IZWxwZXJzID0gb3B0aW9ucy5rbm93bkhlbHBlcnM7XG4gICAgb3B0aW9ucy5rbm93bkhlbHBlcnMgPSB7XG4gICAgICAnaGVscGVyTWlzc2luZyc6IHRydWUsXG4gICAgICAnYmxvY2tIZWxwZXJNaXNzaW5nJzogdHJ1ZSxcbiAgICAgICdlYWNoJzogdHJ1ZSxcbiAgICAgICdpZic6IHRydWUsXG4gICAgICAndW5sZXNzJzogdHJ1ZSxcbiAgICAgICd3aXRoJzogdHJ1ZSxcbiAgICAgICdsb2cnOiB0cnVlLFxuICAgICAgJ2xvb2t1cCc6IHRydWVcbiAgICB9O1xuICAgIGlmIChrbm93bkhlbHBlcnMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgaW4ga25vd25IZWxwZXJzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChuYW1lIGluIGtub3duSGVscGVycykge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNbbmFtZV0gPSBrbm93bkhlbHBlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hY2NlcHQocHJvZ3JhbSk7XG4gIH0sXG5cbiAgY29tcGlsZVByb2dyYW06IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgICBsZXQgY2hpbGRDb21waWxlciA9IG5ldyB0aGlzLmNvbXBpbGVyKCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICByZXN1bHQgPSBjaGlsZENvbXBpbGVyLmNvbXBpbGUocHJvZ3JhbSwgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgZ3VpZCA9IHRoaXMuZ3VpZCsrO1xuXG4gICAgdGhpcy51c2VQYXJ0aWFsID0gdGhpcy51c2VQYXJ0aWFsIHx8IHJlc3VsdC51c2VQYXJ0aWFsO1xuXG4gICAgdGhpcy5jaGlsZHJlbltndWlkXSA9IHJlc3VsdDtcbiAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IHJlc3VsdC51c2VEZXB0aHM7XG5cbiAgICByZXR1cm4gZ3VpZDtcbiAgfSxcblxuICBhY2NlcHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogU2FuaXR5IGNvZGUgKi9cbiAgICBpZiAoIXRoaXNbbm9kZS50eXBlXSkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5rbm93biB0eXBlOiAnICsgbm9kZS50eXBlLCBub2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZU5vZGUudW5zaGlmdChub2RlKTtcbiAgICBsZXQgcmV0ID0gdGhpc1tub2RlLnR5cGVdKG5vZGUpO1xuICAgIHRoaXMuc291cmNlTm9kZS5zaGlmdCgpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgUHJvZ3JhbTogZnVuY3Rpb24ocHJvZ3JhbSkge1xuICAgIHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtcy51bnNoaWZ0KHByb2dyYW0uYmxvY2tQYXJhbXMpO1xuXG4gICAgbGV0IGJvZHkgPSBwcm9ncmFtLmJvZHksXG4gICAgICAgIGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHlMZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHQoYm9keVtpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLnNoaWZ0KCk7XG5cbiAgICB0aGlzLmlzU2ltcGxlID0gYm9keUxlbmd0aCA9PT0gMTtcbiAgICB0aGlzLmJsb2NrUGFyYW1zID0gcHJvZ3JhbS5ibG9ja1BhcmFtcyA/IHByb2dyYW0uYmxvY2tQYXJhbXMubGVuZ3RoIDogMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbihibG9jaykge1xuICAgIHRyYW5zZm9ybUxpdGVyYWxUb1BhdGgoYmxvY2spO1xuXG4gICAgbGV0IHByb2dyYW0gPSBibG9jay5wcm9ncmFtLFxuICAgICAgICBpbnZlcnNlID0gYmxvY2suaW52ZXJzZTtcblxuICAgIHByb2dyYW0gPSBwcm9ncmFtICYmIHRoaXMuY29tcGlsZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgaW52ZXJzZSA9IGludmVyc2UgJiYgdGhpcy5jb21waWxlUHJvZ3JhbShpbnZlcnNlKTtcblxuICAgIGxldCB0eXBlID0gdGhpcy5jbGFzc2lmeVNleHByKGJsb2NrKTtcblxuICAgIGlmICh0eXBlID09PSAnaGVscGVyJykge1xuICAgICAgdGhpcy5oZWxwZXJTZXhwcihibG9jaywgcHJvZ3JhbSwgaW52ZXJzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc2ltcGxlJykge1xuICAgICAgdGhpcy5zaW1wbGVTZXhwcihibG9jayk7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdibG9ja1ZhbHVlJywgYmxvY2sucGF0aC5vcmlnaW5hbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW1iaWd1b3VzU2V4cHIoYmxvY2ssIHByb2dyYW0sIGludmVyc2UpO1xuXG4gICAgICAvLyBub3cgdGhhdCB0aGUgc2ltcGxlIG11c3RhY2hlIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvXG4gICAgICAvLyBldmFsdWF0ZSBpdCBieSBleGVjdXRpbmcgYGJsb2NrSGVscGVyTWlzc2luZ2BcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XG4gICAgICB0aGlzLm9wY29kZSgnZW1wdHlIYXNoJyk7XG4gICAgICB0aGlzLm9wY29kZSgnYW1iaWd1b3VzQmxvY2tWYWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKCdhcHBlbmQnKTtcbiAgfSxcblxuICBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3IpIHtcbiAgICBsZXQgcHJvZ3JhbSA9IGRlY29yYXRvci5wcm9ncmFtICYmIHRoaXMuY29tcGlsZVByb2dyYW0oZGVjb3JhdG9yLnByb2dyYW0pO1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKGRlY29yYXRvciwgcHJvZ3JhbSwgdW5kZWZpbmVkKSxcbiAgICAgICAgcGF0aCA9IGRlY29yYXRvci5wYXRoO1xuXG4gICAgdGhpcy51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcbiAgICB0aGlzLm9wY29kZSgncmVnaXN0ZXJEZWNvcmF0b3InLCBwYXJhbXMubGVuZ3RoLCBwYXRoLm9yaWdpbmFsKTtcbiAgfSxcblxuICBQYXJ0aWFsU3RhdGVtZW50OiBmdW5jdGlvbihwYXJ0aWFsKSB7XG4gICAgdGhpcy51c2VQYXJ0aWFsID0gdHJ1ZTtcblxuICAgIGxldCBwcm9ncmFtID0gcGFydGlhbC5wcm9ncmFtO1xuICAgIGlmIChwcm9ncmFtKSB7XG4gICAgICBwcm9ncmFtID0gdGhpcy5jb21waWxlUHJvZ3JhbShwYXJ0aWFsLnByb2dyYW0pO1xuICAgIH1cblxuICAgIGxldCBwYXJhbXMgPSBwYXJ0aWFsLnBhcmFtcztcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIG51bWJlciBvZiBwYXJ0aWFsIGFyZ3VtZW50czogJyArIHBhcmFtcy5sZW5ndGgsIHBhcnRpYWwpO1xuICAgIH0gZWxzZSBpZiAoIXBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwbGljaXRQYXJ0aWFsQ29udGV4dCkge1xuICAgICAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaCh7dHlwZTogJ1BhdGhFeHByZXNzaW9uJywgcGFydHM6IFtdLCBkZXB0aDogMH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwYXJ0aWFsTmFtZSA9IHBhcnRpYWwubmFtZS5vcmlnaW5hbCxcbiAgICAgICAgaXNEeW5hbWljID0gcGFydGlhbC5uYW1lLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJztcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICB0aGlzLmFjY2VwdChwYXJ0aWFsLm5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMocGFydGlhbCwgcHJvZ3JhbSwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIGxldCBpbmRlbnQgPSBwYXJ0aWFsLmluZGVudCB8fCAnJztcbiAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRJbmRlbnQgJiYgaW5kZW50KSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kQ29udGVudCcsIGluZGVudCk7XG4gICAgICBpbmRlbnQgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZSgnaW52b2tlUGFydGlhbCcsIGlzRHluYW1pYywgcGFydGlhbE5hbWUsIGluZGVudCk7XG4gICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xuICB9LFxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHBhcnRpYWxCbG9jaykge1xuICAgIHRoaXMuUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsQmxvY2spO1xuICB9LFxuXG4gIE11c3RhY2hlU3RhdGVtZW50OiBmdW5jdGlvbihtdXN0YWNoZSkge1xuICAgIHRoaXMuU3ViRXhwcmVzc2lvbihtdXN0YWNoZSk7XG5cbiAgICBpZiAobXVzdGFjaGUuZXNjYXBlZCAmJiAhdGhpcy5vcHRpb25zLm5vRXNjYXBlKSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kRXNjYXBlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gICAgfVxuICB9LFxuICBEZWNvcmF0b3IoZGVjb3JhdG9yKSB7XG4gICAgdGhpcy5EZWNvcmF0b3JCbG9jayhkZWNvcmF0b3IpO1xuICB9LFxuXG5cbiAgQ29udGVudFN0YXRlbWVudDogZnVuY3Rpb24oY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnZhbHVlKSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kQ29udGVudCcsIGNvbnRlbnQudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBDb21tZW50U3RhdGVtZW50OiBmdW5jdGlvbigpIHt9LFxuXG4gIFN1YkV4cHJlc3Npb246IGZ1bmN0aW9uKHNleHByKSB7XG4gICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChzZXhwcik7XG4gICAgbGV0IHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoc2V4cHIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XG4gICAgICB0aGlzLnNpbXBsZVNleHByKHNleHByKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XG4gICAgICB0aGlzLmhlbHBlclNleHByKHNleHByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihzZXhwcik7XG4gICAgfVxuICB9LFxuICBhbWJpZ3VvdXNTZXhwcjogZnVuY3Rpb24oc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcbiAgICBsZXQgcGF0aCA9IHNleHByLnBhdGgsXG4gICAgICAgIG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxuICAgICAgICBpc0Jsb2NrID0gcHJvZ3JhbSAhPSBudWxsIHx8IGludmVyc2UgIT0gbnVsbDtcblxuICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgcGF0aC5kZXB0aCk7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcblxuICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmFjY2VwdChwYXRoKTtcblxuICAgIHRoaXMub3Bjb2RlKCdpbnZva2VBbWJpZ3VvdXMnLCBuYW1lLCBpc0Jsb2NrKTtcbiAgfSxcblxuICBzaW1wbGVTZXhwcjogZnVuY3Rpb24oc2V4cHIpIHtcbiAgICBsZXQgcGF0aCA9IHNleHByLnBhdGg7XG4gICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xuICAgIHRoaXMub3Bjb2RlKCdyZXNvbHZlUG9zc2libGVMYW1iZGEnKTtcbiAgfSxcblxuICBoZWxwZXJTZXhwcjogZnVuY3Rpb24oc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSksXG4gICAgICAgIHBhdGggPSBzZXhwci5wYXRoLFxuICAgICAgICBuYW1lID0gcGF0aC5wYXJ0c1swXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLm9wY29kZSgnaW52b2tlS25vd25IZWxwZXInLCBwYXJhbXMubGVuZ3RoLCBuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdZb3Ugc3BlY2lmaWVkIGtub3duSGVscGVyc09ubHksIGJ1dCB1c2VkIHRoZSB1bmtub3duIGhlbHBlciAnICsgbmFtZSwgc2V4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLnN0cmljdCA9IHRydWU7XG4gICAgICBwYXRoLmZhbHN5ID0gdHJ1ZTtcblxuICAgICAgdGhpcy5hY2NlcHQocGF0aCk7XG4gICAgICB0aGlzLm9wY29kZSgnaW52b2tlSGVscGVyJywgcGFyYW1zLmxlbmd0aCwgcGF0aC5vcmlnaW5hbCwgQVNULmhlbHBlcnMuc2ltcGxlSWQocGF0aCkpO1xuICAgIH1cbiAgfSxcblxuICBQYXRoRXhwcmVzc2lvbjogZnVuY3Rpb24ocGF0aCkge1xuICAgIHRoaXMuYWRkRGVwdGgocGF0aC5kZXB0aCk7XG4gICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBwYXRoLmRlcHRoKTtcblxuICAgIGxldCBuYW1lID0gcGF0aC5wYXJ0c1swXSxcbiAgICAgICAgc2NvcGVkID0gQVNULmhlbHBlcnMuc2NvcGVkSWQocGF0aCksXG4gICAgICAgIGJsb2NrUGFyYW1JZCA9ICFwYXRoLmRlcHRoICYmICFzY29wZWQgJiYgdGhpcy5ibG9ja1BhcmFtSW5kZXgobmFtZSk7XG5cbiAgICBpZiAoYmxvY2tQYXJhbUlkKSB7XG4gICAgICB0aGlzLm9wY29kZSgnbG9va3VwQmxvY2tQYXJhbScsIGJsb2NrUGFyYW1JZCwgcGF0aC5wYXJ0cyk7XG4gICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgLy8gQ29udGV4dCByZWZlcmVuY2UsIGkuZS4gYHt7Zm9vIC59fWAgb3IgYHt7Zm9vIC4ufX1gXG4gICAgICB0aGlzLm9wY29kZSgncHVzaENvbnRleHQnKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguZGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSB0cnVlO1xuICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cERhdGEnLCBwYXRoLmRlcHRoLCBwYXRoLnBhcnRzLCBwYXRoLnN0cmljdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBPbkNvbnRleHQnLCBwYXRoLnBhcnRzLCBwYXRoLmZhbHN5LCBwYXRoLnN0cmljdCwgc2NvcGVkKTtcbiAgICB9XG4gIH0sXG5cbiAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hTdHJpbmcnLCBzdHJpbmcudmFsdWUpO1xuICB9LFxuXG4gIE51bWJlckxpdGVyYWw6IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsIG51bWJlci52YWx1ZSk7XG4gIH0sXG5cbiAgQm9vbGVhbkxpdGVyYWw6IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBib29sLnZhbHVlKTtcbiAgfSxcblxuICBVbmRlZmluZWRMaXRlcmFsOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XG4gIH0sXG5cbiAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICdudWxsJyk7XG4gIH0sXG5cbiAgSGFzaDogZnVuY3Rpb24oaGFzaCkge1xuICAgIGxldCBwYWlycyA9IGhhc2gucGFpcnMsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBsID0gcGFpcnMubGVuZ3RoO1xuXG4gICAgdGhpcy5vcGNvZGUoJ3B1c2hIYXNoJyk7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wdXNoUGFyYW0ocGFpcnNbaV0udmFsdWUpO1xuICAgIH1cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXNzaWduVG9IYXNoJywgcGFpcnNbaV0ua2V5KTtcbiAgICB9XG4gICAgdGhpcy5vcGNvZGUoJ3BvcEhhc2gnKTtcbiAgfSxcblxuICAvLyBIRUxQRVJTXG4gIG9wY29kZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXMub3Bjb2Rlcy5wdXNoKHsgb3Bjb2RlOiBuYW1lLCBhcmdzOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGxvYzogdGhpcy5zb3VyY2VOb2RlWzBdLmxvYyB9KTtcbiAgfSxcblxuICBhZGREZXB0aDogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICBpZiAoIWRlcHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy51c2VEZXB0aHMgPSB0cnVlO1xuICB9LFxuXG4gIGNsYXNzaWZ5U2V4cHI6IGZ1bmN0aW9uKHNleHByKSB7XG4gICAgbGV0IGlzU2ltcGxlID0gQVNULmhlbHBlcnMuc2ltcGxlSWQoc2V4cHIucGF0aCk7XG5cbiAgICBsZXQgaXNCbG9ja1BhcmFtID0gaXNTaW1wbGUgJiYgISF0aGlzLmJsb2NrUGFyYW1JbmRleChzZXhwci5wYXRoLnBhcnRzWzBdKTtcblxuICAgIC8vIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGlmOlxuICAgIC8vICogaXRzIGlkIGlzIHNpbXBsZSAoYSBzaW5nbGUgcGFydCwgbm90IGB0aGlzYCBvciBgLi5gKVxuICAgIGxldCBpc0hlbHBlciA9ICFpc0Jsb2NrUGFyYW0gJiYgQVNULmhlbHBlcnMuaGVscGVyRXhwcmVzc2lvbihzZXhwcik7XG5cbiAgICAvLyBpZiBhIG11c3RhY2hlIGlzIGFuIGVsaWdpYmxlIGhlbHBlciBidXQgbm90IGEgZGVmaW5pdGVcbiAgICAvLyBoZWxwZXIsIGl0IGlzIGFtYmlndW91cywgYW5kIHdpbGwgYmUgcmVzb2x2ZWQgaW4gYSBsYXRlclxuICAgIC8vIHBhc3Mgb3IgYXQgcnVudGltZS5cbiAgICBsZXQgaXNFbGlnaWJsZSA9ICFpc0Jsb2NrUGFyYW0gJiYgKGlzSGVscGVyIHx8IGlzU2ltcGxlKTtcblxuICAgIC8vIGlmIGFtYmlndW91cywgd2UgY2FuIHBvc3NpYmx5IHJlc29sdmUgdGhlIGFtYmlndWl0eSBub3dcbiAgICAvLyBBbiBlbGlnaWJsZSBoZWxwZXIgaXMgb25lIHRoYXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXggcGF0aCwgaS5lLiBgdGhpcy5mb29gLCBgLi4vZm9vYCBldGMuXG4gICAgaWYgKGlzRWxpZ2libGUgJiYgIWlzSGVscGVyKSB7XG4gICAgICBsZXQgbmFtZSA9IHNleHByLnBhdGgucGFydHNbMF0sXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgaWYgKG9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdKSB7XG4gICAgICAgIGlzSGVscGVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XG4gICAgICAgIGlzRWxpZ2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNIZWxwZXIpIHtcbiAgICAgIHJldHVybiAnaGVscGVyJztcbiAgICB9IGVsc2UgaWYgKGlzRWxpZ2libGUpIHtcbiAgICAgIHJldHVybiAnYW1iaWd1b3VzJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdzaW1wbGUnO1xuICAgIH1cbiAgfSxcblxuICBwdXNoUGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHVzaFBhcmFtKHBhcmFtc1tpXSk7XG4gICAgfVxuICB9LFxuXG4gIHB1c2hQYXJhbTogZnVuY3Rpb24odmFsKSB7XG4gICAgbGV0IHZhbHVlID0gdmFsLnZhbHVlICE9IG51bGwgPyB2YWwudmFsdWUgOiB2YWwub3JpZ2luYWwgfHwgJyc7XG5cbiAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKFxcLj9cXC5cXC8pKi9nLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJy4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbC5kZXB0aCkge1xuICAgICAgICB0aGlzLmFkZERlcHRoKHZhbC5kZXB0aCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHZhbC5kZXB0aCB8fCAwKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoU3RyaW5nUGFyYW0nLCB2YWx1ZSwgdmFsLnR5cGUpO1xuXG4gICAgICBpZiAodmFsLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJykge1xuICAgICAgICAvLyBTdWJFeHByZXNzaW9ucyBnZXQgZXZhbHVhdGVkIGFuZCBwYXNzZWQgaW5cbiAgICAgICAgLy8gaW4gc3RyaW5nIHBhcmFtcyBtb2RlLlxuICAgICAgICB0aGlzLmFjY2VwdCh2YWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgICBsZXQgYmxvY2tQYXJhbUluZGV4O1xuICAgICAgICBpZiAodmFsLnBhcnRzICYmICFBU1QuaGVscGVycy5zY29wZWRJZCh2YWwpICYmICF2YWwuZGVwdGgpIHtcbiAgICAgICAgICAgYmxvY2tQYXJhbUluZGV4ID0gdGhpcy5ibG9ja1BhcmFtSW5kZXgodmFsLnBhcnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tQYXJhbUluZGV4KSB7XG4gICAgICAgICAgbGV0IGJsb2NrUGFyYW1DaGlsZCA9IHZhbC5wYXJ0cy5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hJZCcsICdCbG9ja1BhcmFtJywgYmxvY2tQYXJhbUluZGV4LCBibG9ja1BhcmFtQ2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gdmFsLm9yaWdpbmFsIHx8IHZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL150aGlzKD86XFwufCQpLywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXC5cXC8vLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcLiQvLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hJZCcsIHZhbC50eXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWNjZXB0KHZhbCk7XG4gICAgfVxuICB9LFxuXG4gIHNldHVwRnVsbE11c3RhY2hlUGFyYW1zOiBmdW5jdGlvbihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSwgb21pdEVtcHR5KSB7XG4gICAgbGV0IHBhcmFtcyA9IHNleHByLnBhcmFtcztcbiAgICB0aGlzLnB1c2hQYXJhbXMocGFyYW1zKTtcblxuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuXG4gICAgaWYgKHNleHByLmhhc2gpIHtcbiAgICAgIHRoaXMuYWNjZXB0KHNleHByLmhhc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnZW1wdHlIYXNoJywgb21pdEVtcHR5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9LFxuXG4gIGJsb2NrUGFyYW1JbmRleDogZnVuY3Rpb24obmFtZSkge1xuICAgIGZvciAobGV0IGRlcHRoID0gMCwgbGVuID0gdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLmxlbmd0aDsgZGVwdGggPCBsZW47IGRlcHRoKyspIHtcbiAgICAgIGxldCBibG9ja1BhcmFtcyA9IHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtc1tkZXB0aF0sXG4gICAgICAgICAgcGFyYW0gPSBibG9ja1BhcmFtcyAmJiBpbmRleE9mKGJsb2NrUGFyYW1zLCBuYW1lKTtcbiAgICAgIGlmIChibG9ja1BhcmFtcyAmJiBwYXJhbSA+PSAwKSB7XG4gICAgICAgIHJldHVybiBbZGVwdGgsIHBhcmFtXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVjb21waWxlKGlucHV0LCBvcHRpb25zLCBlbnYpIHtcbiAgaWYgKGlucHV0ID09IG51bGwgfHwgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZSAhPT0gJ1Byb2dyYW0nKSkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1lvdSBtdXN0IHBhc3MgYSBzdHJpbmcgb3IgSGFuZGxlYmFycyBBU1QgdG8gSGFuZGxlYmFycy5wcmVjb21waWxlLiBZb3UgcGFzc2VkICcgKyBpbnB1dCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb21wYXQpIHtcbiAgICBvcHRpb25zLnVzZURlcHRocyA9IHRydWU7XG4gIH1cblxuICBsZXQgYXN0ID0gZW52LnBhcnNlKGlucHV0LCBvcHRpb25zKSxcbiAgICAgIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBlbnYuSmF2YVNjcmlwdENvbXBpbGVyKCkuY29tcGlsZShlbnZpcm9ubWVudCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlKGlucHV0LCBvcHRpb25zID0ge30sIGVudikge1xuICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlICE9PSAnUHJvZ3JhbScpKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignWW91IG11c3QgcGFzcyBhIHN0cmluZyBvciBIYW5kbGViYXJzIEFTVCB0byBIYW5kbGViYXJzLmNvbXBpbGUuIFlvdSBwYXNzZWQgJyArIGlucHV0KTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICBpZiAoISgnZGF0YScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRhdGEgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRpb25zLmNvbXBhdCkge1xuICAgIG9wdGlvbnMudXNlRGVwdGhzID0gdHJ1ZTtcbiAgfVxuXG4gIGxldCBjb21waWxlZDtcblxuICBmdW5jdGlvbiBjb21waWxlSW5wdXQoKSB7XG4gICAgbGV0IGFzdCA9IGVudi5wYXJzZShpbnB1dCwgb3B0aW9ucyksXG4gICAgICAgIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKSxcbiAgICAgICAgdGVtcGxhdGVTcGVjID0gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiBlbnYudGVtcGxhdGUodGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIC8vIFRlbXBsYXRlIGlzIG9ubHkgY29tcGlsZWQgb24gZmlyc3QgdXNlIGFuZCBjYWNoZWQgYWZ0ZXIgdGhhdCBwb2ludC5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIGV4ZWNPcHRpb25zKSB7XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBpbGVkLmNhbGwodGhpcywgY29udGV4dCwgZXhlY09wdGlvbnMpO1xuICB9XG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihzZXR1cE9wdGlvbnMpIHtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWQuX3NldHVwKHNldHVwT3B0aW9ucyk7XG4gIH07XG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBpbGVkLl9jaGlsZChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gYXJnRXF1YWxzKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KGEpICYmIGlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWFyZ0VxdWFscyhhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxpdGVyYWxUb1BhdGgoc2V4cHIpIHtcbiAgaWYgKCFzZXhwci5wYXRoLnBhcnRzKSB7XG4gICAgbGV0IGxpdGVyYWwgPSBzZXhwci5wYXRoO1xuICAgIC8vIENhc3RpbmcgdG8gc3RyaW5nIGhlcmUgdG8gbWFrZSBmYWxzZSBhbmQgMCBsaXRlcmFsIHZhbHVlcyBwbGF5IG5pY2VseSB3aXRoIHRoZSByZXN0XG4gICAgLy8gb2YgdGhlIHN5c3RlbS5cbiAgICBzZXhwci5wYXRoID0ge1xuICAgICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcbiAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgZGVwdGg6IDAsXG4gICAgICBwYXJ0czogW2xpdGVyYWwub3JpZ2luYWwgKyAnJ10sXG4gICAgICBvcmlnaW5hbDogbGl0ZXJhbC5vcmlnaW5hbCArICcnLFxuICAgICAgbG9jOiBsaXRlcmFsLmxvY1xuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZnVuY3Rpb24gdmFsaWRhdGVDbG9zZShvcGVuLCBjbG9zZSkge1xuICBjbG9zZSA9IGNsb3NlLnBhdGggPyBjbG9zZS5wYXRoLm9yaWdpbmFsIDogY2xvc2U7XG5cbiAgaWYgKG9wZW4ucGF0aC5vcmlnaW5hbCAhPT0gY2xvc2UpIHtcbiAgICBsZXQgZXJyb3JOb2RlID0ge2xvYzogb3Blbi5wYXRoLmxvY307XG5cbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKG9wZW4ucGF0aC5vcmlnaW5hbCArIFwiIGRvZXNuJ3QgbWF0Y2ggXCIgKyBjbG9zZSwgZXJyb3JOb2RlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oc291cmNlLCBsb2NJbmZvKSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnN0YXJ0ID0ge1xuICAgIGxpbmU6IGxvY0luZm8uZmlyc3RfbGluZSxcbiAgICBjb2x1bW46IGxvY0luZm8uZmlyc3RfY29sdW1uXG4gIH07XG4gIHRoaXMuZW5kID0ge1xuICAgIGxpbmU6IGxvY0luZm8ubGFzdF9saW5lLFxuICAgIGNvbHVtbjogbG9jSW5mby5sYXN0X2NvbHVtblxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaWQodG9rZW4pIHtcbiAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KHRva2VuKSkge1xuICAgIHJldHVybiB0b2tlbi5zdWJzdHIoMSwgdG9rZW4ubGVuZ3RoIC0gMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEZsYWdzKG9wZW4sIGNsb3NlKSB7XG4gIHJldHVybiB7XG4gICAgb3Blbjogb3Blbi5jaGFyQXQoMikgPT09ICd+JyxcbiAgICBjbG9zZTogY2xvc2UuY2hhckF0KGNsb3NlLmxlbmd0aCAtIDMpID09PSAnfidcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwQ29tbWVudChjb21tZW50KSB7XG4gIHJldHVybiBjb21tZW50LnJlcGxhY2UoL15cXHtcXHt+P1xcIS0/LT8vLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvLT8tP34/XFx9XFx9JC8sICcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXRoKGRhdGEsIHBhcnRzLCBsb2MpIHtcbiAgbG9jID0gdGhpcy5sb2NJbmZvKGxvYyk7XG5cbiAgbGV0IG9yaWdpbmFsID0gZGF0YSA/ICdAJyA6ICcnLFxuICAgICAgZGlnID0gW10sXG4gICAgICBkZXB0aCA9IDAsXG4gICAgICBkZXB0aFN0cmluZyA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBwYXJ0c1tpXS5wYXJ0LFxuICAgICAgICAvLyBJZiB3ZSBoYXZlIFtdIHN5bnRheCB0aGVuIHdlIGRvIG5vdCB0cmVhdCBwYXRoIHJlZmVyZW5jZXMgYXMgb3BlcmF0b3JzLFxuICAgICAgICAvLyBpLmUuIGZvby5bdGhpc10gcmVzb2x2ZXMgdG8gYXBwcm94aW1hdGVseSBjb250ZXh0LmZvb1sndGhpcyddXG4gICAgICAgIGlzTGl0ZXJhbCA9IHBhcnRzW2ldLm9yaWdpbmFsICE9PSBwYXJ0O1xuICAgIG9yaWdpbmFsICs9IChwYXJ0c1tpXS5zZXBhcmF0b3IgfHwgJycpICsgcGFydDtcblxuICAgIGlmICghaXNMaXRlcmFsICYmIChwYXJ0ID09PSAnLi4nIHx8IHBhcnQgPT09ICcuJyB8fCBwYXJ0ID09PSAndGhpcycpKSB7XG4gICAgICBpZiAoZGlnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignSW52YWxpZCBwYXRoOiAnICsgb3JpZ2luYWwsIHtsb2N9KTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBkZXB0aFN0cmluZyArPSAnLi4vJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlnLnB1c2gocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLFxuICAgIGRhdGEsXG4gICAgZGVwdGgsXG4gICAgcGFydHM6IGRpZyxcbiAgICBvcmlnaW5hbCxcbiAgICBsb2NcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVNdXN0YWNoZShwYXRoLCBwYXJhbXMsIGhhc2gsIG9wZW4sIHN0cmlwLCBsb2NJbmZvKSB7XG4gIC8vIE11c3QgdXNlIGNoYXJBdCB0byBzdXBwb3J0IElFIHByZS0xMFxuICBsZXQgZXNjYXBlRmxhZyA9IG9wZW4uY2hhckF0KDMpIHx8IG9wZW4uY2hhckF0KDIpLFxuICAgICAgZXNjYXBlZCA9IGVzY2FwZUZsYWcgIT09ICd7JyAmJiBlc2NhcGVGbGFnICE9PSAnJic7XG5cbiAgbGV0IGRlY29yYXRvciA9ICgvXFwqLy50ZXN0KG9wZW4pKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yJyA6ICdNdXN0YWNoZVN0YXRlbWVudCcsXG4gICAgcGF0aCxcbiAgICBwYXJhbXMsXG4gICAgaGFzaCxcbiAgICBlc2NhcGVkLFxuICAgIHN0cmlwLFxuICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUmF3QmxvY2sob3BlblJhd0Jsb2NrLCBjb250ZW50cywgY2xvc2UsIGxvY0luZm8pIHtcbiAgdmFsaWRhdGVDbG9zZShvcGVuUmF3QmxvY2ssIGNsb3NlKTtcblxuICBsb2NJbmZvID0gdGhpcy5sb2NJbmZvKGxvY0luZm8pO1xuICBsZXQgcHJvZ3JhbSA9IHtcbiAgICB0eXBlOiAnUHJvZ3JhbScsXG4gICAgYm9keTogY29udGVudHMsXG4gICAgc3RyaXA6IHt9LFxuICAgIGxvYzogbG9jSW5mb1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICBwYXRoOiBvcGVuUmF3QmxvY2sucGF0aCxcbiAgICBwYXJhbXM6IG9wZW5SYXdCbG9jay5wYXJhbXMsXG4gICAgaGFzaDogb3BlblJhd0Jsb2NrLmhhc2gsXG4gICAgcHJvZ3JhbSxcbiAgICBvcGVuU3RyaXA6IHt9LFxuICAgIGludmVyc2VTdHJpcDoge30sXG4gICAgY2xvc2VTdHJpcDoge30sXG4gICAgbG9jOiBsb2NJbmZvXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQmxvY2sob3BlbkJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlQW5kUHJvZ3JhbSwgY2xvc2UsIGludmVydGVkLCBsb2NJbmZvKSB7XG4gIGlmIChjbG9zZSAmJiBjbG9zZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDbG9zZShvcGVuQmxvY2ssIGNsb3NlKTtcbiAgfVxuXG4gIGxldCBkZWNvcmF0b3IgPSAoL1xcKi8udGVzdChvcGVuQmxvY2sub3BlbikpO1xuXG4gIHByb2dyYW0uYmxvY2tQYXJhbXMgPSBvcGVuQmxvY2suYmxvY2tQYXJhbXM7XG5cbiAgbGV0IGludmVyc2UsXG4gICAgICBpbnZlcnNlU3RyaXA7XG5cbiAgaWYgKGludmVyc2VBbmRQcm9ncmFtKSB7XG4gICAgaWYgKGRlY29yYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5leHBlY3RlZCBpbnZlcnNlIGJsb2NrIG9uIGRlY29yYXRvcicsIGludmVyc2VBbmRQcm9ncmFtKTtcbiAgICB9XG5cbiAgICBpZiAoaW52ZXJzZUFuZFByb2dyYW0uY2hhaW4pIHtcbiAgICAgIGludmVyc2VBbmRQcm9ncmFtLnByb2dyYW0uYm9keVswXS5jbG9zZVN0cmlwID0gY2xvc2Uuc3RyaXA7XG4gICAgfVxuXG4gICAgaW52ZXJzZVN0cmlwID0gaW52ZXJzZUFuZFByb2dyYW0uc3RyaXA7XG4gICAgaW52ZXJzZSA9IGludmVyc2VBbmRQcm9ncmFtLnByb2dyYW07XG4gIH1cblxuICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICBpbnZlcnRlZCA9IGludmVyc2U7XG4gICAgaW52ZXJzZSA9IHByb2dyYW07XG4gICAgcHJvZ3JhbSA9IGludmVydGVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yQmxvY2snIDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICBwYXRoOiBvcGVuQmxvY2sucGF0aCxcbiAgICBwYXJhbXM6IG9wZW5CbG9jay5wYXJhbXMsXG4gICAgaGFzaDogb3BlbkJsb2NrLmhhc2gsXG4gICAgcHJvZ3JhbSxcbiAgICBpbnZlcnNlLFxuICAgIG9wZW5TdHJpcDogb3BlbkJsb2NrLnN0cmlwLFxuICAgIGludmVyc2VTdHJpcCxcbiAgICBjbG9zZVN0cmlwOiBjbG9zZSAmJiBjbG9zZS5zdHJpcCxcbiAgICBsb2M6IHRoaXMubG9jSW5mbyhsb2NJbmZvKVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVByb2dyYW0oc3RhdGVtZW50cywgbG9jKSB7XG4gIGlmICghbG9jICYmIHN0YXRlbWVudHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlyc3RMb2MgPSBzdGF0ZW1lbnRzWzBdLmxvYyxcbiAgICAgICAgICBsYXN0TG9jID0gc3RhdGVtZW50c1tzdGF0ZW1lbnRzLmxlbmd0aCAtIDFdLmxvYztcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGZpcnN0TG9jICYmIGxhc3RMb2MpIHtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgc291cmNlOiBmaXJzdExvYy5zb3VyY2UsXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogZmlyc3RMb2Muc3RhcnQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGZpcnN0TG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBsaW5lOiBsYXN0TG9jLmVuZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogbGFzdExvYy5lbmQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUHJvZ3JhbScsXG4gICAgYm9keTogc3RhdGVtZW50cyxcbiAgICBzdHJpcDoge30sXG4gICAgbG9jOiBsb2NcbiAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBhcnRpYWxCbG9jayhvcGVuLCBwcm9ncmFtLCBjbG9zZSwgbG9jSW5mbykge1xuICB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQnLFxuICAgIG5hbWU6IG9wZW4ucGF0aCxcbiAgICBwYXJhbXM6IG9wZW4ucGFyYW1zLFxuICAgIGhhc2g6IG9wZW4uaGFzaCxcbiAgICBwcm9ncmFtLFxuICAgIG9wZW5TdHJpcDogb3Blbi5zdHJpcCxcbiAgICBjbG9zZVN0cmlwOiBjbG9zZSAmJiBjbG9zZS5zdHJpcCxcbiAgICBsb2M6IHRoaXMubG9jSW5mbyhsb2NJbmZvKVxuICB9O1xufVxuXG4iLCJpbXBvcnQgeyBDT01QSUxFUl9SRVZJU0lPTiwgUkVWSVNJT05fQ0hBTkdFUyB9IGZyb20gJy4uL2Jhc2UnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgQ29kZUdlbiBmcm9tICcuL2NvZGUtZ2VuJztcblxuZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEphdmFTY3JpcHRDb21waWxlcigpIHt9XG5cbkphdmFTY3JpcHRDb21waWxlci5wcm90b3R5cGUgPSB7XG4gIC8vIFBVQkxJQyBBUEk6IFlvdSBjYW4gb3ZlcnJpZGUgdGhlc2UgbWV0aG9kcyBpbiBhIHN1YmNsYXNzIHRvIHByb3ZpZGVcbiAgLy8gYWx0ZXJuYXRpdmUgY29tcGlsZWQgZm9ybXMgZm9yIG5hbWUgbG9va3VwIGFuZCBidWZmZXJpbmcgc2VtYW50aWNzXG4gIG5hbWVMb29rdXA6IGZ1bmN0aW9uKHBhcmVudCwgbmFtZS8qICwgdHlwZSovKSB7XG4gICAgaWYgKEphdmFTY3JpcHRDb21waWxlci5pc1ZhbGlkSmF2YVNjcmlwdFZhcmlhYmxlTmFtZShuYW1lKSkge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsICcuJywgbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbcGFyZW50LCAnWycsIEpTT04uc3RyaW5naWZ5KG5hbWUpLCAnXSddO1xuICAgIH1cbiAgfSxcbiAgZGVwdGhlZExvb2t1cDogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBbdGhpcy5hbGlhc2FibGUoJ2NvbnRhaW5lci5sb29rdXAnKSwgJyhkZXB0aHMsIFwiJywgbmFtZSwgJ1wiKSddO1xuICB9LFxuXG4gIGNvbXBpbGVySW5mbzogZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgcmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTixcbiAgICAgICAgICB2ZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbcmV2aXNpb25dO1xuICAgIHJldHVybiBbcmV2aXNpb24sIHZlcnNpb25zXTtcbiAgfSxcblxuICBhcHBlbmRUb0J1ZmZlcjogZnVuY3Rpb24oc291cmNlLCBsb2NhdGlvbiwgZXhwbGljaXQpIHtcbiAgICAvLyBGb3JjZSBhIHNvdXJjZSBhcyB0aGlzIHNpbXBsaWZpZXMgdGhlIG1lcmdlIGxvZ2ljLlxuICAgIGlmICghaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5zb3VyY2Uud3JhcChzb3VyY2UsIGxvY2F0aW9uKTtcblxuICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XG4gICAgICByZXR1cm4gWydyZXR1cm4gJywgc291cmNlLCAnOyddO1xuICAgIH0gZWxzZSBpZiAoZXhwbGljaXQpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgb3BlcmF0aW9uIG9jY3VycyBhcyBhIGNoaWxkIG9mIGFub3RoZXJcbiAgICAgIC8vIGNvbnN0cnVjdCwgZ2VuZXJhbGx5IGJyYWNlcy4gV2UgaGF2ZSB0byBleHBsaWNpdGx5IG91dHB1dCB0aGVzZSBidWZmZXJcbiAgICAgIC8vIG9wZXJhdGlvbnMgdG8gZW5zdXJlIHRoYXQgdGhlIGVtaXR0ZWQgY29kZSBnb2VzIGluIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgICAgcmV0dXJuIFsnYnVmZmVyICs9ICcsIHNvdXJjZSwgJzsnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlLmFwcGVuZFRvQnVmZmVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICB9LFxuXG4gIGluaXRpYWxpemVCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1b3RlZFN0cmluZygnJyk7XG4gIH0sXG4gIC8vIEVORCBQVUJMSUMgQVBJXG5cbiAgY29tcGlsZTogZnVuY3Rpb24oZW52aXJvbm1lbnQsIG9wdGlvbnMsIGNvbnRleHQsIGFzT2JqZWN0KSB7XG4gICAgdGhpcy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdHJpbmdQYXJhbXMgPSB0aGlzLm9wdGlvbnMuc3RyaW5nUGFyYW1zO1xuICAgIHRoaXMudHJhY2tJZHMgPSB0aGlzLm9wdGlvbnMudHJhY2tJZHM7XG4gICAgdGhpcy5wcmVjb21waWxlID0gIWFzT2JqZWN0O1xuXG4gICAgdGhpcy5uYW1lID0gdGhpcy5lbnZpcm9ubWVudC5uYW1lO1xuICAgIHRoaXMuaXNDaGlsZCA9ICEhY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHtcbiAgICAgIGRlY29yYXRvcnM6IFtdLFxuICAgICAgcHJvZ3JhbXM6IFtdLFxuICAgICAgZW52aXJvbm1lbnRzOiBbXVxuICAgIH07XG5cbiAgICB0aGlzLnByZWFtYmxlKCk7XG5cbiAgICB0aGlzLnN0YWNrU2xvdCA9IDA7XG4gICAgdGhpcy5zdGFja1ZhcnMgPSBbXTtcbiAgICB0aGlzLmFsaWFzZXMgPSB7fTtcbiAgICB0aGlzLnJlZ2lzdGVycyA9IHsgbGlzdDogW10gfTtcbiAgICB0aGlzLmhhc2hlcyA9IFtdO1xuICAgIHRoaXMuY29tcGlsZVN0YWNrID0gW107XG4gICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xuICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBbXTtcblxuICAgIHRoaXMuY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKTtcblxuICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZW52aXJvbm1lbnQudXNlRGVwdGhzIHx8IGVudmlyb25tZW50LnVzZURlY29yYXRvcnMgfHwgdGhpcy5vcHRpb25zLmNvbXBhdDtcbiAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdGhpcy51c2VCbG9ja1BhcmFtcyB8fCBlbnZpcm9ubWVudC51c2VCbG9ja1BhcmFtcztcblxuICAgIGxldCBvcGNvZGVzID0gZW52aXJvbm1lbnQub3Bjb2RlcyxcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICBmaXJzdExvYyxcbiAgICAgICAgaSxcbiAgICAgICAgbDtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBvcGNvZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb3Bjb2RlID0gb3Bjb2Rlc1tpXTtcblxuICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0gb3Bjb2RlLmxvYztcbiAgICAgIGZpcnN0TG9jID0gZmlyc3RMb2MgfHwgb3Bjb2RlLmxvYztcbiAgICAgIHRoaXNbb3Bjb2RlLm9wY29kZV0uYXBwbHkodGhpcywgb3Bjb2RlLmFyZ3MpO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGFueSB0cmFpbGluZyBjb250ZW50IHRoYXQgbWlnaHQgYmUgcGVuZGluZy5cbiAgICB0aGlzLnNvdXJjZS5jdXJyZW50TG9jYXRpb24gPSBmaXJzdExvYztcbiAgICB0aGlzLnB1c2hTb3VyY2UoJycpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy5zdGFja1Nsb3QgfHwgdGhpcy5pbmxpbmVTdGFjay5sZW5ndGggfHwgdGhpcy5jb21waWxlU3RhY2subGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdDb21waWxlIGNvbXBsZXRlZCB3aXRoIGNvbnRlbnQgbGVmdCBvbiBzdGFjaycpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5kZWNvcmF0b3JzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcblxuICAgICAgdGhpcy5kZWNvcmF0b3JzLnByZXBlbmQoJ3ZhciBkZWNvcmF0b3JzID0gY29udGFpbmVyLmRlY29yYXRvcnM7XFxuJyk7XG4gICAgICB0aGlzLmRlY29yYXRvcnMucHVzaCgncmV0dXJuIGZuOycpO1xuXG4gICAgICBpZiAoYXNPYmplY3QpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gRnVuY3Rpb24uYXBwbHkodGhpcywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCAnZGVwdGgwJywgJ2RhdGEnLCAnYmxvY2tQYXJhbXMnLCAnZGVwdGhzJywgdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wcmVwZW5kKCdmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGgwLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XFxuJyk7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCd9XFxuJyk7XG4gICAgICAgIHRoaXMuZGVjb3JhdG9ycyA9IHRoaXMuZGVjb3JhdG9ycy5tZXJnZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGZuID0gdGhpcy5jcmVhdGVGdW5jdGlvbkNvbnRleHQoYXNPYmplY3QpO1xuICAgIGlmICghdGhpcy5pc0NoaWxkKSB7XG4gICAgICBsZXQgcmV0ID0ge1xuICAgICAgICBjb21waWxlcjogdGhpcy5jb21waWxlckluZm8oKSxcbiAgICAgICAgbWFpbjogZm5cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmRlY29yYXRvcnMpIHtcbiAgICAgICAgcmV0Lm1haW5fZCA9IHRoaXMuZGVjb3JhdG9yczsgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICByZXQudXNlRGVjb3JhdG9ycyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGxldCB7cHJvZ3JhbXMsIGRlY29yYXRvcnN9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAocHJvZ3JhbXNbaV0pIHtcbiAgICAgICAgICByZXRbaV0gPSBwcm9ncmFtc1tpXTtcbiAgICAgICAgICBpZiAoZGVjb3JhdG9yc1tpXSkge1xuICAgICAgICAgICAgcmV0W2kgKyAnX2QnXSA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICByZXQudXNlRGVjb3JhdG9ycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVudmlyb25tZW50LnVzZVBhcnRpYWwpIHtcbiAgICAgICAgcmV0LnVzZVBhcnRpYWwgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIHJldC51c2VEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZURlcHRocykge1xuICAgICAgICByZXQudXNlRGVwdGhzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHJldC51c2VCbG9ja1BhcmFtcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdCkge1xuICAgICAgICByZXQuY29tcGF0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhc09iamVjdCkge1xuICAgICAgICByZXQuY29tcGlsZXIgPSBKU09OLnN0cmluZ2lmeShyZXQuY29tcGlsZXIpO1xuXG4gICAgICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IHtzdGFydDoge2xpbmU6IDEsIGNvbHVtbjogMH19O1xuICAgICAgICByZXQgPSB0aGlzLm9iamVjdExpdGVyYWwocmV0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zcmNOYW1lKSB7XG4gICAgICAgICAgcmV0ID0gcmV0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7ZmlsZTogb3B0aW9ucy5kZXN0TmFtZX0pO1xuICAgICAgICAgIHJldC5tYXAgPSByZXQubWFwICYmIHJldC5tYXAudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSByZXQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LmNvbXBpbGVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgfSxcblxuICBwcmVhbWJsZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gdHJhY2sgdGhlIGxhc3QgY29udGV4dCBwdXNoZWQgaW50byBwbGFjZSB0byBhbGxvdyBza2lwcGluZyB0aGVcbiAgICAvLyBnZXRDb250ZXh0IG9wY29kZSB3aGVuIGl0IHdvdWxkIGJlIGEgbm9vcFxuICAgIHRoaXMubGFzdENvbnRleHQgPSAwO1xuICAgIHRoaXMuc291cmNlID0gbmV3IENvZGVHZW4odGhpcy5vcHRpb25zLnNyY05hbWUpO1xuICAgIHRoaXMuZGVjb3JhdG9ycyA9IG5ldyBDb2RlR2VuKHRoaXMub3B0aW9ucy5zcmNOYW1lKTtcbiAgfSxcblxuICBjcmVhdGVGdW5jdGlvbkNvbnRleHQ6IGZ1bmN0aW9uKGFzT2JqZWN0KSB7XG4gICAgbGV0IHZhckRlY2xhcmF0aW9ucyA9ICcnO1xuXG4gICAgbGV0IGxvY2FscyA9IHRoaXMuc3RhY2tWYXJzLmNvbmNhdCh0aGlzLnJlZ2lzdGVycy5saXN0KTtcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCAnICsgbG9jYWxzLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgbWluaW1pemVyIGFsaWFzIG1hcHBpbmdzXG4gICAgLy9cbiAgICAvLyBXaGVuIHVzaW5nIHRydWUgU291cmNlTm9kZXMsIHRoaXMgd2lsbCB1cGRhdGUgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGFsaWFzXG4gICAgLy8gYXMgdGhlIHNvdXJjZSBub2RlcyBhcmUgcmV1c2VkIGluIHNpdHUuIEZvciB0aGUgbm9uLXNvdXJjZSBub2RlIGNvbXBpbGF0aW9uIG1vZGUsXG4gICAgLy8gYWxpYXNlcyB3aWxsIG5vdCBiZSB1c2VkLCBidXQgdGhpcyBjYXNlIGlzIGFscmVhZHkgYmVpbmcgcnVuIG9uIHRoZSBjbGllbnQgYW5kXG4gICAgLy8gd2UgYXJlbid0IGNvbmNlcm4gYWJvdXQgbWluaW1pemluZyB0aGUgdGVtcGxhdGUgc2l6ZS5cbiAgICBsZXQgYWxpYXNDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgYWxpYXMgaW4gdGhpcy5hbGlhc2VzKSB7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICBsZXQgbm9kZSA9IHRoaXMuYWxpYXNlc1thbGlhc107XG5cbiAgICAgIGlmICh0aGlzLmFsaWFzZXMuaGFzT3duUHJvcGVydHkoYWxpYXMpICYmIG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5yZWZlcmVuY2VDb3VudCA+IDEpIHtcbiAgICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsIGFsaWFzJyArICgrK2FsaWFzQ291bnQpICsgJz0nICsgYWxpYXM7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bMF0gPSAnYWxpYXMnICsgYWxpYXNDb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcGFyYW1zID0gWydjb250YWluZXInLCAnZGVwdGgwJywgJ2hlbHBlcnMnLCAncGFydGlhbHMnLCAnZGF0YSddO1xuXG4gICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgdGhpcy51c2VEZXB0aHMpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdibG9ja1BhcmFtcycpO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VEZXB0aHMpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdkZXB0aHMnKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGEgc2Vjb25kIHBhc3Mgb3ZlciB0aGUgb3V0cHV0IHRvIG1lcmdlIGNvbnRlbnQgd2hlbiBwb3NzaWJsZVxuICAgIGxldCBzb3VyY2UgPSB0aGlzLm1lcmdlU291cmNlKHZhckRlY2xhcmF0aW9ucyk7XG5cbiAgICBpZiAoYXNPYmplY3QpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHNvdXJjZSk7XG5cbiAgICAgIHJldHVybiBGdW5jdGlvbi5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2Uud3JhcChbJ2Z1bmN0aW9uKCcsIHBhcmFtcy5qb2luKCcsJyksICcpIHtcXG4gICcsIHNvdXJjZSwgJ30nXSk7XG4gICAgfVxuICB9LFxuICBtZXJnZVNvdXJjZTogZnVuY3Rpb24odmFyRGVjbGFyYXRpb25zKSB7XG4gICAgbGV0IGlzU2ltcGxlID0gdGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSxcbiAgICAgICAgYXBwZW5kT25seSA9ICF0aGlzLmZvcmNlQnVmZmVyLFxuICAgICAgICBhcHBlbmRGaXJzdCxcblxuICAgICAgICBzb3VyY2VTZWVuLFxuICAgICAgICBidWZmZXJTdGFydCxcbiAgICAgICAgYnVmZmVyRW5kO1xuICAgIHRoaXMuc291cmNlLmVhY2goKGxpbmUpID0+IHtcbiAgICAgIGlmIChsaW5lLmFwcGVuZFRvQnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXJTdGFydCkge1xuICAgICAgICAgIGxpbmUucHJlcGVuZCgnICArICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJFbmQgPSBsaW5lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XG4gICAgICAgICAgaWYgKCFzb3VyY2VTZWVuKSB7XG4gICAgICAgICAgICBhcHBlbmRGaXJzdCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ2J1ZmZlciArPSAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xuICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gYnVmZmVyRW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc291cmNlU2VlbiA9IHRydWU7XG4gICAgICAgIGlmICghaXNTaW1wbGUpIHtcbiAgICAgICAgICBhcHBlbmRPbmx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgaWYgKGFwcGVuZE9ubHkpIHtcbiAgICAgIGlmIChidWZmZXJTdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydC5wcmVwZW5kKCdyZXR1cm4gJyk7XG4gICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXNvdXJjZVNlZW4pIHtcbiAgICAgICAgdGhpcy5zb3VyY2UucHVzaCgncmV0dXJuIFwiXCI7Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCBidWZmZXIgPSAnICsgKGFwcGVuZEZpcnN0ID8gJycgOiB0aGlzLmluaXRpYWxpemVCdWZmZXIoKSk7XG5cbiAgICAgIGlmIChidWZmZXJTdGFydCkge1xuICAgICAgICBidWZmZXJTdGFydC5wcmVwZW5kKCdyZXR1cm4gYnVmZmVyICsgJyk7XG4gICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc291cmNlLnB1c2goJ3JldHVybiBidWZmZXI7Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhckRlY2xhcmF0aW9ucykge1xuICAgICAgdGhpcy5zb3VyY2UucHJlcGVuZCgndmFyICcgKyB2YXJEZWNsYXJhdGlvbnMuc3Vic3RyaW5nKDIpICsgKGFwcGVuZEZpcnN0ID8gJycgOiAnO1xcbicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubWVyZ2UoKTtcbiAgfSxcblxuICAvLyBbYmxvY2tWYWx1ZV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXR1cm4gdmFsdWUgb2YgYmxvY2tIZWxwZXJNaXNzaW5nXG4gIC8vXG4gIC8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgb3Bjb2RlIGlzIHRvIHRha2UgYSBibG9jayBvZiB0aGUgZm9ybVxuICAvLyBge3sjdGhpcy5mb299fS4uLnt7L3RoaXMuZm9vfX1gLCByZXNvbHZlIHRoZSB2YWx1ZSBvZiBgZm9vYCwgYW5kXG4gIC8vIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIHdpdGggdGhlIHJlc3VsdCBvZiBwcm9wZXJseVxuICAvLyBpbnZva2luZyBibG9ja0hlbHBlck1pc3NpbmcuXG4gIGJsb2NrVmFsdWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBsZXQgYmxvY2tIZWxwZXJNaXNzaW5nID0gdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuYmxvY2tIZWxwZXJNaXNzaW5nJyksXG4gICAgICAgIHBhcmFtcyA9IFt0aGlzLmNvbnRleHROYW1lKDApXTtcbiAgICB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCAwLCBwYXJhbXMpO1xuXG4gICAgbGV0IGJsb2NrTmFtZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICBwYXJhbXMuc3BsaWNlKDEsIDAsIGJsb2NrTmFtZSk7XG5cbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGJsb2NrSGVscGVyTWlzc2luZywgJ2NhbGwnLCBwYXJhbXMpKTtcbiAgfSxcblxuICAvLyBbYW1iaWd1b3VzQmxvY2tWYWx1ZV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcbiAgLy8gQ29tcGlsZXIgdmFsdWUsIGJlZm9yZTogbGFzdEhlbHBlcj12YWx1ZSBvZiBsYXN0IGZvdW5kIGhlbHBlciwgaWYgYW55XG4gIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbm8gbGFzdEhlbHBlcjogc2FtZSBhcyBbYmxvY2tWYWx1ZV1cbiAgLy8gT24gc3RhY2ssIGFmdGVyLCBpZiBsYXN0SGVscGVyOiB2YWx1ZVxuICBhbWJpZ3VvdXNCbG9ja1ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBXZSdyZSBiZWluZyBhIGJpdCBjaGVla3kgYW5kIHJldXNpbmcgdGhlIG9wdGlvbnMgdmFsdWUgZnJvbSB0aGUgcHJpb3IgZXhlY1xuICAgIGxldCBibG9ja0hlbHBlck1pc3NpbmcgPSB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnKSxcbiAgICAgICAgcGFyYW1zID0gW3RoaXMuY29udGV4dE5hbWUoMCldO1xuICAgIHRoaXMuc2V0dXBIZWxwZXJBcmdzKCcnLCAwLCBwYXJhbXMsIHRydWUpO1xuXG4gICAgdGhpcy5mbHVzaElubGluZSgpO1xuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLnRvcFN0YWNrKCk7XG4gICAgcGFyYW1zLnNwbGljZSgxLCAwLCBjdXJyZW50KTtcblxuICAgIHRoaXMucHVzaFNvdXJjZShbXG4gICAgICAgICdpZiAoIScsIHRoaXMubGFzdEhlbHBlciwgJykgeyAnLFxuICAgICAgICAgIGN1cnJlbnQsICcgPSAnLCB0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoYmxvY2tIZWxwZXJNaXNzaW5nLCAnY2FsbCcsIHBhcmFtcyksXG4gICAgICAgICd9J10pO1xuICB9LFxuXG4gIC8vIFthcHBlbmRDb250ZW50XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gQXBwZW5kcyB0aGUgc3RyaW5nIHZhbHVlIG9mIGBjb250ZW50YCB0byB0aGUgY3VycmVudCBidWZmZXJcbiAgYXBwZW5kQ29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5wZW5kaW5nQ29udGVudCArIGNvbnRlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVuZGluZ0xvY2F0aW9uID0gdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uO1xuICAgIH1cblxuICAgIHRoaXMucGVuZGluZ0NvbnRlbnQgPSBjb250ZW50O1xuICB9LFxuXG4gIC8vIFthcHBlbmRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gQ29lcmNlcyBgdmFsdWVgIHRvIGEgU3RyaW5nIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAgLy9cbiAgLy8gSWYgYHZhbHVlYCBpcyB0cnV0aHksIG9yIDAsIGl0IGlzIGNvZXJjZWQgaW50byBhIHN0cmluZyBhbmQgYXBwZW5kZWRcbiAgLy8gT3RoZXJ3aXNlLCB0aGUgZW1wdHkgc3RyaW5nIGlzIGFwcGVuZGVkXG4gIGFwcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgdGhpcy5yZXBsYWNlU3RhY2soKGN1cnJlbnQpID0+IFsnICE9IG51bGwgPyAnLCBjdXJyZW50LCAnIDogXCJcIiddKTtcblxuICAgICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5wb3BTdGFjaygpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsb2NhbCA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICgnLCBsb2NhbCwgJyAhPSBudWxsKSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIobG9jYWwsIHVuZGVmaW5lZCwgdHJ1ZSksICcgfSddKTtcbiAgICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XG4gICAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2Vsc2UgeyAnLCB0aGlzLmFwcGVuZFRvQnVmZmVyKFwiJydcIiwgdW5kZWZpbmVkLCB0cnVlKSwgJyB9J10pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBbYXBwZW5kRXNjYXBlZF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBFc2NhcGUgYHZhbHVlYCBhbmQgYXBwZW5kIGl0IHRvIHRoZSBidWZmZXJcbiAgYXBwZW5kRXNjYXBlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIoXG4gICAgICAgIFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmVzY2FwZUV4cHJlc3Npb24nKSwgJygnLCB0aGlzLnBvcFN0YWNrKCksICcpJ10pKTtcbiAgfSxcblxuICAvLyBbZ2V0Q29udGV4dF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXG4gIC8vIENvbXBpbGVyIHZhbHVlLCBhZnRlcjogbGFzdENvbnRleHQ9ZGVwdGhcbiAgLy9cbiAgLy8gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGxhc3RDb250ZXh0YCBjb21waWxlciB2YWx1ZSB0byB0aGUgZGVwdGhcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICB0aGlzLmxhc3RDb250ZXh0ID0gZGVwdGg7XG4gIH0sXG5cbiAgLy8gW3B1c2hDb250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFB1c2hlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29udGV4dCBvbnRvIHRoZSBzdGFjay5cbiAgcHVzaENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh0aGlzLmNvbnRleHROYW1lKHRoaXMubGFzdENvbnRleHQpKTtcbiAgfSxcblxuICAvLyBbbG9va3VwT25Db250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dFtuYW1lXSwgLi4uXG4gIC8vXG4gIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgbmFtZWAgb24gdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgcHVzaGVzXG4gIC8vIGl0IG9udG8gdGhlIHN0YWNrLlxuICBsb29rdXBPbkNvbnRleHQ6IGZ1bmN0aW9uKHBhcnRzLCBmYWxzeSwgc3RyaWN0LCBzY29wZWQpIHtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBpZiAoIXNjb3BlZCAmJiB0aGlzLm9wdGlvbnMuY29tcGF0ICYmICF0aGlzLmxhc3RDb250ZXh0KSB7XG4gICAgICAvLyBUaGUgZGVwdGhlZCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYW5kbGUgdGhlIHVuZGVmaW5lZCBsb2dpYyBmb3IgdGhlIHJvb3QgbGV2ZWwgdGhhdFxuICAgICAgLy8gaXMgaW1wbGVtZW50ZWQgYmVsb3csIHNvIHdlIGV2YWx1YXRlIHRoYXQgZGlyZWN0bHkgaW4gY29tcGF0IG1vZGVcbiAgICAgIHRoaXMucHVzaCh0aGlzLmRlcHRoZWRMb29rdXAocGFydHNbaSsrXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KTtcbiAgfSxcblxuICAvLyBbbG9va3VwQmxvY2tQYXJhbV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogYmxvY2tQYXJhbVtuYW1lXSwgLi4uXG4gIC8vXG4gIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgcGFydHNgIG9uIHRoZSBnaXZlbiBibG9jayBwYXJhbSBhbmQgcHVzaGVzXG4gIC8vIGl0IG9udG8gdGhlIHN0YWNrLlxuICBsb29rdXBCbG9ja1BhcmFtOiBmdW5jdGlvbihibG9ja1BhcmFtSWQsIHBhcnRzKSB7XG4gICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRydWU7XG5cbiAgICB0aGlzLnB1c2goWydibG9ja1BhcmFtc1snLCBibG9ja1BhcmFtSWRbMF0sICddWycsIGJsb2NrUGFyYW1JZFsxXSwgJ10nXSk7XG4gICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCAxKTtcbiAgfSxcblxuICAvLyBbbG9va3VwRGF0YV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogZGF0YSwgLi4uXG4gIC8vXG4gIC8vIFB1c2ggdGhlIGRhdGEgbG9va3VwIG9wZXJhdG9yXG4gIGxvb2t1cERhdGE6IGZ1bmN0aW9uKGRlcHRoLCBwYXJ0cywgc3RyaWN0KSB7XG4gICAgaWYgKCFkZXB0aCkge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdkYXRhJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnY29udGFpbmVyLmRhdGEoZGF0YSwgJyArIGRlcHRoICsgJyknKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc29sdmVQYXRoKCdkYXRhJywgcGFydHMsIDAsIHRydWUsIHN0cmljdCk7XG4gIH0sXG5cbiAgcmVzb2x2ZVBhdGg6IGZ1bmN0aW9uKHR5cGUsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgfHwgdGhpcy5vcHRpb25zLmFzc3VtZU9iamVjdHMpIHtcbiAgICAgIHRoaXMucHVzaChzdHJpY3RMb29rdXAodGhpcy5vcHRpb25zLnN0cmljdCAmJiBzdHJpY3QsIHRoaXMsIHBhcnRzLCB0eXBlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cbiAgICAgIHRoaXMucmVwbGFjZVN0YWNrKChjdXJyZW50KSA9PiB7XG4gICAgICAgIGxldCBsb29rdXAgPSB0aGlzLm5hbWVMb29rdXAoY3VycmVudCwgcGFydHNbaV0sIHR5cGUpO1xuICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IHplcm8gYW5kIGZhbHNlIGFyZSBoYW5kbGVkIHByb3Blcmx5IGlmIHRoZSBjb250ZXh0IChmYWxzeSBmbGFnKVxuICAgICAgICAvLyBuZWVkcyB0byBoYXZlIHRoZSBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGVzZSB2YWx1ZXMuXG4gICAgICAgIGlmICghZmFsc3kpIHtcbiAgICAgICAgICByZXR1cm4gWycgIT0gbnVsbCA/ICcsIGxvb2t1cCwgJyA6ICcsIGN1cnJlbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gdXNlIGdlbmVyaWMgZmFsc3kgaGFuZGxpbmdcbiAgICAgICAgICByZXR1cm4gWycgJiYgJywgbG9va3VwXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuICAgIH1cbiAgfSxcblxuICAvLyBbcmVzb2x2ZVBvc3NpYmxlTGFtYmRhXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzb2x2ZWQgdmFsdWUsIC4uLlxuICAvL1xuICAvLyBJZiB0aGUgYHZhbHVlYCBpcyBhIGxhbWJkYSwgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgYnlcbiAgLy8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbGFtYmRhXG4gIHJlc29sdmVQb3NzaWJsZUxhbWJkYTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXNoKFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmxhbWJkYScpLCAnKCcsIHRoaXMucG9wU3RhY2soKSwgJywgJywgdGhpcy5jb250ZXh0TmFtZSgwKSwgJyknXSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hTdHJpbmdQYXJhbV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogc3RyaW5nLCBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFRoaXMgb3Bjb2RlIGlzIGRlc2lnbmVkIGZvciB1c2UgaW4gc3RyaW5nIG1vZGUsIHdoaWNoXG4gIC8vIHByb3ZpZGVzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBwYXJhbWV0ZXIgYWxvbmcgd2l0aCBpdHNcbiAgLy8gZGVwdGggcmF0aGVyIHRoYW4gcmVzb2x2aW5nIGl0IGltbWVkaWF0ZWx5LlxuICBwdXNoU3RyaW5nUGFyYW06IGZ1bmN0aW9uKHN0cmluZywgdHlwZSkge1xuICAgIHRoaXMucHVzaENvbnRleHQoKTtcbiAgICB0aGlzLnB1c2hTdHJpbmcodHlwZSk7XG5cbiAgICAvLyBJZiBpdCdzIGEgc3ViZXhwcmVzc2lvbiwgdGhlIHN0cmluZyByZXN1bHRcbiAgICAvLyB3aWxsIGJlIHB1c2hlZCBhZnRlciB0aGlzIG9wY29kZS5cbiAgICBpZiAodHlwZSAhPT0gJ1N1YkV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5wdXNoU3RyaW5nKHN0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZW1wdHlIYXNoOiBmdW5jdGlvbihvbWl0RW1wdHkpIHtcbiAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoSWRzXG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoQ29udGV4dHNcbiAgICAgIHRoaXMucHVzaCgne30nKTsgLy8gaGFzaFR5cGVzXG4gICAgfVxuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChvbWl0RW1wdHkgPyAndW5kZWZpbmVkJyA6ICd7fScpO1xuICB9LFxuICBwdXNoSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaGFzaCkge1xuICAgICAgdGhpcy5oYXNoZXMucHVzaCh0aGlzLmhhc2gpO1xuICAgIH1cbiAgICB0aGlzLmhhc2ggPSB7dmFsdWVzOiBbXSwgdHlwZXM6IFtdLCBjb250ZXh0czogW10sIGlkczogW119O1xuICB9LFxuICBwb3BIYXNoOiBmdW5jdGlvbigpIHtcbiAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaDtcbiAgICB0aGlzLmhhc2ggPSB0aGlzLmhhc2hlcy5wb3AoKTtcblxuICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guaWRzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLmNvbnRleHRzKSk7XG4gICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudHlwZXMpKTtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudmFsdWVzKSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hTdHJpbmddXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHF1b3RlZFN0cmluZyhzdHJpbmcpLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCBhIHF1b3RlZCB2ZXJzaW9uIG9mIGBzdHJpbmdgIG9udG8gdGhlIHN0YWNrXG4gIHB1c2hTdHJpbmc6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh0aGlzLnF1b3RlZFN0cmluZyhzdHJpbmcpKTtcbiAgfSxcblxuICAvLyBbcHVzaExpdGVyYWxdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHZhbHVlLCAuLi5cbiAgLy9cbiAgLy8gUHVzaGVzIGEgdmFsdWUgb250byB0aGUgc3RhY2suIFRoaXMgb3BlcmF0aW9uIHByZXZlbnRzXG4gIC8vIHRoZSBjb21waWxlciBmcm9tIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGhvbGRcbiAgLy8gaXQuXG4gIHB1c2hMaXRlcmFsOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh2YWx1ZSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hQcm9ncmFtXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBwcm9ncmFtKGd1aWQpLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCBhIHByb2dyYW0gZXhwcmVzc2lvbiBvbnRvIHRoZSBzdGFjay4gVGhpcyB0YWtlc1xuICAvLyBhIGNvbXBpbGUtdGltZSBndWlkIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgcnVudGltZS1hY2Nlc3NpYmxlXG4gIC8vIGV4cHJlc3Npb24uXG4gIHB1c2hQcm9ncmFtOiBmdW5jdGlvbihndWlkKSB7XG4gICAgaWYgKGd1aWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucHJvZ3JhbUV4cHJlc3Npb24oZ3VpZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwobnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFtyZWdpc3RlckRlY29yYXRvcl1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gUG9wcyBvZmYgdGhlIGRlY29yYXRvcidzIHBhcmFtZXRlcnMsIGludm9rZXMgdGhlIGRlY29yYXRvcixcbiAgLy8gYW5kIGluc2VydHMgdGhlIGRlY29yYXRvciBpbnRvIHRoZSBkZWNvcmF0b3JzIGxpc3QuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yKHBhcmFtU2l6ZSwgbmFtZSkge1xuICAgIGxldCBmb3VuZERlY29yYXRvciA9IHRoaXMubmFtZUxvb2t1cCgnZGVjb3JhdG9ycycsIG5hbWUsICdkZWNvcmF0b3InKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuc2V0dXBIZWxwZXJBcmdzKG5hbWUsIHBhcmFtU2l6ZSk7XG5cbiAgICB0aGlzLmRlY29yYXRvcnMucHVzaChbXG4gICAgICAnZm4gPSAnLFxuICAgICAgdGhpcy5kZWNvcmF0b3JzLmZ1bmN0aW9uQ2FsbChmb3VuZERlY29yYXRvciwgJycsIFsnZm4nLCAncHJvcHMnLCAnY29udGFpbmVyJywgb3B0aW9uc10pLFxuICAgICAgJyB8fCBmbjsnXG4gICAgXSk7XG4gIH0sXG5cbiAgLy8gW2ludm9rZUhlbHBlcl1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgaGVscGVyIGludm9jYXRpb25cbiAgLy9cbiAgLy8gUG9wcyBvZmYgdGhlIGhlbHBlcidzIHBhcmFtZXRlcnMsIGludm9rZXMgdGhlIGhlbHBlcixcbiAgLy8gYW5kIHB1c2hlcyB0aGUgaGVscGVyJ3MgcmV0dXJuIHZhbHVlIG9udG8gdGhlIHN0YWNrLlxuICAvL1xuICAvLyBJZiB0aGUgaGVscGVyIGlzIG5vdCBmb3VuZCwgYGhlbHBlck1pc3NpbmdgIGlzIGNhbGxlZC5cbiAgaW52b2tlSGVscGVyOiBmdW5jdGlvbihwYXJhbVNpemUsIG5hbWUsIGlzU2ltcGxlKSB7XG4gICAgbGV0IG5vbkhlbHBlciA9IHRoaXMucG9wU3RhY2soKSxcbiAgICAgICAgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcihwYXJhbVNpemUsIG5hbWUpLFxuICAgICAgICBzaW1wbGUgPSBpc1NpbXBsZSA/IFtoZWxwZXIubmFtZSwgJyB8fCAnXSA6ICcnO1xuXG4gICAgbGV0IGxvb2t1cCA9IFsnKCddLmNvbmNhdChzaW1wbGUsIG5vbkhlbHBlcik7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICBsb29rdXAucHVzaCgnIHx8ICcsIHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmhlbHBlck1pc3NpbmcnKSk7XG4gICAgfVxuICAgIGxvb2t1cC5wdXNoKCcpJyk7XG5cbiAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGxvb2t1cCwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xuICB9LFxuXG4gIC8vIFtpbnZva2VLbm93bkhlbHBlcl1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgaGVscGVyIGludm9jYXRpb25cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIHRoZSBoZWxwZXIgaXMga25vd24gdG8gZXhpc3QsXG4gIC8vIHNvIGEgYGhlbHBlck1pc3NpbmdgIGZhbGxiYWNrIGlzIG5vdCByZXF1aXJlZC5cbiAgaW52b2tlS25vd25IZWxwZXI6IGZ1bmN0aW9uKHBhcmFtU2l6ZSwgbmFtZSkge1xuICAgIGxldCBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSk7XG4gICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChoZWxwZXIubmFtZSwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xuICB9LFxuXG4gIC8vIFtpbnZva2VBbWJpZ3VvdXNdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHBhcmFtcy4uLiwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGRpc2FtYmlndWF0aW9uXG4gIC8vXG4gIC8vIFRoaXMgb3BlcmF0aW9uIGlzIHVzZWQgd2hlbiBhbiBleHByZXNzaW9uIGxpa2UgYHt7Zm9vfX1gXG4gIC8vIGlzIHByb3ZpZGVkLCBidXQgd2UgZG9uJ3Qga25vdyBhdCBjb21waWxlLXRpbWUgd2hldGhlciBpdFxuICAvLyBpcyBhIGhlbHBlciBvciBhIHBhdGguXG4gIC8vXG4gIC8vIFRoaXMgb3BlcmF0aW9uIGVtaXRzIG1vcmUgY29kZSB0aGFuIHRoZSBvdGhlciBvcHRpb25zLFxuICAvLyBhbmQgY2FuIGJlIGF2b2lkZWQgYnkgcGFzc2luZyB0aGUgYGtub3duSGVscGVyc2AgYW5kXG4gIC8vIGBrbm93bkhlbHBlcnNPbmx5YCBmbGFncyBhdCBjb21waWxlLXRpbWUuXG4gIGludm9rZUFtYmlndW91czogZnVuY3Rpb24obmFtZSwgaGVscGVyQ2FsbCkge1xuICAgIHRoaXMudXNlUmVnaXN0ZXIoJ2hlbHBlcicpO1xuXG4gICAgbGV0IG5vbkhlbHBlciA9IHRoaXMucG9wU3RhY2soKTtcblxuICAgIHRoaXMuZW1wdHlIYXNoKCk7XG4gICAgbGV0IGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIoMCwgbmFtZSwgaGVscGVyQ2FsbCk7XG5cbiAgICBsZXQgaGVscGVyTmFtZSA9IHRoaXMubGFzdEhlbHBlciA9IHRoaXMubmFtZUxvb2t1cCgnaGVscGVycycsIG5hbWUsICdoZWxwZXInKTtcblxuICAgIGxldCBsb29rdXAgPSBbJygnLCAnKGhlbHBlciA9ICcsIGhlbHBlck5hbWUsICcgfHwgJywgbm9uSGVscGVyLCAnKSddO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnN0cmljdCkge1xuICAgICAgbG9va3VwWzBdID0gJyhoZWxwZXIgPSAnO1xuICAgICAgbG9va3VwLnB1c2goXG4gICAgICAgICcgIT0gbnVsbCA/IGhlbHBlciA6ICcsXG4gICAgICAgIHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmhlbHBlck1pc3NpbmcnKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2goW1xuICAgICAgICAnKCcsIGxvb2t1cCxcbiAgICAgICAgKGhlbHBlci5wYXJhbXNJbml0ID8gWycpLCgnLCBoZWxwZXIucGFyYW1zSW5pdF0gOiBbXSksICcpLCcsXG4gICAgICAgICcodHlwZW9mIGhlbHBlciA9PT0gJywgdGhpcy5hbGlhc2FibGUoJ1wiZnVuY3Rpb25cIicpLCAnID8gJyxcbiAgICAgICAgdGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKCdoZWxwZXInLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSwgJyA6IGhlbHBlcikpJ1xuICAgIF0pO1xuICB9LFxuXG4gIC8vIFtpbnZva2VQYXJ0aWFsXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBjb250ZXh0LCAuLi5cbiAgLy8gT24gc3RhY2sgYWZ0ZXI6IHJlc3VsdCBvZiBwYXJ0aWFsIGludm9jYXRpb25cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gcG9wcyBvZmYgYSBjb250ZXh0LCBpbnZva2VzIGEgcGFydGlhbCB3aXRoIHRoYXQgY29udGV4dCxcbiAgLy8gYW5kIHB1c2hlcyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZvY2F0aW9uIGJhY2suXG4gIGludm9rZVBhcnRpYWw6IGZ1bmN0aW9uKGlzRHluYW1pYywgbmFtZSwgaW5kZW50KSB7XG4gICAgbGV0IHBhcmFtcyA9IFtdLFxuICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhuYW1lLCAxLCBwYXJhbXMpO1xuXG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgbmFtZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgb3B0aW9ucy5pbmRlbnQgPSBKU09OLnN0cmluZ2lmeShpbmRlbnQpO1xuICAgIH1cbiAgICBvcHRpb25zLmhlbHBlcnMgPSAnaGVscGVycyc7XG4gICAgb3B0aW9ucy5wYXJ0aWFscyA9ICdwYXJ0aWFscyc7XG4gICAgb3B0aW9ucy5kZWNvcmF0b3JzID0gJ2NvbnRhaW5lci5kZWNvcmF0b3JzJztcblxuICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICBwYXJhbXMudW5zaGlmdCh0aGlzLm5hbWVMb29rdXAoJ3BhcnRpYWxzJywgbmFtZSwgJ3BhcnRpYWwnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XG4gICAgICBvcHRpb25zLmRlcHRocyA9ICdkZXB0aHMnO1xuICAgIH1cbiAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xuICAgIHBhcmFtcy5wdXNoKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbCgnY29udGFpbmVyLmludm9rZVBhcnRpYWwnLCAnJywgcGFyYW1zKSk7XG4gIH0sXG5cbiAgLy8gW2Fzc2lnblRvSGFzaF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLiwgaGFzaCwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uLCBoYXNoLCAuLi5cbiAgLy9cbiAgLy8gUG9wcyBhIHZhbHVlIG9mZiB0aGUgc3RhY2sgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIGN1cnJlbnQgaGFzaFxuICBhc3NpZ25Ub0hhc2g6IGZ1bmN0aW9uKGtleSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wU3RhY2soKSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaWQ7XG5cbiAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgaWQgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgdHlwZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuXG4gICAgbGV0IGhhc2ggPSB0aGlzLmhhc2g7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGhhc2guY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XG4gICAgfVxuICAgIGlmICh0eXBlKSB7XG4gICAgICBoYXNoLnR5cGVzW2tleV0gPSB0eXBlO1xuICAgIH1cbiAgICBpZiAoaWQpIHtcbiAgICAgIGhhc2guaWRzW2tleV0gPSBpZDtcbiAgICB9XG4gICAgaGFzaC52YWx1ZXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIHB1c2hJZDogZnVuY3Rpb24odHlwZSwgbmFtZSwgY2hpbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ0Jsb2NrUGFyYW0nKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoXG4gICAgICAgICAgJ2Jsb2NrUGFyYW1zWycgKyBuYW1lWzBdICsgJ10ucGF0aFsnICsgbmFtZVsxXSArICddJ1xuICAgICAgICAgICsgKGNoaWxkID8gJyArICcgKyBKU09OLnN0cmluZ2lmeSgnLicgKyBjaGlsZCkgOiAnJykpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xuICAgICAgdGhpcy5wdXNoU3RyaW5nKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nKSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdudWxsJyk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEhFTFBFUlNcblxuICBjb21waWxlcjogSmF2YVNjcmlwdENvbXBpbGVyLFxuXG4gIGNvbXBpbGVDaGlsZHJlbjogZnVuY3Rpb24oZW52aXJvbm1lbnQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbnZpcm9ubWVudC5jaGlsZHJlbiwgY2hpbGQsIGNvbXBpbGVyO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb21waWxlciA9IG5ldyB0aGlzLmNvbXBpbGVyKCk7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLm1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKTtcblxuICAgICAgaWYgKGV4aXN0aW5nID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnByb2dyYW1zLnB1c2goJycpOyAgICAgLy8gUGxhY2Vob2xkZXIgdG8gcHJldmVudCBuYW1lIGNvbmZsaWN0cyBmb3IgbmVzdGVkIGNoaWxkcmVuXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuY29udGV4dC5wcm9ncmFtcy5sZW5ndGg7XG4gICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNoaWxkLm5hbWUgPSAncHJvZ3JhbScgKyBpbmRleDtcbiAgICAgICAgdGhpcy5jb250ZXh0LnByb2dyYW1zW2luZGV4XSA9IGNvbXBpbGVyLmNvbXBpbGUoY2hpbGQsIG9wdGlvbnMsIHRoaXMuY29udGV4dCwgIXRoaXMucHJlY29tcGlsZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvcmF0b3JzW2luZGV4XSA9IGNvbXBpbGVyLmRlY29yYXRvcnM7XG4gICAgICAgIHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHNbaW5kZXhdID0gY2hpbGQ7XG5cbiAgICAgICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBjb21waWxlci51c2VEZXB0aHM7XG4gICAgICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGNvbXBpbGVyLnVzZUJsb2NrUGFyYW1zO1xuICAgICAgICBjaGlsZC51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocztcbiAgICAgICAgY2hpbGQudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQuaW5kZXggPSBleGlzdGluZy5pbmRleDtcbiAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGV4aXN0aW5nLmluZGV4O1xuXG4gICAgICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZXhpc3RpbmcudXNlRGVwdGhzO1xuICAgICAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdGhpcy51c2VCbG9ja1BhcmFtcyB8fCBleGlzdGluZy51c2VCbG9ja1BhcmFtcztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGNoRXhpc3RpbmdQcm9ncmFtOiBmdW5jdGlvbihjaGlsZCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgZW52aXJvbm1lbnQgPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzW2ldO1xuICAgICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50LmVxdWFscyhjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9ncmFtRXhwcmVzc2lvbjogZnVuY3Rpb24oZ3VpZCkge1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZW52aXJvbm1lbnQuY2hpbGRyZW5bZ3VpZF0sXG4gICAgICAgIHByb2dyYW1QYXJhbXMgPSBbY2hpbGQuaW5kZXgsICdkYXRhJywgY2hpbGQuYmxvY2tQYXJhbXNdO1xuXG4gICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgdGhpcy51c2VEZXB0aHMpIHtcbiAgICAgIHByb2dyYW1QYXJhbXMucHVzaCgnYmxvY2tQYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XG4gICAgICBwcm9ncmFtUGFyYW1zLnB1c2goJ2RlcHRocycpO1xuICAgIH1cblxuICAgIHJldHVybiAnY29udGFpbmVyLnByb2dyYW0oJyArIHByb2dyYW1QYXJhbXMuam9pbignLCAnKSArICcpJztcbiAgfSxcblxuICB1c2VSZWdpc3RlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5yZWdpc3RlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVnaXN0ZXJzLmxpc3QucHVzaChuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgcHVzaDogZnVuY3Rpb24oZXhwcikge1xuICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBMaXRlcmFsKSkge1xuICAgICAgZXhwciA9IHRoaXMuc291cmNlLndyYXAoZXhwcik7XG4gICAgfVxuXG4gICAgdGhpcy5pbmxpbmVTdGFjay5wdXNoKGV4cHIpO1xuICAgIHJldHVybiBleHByO1xuICB9LFxuXG4gIHB1c2hTdGFja0xpdGVyYWw6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB0aGlzLnB1c2gobmV3IExpdGVyYWwoaXRlbSkpO1xuICB9LFxuXG4gIHB1c2hTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZS5wdXNoKFxuICAgICAgICAgIHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5zb3VyY2UucXVvdGVkU3RyaW5nKHRoaXMucGVuZGluZ0NvbnRlbnQpLCB0aGlzLnBlbmRpbmdMb2NhdGlvbikpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLnNvdXJjZS5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICB9LFxuXG4gIHJlcGxhY2VTdGFjazogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBsZXQgcHJlZml4ID0gWycoJ10sXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBjcmVhdGVkU3RhY2ssXG4gICAgICAgIHVzZWRMaXRlcmFsO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIXRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbigncmVwbGFjZVN0YWNrIG9uIG5vbi1pbmxpbmUnKTtcbiAgICB9XG5cbiAgICAvLyBXZSB3YW50IHRvIG1lcmdlIHRoZSBpbmxpbmUgc3RhdGVtZW50IGludG8gdGhlIHJlcGxhY2VtZW50IHN0YXRlbWVudCB2aWEgJywnXG4gICAgbGV0IHRvcCA9IHRoaXMucG9wU3RhY2sodHJ1ZSk7XG5cbiAgICBpZiAodG9wIGluc3RhbmNlb2YgTGl0ZXJhbCkge1xuICAgICAgLy8gTGl0ZXJhbHMgZG8gbm90IG5lZWQgdG8gYmUgaW5saW5lZFxuICAgICAgc3RhY2sgPSBbdG9wLnZhbHVlXTtcbiAgICAgIHByZWZpeCA9IFsnKCcsIHN0YWNrXTtcbiAgICAgIHVzZWRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBzdGFjayBuYW1lIGZvciB1c2UgYnkgdGhlIGlubGluZVxuICAgICAgY3JlYXRlZFN0YWNrID0gdHJ1ZTtcbiAgICAgIGxldCBuYW1lID0gdGhpcy5pbmNyU3RhY2soKTtcblxuICAgICAgcHJlZml4ID0gWycoKCcsIHRoaXMucHVzaChuYW1lKSwgJyA9ICcsIHRvcCwgJyknXTtcbiAgICAgIHN0YWNrID0gdGhpcy50b3BTdGFjaygpO1xuICAgIH1cblxuICAgIGxldCBpdGVtID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdGFjayk7XG5cbiAgICBpZiAoIXVzZWRMaXRlcmFsKSB7XG4gICAgICB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuICAgIGlmIChjcmVhdGVkU3RhY2spIHtcbiAgICAgIHRoaXMuc3RhY2tTbG90LS07XG4gICAgfVxuICAgIHRoaXMucHVzaChwcmVmaXguY29uY2F0KGl0ZW0sICcpJykpO1xuICB9LFxuXG4gIGluY3JTdGFjazogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdGFja1Nsb3QrKztcbiAgICBpZiAodGhpcy5zdGFja1Nsb3QgPiB0aGlzLnN0YWNrVmFycy5sZW5ndGgpIHsgdGhpcy5zdGFja1ZhcnMucHVzaCgnc3RhY2snICsgdGhpcy5zdGFja1Nsb3QpOyB9XG4gICAgcmV0dXJuIHRoaXMudG9wU3RhY2tOYW1lKCk7XG4gIH0sXG4gIHRvcFN0YWNrTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdzdGFjaycgKyB0aGlzLnN0YWNrU2xvdDtcbiAgfSxcbiAgZmx1c2hJbmxpbmU6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBpbmxpbmVTdGFjayA9IHRoaXMuaW5saW5lU3RhY2s7XG4gICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpbmxpbmVTdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGVudHJ5ID0gaW5saW5lU3RhY2tbaV07XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5jb21waWxlU3RhY2sucHVzaChlbnRyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc3RhY2sgPSB0aGlzLmluY3JTdGFjaygpO1xuICAgICAgICB0aGlzLnB1c2hTb3VyY2UoW3N0YWNrLCAnID0gJywgZW50cnksICc7J10pO1xuICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKHN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzSW5saW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbmxpbmVTdGFjay5sZW5ndGg7XG4gIH0sXG5cbiAgcG9wU3RhY2s6IGZ1bmN0aW9uKHdyYXBwZWQpIHtcbiAgICBsZXQgaW5saW5lID0gdGhpcy5pc0lubGluZSgpLFxuICAgICAgICBpdGVtID0gKGlubGluZSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjaykucG9wKCk7XG5cbiAgICBpZiAoIXdyYXBwZWQgJiYgKGl0ZW0gaW5zdGFuY2VvZiBMaXRlcmFsKSkge1xuICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5saW5lKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghdGhpcy5zdGFja1Nsb3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdJbnZhbGlkIHN0YWNrIHBvcCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2tTbG90LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgdG9wU3RhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGxldCBzdGFjayA9ICh0aGlzLmlzSW5saW5lKCkgPyB0aGlzLmlubGluZVN0YWNrIDogdGhpcy5jb21waWxlU3RhY2spLFxuICAgICAgICBpdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgY29udGV4dE5hbWU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy51c2VEZXB0aHMgJiYgY29udGV4dCkge1xuICAgICAgcmV0dXJuICdkZXB0aHNbJyArIGNvbnRleHQgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnZGVwdGgnICsgY29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgcXVvdGVkU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UucXVvdGVkU3RyaW5nKHN0cik7XG4gIH0sXG5cbiAgb2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLm9iamVjdExpdGVyYWwob2JqKTtcbiAgfSxcblxuICBhbGlhc2FibGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBsZXQgcmV0ID0gdGhpcy5hbGlhc2VzW25hbWVdO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHJldC5yZWZlcmVuY2VDb3VudCsrO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXQgPSB0aGlzLmFsaWFzZXNbbmFtZV0gPSB0aGlzLnNvdXJjZS53cmFwKG5hbWUpO1xuICAgIHJldC5hbGlhc2FibGUgPSB0cnVlO1xuICAgIHJldC5yZWZlcmVuY2VDb3VudCA9IDE7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIHNldHVwSGVscGVyOiBmdW5jdGlvbihwYXJhbVNpemUsIG5hbWUsIGJsb2NrSGVscGVyKSB7XG4gICAgbGV0IHBhcmFtcyA9IFtdLFxuICAgICAgICBwYXJhbXNJbml0ID0gdGhpcy5zZXR1cEhlbHBlckFyZ3MobmFtZSwgcGFyYW1TaXplLCBwYXJhbXMsIGJsb2NrSGVscGVyKTtcbiAgICBsZXQgZm91bmRIZWxwZXIgPSB0aGlzLm5hbWVMb29rdXAoJ2hlbHBlcnMnLCBuYW1lLCAnaGVscGVyJyksXG4gICAgICAgIGNhbGxDb250ZXh0ID0gdGhpcy5hbGlhc2FibGUoYCR7dGhpcy5jb250ZXh0TmFtZSgwKX0gIT0gbnVsbCA/ICR7dGhpcy5jb250ZXh0TmFtZSgwKX0gOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KWApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgcGFyYW1zSW5pdDogcGFyYW1zSW5pdCxcbiAgICAgIG5hbWU6IGZvdW5kSGVscGVyLFxuICAgICAgY2FsbFBhcmFtczogW2NhbGxDb250ZXh0XS5jb25jYXQocGFyYW1zKVxuICAgIH07XG4gIH0sXG5cbiAgc2V0dXBQYXJhbXM6IGZ1bmN0aW9uKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9LFxuICAgICAgICBjb250ZXh0cyA9IFtdLFxuICAgICAgICB0eXBlcyA9IFtdLFxuICAgICAgICBpZHMgPSBbXSxcbiAgICAgICAgb2JqZWN0QXJncyA9ICFwYXJhbXMsXG4gICAgICAgIHBhcmFtO1xuXG4gICAgaWYgKG9iamVjdEFyZ3MpIHtcbiAgICAgIHBhcmFtcyA9IFtdO1xuICAgIH1cblxuICAgIG9wdGlvbnMubmFtZSA9IHRoaXMucXVvdGVkU3RyaW5nKGhlbHBlcik7XG4gICAgb3B0aW9ucy5oYXNoID0gdGhpcy5wb3BTdGFjaygpO1xuXG4gICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcbiAgICAgIG9wdGlvbnMuaGFzaElkcyA9IHRoaXMucG9wU3RhY2soKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICBvcHRpb25zLmhhc2hUeXBlcyA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIG9wdGlvbnMuaGFzaENvbnRleHRzID0gdGhpcy5wb3BTdGFjaygpO1xuICAgIH1cblxuICAgIGxldCBpbnZlcnNlID0gdGhpcy5wb3BTdGFjaygpLFxuICAgICAgICBwcm9ncmFtID0gdGhpcy5wb3BTdGFjaygpO1xuXG4gICAgLy8gQXZvaWQgc2V0dGluZyBmbiBhbmQgaW52ZXJzZSBpZiBuZWl0aGVyIGFyZSBzZXQuIFRoaXMgYWxsb3dzXG4gICAgLy8gaGVscGVycyB0byBkbyBhIGNoZWNrIGZvciBgaWYgKG9wdGlvbnMuZm4pYFxuICAgIGlmIChwcm9ncmFtIHx8IGludmVyc2UpIHtcbiAgICAgIG9wdGlvbnMuZm4gPSBwcm9ncmFtIHx8ICdjb250YWluZXIubm9vcCc7XG4gICAgICBvcHRpb25zLmludmVyc2UgPSBpbnZlcnNlIHx8ICdjb250YWluZXIubm9vcCc7XG4gICAgfVxuXG4gICAgLy8gVGhlIHBhcmFtZXRlcnMgZ28gb24gdG8gdGhlIHN0YWNrIGluIG9yZGVyIChtYWtpbmcgc3VyZSB0aGF0IHRoZXkgYXJlIGV2YWx1YXRlZCBpbiBvcmRlcilcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHBvcCB0aGVtIG9mZiB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlclxuICAgIGxldCBpID0gcGFyYW1TaXplO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHBhcmFtID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgcGFyYW1zW2ldID0gcGFyYW07XG5cbiAgICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XG4gICAgICAgIGlkc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgICB0eXBlc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgICAgY29udGV4dHNbaV0gPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdEFyZ3MpIHtcbiAgICAgIG9wdGlvbnMuYXJncyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkocGFyYW1zKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmFja0lkcykge1xuICAgICAgb3B0aW9ucy5pZHMgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KGlkcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xuICAgICAgb3B0aW9ucy50eXBlcyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkodHlwZXMpO1xuICAgICAgb3B0aW9ucy5jb250ZXh0cyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkoY29udGV4dHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YSkge1xuICAgICAgb3B0aW9ucy5kYXRhID0gJ2RhdGEnO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcykge1xuICAgICAgb3B0aW9ucy5ibG9ja1BhcmFtcyA9ICdibG9ja1BhcmFtcyc7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuXG4gIHNldHVwSGVscGVyQXJnczogZnVuY3Rpb24oaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcywgdXNlUmVnaXN0ZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuc2V0dXBQYXJhbXMoaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IHRoaXMub2JqZWN0TGl0ZXJhbChvcHRpb25zKTtcbiAgICBpZiAodXNlUmVnaXN0ZXIpIHtcbiAgICAgIHRoaXMudXNlUmVnaXN0ZXIoJ29wdGlvbnMnKTtcbiAgICAgIHBhcmFtcy5wdXNoKCdvcHRpb25zJyk7XG4gICAgICByZXR1cm4gWydvcHRpb25zPScsIG9wdGlvbnNdO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICBwYXJhbXMucHVzaChvcHRpb25zKTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9XG59O1xuXG5cbihmdW5jdGlvbigpIHtcbiAgY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IChcbiAgICAnYnJlYWsgZWxzZSBuZXcgdmFyJyArXG4gICAgJyBjYXNlIGZpbmFsbHkgcmV0dXJuIHZvaWQnICtcbiAgICAnIGNhdGNoIGZvciBzd2l0Y2ggd2hpbGUnICtcbiAgICAnIGNvbnRpbnVlIGZ1bmN0aW9uIHRoaXMgd2l0aCcgK1xuICAgICcgZGVmYXVsdCBpZiB0aHJvdycgK1xuICAgICcgZGVsZXRlIGluIHRyeScgK1xuICAgICcgZG8gaW5zdGFuY2VvZiB0eXBlb2YnICtcbiAgICAnIGFic3RyYWN0IGVudW0gaW50IHNob3J0JyArXG4gICAgJyBib29sZWFuIGV4cG9ydCBpbnRlcmZhY2Ugc3RhdGljJyArXG4gICAgJyBieXRlIGV4dGVuZHMgbG9uZyBzdXBlcicgK1xuICAgICcgY2hhciBmaW5hbCBuYXRpdmUgc3luY2hyb25pemVkJyArXG4gICAgJyBjbGFzcyBmbG9hdCBwYWNrYWdlIHRocm93cycgK1xuICAgICcgY29uc3QgZ290byBwcml2YXRlIHRyYW5zaWVudCcgK1xuICAgICcgZGVidWdnZXIgaW1wbGVtZW50cyBwcm90ZWN0ZWQgdm9sYXRpbGUnICtcbiAgICAnIGRvdWJsZSBpbXBvcnQgcHVibGljIGxldCB5aWVsZCBhd2FpdCcgK1xuICAgICcgbnVsbCB0cnVlIGZhbHNlJ1xuICApLnNwbGl0KCcgJyk7XG5cbiAgY29uc3QgY29tcGlsZXJXb3JkcyA9IEphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEUyA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcmVzZXJ2ZWRXb3Jkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb21waWxlcldvcmRzW3Jlc2VydmVkV29yZHNbaV1dID0gdHJ1ZTtcbiAgfVxufSgpKTtcblxuSmF2YVNjcmlwdENvbXBpbGVyLmlzVmFsaWRKYXZhU2NyaXB0VmFyaWFibGVOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gIUphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEU1tuYW1lXSAmJiAoL15bYS16QS1aXyRdWzAtOWEtekEtWl8kXSokLykudGVzdChuYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHN0cmljdExvb2t1cChyZXF1aXJlVGVybWluYWwsIGNvbXBpbGVyLCBwYXJ0cywgdHlwZSkge1xuICBsZXQgc3RhY2sgPSBjb21waWxlci5wb3BTdGFjaygpLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gIGlmIChyZXF1aXJlVGVybWluYWwpIHtcbiAgICBsZW4tLTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdGFjayA9IGNvbXBpbGVyLm5hbWVMb29rdXAoc3RhY2ssIHBhcnRzW2ldLCB0eXBlKTtcbiAgfVxuXG4gIGlmIChyZXF1aXJlVGVybWluYWwpIHtcbiAgICByZXR1cm4gW2NvbXBpbGVyLmFsaWFzYWJsZSgnY29udGFpbmVyLnN0cmljdCcpLCAnKCcsIHN0YWNrLCAnLCAnLCBjb21waWxlci5xdW90ZWRTdHJpbmcocGFydHNbaV0pLCAnKSddO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdGFjaztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBKYXZhU2NyaXB0Q29tcGlsZXI7XG4iLCIvLyBGaWxlIGlnbm9yZWQgaW4gY292ZXJhZ2UgdGVzdHMgdmlhIHNldHRpbmcgaW4gLmlzdGFuYnVsLnltbFxuLyogSmlzb24gZ2VuZXJhdGVkIHBhcnNlciAqL1xudmFyIGhhbmRsZWJhcnMgPSAoZnVuY3Rpb24oKXtcbnZhciBwYXJzZXIgPSB7dHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkgeyB9LFxueXk6IHt9LFxuc3ltYm9sc186IHtcImVycm9yXCI6MixcInJvb3RcIjozLFwicHJvZ3JhbVwiOjQsXCJFT0ZcIjo1LFwicHJvZ3JhbV9yZXBldGl0aW9uMFwiOjYsXCJzdGF0ZW1lbnRcIjo3LFwibXVzdGFjaGVcIjo4LFwiYmxvY2tcIjo5LFwicmF3QmxvY2tcIjoxMCxcInBhcnRpYWxcIjoxMSxcInBhcnRpYWxCbG9ja1wiOjEyLFwiY29udGVudFwiOjEzLFwiQ09NTUVOVFwiOjE0LFwiQ09OVEVOVFwiOjE1LFwib3BlblJhd0Jsb2NrXCI6MTYsXCJyYXdCbG9ja19yZXBldGl0aW9uX3BsdXMwXCI6MTcsXCJFTkRfUkFXX0JMT0NLXCI6MTgsXCJPUEVOX1JBV19CTE9DS1wiOjE5LFwiaGVscGVyTmFtZVwiOjIwLFwib3BlblJhd0Jsb2NrX3JlcGV0aXRpb24wXCI6MjEsXCJvcGVuUmF3QmxvY2tfb3B0aW9uMFwiOjIyLFwiQ0xPU0VfUkFXX0JMT0NLXCI6MjMsXCJvcGVuQmxvY2tcIjoyNCxcImJsb2NrX29wdGlvbjBcIjoyNSxcImNsb3NlQmxvY2tcIjoyNixcIm9wZW5JbnZlcnNlXCI6MjcsXCJibG9ja19vcHRpb24xXCI6MjgsXCJPUEVOX0JMT0NLXCI6MjksXCJvcGVuQmxvY2tfcmVwZXRpdGlvbjBcIjozMCxcIm9wZW5CbG9ja19vcHRpb24wXCI6MzEsXCJvcGVuQmxvY2tfb3B0aW9uMVwiOjMyLFwiQ0xPU0VcIjozMyxcIk9QRU5fSU5WRVJTRVwiOjM0LFwib3BlbkludmVyc2VfcmVwZXRpdGlvbjBcIjozNSxcIm9wZW5JbnZlcnNlX29wdGlvbjBcIjozNixcIm9wZW5JbnZlcnNlX29wdGlvbjFcIjozNyxcIm9wZW5JbnZlcnNlQ2hhaW5cIjozOCxcIk9QRU5fSU5WRVJTRV9DSEFJTlwiOjM5LFwib3BlbkludmVyc2VDaGFpbl9yZXBldGl0aW9uMFwiOjQwLFwib3BlbkludmVyc2VDaGFpbl9vcHRpb24wXCI6NDEsXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjFcIjo0MixcImludmVyc2VBbmRQcm9ncmFtXCI6NDMsXCJJTlZFUlNFXCI6NDQsXCJpbnZlcnNlQ2hhaW5cIjo0NSxcImludmVyc2VDaGFpbl9vcHRpb24wXCI6NDYsXCJPUEVOX0VOREJMT0NLXCI6NDcsXCJPUEVOXCI6NDgsXCJtdXN0YWNoZV9yZXBldGl0aW9uMFwiOjQ5LFwibXVzdGFjaGVfb3B0aW9uMFwiOjUwLFwiT1BFTl9VTkVTQ0FQRURcIjo1MSxcIm11c3RhY2hlX3JlcGV0aXRpb24xXCI6NTIsXCJtdXN0YWNoZV9vcHRpb24xXCI6NTMsXCJDTE9TRV9VTkVTQ0FQRURcIjo1NCxcIk9QRU5fUEFSVElBTFwiOjU1LFwicGFydGlhbE5hbWVcIjo1NixcInBhcnRpYWxfcmVwZXRpdGlvbjBcIjo1NyxcInBhcnRpYWxfb3B0aW9uMFwiOjU4LFwib3BlblBhcnRpYWxCbG9ja1wiOjU5LFwiT1BFTl9QQVJUSUFMX0JMT0NLXCI6NjAsXCJvcGVuUGFydGlhbEJsb2NrX3JlcGV0aXRpb24wXCI6NjEsXCJvcGVuUGFydGlhbEJsb2NrX29wdGlvbjBcIjo2MixcInBhcmFtXCI6NjMsXCJzZXhwclwiOjY0LFwiT1BFTl9TRVhQUlwiOjY1LFwic2V4cHJfcmVwZXRpdGlvbjBcIjo2NixcInNleHByX29wdGlvbjBcIjo2NyxcIkNMT1NFX1NFWFBSXCI6NjgsXCJoYXNoXCI6NjksXCJoYXNoX3JlcGV0aXRpb25fcGx1czBcIjo3MCxcImhhc2hTZWdtZW50XCI6NzEsXCJJRFwiOjcyLFwiRVFVQUxTXCI6NzMsXCJibG9ja1BhcmFtc1wiOjc0LFwiT1BFTl9CTE9DS19QQVJBTVNcIjo3NSxcImJsb2NrUGFyYW1zX3JlcGV0aXRpb25fcGx1czBcIjo3NixcIkNMT1NFX0JMT0NLX1BBUkFNU1wiOjc3LFwicGF0aFwiOjc4LFwiZGF0YU5hbWVcIjo3OSxcIlNUUklOR1wiOjgwLFwiTlVNQkVSXCI6ODEsXCJCT09MRUFOXCI6ODIsXCJVTkRFRklORURcIjo4MyxcIk5VTExcIjo4NCxcIkRBVEFcIjo4NSxcInBhdGhTZWdtZW50c1wiOjg2LFwiU0VQXCI6ODcsXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw1OlwiRU9GXCIsMTQ6XCJDT01NRU5UXCIsMTU6XCJDT05URU5UXCIsMTg6XCJFTkRfUkFXX0JMT0NLXCIsMTk6XCJPUEVOX1JBV19CTE9DS1wiLDIzOlwiQ0xPU0VfUkFXX0JMT0NLXCIsMjk6XCJPUEVOX0JMT0NLXCIsMzM6XCJDTE9TRVwiLDM0OlwiT1BFTl9JTlZFUlNFXCIsMzk6XCJPUEVOX0lOVkVSU0VfQ0hBSU5cIiw0NDpcIklOVkVSU0VcIiw0NzpcIk9QRU5fRU5EQkxPQ0tcIiw0ODpcIk9QRU5cIiw1MTpcIk9QRU5fVU5FU0NBUEVEXCIsNTQ6XCJDTE9TRV9VTkVTQ0FQRURcIiw1NTpcIk9QRU5fUEFSVElBTFwiLDYwOlwiT1BFTl9QQVJUSUFMX0JMT0NLXCIsNjU6XCJPUEVOX1NFWFBSXCIsNjg6XCJDTE9TRV9TRVhQUlwiLDcyOlwiSURcIiw3MzpcIkVRVUFMU1wiLDc1OlwiT1BFTl9CTE9DS19QQVJBTVNcIiw3NzpcIkNMT1NFX0JMT0NLX1BBUkFNU1wiLDgwOlwiU1RSSU5HXCIsODE6XCJOVU1CRVJcIiw4MjpcIkJPT0xFQU5cIiw4MzpcIlVOREVGSU5FRFwiLDg0OlwiTlVMTFwiLDg1OlwiREFUQVwiLDg3OlwiU0VQXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwxXSxbNywxXSxbNywxXSxbNywxXSxbNywxXSxbNywxXSxbNywxXSxbNywxXSxbMTMsMV0sWzEwLDNdLFsxNiw1XSxbOSw0XSxbOSw0XSxbMjQsNl0sWzI3LDZdLFszOCw2XSxbNDMsMl0sWzQ1LDNdLFs0NSwxXSxbMjYsM10sWzgsNV0sWzgsNV0sWzExLDVdLFsxMiwzXSxbNTksNV0sWzYzLDFdLFs2MywxXSxbNjQsNV0sWzY5LDFdLFs3MSwzXSxbNzQsM10sWzIwLDFdLFsyMCwxXSxbMjAsMV0sWzIwLDFdLFsyMCwxXSxbMjAsMV0sWzIwLDFdLFs1NiwxXSxbNTYsMV0sWzc5LDJdLFs3OCwxXSxbODYsM10sWzg2LDFdLFs2LDBdLFs2LDJdLFsxNywxXSxbMTcsMl0sWzIxLDBdLFsyMSwyXSxbMjIsMF0sWzIyLDFdLFsyNSwwXSxbMjUsMV0sWzI4LDBdLFsyOCwxXSxbMzAsMF0sWzMwLDJdLFszMSwwXSxbMzEsMV0sWzMyLDBdLFszMiwxXSxbMzUsMF0sWzM1LDJdLFszNiwwXSxbMzYsMV0sWzM3LDBdLFszNywxXSxbNDAsMF0sWzQwLDJdLFs0MSwwXSxbNDEsMV0sWzQyLDBdLFs0MiwxXSxbNDYsMF0sWzQ2LDFdLFs0OSwwXSxbNDksMl0sWzUwLDBdLFs1MCwxXSxbNTIsMF0sWzUyLDJdLFs1MywwXSxbNTMsMV0sWzU3LDBdLFs1NywyXSxbNTgsMF0sWzU4LDFdLFs2MSwwXSxbNjEsMl0sWzYyLDBdLFs2MiwxXSxbNjYsMF0sWzY2LDJdLFs2NywwXSxbNjcsMV0sWzcwLDFdLFs3MCwyXSxbNzYsMV0sWzc2LDJdXSxcbnBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQseXlsZW5nLHl5bGluZW5vLHl5LHl5c3RhdGUsJCQsXyRcbi8qKi8pIHtcblxudmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbnN3aXRjaCAoeXlzdGF0ZSkge1xuY2FzZSAxOiByZXR1cm4gJCRbJDAtMV07IFxuYnJlYWs7XG5jYXNlIDI6dGhpcy4kID0geXkucHJlcGFyZVByb2dyYW0oJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAzOnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA0OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA1OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA2OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA3OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA4OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSA5OlxuICAgIHRoaXMuJCA9IHtcbiAgICAgIHR5cGU6ICdDb21tZW50U3RhdGVtZW50JyxcbiAgICAgIHZhbHVlOiB5eS5zdHJpcENvbW1lbnQoJCRbJDBdKSxcbiAgICAgIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwXSwgJCRbJDBdKSxcbiAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxuICAgIH07XG4gIFxuYnJlYWs7XG5jYXNlIDEwOlxuICAgIHRoaXMuJCA9IHtcbiAgICAgIHR5cGU6ICdDb250ZW50U3RhdGVtZW50JyxcbiAgICAgIG9yaWdpbmFsOiAkJFskMF0sXG4gICAgICB2YWx1ZTogJCRbJDBdLFxuICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXG4gICAgfTtcbiAgXG5icmVhaztcbmNhc2UgMTE6dGhpcy4kID0geXkucHJlcGFyZVJhd0Jsb2NrKCQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAxMjp0aGlzLiQgPSB7IHBhdGg6ICQkWyQwLTNdLCBwYXJhbXM6ICQkWyQwLTJdLCBoYXNoOiAkJFskMC0xXSB9O1xuYnJlYWs7XG5jYXNlIDEzOnRoaXMuJCA9IHl5LnByZXBhcmVCbG9jaygkJFskMC0zXSwgJCRbJDAtMl0sICQkWyQwLTFdLCAkJFskMF0sIGZhbHNlLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAxNDp0aGlzLiQgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAtM10sICQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDBdLCB0cnVlLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAxNTp0aGlzLiQgPSB7IG9wZW46ICQkWyQwLTVdLCBwYXRoOiAkJFskMC00XSwgcGFyYW1zOiAkJFskMC0zXSwgaGFzaDogJCRbJDAtMl0sIGJsb2NrUGFyYW1zOiAkJFskMC0xXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAtNV0sICQkWyQwXSkgfTtcbmJyZWFrO1xuY2FzZSAxNjp0aGlzLiQgPSB7IHBhdGg6ICQkWyQwLTRdLCBwYXJhbXM6ICQkWyQwLTNdLCBoYXNoOiAkJFskMC0yXSwgYmxvY2tQYXJhbXM6ICQkWyQwLTFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMC01XSwgJCRbJDBdKSB9O1xuYnJlYWs7XG5jYXNlIDE3OnRoaXMuJCA9IHsgcGF0aDogJCRbJDAtNF0sIHBhcmFtczogJCRbJDAtM10sIGhhc2g6ICQkWyQwLTJdLCBibG9ja1BhcmFtczogJCRbJDAtMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTVdLCAkJFskMF0pIH07XG5icmVhaztcbmNhc2UgMTg6dGhpcy4kID0geyBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMC0xXSwgJCRbJDAtMV0pLCBwcm9ncmFtOiAkJFskMF0gfTtcbmJyZWFrO1xuY2FzZSAxOTpcbiAgICB2YXIgaW52ZXJzZSA9IHl5LnByZXBhcmVCbG9jaygkJFskMC0yXSwgJCRbJDAtMV0sICQkWyQwXSwgJCRbJDBdLCBmYWxzZSwgdGhpcy5fJCksXG4gICAgICAgIHByb2dyYW0gPSB5eS5wcmVwYXJlUHJvZ3JhbShbaW52ZXJzZV0sICQkWyQwLTFdLmxvYyk7XG4gICAgcHJvZ3JhbS5jaGFpbmVkID0gdHJ1ZTtcblxuICAgIHRoaXMuJCA9IHsgc3RyaXA6ICQkWyQwLTJdLnN0cmlwLCBwcm9ncmFtOiBwcm9ncmFtLCBjaGFpbjogdHJ1ZSB9O1xuICBcbmJyZWFrO1xuY2FzZSAyMDp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMjE6dGhpcy4kID0ge3BhdGg6ICQkWyQwLTFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMC0yXSwgJCRbJDBdKX07XG5icmVhaztcbmNhc2UgMjI6dGhpcy4kID0geXkucHJlcGFyZU11c3RhY2hlKCQkWyQwLTNdLCAkJFskMC0yXSwgJCRbJDAtMV0sICQkWyQwLTRdLCB5eS5zdHJpcEZsYWdzKCQkWyQwLTRdLCAkJFskMF0pLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyMzp0aGlzLiQgPSB5eS5wcmVwYXJlTXVzdGFjaGUoJCRbJDAtM10sICQkWyQwLTJdLCAkJFskMC0xXSwgJCRbJDAtNF0sIHl5LnN0cmlwRmxhZ3MoJCRbJDAtNF0sICQkWyQwXSksIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDI0OlxuICAgIHRoaXMuJCA9IHtcbiAgICAgIHR5cGU6ICdQYXJ0aWFsU3RhdGVtZW50JyxcbiAgICAgIG5hbWU6ICQkWyQwLTNdLFxuICAgICAgcGFyYW1zOiAkJFskMC0yXSxcbiAgICAgIGhhc2g6ICQkWyQwLTFdLFxuICAgICAgaW5kZW50OiAnJyxcbiAgICAgIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTRdLCAkJFskMF0pLFxuICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXG4gICAgfTtcbiAgXG5icmVhaztcbmNhc2UgMjU6dGhpcy4kID0geXkucHJlcGFyZVBhcnRpYWxCbG9jaygkJFskMC0yXSwgJCRbJDAtMV0sICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMjY6dGhpcy4kID0geyBwYXRoOiAkJFskMC0zXSwgcGFyYW1zOiAkJFskMC0yXSwgaGFzaDogJCRbJDAtMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwLTRdLCAkJFskMF0pIH07XG5icmVhaztcbmNhc2UgMjc6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDI4OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAyOTpcbiAgICB0aGlzLiQgPSB7XG4gICAgICB0eXBlOiAnU3ViRXhwcmVzc2lvbicsXG4gICAgICBwYXRoOiAkJFskMC0zXSxcbiAgICAgIHBhcmFtczogJCRbJDAtMl0sXG4gICAgICBoYXNoOiAkJFskMC0xXSxcbiAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxuICAgIH07XG4gIFxuYnJlYWs7XG5jYXNlIDMwOnRoaXMuJCA9IHt0eXBlOiAnSGFzaCcsIHBhaXJzOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzE6dGhpcy4kID0ge3R5cGU6ICdIYXNoUGFpcicsIGtleTogeXkuaWQoJCRbJDAtMl0pLCB2YWx1ZTogJCRbJDBdLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCl9O1xuYnJlYWs7XG5jYXNlIDMyOnRoaXMuJCA9IHl5LmlkKCQkWyQwLTFdKTtcbmJyZWFrO1xuY2FzZSAzMzp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMzQ6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDM1OnRoaXMuJCA9IHt0eXBlOiAnU3RyaW5nTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0sIG9yaWdpbmFsOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzY6dGhpcy4kID0ge3R5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWU6IE51bWJlcigkJFskMF0pLCBvcmlnaW5hbDogTnVtYmVyKCQkWyQwXSksIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzc6dGhpcy4kID0ge3R5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0gPT09ICd0cnVlJywgb3JpZ2luYWw6ICQkWyQwXSA9PT0gJ3RydWUnLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCl9O1xuYnJlYWs7XG5jYXNlIDM4OnRoaXMuJCA9IHt0eXBlOiAnVW5kZWZpbmVkTGl0ZXJhbCcsIG9yaWdpbmFsOiB1bmRlZmluZWQsIHZhbHVlOiB1bmRlZmluZWQsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKX07XG5icmVhaztcbmNhc2UgMzk6dGhpcy4kID0ge3R5cGU6ICdOdWxsTGl0ZXJhbCcsIG9yaWdpbmFsOiBudWxsLCB2YWx1ZTogbnVsbCwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpfTtcbmJyZWFrO1xuY2FzZSA0MDp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgNDE6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDQyOnRoaXMuJCA9IHl5LnByZXBhcmVQYXRoKHRydWUsICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgNDM6dGhpcy4kID0geXkucHJlcGFyZVBhdGgoZmFsc2UsICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgNDQ6ICQkWyQwLTJdLnB1c2goe3BhcnQ6IHl5LmlkKCQkWyQwXSksIG9yaWdpbmFsOiAkJFskMF0sIHNlcGFyYXRvcjogJCRbJDAtMV19KTsgdGhpcy4kID0gJCRbJDAtMl07IFxuYnJlYWs7XG5jYXNlIDQ1OnRoaXMuJCA9IFt7cGFydDogeXkuaWQoJCRbJDBdKSwgb3JpZ2luYWw6ICQkWyQwXX1dO1xuYnJlYWs7XG5jYXNlIDQ2OnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDQ3OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA0ODp0aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSA0OTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNTA6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNTE6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDU4OnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDU5OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA2NDp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA2NTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgNzA6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNzE6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDc4OnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDc5OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA4Mjp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA4MzokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgODY6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgODc6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDkwOnRoaXMuJCA9IFtdO1xuYnJlYWs7XG5jYXNlIDkxOiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSA5NDp0aGlzLiQgPSBbXTtcbmJyZWFrO1xuY2FzZSA5NTokJFskMC0xXS5wdXNoKCQkWyQwXSk7XG5icmVhaztcbmNhc2UgOTg6dGhpcy4kID0gWyQkWyQwXV07XG5icmVhaztcbmNhc2UgOTk6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDEwMDp0aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxMDE6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MzoxLDQ6Miw1OlsyLDQ2XSw2OjMsMTQ6WzIsNDZdLDE1OlsyLDQ2XSwxOTpbMiw0Nl0sMjk6WzIsNDZdLDM0OlsyLDQ2XSw0ODpbMiw0Nl0sNTE6WzIsNDZdLDU1OlsyLDQ2XSw2MDpbMiw0Nl19LHsxOlszXX0sezU6WzEsNF19LHs1OlsyLDJdLDc6NSw4OjYsOTo3LDEwOjgsMTE6OSwxMjoxMCwxMzoxMSwxNDpbMSwxMl0sMTU6WzEsMjBdLDE2OjE3LDE5OlsxLDIzXSwyNDoxNSwyNzoxNiwyOTpbMSwyMV0sMzQ6WzEsMjJdLDM5OlsyLDJdLDQ0OlsyLDJdLDQ3OlsyLDJdLDQ4OlsxLDEzXSw1MTpbMSwxNF0sNTU6WzEsMThdLDU5OjE5LDYwOlsxLDI0XX0sezE6WzIsMV19LHs1OlsyLDQ3XSwxNDpbMiw0N10sMTU6WzIsNDddLDE5OlsyLDQ3XSwyOTpbMiw0N10sMzQ6WzIsNDddLDM5OlsyLDQ3XSw0NDpbMiw0N10sNDc6WzIsNDddLDQ4OlsyLDQ3XSw1MTpbMiw0N10sNTU6WzIsNDddLDYwOlsyLDQ3XX0sezU6WzIsM10sMTQ6WzIsM10sMTU6WzIsM10sMTk6WzIsM10sMjk6WzIsM10sMzQ6WzIsM10sMzk6WzIsM10sNDQ6WzIsM10sNDc6WzIsM10sNDg6WzIsM10sNTE6WzIsM10sNTU6WzIsM10sNjA6WzIsM119LHs1OlsyLDRdLDE0OlsyLDRdLDE1OlsyLDRdLDE5OlsyLDRdLDI5OlsyLDRdLDM0OlsyLDRdLDM5OlsyLDRdLDQ0OlsyLDRdLDQ3OlsyLDRdLDQ4OlsyLDRdLDUxOlsyLDRdLDU1OlsyLDRdLDYwOlsyLDRdfSx7NTpbMiw1XSwxNDpbMiw1XSwxNTpbMiw1XSwxOTpbMiw1XSwyOTpbMiw1XSwzNDpbMiw1XSwzOTpbMiw1XSw0NDpbMiw1XSw0NzpbMiw1XSw0ODpbMiw1XSw1MTpbMiw1XSw1NTpbMiw1XSw2MDpbMiw1XX0sezU6WzIsNl0sMTQ6WzIsNl0sMTU6WzIsNl0sMTk6WzIsNl0sMjk6WzIsNl0sMzQ6WzIsNl0sMzk6WzIsNl0sNDQ6WzIsNl0sNDc6WzIsNl0sNDg6WzIsNl0sNTE6WzIsNl0sNTU6WzIsNl0sNjA6WzIsNl19LHs1OlsyLDddLDE0OlsyLDddLDE1OlsyLDddLDE5OlsyLDddLDI5OlsyLDddLDM0OlsyLDddLDM5OlsyLDddLDQ0OlsyLDddLDQ3OlsyLDddLDQ4OlsyLDddLDUxOlsyLDddLDU1OlsyLDddLDYwOlsyLDddfSx7NTpbMiw4XSwxNDpbMiw4XSwxNTpbMiw4XSwxOTpbMiw4XSwyOTpbMiw4XSwzNDpbMiw4XSwzOTpbMiw4XSw0NDpbMiw4XSw0NzpbMiw4XSw0ODpbMiw4XSw1MTpbMiw4XSw1NTpbMiw4XSw2MDpbMiw4XX0sezU6WzIsOV0sMTQ6WzIsOV0sMTU6WzIsOV0sMTk6WzIsOV0sMjk6WzIsOV0sMzQ6WzIsOV0sMzk6WzIsOV0sNDQ6WzIsOV0sNDc6WzIsOV0sNDg6WzIsOV0sNTE6WzIsOV0sNTU6WzIsOV0sNjA6WzIsOV19LHsyMDoyNSw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDozNiw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs0OjM3LDY6MywxNDpbMiw0Nl0sMTU6WzIsNDZdLDE5OlsyLDQ2XSwyOTpbMiw0Nl0sMzQ6WzIsNDZdLDM5OlsyLDQ2XSw0NDpbMiw0Nl0sNDc6WzIsNDZdLDQ4OlsyLDQ2XSw1MTpbMiw0Nl0sNTU6WzIsNDZdLDYwOlsyLDQ2XX0sezQ6MzgsNjozLDE0OlsyLDQ2XSwxNTpbMiw0Nl0sMTk6WzIsNDZdLDI5OlsyLDQ2XSwzNDpbMiw0Nl0sNDQ6WzIsNDZdLDQ3OlsyLDQ2XSw0ODpbMiw0Nl0sNTE6WzIsNDZdLDU1OlsyLDQ2XSw2MDpbMiw0Nl19LHsxMzo0MCwxNTpbMSwyMF0sMTc6Mzl9LHsyMDo0Miw1Njo0MSw2NDo0Myw2NTpbMSw0NF0sNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7NDo0NSw2OjMsMTQ6WzIsNDZdLDE1OlsyLDQ2XSwxOTpbMiw0Nl0sMjk6WzIsNDZdLDM0OlsyLDQ2XSw0NzpbMiw0Nl0sNDg6WzIsNDZdLDUxOlsyLDQ2XSw1NTpbMiw0Nl0sNjA6WzIsNDZdfSx7NTpbMiwxMF0sMTQ6WzIsMTBdLDE1OlsyLDEwXSwxODpbMiwxMF0sMTk6WzIsMTBdLDI5OlsyLDEwXSwzNDpbMiwxMF0sMzk6WzIsMTBdLDQ0OlsyLDEwXSw0NzpbMiwxMF0sNDg6WzIsMTBdLDUxOlsyLDEwXSw1NTpbMiwxMF0sNjA6WzIsMTBdfSx7MjA6NDYsNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjA6NDcsNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjA6NDgsNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjA6NDIsNTY6NDksNjQ6NDMsNjU6WzEsNDRdLDcyOlsxLDM1XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezMzOlsyLDc4XSw0OTo1MCw2NTpbMiw3OF0sNzI6WzIsNzhdLDgwOlsyLDc4XSw4MTpbMiw3OF0sODI6WzIsNzhdLDgzOlsyLDc4XSw4NDpbMiw3OF0sODU6WzIsNzhdfSx7MjM6WzIsMzNdLDMzOlsyLDMzXSw1NDpbMiwzM10sNjU6WzIsMzNdLDY4OlsyLDMzXSw3MjpbMiwzM10sNzU6WzIsMzNdLDgwOlsyLDMzXSw4MTpbMiwzM10sODI6WzIsMzNdLDgzOlsyLDMzXSw4NDpbMiwzM10sODU6WzIsMzNdfSx7MjM6WzIsMzRdLDMzOlsyLDM0XSw1NDpbMiwzNF0sNjU6WzIsMzRdLDY4OlsyLDM0XSw3MjpbMiwzNF0sNzU6WzIsMzRdLDgwOlsyLDM0XSw4MTpbMiwzNF0sODI6WzIsMzRdLDgzOlsyLDM0XSw4NDpbMiwzNF0sODU6WzIsMzRdfSx7MjM6WzIsMzVdLDMzOlsyLDM1XSw1NDpbMiwzNV0sNjU6WzIsMzVdLDY4OlsyLDM1XSw3MjpbMiwzNV0sNzU6WzIsMzVdLDgwOlsyLDM1XSw4MTpbMiwzNV0sODI6WzIsMzVdLDgzOlsyLDM1XSw4NDpbMiwzNV0sODU6WzIsMzVdfSx7MjM6WzIsMzZdLDMzOlsyLDM2XSw1NDpbMiwzNl0sNjU6WzIsMzZdLDY4OlsyLDM2XSw3MjpbMiwzNl0sNzU6WzIsMzZdLDgwOlsyLDM2XSw4MTpbMiwzNl0sODI6WzIsMzZdLDgzOlsyLDM2XSw4NDpbMiwzNl0sODU6WzIsMzZdfSx7MjM6WzIsMzddLDMzOlsyLDM3XSw1NDpbMiwzN10sNjU6WzIsMzddLDY4OlsyLDM3XSw3MjpbMiwzN10sNzU6WzIsMzddLDgwOlsyLDM3XSw4MTpbMiwzN10sODI6WzIsMzddLDgzOlsyLDM3XSw4NDpbMiwzN10sODU6WzIsMzddfSx7MjM6WzIsMzhdLDMzOlsyLDM4XSw1NDpbMiwzOF0sNjU6WzIsMzhdLDY4OlsyLDM4XSw3MjpbMiwzOF0sNzU6WzIsMzhdLDgwOlsyLDM4XSw4MTpbMiwzOF0sODI6WzIsMzhdLDgzOlsyLDM4XSw4NDpbMiwzOF0sODU6WzIsMzhdfSx7MjM6WzIsMzldLDMzOlsyLDM5XSw1NDpbMiwzOV0sNjU6WzIsMzldLDY4OlsyLDM5XSw3MjpbMiwzOV0sNzU6WzIsMzldLDgwOlsyLDM5XSw4MTpbMiwzOV0sODI6WzIsMzldLDgzOlsyLDM5XSw4NDpbMiwzOV0sODU6WzIsMzldfSx7MjM6WzIsNDNdLDMzOlsyLDQzXSw1NDpbMiw0M10sNjU6WzIsNDNdLDY4OlsyLDQzXSw3MjpbMiw0M10sNzU6WzIsNDNdLDgwOlsyLDQzXSw4MTpbMiw0M10sODI6WzIsNDNdLDgzOlsyLDQzXSw4NDpbMiw0M10sODU6WzIsNDNdLDg3OlsxLDUxXX0sezcyOlsxLDM1XSw4Njo1Mn0sezIzOlsyLDQ1XSwzMzpbMiw0NV0sNTQ6WzIsNDVdLDY1OlsyLDQ1XSw2ODpbMiw0NV0sNzI6WzIsNDVdLDc1OlsyLDQ1XSw4MDpbMiw0NV0sODE6WzIsNDVdLDgyOlsyLDQ1XSw4MzpbMiw0NV0sODQ6WzIsNDVdLDg1OlsyLDQ1XSw4NzpbMiw0NV19LHs1Mjo1Myw1NDpbMiw4Ml0sNjU6WzIsODJdLDcyOlsyLDgyXSw4MDpbMiw4Ml0sODE6WzIsODJdLDgyOlsyLDgyXSw4MzpbMiw4Ml0sODQ6WzIsODJdLDg1OlsyLDgyXX0sezI1OjU0LDM4OjU2LDM5OlsxLDU4XSw0Mzo1Nyw0NDpbMSw1OV0sNDU6NTUsNDc6WzIsNTRdfSx7Mjg6NjAsNDM6NjEsNDQ6WzEsNTldLDQ3OlsyLDU2XX0sezEzOjYzLDE1OlsxLDIwXSwxODpbMSw2Ml19LHsxNTpbMiw0OF0sMTg6WzIsNDhdfSx7MzM6WzIsODZdLDU3OjY0LDY1OlsyLDg2XSw3MjpbMiw4Nl0sODA6WzIsODZdLDgxOlsyLDg2XSw4MjpbMiw4Nl0sODM6WzIsODZdLDg0OlsyLDg2XSw4NTpbMiw4Nl19LHszMzpbMiw0MF0sNjU6WzIsNDBdLDcyOlsyLDQwXSw4MDpbMiw0MF0sODE6WzIsNDBdLDgyOlsyLDQwXSw4MzpbMiw0MF0sODQ6WzIsNDBdLDg1OlsyLDQwXX0sezMzOlsyLDQxXSw2NTpbMiw0MV0sNzI6WzIsNDFdLDgwOlsyLDQxXSw4MTpbMiw0MV0sODI6WzIsNDFdLDgzOlsyLDQxXSw4NDpbMiw0MV0sODU6WzIsNDFdfSx7MjA6NjUsNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjY6NjYsNDc6WzEsNjddfSx7MzA6NjgsMzM6WzIsNThdLDY1OlsyLDU4XSw3MjpbMiw1OF0sNzU6WzIsNThdLDgwOlsyLDU4XSw4MTpbMiw1OF0sODI6WzIsNThdLDgzOlsyLDU4XSw4NDpbMiw1OF0sODU6WzIsNThdfSx7MzM6WzIsNjRdLDM1OjY5LDY1OlsyLDY0XSw3MjpbMiw2NF0sNzU6WzIsNjRdLDgwOlsyLDY0XSw4MTpbMiw2NF0sODI6WzIsNjRdLDgzOlsyLDY0XSw4NDpbMiw2NF0sODU6WzIsNjRdfSx7MjE6NzAsMjM6WzIsNTBdLDY1OlsyLDUwXSw3MjpbMiw1MF0sODA6WzIsNTBdLDgxOlsyLDUwXSw4MjpbMiw1MF0sODM6WzIsNTBdLDg0OlsyLDUwXSw4NTpbMiw1MF19LHszMzpbMiw5MF0sNjE6NzEsNjU6WzIsOTBdLDcyOlsyLDkwXSw4MDpbMiw5MF0sODE6WzIsOTBdLDgyOlsyLDkwXSw4MzpbMiw5MF0sODQ6WzIsOTBdLDg1OlsyLDkwXX0sezIwOjc1LDMzOlsyLDgwXSw1MDo3Miw2Mzo3Myw2NDo3Niw2NTpbMSw0NF0sNjk6NzQsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7NzI6WzEsODBdfSx7MjM6WzIsNDJdLDMzOlsyLDQyXSw1NDpbMiw0Ml0sNjU6WzIsNDJdLDY4OlsyLDQyXSw3MjpbMiw0Ml0sNzU6WzIsNDJdLDgwOlsyLDQyXSw4MTpbMiw0Ml0sODI6WzIsNDJdLDgzOlsyLDQyXSw4NDpbMiw0Ml0sODU6WzIsNDJdLDg3OlsxLDUxXX0sezIwOjc1LDUzOjgxLDU0OlsyLDg0XSw2Mzo4Miw2NDo3Niw2NTpbMSw0NF0sNjk6ODMsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MjY6ODQsNDc6WzEsNjddfSx7NDc6WzIsNTVdfSx7NDo4NSw2OjMsMTQ6WzIsNDZdLDE1OlsyLDQ2XSwxOTpbMiw0Nl0sMjk6WzIsNDZdLDM0OlsyLDQ2XSwzOTpbMiw0Nl0sNDQ6WzIsNDZdLDQ3OlsyLDQ2XSw0ODpbMiw0Nl0sNTE6WzIsNDZdLDU1OlsyLDQ2XSw2MDpbMiw0Nl19LHs0NzpbMiwyMF19LHsyMDo4Niw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs0Ojg3LDY6MywxNDpbMiw0Nl0sMTU6WzIsNDZdLDE5OlsyLDQ2XSwyOTpbMiw0Nl0sMzQ6WzIsNDZdLDQ3OlsyLDQ2XSw0ODpbMiw0Nl0sNTE6WzIsNDZdLDU1OlsyLDQ2XSw2MDpbMiw0Nl19LHsyNjo4OCw0NzpbMSw2N119LHs0NzpbMiw1N119LHs1OlsyLDExXSwxNDpbMiwxMV0sMTU6WzIsMTFdLDE5OlsyLDExXSwyOTpbMiwxMV0sMzQ6WzIsMTFdLDM5OlsyLDExXSw0NDpbMiwxMV0sNDc6WzIsMTFdLDQ4OlsyLDExXSw1MTpbMiwxMV0sNTU6WzIsMTFdLDYwOlsyLDExXX0sezE1OlsyLDQ5XSwxODpbMiw0OV19LHsyMDo3NSwzMzpbMiw4OF0sNTg6ODksNjM6OTAsNjQ6NzYsNjU6WzEsNDRdLDY5OjkxLDcwOjc3LDcxOjc4LDcyOlsxLDc5XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezY1OlsyLDk0XSw2Njo5Miw2ODpbMiw5NF0sNzI6WzIsOTRdLDgwOlsyLDk0XSw4MTpbMiw5NF0sODI6WzIsOTRdLDgzOlsyLDk0XSw4NDpbMiw5NF0sODU6WzIsOTRdfSx7NTpbMiwyNV0sMTQ6WzIsMjVdLDE1OlsyLDI1XSwxOTpbMiwyNV0sMjk6WzIsMjVdLDM0OlsyLDI1XSwzOTpbMiwyNV0sNDQ6WzIsMjVdLDQ3OlsyLDI1XSw0ODpbMiwyNV0sNTE6WzIsMjVdLDU1OlsyLDI1XSw2MDpbMiwyNV19LHsyMDo5Myw3MjpbMSwzNV0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo3NSwzMTo5NCwzMzpbMiw2MF0sNjM6OTUsNjQ6NzYsNjU6WzEsNDRdLDY5Ojk2LDcwOjc3LDcxOjc4LDcyOlsxLDc5XSw3NTpbMiw2MF0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo3NSwzMzpbMiw2Nl0sMzY6OTcsNjM6OTgsNjQ6NzYsNjU6WzEsNDRdLDY5Ojk5LDcwOjc3LDcxOjc4LDcyOlsxLDc5XSw3NTpbMiw2Nl0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHsyMDo3NSwyMjoxMDAsMjM6WzIsNTJdLDYzOjEwMSw2NDo3Niw2NTpbMSw0NF0sNjk6MTAyLDcwOjc3LDcxOjc4LDcyOlsxLDc5XSw3ODoyNiw3OToyNyw4MDpbMSwyOF0sODE6WzEsMjldLDgyOlsxLDMwXSw4MzpbMSwzMV0sODQ6WzEsMzJdLDg1OlsxLDM0XSw4NjozM30sezIwOjc1LDMzOlsyLDkyXSw2MjoxMDMsNjM6MTA0LDY0Ojc2LDY1OlsxLDQ0XSw2OToxMDUsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MzM6WzEsMTA2XX0sezMzOlsyLDc5XSw2NTpbMiw3OV0sNzI6WzIsNzldLDgwOlsyLDc5XSw4MTpbMiw3OV0sODI6WzIsNzldLDgzOlsyLDc5XSw4NDpbMiw3OV0sODU6WzIsNzldfSx7MzM6WzIsODFdfSx7MjM6WzIsMjddLDMzOlsyLDI3XSw1NDpbMiwyN10sNjU6WzIsMjddLDY4OlsyLDI3XSw3MjpbMiwyN10sNzU6WzIsMjddLDgwOlsyLDI3XSw4MTpbMiwyN10sODI6WzIsMjddLDgzOlsyLDI3XSw4NDpbMiwyN10sODU6WzIsMjddfSx7MjM6WzIsMjhdLDMzOlsyLDI4XSw1NDpbMiwyOF0sNjU6WzIsMjhdLDY4OlsyLDI4XSw3MjpbMiwyOF0sNzU6WzIsMjhdLDgwOlsyLDI4XSw4MTpbMiwyOF0sODI6WzIsMjhdLDgzOlsyLDI4XSw4NDpbMiwyOF0sODU6WzIsMjhdfSx7MjM6WzIsMzBdLDMzOlsyLDMwXSw1NDpbMiwzMF0sNjg6WzIsMzBdLDcxOjEwNyw3MjpbMSwxMDhdLDc1OlsyLDMwXX0sezIzOlsyLDk4XSwzMzpbMiw5OF0sNTQ6WzIsOThdLDY4OlsyLDk4XSw3MjpbMiw5OF0sNzU6WzIsOThdfSx7MjM6WzIsNDVdLDMzOlsyLDQ1XSw1NDpbMiw0NV0sNjU6WzIsNDVdLDY4OlsyLDQ1XSw3MjpbMiw0NV0sNzM6WzEsMTA5XSw3NTpbMiw0NV0sODA6WzIsNDVdLDgxOlsyLDQ1XSw4MjpbMiw0NV0sODM6WzIsNDVdLDg0OlsyLDQ1XSw4NTpbMiw0NV0sODc6WzIsNDVdfSx7MjM6WzIsNDRdLDMzOlsyLDQ0XSw1NDpbMiw0NF0sNjU6WzIsNDRdLDY4OlsyLDQ0XSw3MjpbMiw0NF0sNzU6WzIsNDRdLDgwOlsyLDQ0XSw4MTpbMiw0NF0sODI6WzIsNDRdLDgzOlsyLDQ0XSw4NDpbMiw0NF0sODU6WzIsNDRdLDg3OlsyLDQ0XX0sezU0OlsxLDExMF19LHs1NDpbMiw4M10sNjU6WzIsODNdLDcyOlsyLDgzXSw4MDpbMiw4M10sODE6WzIsODNdLDgyOlsyLDgzXSw4MzpbMiw4M10sODQ6WzIsODNdLDg1OlsyLDgzXX0sezU0OlsyLDg1XX0sezU6WzIsMTNdLDE0OlsyLDEzXSwxNTpbMiwxM10sMTk6WzIsMTNdLDI5OlsyLDEzXSwzNDpbMiwxM10sMzk6WzIsMTNdLDQ0OlsyLDEzXSw0NzpbMiwxM10sNDg6WzIsMTNdLDUxOlsyLDEzXSw1NTpbMiwxM10sNjA6WzIsMTNdfSx7Mzg6NTYsMzk6WzEsNThdLDQzOjU3LDQ0OlsxLDU5XSw0NToxMTIsNDY6MTExLDQ3OlsyLDc2XX0sezMzOlsyLDcwXSw0MDoxMTMsNjU6WzIsNzBdLDcyOlsyLDcwXSw3NTpbMiw3MF0sODA6WzIsNzBdLDgxOlsyLDcwXSw4MjpbMiw3MF0sODM6WzIsNzBdLDg0OlsyLDcwXSw4NTpbMiw3MF19LHs0NzpbMiwxOF19LHs1OlsyLDE0XSwxNDpbMiwxNF0sMTU6WzIsMTRdLDE5OlsyLDE0XSwyOTpbMiwxNF0sMzQ6WzIsMTRdLDM5OlsyLDE0XSw0NDpbMiwxNF0sNDc6WzIsMTRdLDQ4OlsyLDE0XSw1MTpbMiwxNF0sNTU6WzIsMTRdLDYwOlsyLDE0XX0sezMzOlsxLDExNF19LHszMzpbMiw4N10sNjU6WzIsODddLDcyOlsyLDg3XSw4MDpbMiw4N10sODE6WzIsODddLDgyOlsyLDg3XSw4MzpbMiw4N10sODQ6WzIsODddLDg1OlsyLDg3XX0sezMzOlsyLDg5XX0sezIwOjc1LDYzOjExNiw2NDo3Niw2NTpbMSw0NF0sNjc6MTE1LDY4OlsyLDk2XSw2OToxMTcsNzA6NzcsNzE6NzgsNzI6WzEsNzldLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7MzM6WzEsMTE4XX0sezMyOjExOSwzMzpbMiw2Ml0sNzQ6MTIwLDc1OlsxLDEyMV19LHszMzpbMiw1OV0sNjU6WzIsNTldLDcyOlsyLDU5XSw3NTpbMiw1OV0sODA6WzIsNTldLDgxOlsyLDU5XSw4MjpbMiw1OV0sODM6WzIsNTldLDg0OlsyLDU5XSw4NTpbMiw1OV19LHszMzpbMiw2MV0sNzU6WzIsNjFdfSx7MzM6WzIsNjhdLDM3OjEyMiw3NDoxMjMsNzU6WzEsMTIxXX0sezMzOlsyLDY1XSw2NTpbMiw2NV0sNzI6WzIsNjVdLDc1OlsyLDY1XSw4MDpbMiw2NV0sODE6WzIsNjVdLDgyOlsyLDY1XSw4MzpbMiw2NV0sODQ6WzIsNjVdLDg1OlsyLDY1XX0sezMzOlsyLDY3XSw3NTpbMiw2N119LHsyMzpbMSwxMjRdfSx7MjM6WzIsNTFdLDY1OlsyLDUxXSw3MjpbMiw1MV0sODA6WzIsNTFdLDgxOlsyLDUxXSw4MjpbMiw1MV0sODM6WzIsNTFdLDg0OlsyLDUxXSw4NTpbMiw1MV19LHsyMzpbMiw1M119LHszMzpbMSwxMjVdfSx7MzM6WzIsOTFdLDY1OlsyLDkxXSw3MjpbMiw5MV0sODA6WzIsOTFdLDgxOlsyLDkxXSw4MjpbMiw5MV0sODM6WzIsOTFdLDg0OlsyLDkxXSw4NTpbMiw5MV19LHszMzpbMiw5M119LHs1OlsyLDIyXSwxNDpbMiwyMl0sMTU6WzIsMjJdLDE5OlsyLDIyXSwyOTpbMiwyMl0sMzQ6WzIsMjJdLDM5OlsyLDIyXSw0NDpbMiwyMl0sNDc6WzIsMjJdLDQ4OlsyLDIyXSw1MTpbMiwyMl0sNTU6WzIsMjJdLDYwOlsyLDIyXX0sezIzOlsyLDk5XSwzMzpbMiw5OV0sNTQ6WzIsOTldLDY4OlsyLDk5XSw3MjpbMiw5OV0sNzU6WzIsOTldfSx7NzM6WzEsMTA5XX0sezIwOjc1LDYzOjEyNiw2NDo3Niw2NTpbMSw0NF0sNzI6WzEsMzVdLDc4OjI2LDc5OjI3LDgwOlsxLDI4XSw4MTpbMSwyOV0sODI6WzEsMzBdLDgzOlsxLDMxXSw4NDpbMSwzMl0sODU6WzEsMzRdLDg2OjMzfSx7NTpbMiwyM10sMTQ6WzIsMjNdLDE1OlsyLDIzXSwxOTpbMiwyM10sMjk6WzIsMjNdLDM0OlsyLDIzXSwzOTpbMiwyM10sNDQ6WzIsMjNdLDQ3OlsyLDIzXSw0ODpbMiwyM10sNTE6WzIsMjNdLDU1OlsyLDIzXSw2MDpbMiwyM119LHs0NzpbMiwxOV19LHs0NzpbMiw3N119LHsyMDo3NSwzMzpbMiw3Ml0sNDE6MTI3LDYzOjEyOCw2NDo3Niw2NTpbMSw0NF0sNjk6MTI5LDcwOjc3LDcxOjc4LDcyOlsxLDc5XSw3NTpbMiw3Ml0sNzg6MjYsNzk6MjcsODA6WzEsMjhdLDgxOlsxLDI5XSw4MjpbMSwzMF0sODM6WzEsMzFdLDg0OlsxLDMyXSw4NTpbMSwzNF0sODY6MzN9LHs1OlsyLDI0XSwxNDpbMiwyNF0sMTU6WzIsMjRdLDE5OlsyLDI0XSwyOTpbMiwyNF0sMzQ6WzIsMjRdLDM5OlsyLDI0XSw0NDpbMiwyNF0sNDc6WzIsMjRdLDQ4OlsyLDI0XSw1MTpbMiwyNF0sNTU6WzIsMjRdLDYwOlsyLDI0XX0sezY4OlsxLDEzMF19LHs2NTpbMiw5NV0sNjg6WzIsOTVdLDcyOlsyLDk1XSw4MDpbMiw5NV0sODE6WzIsOTVdLDgyOlsyLDk1XSw4MzpbMiw5NV0sODQ6WzIsOTVdLDg1OlsyLDk1XX0sezY4OlsyLDk3XX0sezU6WzIsMjFdLDE0OlsyLDIxXSwxNTpbMiwyMV0sMTk6WzIsMjFdLDI5OlsyLDIxXSwzNDpbMiwyMV0sMzk6WzIsMjFdLDQ0OlsyLDIxXSw0NzpbMiwyMV0sNDg6WzIsMjFdLDUxOlsyLDIxXSw1NTpbMiwyMV0sNjA6WzIsMjFdfSx7MzM6WzEsMTMxXX0sezMzOlsyLDYzXX0sezcyOlsxLDEzM10sNzY6MTMyfSx7MzM6WzEsMTM0XX0sezMzOlsyLDY5XX0sezE1OlsyLDEyXX0sezE0OlsyLDI2XSwxNTpbMiwyNl0sMTk6WzIsMjZdLDI5OlsyLDI2XSwzNDpbMiwyNl0sNDc6WzIsMjZdLDQ4OlsyLDI2XSw1MTpbMiwyNl0sNTU6WzIsMjZdLDYwOlsyLDI2XX0sezIzOlsyLDMxXSwzMzpbMiwzMV0sNTQ6WzIsMzFdLDY4OlsyLDMxXSw3MjpbMiwzMV0sNzU6WzIsMzFdfSx7MzM6WzIsNzRdLDQyOjEzNSw3NDoxMzYsNzU6WzEsMTIxXX0sezMzOlsyLDcxXSw2NTpbMiw3MV0sNzI6WzIsNzFdLDc1OlsyLDcxXSw4MDpbMiw3MV0sODE6WzIsNzFdLDgyOlsyLDcxXSw4MzpbMiw3MV0sODQ6WzIsNzFdLDg1OlsyLDcxXX0sezMzOlsyLDczXSw3NTpbMiw3M119LHsyMzpbMiwyOV0sMzM6WzIsMjldLDU0OlsyLDI5XSw2NTpbMiwyOV0sNjg6WzIsMjldLDcyOlsyLDI5XSw3NTpbMiwyOV0sODA6WzIsMjldLDgxOlsyLDI5XSw4MjpbMiwyOV0sODM6WzIsMjldLDg0OlsyLDI5XSw4NTpbMiwyOV19LHsxNDpbMiwxNV0sMTU6WzIsMTVdLDE5OlsyLDE1XSwyOTpbMiwxNV0sMzQ6WzIsMTVdLDM5OlsyLDE1XSw0NDpbMiwxNV0sNDc6WzIsMTVdLDQ4OlsyLDE1XSw1MTpbMiwxNV0sNTU6WzIsMTVdLDYwOlsyLDE1XX0sezcyOlsxLDEzOF0sNzc6WzEsMTM3XX0sezcyOlsyLDEwMF0sNzc6WzIsMTAwXX0sezE0OlsyLDE2XSwxNTpbMiwxNl0sMTk6WzIsMTZdLDI5OlsyLDE2XSwzNDpbMiwxNl0sNDQ6WzIsMTZdLDQ3OlsyLDE2XSw0ODpbMiwxNl0sNTE6WzIsMTZdLDU1OlsyLDE2XSw2MDpbMiwxNl19LHszMzpbMSwxMzldfSx7MzM6WzIsNzVdfSx7MzM6WzIsMzJdfSx7NzI6WzIsMTAxXSw3NzpbMiwxMDFdfSx7MTQ6WzIsMTddLDE1OlsyLDE3XSwxOTpbMiwxN10sMjk6WzIsMTddLDM0OlsyLDE3XSwzOTpbMiwxN10sNDQ6WzIsMTddLDQ3OlsyLDE3XSw0ODpbMiwxN10sNTE6WzIsMTddLDU1OlsyLDE3XSw2MDpbMiwxN119XSxcbmRlZmF1bHRBY3Rpb25zOiB7NDpbMiwxXSw1NTpbMiw1NV0sNTc6WzIsMjBdLDYxOlsyLDU3XSw3NDpbMiw4MV0sODM6WzIsODVdLDg3OlsyLDE4XSw5MTpbMiw4OV0sMTAyOlsyLDUzXSwxMDU6WzIsOTNdLDExMTpbMiwxOV0sMTEyOlsyLDc3XSwxMTc6WzIsOTddLDEyMDpbMiw2M10sMTIzOlsyLDY5XSwxMjQ6WzIsMTJdLDEzNjpbMiw3NV0sMTM3OlsyLDMyXX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gXCJcIiwgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB0aGlzLmxleGVyLnNldElucHV0KGlucHV0KTtcbiAgICB0aGlzLmxleGVyLnl5ID0gdGhpcy55eTtcbiAgICB0aGlzLnl5LmxleGVyID0gdGhpcy5sZXhlcjtcbiAgICB0aGlzLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxleGVyLnl5bGxvYyA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLmxleGVyLnl5bGxvYyA9IHt9O1xuICAgIHZhciB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5sZXhlci5vcHRpb25zICYmIHRoaXMubGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy55eS5wYXJzZUVycm9yO1xuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSBzZWxmLmxleGVyLmxleCgpIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgdmFyIGVyclN0ciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjpcXG5cIiArIHRoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyBcIlxcbkV4cGVjdGluZyBcIiArIGV4cGVjdGVkLmpvaW4oXCIsIFwiKSArIFwiLCBnb3QgJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOiBVbmV4cGVjdGVkIFwiICsgKHN5bWJvbCA9PSAxP1wiZW5kIG9mIGlucHV0XCI6XCInXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge3RleHQ6IHRoaXMubGV4ZXIubWF0Y2gsIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsIGxpbmU6IHRoaXMubGV4ZXIueXlsaW5lbm8sIGxvYzogeXlsb2MsIGV4cGVjdGVkOiBleHBlY3RlZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6IFwiICsgc3RhdGUgKyBcIiwgdG9rZW46IFwiICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh0aGlzLmxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh0aGlzLmxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IHRoaXMubGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IHRoaXMubGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1ufTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB0aGlzLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbn07XG4vKiBKaXNvbiBnZW5lcmF0ZWQgbGV4ZXIgKi9cbnZhciBsZXhlciA9IChmdW5jdGlvbigpe1xudmFyIGxleGVyID0gKHtFT0Y6MSxcbnBhcnNlRXJyb3I6ZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgfVxuICAgIH0sXG5zZXRJbnB1dDpmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2xlc3MgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZToxLGZpcnN0X2NvbHVtbjowLGxhc3RfbGluZToxLGxhc3RfY29sdW1uOjB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoLWxlbi0xKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGgtMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aC0xKTtcblxuICAgICAgICBpZiAobGluZXMubGVuZ3RoLTEpIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoLTE7XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG5cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8rMSxcbiAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKSArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5tb3JlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcbnBhc3RJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXN0ID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gdGhpcy5tYXRjaC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJzonJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApKyhuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjK1wiXlwiO1xuICAgIH0sXG5uZXh0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGNvbCxcbiAgICAgICAgICAgIGxpbmVzO1xuICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG4gICAgICAgIGZvciAodmFyIGk9MDtpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICAgICAgaWYgKGxpbmVzKSB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jID0ge2ZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubysxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aC0xXS5sZW5ndGgtbGluZXNbbGluZXMubGVuZ3RoLTFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RofTtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIHJ1bGVzW2luZGV4XSx0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTFdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnKyh0aGlzLnl5bGluZW5vKzEpKycuIFVucmVjb2duaXplZCB0ZXh0LlxcbicrdGhpcy5zaG93UG9zaXRpb24oKSxcbiAgICAgICAgICAgICAgICAgICAge3RleHQ6IFwiXCIsIHRva2VuOiBudWxsLCBsaW5lOiB0aGlzLnl5bGluZW5vfSk7XG4gICAgICAgIH1cbiAgICB9LFxubGV4OmZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICB9LFxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV1dLnJ1bGVzO1xuICAgIH0sXG50b3BTdGF0ZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoLTJdO1xuICAgIH0sXG5wdXNoU3RhdGU6ZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9fSk7XG5sZXhlci5vcHRpb25zID0ge307XG5sZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUXG4vKiovKSB7XG5cblxuZnVuY3Rpb24gc3RyaXAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4geXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKHN0YXJ0LCB5eV8ueXlsZW5nLWVuZCk7XG59XG5cblxudmFyIFlZU1RBVEU9WVlfU1RBUlRcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHl5Xy55eXRleHQuc2xpY2UoLTIpID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcCgwLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJtdVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHl5Xy55eXRleHQuc2xpY2UoLTEpID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwKDAsMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcImVtdVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwibXVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeXlfLnl5dGV4dCkgcmV0dXJuIDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5icmVhaztcbmNhc2UgMTpyZXR1cm4gMTU7XG5icmVhaztcbmNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmJyZWFrO1xuY2FzZSAzOnRoaXMuYmVnaW4oJ3JhdycpOyByZXR1cm4gMTU7XG5icmVhaztcbmNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHVzaW5nIGB0aGlzLnRvcFN0YXRlKClgIGJlbG93LCBidXQgaXQgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgc2Vjb25kIHRvcCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCB0b3AuIE9wZW5lZCBhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlIGFib3V0IGl0IGF0IGh0dHBzOi8vZ2l0aHViLmNvbS96YWFjaC9qaXNvbi9pc3N1ZXMvMjkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV0gPT09ICdyYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cig1LCB5eV8ueXlsZW5nLTkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdFTkRfUkFXX0JMT0NLJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmJyZWFrO1xuY2FzZSA1OiByZXR1cm4gMTU7IFxuYnJlYWs7XG5jYXNlIDY6XG4gIHRoaXMucG9wU3RhdGUoKTtcbiAgcmV0dXJuIDE0O1xuXG5icmVhaztcbmNhc2UgNzpyZXR1cm4gNjU7XG5icmVhaztcbmNhc2UgODpyZXR1cm4gNjg7XG5icmVhaztcbmNhc2UgOTogcmV0dXJuIDE5OyBcbmJyZWFrO1xuY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbigncmF3Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5icmVhaztcbmNhc2UgMTE6cmV0dXJuIDU1O1xuYnJlYWs7XG5jYXNlIDEyOnJldHVybiA2MDtcbmJyZWFrO1xuY2FzZSAxMzpyZXR1cm4gMjk7XG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDQ3O1xuYnJlYWs7XG5jYXNlIDE1OnRoaXMucG9wU3RhdGUoKTsgcmV0dXJuIDQ0O1xuYnJlYWs7XG5jYXNlIDE2OnRoaXMucG9wU3RhdGUoKTsgcmV0dXJuIDQ0O1xuYnJlYWs7XG5jYXNlIDE3OnJldHVybiAzNDtcbmJyZWFrO1xuY2FzZSAxODpyZXR1cm4gMzk7XG5icmVhaztcbmNhc2UgMTk6cmV0dXJuIDUxO1xuYnJlYWs7XG5jYXNlIDIwOnJldHVybiA0ODtcbmJyZWFrO1xuY2FzZSAyMTpcbiAgdGhpcy51bnB1dCh5eV8ueXl0ZXh0KTtcbiAgdGhpcy5wb3BTdGF0ZSgpO1xuICB0aGlzLmJlZ2luKCdjb20nKTtcblxuYnJlYWs7XG5jYXNlIDIyOlxuICB0aGlzLnBvcFN0YXRlKCk7XG4gIHJldHVybiAxNDtcblxuYnJlYWs7XG5jYXNlIDIzOnJldHVybiA0ODtcbmJyZWFrO1xuY2FzZSAyNDpyZXR1cm4gNzM7XG5icmVhaztcbmNhc2UgMjU6cmV0dXJuIDcyO1xuYnJlYWs7XG5jYXNlIDI2OnJldHVybiA3MjtcbmJyZWFrO1xuY2FzZSAyNzpyZXR1cm4gODc7XG5icmVhaztcbmNhc2UgMjg6Ly8gaWdub3JlIHdoaXRlc3BhY2VcbmJyZWFrO1xuY2FzZSAyOTp0aGlzLnBvcFN0YXRlKCk7IHJldHVybiA1NDtcbmJyZWFrO1xuY2FzZSAzMDp0aGlzLnBvcFN0YXRlKCk7IHJldHVybiAzMztcbmJyZWFrO1xuY2FzZSAzMTp5eV8ueXl0ZXh0ID0gc3RyaXAoMSwyKS5yZXBsYWNlKC9cXFxcXCIvZywnXCInKTsgcmV0dXJuIDgwO1xuYnJlYWs7XG5jYXNlIDMyOnl5Xy55eXRleHQgPSBzdHJpcCgxLDIpLnJlcGxhY2UoL1xcXFwnL2csXCInXCIpOyByZXR1cm4gODA7XG5icmVhaztcbmNhc2UgMzM6cmV0dXJuIDg1O1xuYnJlYWs7XG5jYXNlIDM0OnJldHVybiA4MjtcbmJyZWFrO1xuY2FzZSAzNTpyZXR1cm4gODI7XG5icmVhaztcbmNhc2UgMzY6cmV0dXJuIDgzO1xuYnJlYWs7XG5jYXNlIDM3OnJldHVybiA4NDtcbmJyZWFrO1xuY2FzZSAzODpyZXR1cm4gODE7XG5icmVhaztcbmNhc2UgMzk6cmV0dXJuIDc1O1xuYnJlYWs7XG5jYXNlIDQwOnJldHVybiA3NztcbmJyZWFrO1xuY2FzZSA0MTpyZXR1cm4gNzI7XG5icmVhaztcbmNhc2UgNDI6eXlfLnl5dGV4dCA9IHl5Xy55eXRleHQucmVwbGFjZSgvXFxcXChbXFxcXFxcXV0pL2csJyQxJyk7IHJldHVybiA3MjtcbmJyZWFrO1xuY2FzZSA0MzpyZXR1cm4gJ0lOVkFMSUQnO1xuYnJlYWs7XG5jYXNlIDQ0OnJldHVybiA1O1xuYnJlYWs7XG59XG59O1xubGV4ZXIucnVsZXMgPSBbL14oPzpbXlxceDAwXSo/KD89KFxce1xceykpKS8sL14oPzpbXlxceDAwXSspLywvXig/OlteXFx4MDBdezIsfT8oPz0oXFx7XFx7fFxcXFxcXHtcXHt8XFxcXFxcXFxcXHtcXHt8JCkpKS8sL14oPzpcXHtcXHtcXHtcXHsoPz1bXlxcL10pKS8sL14oPzpcXHtcXHtcXHtcXHtcXC9bXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89Wz19XFxzXFwvLl0pXFx9XFx9XFx9XFx9KS8sL14oPzpbXlxceDAwXSo/KD89KFxce1xce1xce1xceykpKS8sL14oPzpbXFxzXFxTXSo/LS0ofik/XFx9XFx9KS8sL14oPzpcXCgpLywvXig/OlxcKSkvLC9eKD86XFx7XFx7XFx7XFx7KS8sL14oPzpcXH1cXH1cXH1cXH0pLywvXig/Olxce1xceyh+KT8+KS8sL14oPzpcXHtcXHsofik/Iz4pLywvXig/Olxce1xceyh+KT8jXFwqPykvLC9eKD86XFx7XFx7KH4pP1xcLykvLC9eKD86XFx7XFx7KH4pP1xcXlxccyoofik/XFx9XFx9KS8sL14oPzpcXHtcXHsofik/XFxzKmVsc2VcXHMqKH4pP1xcfVxcfSkvLC9eKD86XFx7XFx7KH4pP1xcXikvLC9eKD86XFx7XFx7KH4pP1xccyplbHNlXFxiKS8sL14oPzpcXHtcXHsofik/XFx7KS8sL14oPzpcXHtcXHsofik/JikvLC9eKD86XFx7XFx7KH4pPyEtLSkvLC9eKD86XFx7XFx7KH4pPyFbXFxzXFxTXSo/XFx9XFx9KS8sL14oPzpcXHtcXHsofik/XFwqPykvLC9eKD86PSkvLC9eKD86XFwuXFwuKS8sL14oPzpcXC4oPz0oWz1+fVxcc1xcLy4pfF0pKSkvLC9eKD86W1xcLy5dKS8sL14oPzpcXHMrKS8sL14oPzpcXH0ofik/XFx9XFx9KS8sL14oPzoofik/XFx9XFx9KS8sL14oPzpcIihcXFxcW1wiXXxbXlwiXSkqXCIpLywvXig/OicoXFxcXFsnXXxbXiddKSonKS8sL14oPzpAKS8sL14oPzp0cnVlKD89KFt+fVxccyldKSkpLywvXig/OmZhbHNlKD89KFt+fVxccyldKSkpLywvXig/OnVuZGVmaW5lZCg/PShbfn1cXHMpXSkpKS8sL14oPzpudWxsKD89KFt+fVxccyldKSkpLywvXig/Oi0/WzAtOV0rKD86XFwuWzAtOV0rKT8oPz0oW359XFxzKV0pKSkvLC9eKD86YXNcXHMrXFx8KS8sL14oPzpcXHwpLywvXig/OihbXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89KFs9fn1cXHNcXC8uKXxdKSkpKS8sL14oPzpcXFsoXFxcXFxcXXxbXlxcXV0pKlxcXSkvLC9eKD86LikvLC9eKD86JCkvXTtcbmxleGVyLmNvbmRpdGlvbnMgPSB7XCJtdVwiOntcInJ1bGVzXCI6WzcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0XSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcImVtdVwiOntcInJ1bGVzXCI6WzJdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwiY29tXCI6e1wicnVsZXNcIjpbNl0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJyYXdcIjp7XCJydWxlc1wiOlszLDQsNV0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDQ0XSxcImluY2x1c2l2ZVwiOnRydWV9fTtcbnJldHVybiBsZXhlcjt9KSgpXG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7IHRoaXMueXkgPSB7fTsgfVBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtleHBvcnQgZGVmYXVsdCBoYW5kbGViYXJzO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuaW1wb3J0IFZpc2l0b3IgZnJvbSAnLi92aXNpdG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50KGFzdCkge1xuICByZXR1cm4gbmV3IFByaW50VmlzaXRvcigpLmFjY2VwdChhc3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUHJpbnRWaXNpdG9yKCkge1xuICB0aGlzLnBhZGRpbmcgPSAwO1xufVxuXG5QcmludFZpc2l0b3IucHJvdG90eXBlID0gbmV3IFZpc2l0b3IoKTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgbGV0IG91dCA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5wYWRkaW5nOyBpIDwgbDsgaSsrKSB7XG4gICAgb3V0ICs9ICcgICc7XG4gIH1cblxuICBvdXQgKz0gc3RyaW5nICsgJ1xcbic7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlByb2dyYW0gPSBmdW5jdGlvbihwcm9ncmFtKSB7XG4gIGxldCBvdXQgPSAnJyxcbiAgICAgIGJvZHkgPSBwcm9ncmFtLmJvZHksXG4gICAgICBpLCBsO1xuXG4gIGlmIChwcm9ncmFtLmJsb2NrUGFyYW1zKSB7XG4gICAgbGV0IGJsb2NrUGFyYW1zID0gJ0JMT0NLIFBBUkFNUzogWyc7XG4gICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW0uYmxvY2tQYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgYmxvY2tQYXJhbXMgKz0gJyAnICsgcHJvZ3JhbS5ibG9ja1BhcmFtc1tpXTtcbiAgICB9XG4gICAgYmxvY2tQYXJhbXMgKz0gJyBdJztcbiAgICBvdXQgKz0gdGhpcy5wYWQoYmxvY2tQYXJhbXMpO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbCA9IGJvZHkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3V0ICs9IHRoaXMuYWNjZXB0KGJvZHlbaV0pO1xuICB9XG5cbiAgdGhpcy5wYWRkaW5nLS07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuTXVzdGFjaGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihtdXN0YWNoZSkge1xuICByZXR1cm4gdGhpcy5wYWQoJ3t7ICcgKyB0aGlzLlN1YkV4cHJlc3Npb24obXVzdGFjaGUpICsgJyB9fScpO1xufTtcblByaW50VmlzaXRvci5wcm90b3R5cGUuRGVjb3JhdG9yID0gZnVuY3Rpb24obXVzdGFjaGUpIHtcbiAgcmV0dXJuIHRoaXMucGFkKCd7eyBESVJFQ1RJVkUgJyArIHRoaXMuU3ViRXhwcmVzc2lvbihtdXN0YWNoZSkgKyAnIH19Jyk7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkJsb2NrU3RhdGVtZW50ID1cblByaW50VmlzaXRvci5wcm90b3R5cGUuRGVjb3JhdG9yQmxvY2sgPSBmdW5jdGlvbihibG9jaykge1xuICBsZXQgb3V0ID0gJyc7XG5cbiAgb3V0ICs9IHRoaXMucGFkKChibG9jay50eXBlID09PSAnRGVjb3JhdG9yQmxvY2snID8gJ0RJUkVDVElWRSAnIDogJycpICsgJ0JMT0NLOicpO1xuICB0aGlzLnBhZGRpbmcrKztcbiAgb3V0ICs9IHRoaXMucGFkKHRoaXMuU3ViRXhwcmVzc2lvbihibG9jaykpO1xuICBpZiAoYmxvY2sucHJvZ3JhbSkge1xuICAgIG91dCArPSB0aGlzLnBhZCgnUFJPR1JBTTonKTtcbiAgICB0aGlzLnBhZGRpbmcrKztcbiAgICBvdXQgKz0gdGhpcy5hY2NlcHQoYmxvY2sucHJvZ3JhbSk7XG4gICAgdGhpcy5wYWRkaW5nLS07XG4gIH1cbiAgaWYgKGJsb2NrLmludmVyc2UpIHtcbiAgICBpZiAoYmxvY2sucHJvZ3JhbSkgeyB0aGlzLnBhZGRpbmcrKzsgfVxuICAgIG91dCArPSB0aGlzLnBhZCgne3tefX0nKTtcbiAgICB0aGlzLnBhZGRpbmcrKztcbiAgICBvdXQgKz0gdGhpcy5hY2NlcHQoYmxvY2suaW52ZXJzZSk7XG4gICAgdGhpcy5wYWRkaW5nLS07XG4gICAgaWYgKGJsb2NrLnByb2dyYW0pIHsgdGhpcy5wYWRkaW5nLS07IH1cbiAgfVxuICB0aGlzLnBhZGRpbmctLTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5QYXJ0aWFsU3RhdGVtZW50ID0gZnVuY3Rpb24ocGFydGlhbCkge1xuICBsZXQgY29udGVudCA9ICdQQVJUSUFMOicgKyBwYXJ0aWFsLm5hbWUub3JpZ2luYWw7XG4gIGlmIChwYXJ0aWFsLnBhcmFtc1swXSkge1xuICAgIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5hY2NlcHQocGFydGlhbC5wYXJhbXNbMF0pO1xuICB9XG4gIGlmIChwYXJ0aWFsLmhhc2gpIHtcbiAgICBjb250ZW50ICs9ICcgJyArIHRoaXMuYWNjZXB0KHBhcnRpYWwuaGFzaCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucGFkKCd7ez4gJyArIGNvbnRlbnQgKyAnIH19Jyk7XG59O1xuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQgPSBmdW5jdGlvbihwYXJ0aWFsKSB7XG4gIGxldCBjb250ZW50ID0gJ1BBUlRJQUwgQkxPQ0s6JyArIHBhcnRpYWwubmFtZS5vcmlnaW5hbDtcbiAgaWYgKHBhcnRpYWwucGFyYW1zWzBdKSB7XG4gICAgY29udGVudCArPSAnICcgKyB0aGlzLmFjY2VwdChwYXJ0aWFsLnBhcmFtc1swXSk7XG4gIH1cbiAgaWYgKHBhcnRpYWwuaGFzaCkge1xuICAgIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5hY2NlcHQocGFydGlhbC5oYXNoKTtcbiAgfVxuXG4gIGNvbnRlbnQgKz0gJyAnICsgdGhpcy5wYWQoJ1BST0dSQU06Jyk7XG4gIHRoaXMucGFkZGluZysrO1xuICBjb250ZW50ICs9IHRoaXMuYWNjZXB0KHBhcnRpYWwucHJvZ3JhbSk7XG4gIHRoaXMucGFkZGluZy0tO1xuXG4gIHJldHVybiB0aGlzLnBhZCgne3s+ICcgKyBjb250ZW50ICsgJyB9fScpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5Db250ZW50U3RhdGVtZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gdGhpcy5wYWQoXCJDT05URU5UWyAnXCIgKyBjb250ZW50LnZhbHVlICsgXCInIF1cIik7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkNvbW1lbnRTdGF0ZW1lbnQgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gIHJldHVybiB0aGlzLnBhZChcInt7ISAnXCIgKyBjb21tZW50LnZhbHVlICsgXCInIH19XCIpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5TdWJFeHByZXNzaW9uID0gZnVuY3Rpb24oc2V4cHIpIHtcbiAgbGV0IHBhcmFtcyA9IHNleHByLnBhcmFtcyxcbiAgICAgIHBhcmFtU3RyaW5ncyA9IFtdLFxuICAgICAgaGFzaDtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJhbVN0cmluZ3MucHVzaCh0aGlzLmFjY2VwdChwYXJhbXNbaV0pKTtcbiAgfVxuXG4gIHBhcmFtcyA9ICdbJyArIHBhcmFtU3RyaW5ncy5qb2luKCcsICcpICsgJ10nO1xuXG4gIGhhc2ggPSBzZXhwci5oYXNoID8gJyAnICsgdGhpcy5hY2NlcHQoc2V4cHIuaGFzaCkgOiAnJztcblxuICByZXR1cm4gdGhpcy5hY2NlcHQoc2V4cHIucGF0aCkgKyAnICcgKyBwYXJhbXMgKyBoYXNoO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5QYXRoRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGlkKSB7XG4gIGxldCBwYXRoID0gaWQucGFydHMuam9pbignLycpO1xuICByZXR1cm4gKGlkLmRhdGEgPyAnQCcgOiAnJykgKyAnUEFUSDonICsgcGF0aDtcbn07XG5cblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5TdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiAnXCInICsgc3RyaW5nLnZhbHVlICsgJ1wiJztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuTnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uKG51bWJlcikge1xuICByZXR1cm4gJ05VTUJFUnsnICsgbnVtYmVyLnZhbHVlICsgJ30nO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5Cb29sZWFuTGl0ZXJhbCA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgcmV0dXJuICdCT09MRUFOeycgKyBib29sLnZhbHVlICsgJ30nO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5VbmRlZmluZWRMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnVU5ERUZJTkVEJztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuTnVsbExpdGVyYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdOVUxMJztcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgbGV0IHBhaXJzID0gaGFzaC5wYWlycyxcbiAgICAgIGpvaW5lZFBhaXJzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBqb2luZWRQYWlycy5wdXNoKHRoaXMuYWNjZXB0KHBhaXJzW2ldKSk7XG4gIH1cblxuICByZXR1cm4gJ0hBU0h7JyArIGpvaW5lZFBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG59O1xuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5IYXNoUGFpciA9IGZ1bmN0aW9uKHBhaXIpIHtcbiAgcmV0dXJuIHBhaXIua2V5ICsgJz0nICsgdGhpcy5hY2NlcHQocGFpci52YWx1ZSk7XG59O1xuLyogZXNsaW50LWVuYWJsZSBuZXctY2FwICovXG4iLCJpbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmZ1bmN0aW9uIFZpc2l0b3IoKSB7XG4gIHRoaXMucGFyZW50cyA9IFtdO1xufVxuXG5WaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFZpc2l0b3IsXG4gIG11dGF0aW5nOiBmYWxzZSxcblxuICAvLyBWaXNpdHMgYSBnaXZlbiB2YWx1ZS4gSWYgbXV0YXRpbmcsIHdpbGwgcmVwbGFjZSB0aGUgdmFsdWUgaWYgbmVjZXNzYXJ5LlxuICBhY2NlcHRLZXk6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmFjY2VwdChub2RlW25hbWVdKTtcbiAgICBpZiAodGhpcy5tdXRhdGluZykge1xuICAgICAgLy8gSGFja3kgc2FuaXR5IGNoZWNrOiBUaGlzIG1heSBoYXZlIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyBmb3IgdHlwZSBmb3IgdGhlIGhlbHBlclxuICAgICAgLy8gbWV0aG9kcyBidXQgd2lsbCBnZW5lcmFsbHkgZG8gdGhlIHJpZ2h0IHRoaW5nIHdpdGhvdXQgYSBsb3Qgb2Ygb3ZlcmhlYWQuXG4gICAgICBpZiAodmFsdWUgJiYgIVZpc2l0b3IucHJvdG90eXBlW3ZhbHVlLnR5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1VuZXhwZWN0ZWQgbm9kZSB0eXBlIFwiJyArIHZhbHVlLnR5cGUgKyAnXCIgZm91bmQgd2hlbiBhY2NlcHRpbmcgJyArIG5hbWUgKyAnIG9uICcgKyBub2RlLnR5cGUpO1xuICAgICAgfVxuICAgICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvLyBQZXJmb3JtcyBhbiBhY2NlcHQgb3BlcmF0aW9uIHdpdGggYWRkZWQgc2FuaXR5IGNoZWNrIHRvIGVuc3VyZVxuICAvLyByZXF1aXJlZCBrZXlzIGFyZSBub3QgcmVtb3ZlZC5cbiAgYWNjZXB0UmVxdWlyZWQ6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICB0aGlzLmFjY2VwdEtleShub2RlLCBuYW1lKTtcblxuICAgIGlmICghbm9kZVtuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihub2RlLnR5cGUgKyAnIHJlcXVpcmVzICcgKyBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gVHJhdmVyc2VzIGEgZ2l2ZW4gYXJyYXkuIElmIG11dGF0aW5nLCBlbXB0eSByZXNwbnNlcyB3aWxsIGJlIHJlbW92ZWRcbiAgLy8gZm9yIGNoaWxkIGVsZW1lbnRzLlxuICBhY2NlcHRBcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHRLZXkoYXJyYXksIGkpO1xuXG4gICAgICBpZiAoIWFycmF5W2ldKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBsLS07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFjY2VwdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogU2FuaXR5IGNvZGUgKi9cbiAgICBpZiAoIXRoaXNbb2JqZWN0LnR5cGVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHR5cGU6ICcgKyBvYmplY3QudHlwZSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudHMudW5zaGlmdCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBvYmplY3Q7XG5cbiAgICBsZXQgcmV0ID0gdGhpc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcblxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMucGFyZW50cy5zaGlmdCgpO1xuXG4gICAgaWYgKCF0aGlzLm11dGF0aW5nIHx8IHJldCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKHJldCAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9LFxuXG4gIFByb2dyYW06IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgICB0aGlzLmFjY2VwdEFycmF5KHByb2dyYW0uYm9keSk7XG4gIH0sXG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQ6IHZpc2l0U3ViRXhwcmVzc2lvbixcbiAgRGVjb3JhdG9yOiB2aXNpdFN1YkV4cHJlc3Npb24sXG5cbiAgQmxvY2tTdGF0ZW1lbnQ6IHZpc2l0QmxvY2ssXG4gIERlY29yYXRvckJsb2NrOiB2aXNpdEJsb2NrLFxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IHZpc2l0UGFydGlhbCxcbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbihwYXJ0aWFsKSB7XG4gICAgdmlzaXRQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCk7XG5cbiAgICB0aGlzLmFjY2VwdEtleShwYXJ0aWFsLCAncHJvZ3JhbScpO1xuICB9LFxuXG4gIENvbnRlbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uKC8qIGNvbnRlbnQgKi8pIHt9LFxuICBDb21tZW50U3RhdGVtZW50OiBmdW5jdGlvbigvKiBjb21tZW50ICovKSB7fSxcblxuICBTdWJFeHByZXNzaW9uOiB2aXNpdFN1YkV4cHJlc3Npb24sXG5cbiAgUGF0aEV4cHJlc3Npb246IGZ1bmN0aW9uKC8qIHBhdGggKi8pIHt9LFxuXG4gIFN0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKC8qIHN0cmluZyAqLykge30sXG4gIE51bWJlckxpdGVyYWw6IGZ1bmN0aW9uKC8qIG51bWJlciAqLykge30sXG4gIEJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbigvKiBib29sICovKSB7fSxcbiAgVW5kZWZpbmVkTGl0ZXJhbDogZnVuY3Rpb24oLyogbGl0ZXJhbCAqLykge30sXG4gIE51bGxMaXRlcmFsOiBmdW5jdGlvbigvKiBsaXRlcmFsICovKSB7fSxcblxuICBIYXNoOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgdGhpcy5hY2NlcHRBcnJheShoYXNoLnBhaXJzKTtcbiAgfSxcbiAgSGFzaFBhaXI6IGZ1bmN0aW9uKHBhaXIpIHtcbiAgICB0aGlzLmFjY2VwdFJlcXVpcmVkKHBhaXIsICd2YWx1ZScpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2aXNpdFN1YkV4cHJlc3Npb24obXVzdGFjaGUpIHtcbiAgdGhpcy5hY2NlcHRSZXF1aXJlZChtdXN0YWNoZSwgJ3BhdGgnKTtcbiAgdGhpcy5hY2NlcHRBcnJheShtdXN0YWNoZS5wYXJhbXMpO1xuICB0aGlzLmFjY2VwdEtleShtdXN0YWNoZSwgJ2hhc2gnKTtcbn1cbmZ1bmN0aW9uIHZpc2l0QmxvY2soYmxvY2spIHtcbiAgdmlzaXRTdWJFeHByZXNzaW9uLmNhbGwodGhpcywgYmxvY2spO1xuXG4gIHRoaXMuYWNjZXB0S2V5KGJsb2NrLCAncHJvZ3JhbScpO1xuICB0aGlzLmFjY2VwdEtleShibG9jaywgJ2ludmVyc2UnKTtcbn1cbmZ1bmN0aW9uIHZpc2l0UGFydGlhbChwYXJ0aWFsKSB7XG4gIHRoaXMuYWNjZXB0UmVxdWlyZWQocGFydGlhbCwgJ25hbWUnKTtcbiAgdGhpcy5hY2NlcHRBcnJheShwYXJ0aWFsLnBhcmFtcyk7XG4gIHRoaXMuYWNjZXB0S2V5KHBhcnRpYWwsICdoYXNoJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpc2l0b3I7XG4iLCJpbXBvcnQgVmlzaXRvciBmcm9tICcuL3Zpc2l0b3InO1xuXG5mdW5jdGlvbiBXaGl0ZXNwYWNlQ29udHJvbChvcHRpb25zID0ge30pIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn1cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZSA9IG5ldyBWaXNpdG9yKCk7XG5cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5Qcm9ncmFtID0gZnVuY3Rpb24ocHJvZ3JhbSkge1xuICBjb25zdCBkb1N0YW5kYWxvbmUgPSAhdGhpcy5vcHRpb25zLmlnbm9yZVN0YW5kYWxvbmU7XG5cbiAgbGV0IGlzUm9vdCA9ICF0aGlzLmlzUm9vdFNlZW47XG4gIHRoaXMuaXNSb290U2VlbiA9IHRydWU7XG5cbiAgbGV0IGJvZHkgPSBwcm9ncmFtLmJvZHk7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgY3VycmVudCA9IGJvZHlbaV0sXG4gICAgICAgIHN0cmlwID0gdGhpcy5hY2NlcHQoY3VycmVudCk7XG5cbiAgICBpZiAoIXN0cmlwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgX2lzUHJldldoaXRlc3BhY2UgPSBpc1ByZXZXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXG4gICAgICAgIF9pc05leHRXaGl0ZXNwYWNlID0gaXNOZXh0V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpLFxuXG4gICAgICAgIG9wZW5TdGFuZGFsb25lID0gc3RyaXAub3BlblN0YW5kYWxvbmUgJiYgX2lzUHJldldoaXRlc3BhY2UsXG4gICAgICAgIGNsb3NlU3RhbmRhbG9uZSA9IHN0cmlwLmNsb3NlU3RhbmRhbG9uZSAmJiBfaXNOZXh0V2hpdGVzcGFjZSxcbiAgICAgICAgaW5saW5lU3RhbmRhbG9uZSA9IHN0cmlwLmlubGluZVN0YW5kYWxvbmUgJiYgX2lzUHJldldoaXRlc3BhY2UgJiYgX2lzTmV4dFdoaXRlc3BhY2U7XG5cbiAgICBpZiAoc3RyaXAuY2xvc2UpIHtcbiAgICAgIG9taXRSaWdodChib2R5LCBpLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHN0cmlwLm9wZW4pIHtcbiAgICAgIG9taXRMZWZ0KGJvZHksIGksIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChkb1N0YW5kYWxvbmUgJiYgaW5saW5lU3RhbmRhbG9uZSkge1xuICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xuXG4gICAgICBpZiAob21pdExlZnQoYm9keSwgaSkpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhbmRhbG9uZSBub2RlLCBzYXZlIHRoZSBpbmRlbnQgaW5mbyBmb3IgcGFydGlhbHNcbiAgICAgICAgaWYgKGN1cnJlbnQudHlwZSA9PT0gJ1BhcnRpYWxTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgLy8gUHVsbCBvdXQgdGhlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZmluYWwgbGluZVxuICAgICAgICAgIGN1cnJlbnQuaW5kZW50ID0gKC8oWyBcXHRdKyQpLykuZXhlYyhib2R5W2kgLSAxXS5vcmlnaW5hbClbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBvcGVuU3RhbmRhbG9uZSkge1xuICAgICAgb21pdFJpZ2h0KChjdXJyZW50LnByb2dyYW0gfHwgY3VycmVudC5pbnZlcnNlKS5ib2R5KTtcblxuICAgICAgLy8gU3RyaXAgb3V0IHRoZSBwcmV2aW91cyBjb250ZW50IG5vZGUgaWYgaXQncyB3aGl0ZXNwYWNlIG9ubHlcbiAgICAgIG9taXRMZWZ0KGJvZHksIGkpO1xuICAgIH1cbiAgICBpZiAoZG9TdGFuZGFsb25lICYmIGNsb3NlU3RhbmRhbG9uZSkge1xuICAgICAgLy8gQWx3YXlzIHN0cmlwIHRoZSBuZXh0IG5vZGVcbiAgICAgIG9taXRSaWdodChib2R5LCBpKTtcblxuICAgICAgb21pdExlZnQoKGN1cnJlbnQuaW52ZXJzZSB8fCBjdXJyZW50LnByb2dyYW0pLmJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufTtcblxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkJsb2NrU3RhdGVtZW50ID1cbldoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5EZWNvcmF0b3JCbG9jayA9XG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbEJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24oYmxvY2spIHtcbiAgdGhpcy5hY2NlcHQoYmxvY2sucHJvZ3JhbSk7XG4gIHRoaXMuYWNjZXB0KGJsb2NrLmludmVyc2UpO1xuXG4gIC8vIEZpbmQgdGhlIGludmVyc2UgcHJvZ3JhbSB0aGF0IGlzIGludm9sZWQgd2l0aCB3aGl0ZXNwYWNlIHN0cmlwcGluZy5cbiAgbGV0IHByb2dyYW0gPSBibG9jay5wcm9ncmFtIHx8IGJsb2NrLmludmVyc2UsXG4gICAgICBpbnZlcnNlID0gYmxvY2sucHJvZ3JhbSAmJiBibG9jay5pbnZlcnNlLFxuICAgICAgZmlyc3RJbnZlcnNlID0gaW52ZXJzZSxcbiAgICAgIGxhc3RJbnZlcnNlID0gaW52ZXJzZTtcblxuICBpZiAoaW52ZXJzZSAmJiBpbnZlcnNlLmNoYWluZWQpIHtcbiAgICBmaXJzdEludmVyc2UgPSBpbnZlcnNlLmJvZHlbMF0ucHJvZ3JhbTtcblxuICAgIC8vIFdhbGsgdGhlIGludmVyc2UgY2hhaW4gdG8gZmluZCB0aGUgbGFzdCBpbnZlcnNlIHRoYXQgaXMgYWN0dWFsbHkgaW4gdGhlIGNoYWluLlxuICAgIHdoaWxlIChsYXN0SW52ZXJzZS5jaGFpbmVkKSB7XG4gICAgICBsYXN0SW52ZXJzZSA9IGxhc3RJbnZlcnNlLmJvZHlbbGFzdEludmVyc2UuYm9keS5sZW5ndGggLSAxXS5wcm9ncmFtO1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdHJpcCA9IHtcbiAgICBvcGVuOiBibG9jay5vcGVuU3RyaXAub3BlbixcbiAgICBjbG9zZTogYmxvY2suY2xvc2VTdHJpcC5jbG9zZSxcblxuICAgIC8vIERldGVybWluZSB0aGUgc3RhbmRhbG9uZSBjYW5kaWFjeS4gQmFzaWNhbGx5IGZsYWcgb3VyIGNvbnRlbnQgYXMgYmVpbmcgcG9zc2libHkgc3RhbmRhbG9uZVxuICAgIC8vIHNvIG91ciBwYXJlbnQgY2FuIGRldGVybWluZSBpZiB3ZSBhY3R1YWxseSBhcmUgc3RhbmRhbG9uZVxuICAgIG9wZW5TdGFuZGFsb25lOiBpc05leHRXaGl0ZXNwYWNlKHByb2dyYW0uYm9keSksXG4gICAgY2xvc2VTdGFuZGFsb25lOiBpc1ByZXZXaGl0ZXNwYWNlKChmaXJzdEludmVyc2UgfHwgcHJvZ3JhbSkuYm9keSlcbiAgfTtcblxuICBpZiAoYmxvY2sub3BlblN0cmlwLmNsb3NlKSB7XG4gICAgb21pdFJpZ2h0KHByb2dyYW0uYm9keSwgbnVsbCwgdHJ1ZSk7XG4gIH1cblxuICBpZiAoaW52ZXJzZSkge1xuICAgIGxldCBpbnZlcnNlU3RyaXAgPSBibG9jay5pbnZlcnNlU3RyaXA7XG5cbiAgICBpZiAoaW52ZXJzZVN0cmlwLm9wZW4pIHtcbiAgICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGludmVyc2VTdHJpcC5jbG9zZSkge1xuICAgICAgb21pdFJpZ2h0KGZpcnN0SW52ZXJzZS5ib2R5LCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLmNsb3NlU3RyaXAub3Blbikge1xuICAgICAgb21pdExlZnQobGFzdEludmVyc2UuYm9keSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBzdGFuZGFsb25lIGVsc2Ugc3RhdG1lbnRzXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlU3RhbmRhbG9uZVxuICAgICAgICAmJiBpc1ByZXZXaGl0ZXNwYWNlKHByb2dyYW0uYm9keSlcbiAgICAgICAgJiYgaXNOZXh0V2hpdGVzcGFjZShmaXJzdEludmVyc2UuYm9keSkpIHtcbiAgICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSk7XG4gICAgICBvbWl0UmlnaHQoZmlyc3RJbnZlcnNlLmJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChibG9jay5jbG9zZVN0cmlwLm9wZW4pIHtcbiAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmlwO1xufTtcblxuV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkRlY29yYXRvciA9XG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuTXVzdGFjaGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihtdXN0YWNoZSkge1xuICByZXR1cm4gbXVzdGFjaGUuc3RyaXA7XG59O1xuXG5XaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbFN0YXRlbWVudCA9XG4gICAgV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkNvbW1lbnRTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCBzdHJpcCA9IG5vZGUuc3RyaXAgfHwge307XG4gIHJldHVybiB7XG4gICAgaW5saW5lU3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBvcGVuOiBzdHJpcC5vcGVuLFxuICAgIGNsb3NlOiBzdHJpcC5jbG9zZVxuICB9O1xufTtcblxuXG5mdW5jdGlvbiBpc1ByZXZXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCkge1xuICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IGJvZHkubGVuZ3RoO1xuICB9XG5cbiAgLy8gTm9kZXMgdGhhdCBlbmQgd2l0aCBuZXdsaW5lcyBhcmUgY29uc2lkZXJlZCB3aGl0ZXNwYWNlIChidXQgYXJlIHNwZWNpYWxcbiAgLy8gY2FzZWQgZm9yIHN0cmlwIG9wZXJhdGlvbnMpXG4gIGxldCBwcmV2ID0gYm9keVtpIC0gMV0sXG4gICAgICBzaWJsaW5nID0gYm9keVtpIC0gMl07XG4gIGlmICghcHJldikge1xuICAgIHJldHVybiBpc1Jvb3Q7XG4gIH1cblxuICBpZiAocHJldi50eXBlID09PSAnQ29udGVudFN0YXRlbWVudCcpIHtcbiAgICByZXR1cm4gKHNpYmxpbmcgfHwgIWlzUm9vdCA/ICgvXFxyP1xcblxccyo/JC8pIDogKC8oXnxcXHI/XFxuKVxccyo/JC8pKS50ZXN0KHByZXYub3JpZ2luYWwpO1xuICB9XG59XG5mdW5jdGlvbiBpc05leHRXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCkge1xuICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IC0xO1xuICB9XG5cbiAgbGV0IG5leHQgPSBib2R5W2kgKyAxXSxcbiAgICAgIHNpYmxpbmcgPSBib2R5W2kgKyAyXTtcbiAgaWYgKCFuZXh0KSB7XG4gICAgcmV0dXJuIGlzUm9vdDtcbiAgfVxuXG4gIGlmIChuZXh0LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xuICAgIHJldHVybiAoc2libGluZyB8fCAhaXNSb290ID8gKC9eXFxzKj9cXHI/XFxuLykgOiAoL15cXHMqPyhcXHI/XFxufCQpLykpLnRlc3QobmV4dC5vcmlnaW5hbCk7XG4gIH1cbn1cblxuLy8gTWFya3MgdGhlIG5vZGUgdG8gdGhlIHJpZ2h0IG9mIHRoZSBwb3NpdGlvbiBhcyBvbWl0dGVkLlxuLy8gSS5lLiB7e2Zvb319JyAnIHdpbGwgbWFyayB0aGUgJyAnIG5vZGUgYXMgb21pdHRlZC5cbi8vXG4vLyBJZiBpIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSBtYXJrZWQgYXMgc3VjaC5cbi8vXG4vLyBJZiBtdWxpdHBsZSBpcyB0cnV0aHkgdGhlbiBhbGwgd2hpdGVzcGFjZSB3aWxsIGJlIHN0cmlwcGVkIG91dCB1bnRpbCBub24td2hpdGVzcGFjZVxuLy8gY29udGVudCBpcyBtZXQuXG5mdW5jdGlvbiBvbWl0UmlnaHQoYm9keSwgaSwgbXVsdGlwbGUpIHtcbiAgbGV0IGN1cnJlbnQgPSBib2R5W2kgPT0gbnVsbCA/IDAgOiBpICsgMV07XG4gIGlmICghY3VycmVudCB8fCBjdXJyZW50LnR5cGUgIT09ICdDb250ZW50U3RhdGVtZW50JyB8fCAoIW11bHRpcGxlICYmIGN1cnJlbnQucmlnaHRTdHJpcHBlZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgb3JpZ2luYWwgPSBjdXJyZW50LnZhbHVlO1xuICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gKC9eXFxzKy8pIDogKC9eWyBcXHRdKlxccj9cXG4/LyksICcnKTtcbiAgY3VycmVudC5yaWdodFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XG59XG5cbi8vIE1hcmtzIHRoZSBub2RlIHRvIHRoZSBsZWZ0IG9mIHRoZSBwb3NpdGlvbiBhcyBvbWl0dGVkLlxuLy8gSS5lLiAnICd7e2Zvb319IHdpbGwgbWFyayB0aGUgJyAnIG5vZGUgYXMgb21pdHRlZC5cbi8vXG4vLyBJZiBpIGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBsYXN0IGNoaWxkIHdpbGwgYmUgbWFya2VkIGFzIHN1Y2guXG4vL1xuLy8gSWYgbXVsaXRwbGUgaXMgdHJ1dGh5IHRoZW4gYWxsIHdoaXRlc3BhY2Ugd2lsbCBiZSBzdHJpcHBlZCBvdXQgdW50aWwgbm9uLXdoaXRlc3BhY2Vcbi8vIGNvbnRlbnQgaXMgbWV0LlxuZnVuY3Rpb24gb21pdExlZnQoYm9keSwgaSwgbXVsdGlwbGUpIHtcbiAgbGV0IGN1cnJlbnQgPSBib2R5W2kgPT0gbnVsbCA/IGJvZHkubGVuZ3RoIC0gMSA6IGkgLSAxXTtcbiAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICghbXVsdGlwbGUgJiYgY3VycmVudC5sZWZ0U3RyaXBwZWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2Ugb21pdCB0aGUgbGFzdCBub2RlIGlmIGl0J3Mgd2hpdGVzcGFjZSBvbmx5IGFuZCBub3QgcHJlY2VlZGVkIGJ5IGEgbm9uLWNvbnRlbnQgbm9kZS5cbiAgbGV0IG9yaWdpbmFsID0gY3VycmVudC52YWx1ZTtcbiAgY3VycmVudC52YWx1ZSA9IGN1cnJlbnQudmFsdWUucmVwbGFjZShtdWx0aXBsZSA/ICgvXFxzKyQvKSA6ICgvWyBcXHRdKyQvKSwgJycpO1xuICBjdXJyZW50LmxlZnRTdHJpcHBlZCA9IGN1cnJlbnQudmFsdWUgIT09IG9yaWdpbmFsO1xuICByZXR1cm4gY3VycmVudC5sZWZ0U3RyaXBwZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdoaXRlc3BhY2VDb250cm9sO1xuIiwiaW1wb3J0IHJlZ2lzdGVySW5saW5lIGZyb20gJy4vZGVjb3JhdG9ycy9pbmxpbmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyhpbnN0YW5jZSkge1xuICByZWdpc3RlcklubGluZShpbnN0YW5jZSk7XG59XG5cbiIsImltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIGxldCByZXQgPSBmbjtcbiAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XG4gICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xuICAgICAgcmV0ID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cbiAgICAgICAgbGV0IG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBleHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XG4gICAgICAgIGxldCByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iLCJcbmNvbnN0IGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbWVzc2FnZScsICduYW1lJywgJ251bWJlcicsICdzdGFjayddO1xuXG5mdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSwgbm9kZSkge1xuICBsZXQgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcbiAgICAgIGxpbmUsXG4gICAgICBjb2x1bW47XG4gIGlmIChsb2MpIHtcbiAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XG4gICAgY29sdW1uID0gbG9jLnN0YXJ0LmNvbHVtbjtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xuICB9XG5cbiAgbGV0IHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBlcnJvclByb3BzLmxlbmd0aDsgaWR4KyspIHtcbiAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChsb2MpIHtcbiAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmU7XG5cbiAgICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIHVuZGVyIHNhZmFyaSB3aGVyZSB3ZSBjYW4ndCBkaXJlY3RseSBzZXQgdGhlIGNvbHVtbiB2YWx1ZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2x1bW4nLCB7XG4gICAgICAgICAgdmFsdWU6IGNvbHVtbixcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChub3ApIHtcbiAgICAvKiBJZ25vcmUgaWYgdGhlIGJyb3dzZXIgaXMgdmVyeSBwYXJ0aWN1bGFyICovXG4gIH1cbn1cblxuRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBFeGNlcHRpb247XG4iLCJpbXBvcnQgcmVnaXN0ZXJCbG9ja0hlbHBlck1pc3NpbmcgZnJvbSAnLi9oZWxwZXJzL2Jsb2NrLWhlbHBlci1taXNzaW5nJztcbmltcG9ydCByZWdpc3RlckVhY2ggZnJvbSAnLi9oZWxwZXJzL2VhY2gnO1xuaW1wb3J0IHJlZ2lzdGVySGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvaGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVySWYgZnJvbSAnLi9oZWxwZXJzL2lmJztcbmltcG9ydCByZWdpc3RlckxvZyBmcm9tICcuL2hlbHBlcnMvbG9nJztcbmltcG9ydCByZWdpc3Rlckxvb2t1cCBmcm9tICcuL2hlbHBlcnMvbG9va3VwJztcbmltcG9ydCByZWdpc3RlcldpdGggZnJvbSAnLi9oZWxwZXJzL3dpdGgnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0SGVscGVycyhpbnN0YW5jZSkge1xuICByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyhpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyRWFjaChpbnN0YW5jZSk7XG4gIHJlZ2lzdGVySGVscGVyTWlzc2luZyhpbnN0YW5jZSk7XG4gIHJlZ2lzdGVySWYoaW5zdGFuY2UpO1xuICByZWdpc3RlckxvZyhpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9va3VwKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJXaXRoKGluc3RhbmNlKTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGNyZWF0ZUZyYW1lLCBpc0FycmF5fSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgbGV0IGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZm4odGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgb3B0aW9ucyA9IHtkYXRhOiBkYXRhfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzQXJyYXksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2VhY2gnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdNdXN0IHBhc3MgaXRlcmF0b3IgdG8gI2VhY2gnKTtcbiAgICB9XG5cbiAgICBsZXQgZm4gPSBvcHRpb25zLmZuLFxuICAgICAgICBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcmV0ID0gJycsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHRQYXRoO1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgY29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMuaWRzWzBdKSArICcuJztcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjSXRlcmF0aW9uKGZpZWxkLCBpbmRleCwgbGFzdCkge1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5rZXkgPSBmaWVsZDtcbiAgICAgICAgZGF0YS5pbmRleCA9IGluZGV4O1xuICAgICAgICBkYXRhLmZpcnN0ID0gaW5kZXggPT09IDA7XG4gICAgICAgIGRhdGEubGFzdCA9ICEhbGFzdDtcblxuICAgICAgICBpZiAoY29udGV4dFBhdGgpIHtcbiAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSByZXQgKyBmbihjb250ZXh0W2ZpZWxkXSwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRbZmllbGRdLCBmaWVsZF0sIFtjb250ZXh0UGF0aCArIGZpZWxkLCBudWxsXSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgaW4gY29udGV4dCkge1xuICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByaW9yS2V5O1xuXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBpdGVyYXRpb24gd2l0aG91dCBoYXZlIHRvIHNjYW4gdGhlIG9iamVjdCB0d2ljZSBhbmQgY3JlYXRlXG4gICAgICAgICAgICAvLyBhbiBpdGVybWVkaWF0ZSBrZXlzIGFycmF5LlxuICAgICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldCA9IGludmVyc2UodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG4iLCJpbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdoZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24oLyogW2FyZ3MsIF1vcHRpb25zICovKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEEgbWlzc2luZyBmaWVsZCBpbiBhIHt7Zm9vfX0gY29uc3RydWN0LlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU29tZW9uZSBpcyBhY3R1YWxseSB0cnlpbmcgdG8gY2FsbCBzb21ldGhpbmcsIGJsb3cgdXAuXG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdNaXNzaW5nIGhlbHBlcjogXCInICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5uYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7aXNFbXB0eSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb2cnLCBmdW5jdGlvbigvKiBtZXNzYWdlLCBvcHRpb25zICovKSB7XG4gICAgbGV0IGFyZ3MgPSBbdW5kZWZpbmVkXSxcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgbGV2ZWwgPSAxO1xuICAgIGlmIChvcHRpb25zLmhhc2gubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmhhc2gubGV2ZWw7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5kYXRhLmxldmVsO1xuICAgIH1cbiAgICBhcmdzWzBdID0gbGV2ZWw7XG5cbiAgICBpbnN0YW5jZS5sb2coLi4uIGFyZ3MpO1xuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbihvYmosIGZpZWxkKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmpbZmllbGRdO1xuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNFbXB0eSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBsZXQgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKCFpc0VtcHR5KGNvbnRleHQpKSB7XG4gICAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMuaWRzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zKFtjb250ZXh0XSwgW2RhdGEgJiYgZGF0YS5jb250ZXh0UGF0aF0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpbmRleE9mfSBmcm9tICcuL3V0aWxzJztcblxubGV0IGxvZ2dlciA9IHtcbiAgbWV0aG9kTWFwOiBbJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddLFxuICBsZXZlbDogJ2luZm8nLFxuXG4gIC8vIE1hcHMgYSBnaXZlbiBsZXZlbCB2YWx1ZSB0byB0aGUgYG1ldGhvZE1hcGAgaW5kZXhlcyBhYm92ZS5cbiAgbG9va3VwTGV2ZWw6IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBsZXZlbE1hcCA9IGluZGV4T2YobG9nZ2VyLm1ldGhvZE1hcCwgbGV2ZWwudG9Mb3dlckNhc2UoKSk7XG4gICAgICBpZiAobGV2ZWxNYXAgPj0gMCkge1xuICAgICAgICBsZXZlbCA9IGxldmVsTWFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWwgPSBwYXJzZUludChsZXZlbCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsZXZlbDtcbiAgfSxcblxuICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudFxuICBsb2c6IGZ1bmN0aW9uKGxldmVsLCAuLi5tZXNzYWdlKSB7XG4gICAgbGV2ZWwgPSBsb2dnZXIubG9va3VwTGV2ZWwobGV2ZWwpO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBsb2dnZXIubG9va3VwTGV2ZWwobG9nZ2VyLmxldmVsKSA8PSBsZXZlbCkge1xuICAgICAgbGV0IG1ldGhvZCA9IGxvZ2dlci5tZXRob2RNYXBbbGV2ZWxdO1xuICAgICAgaWYgKCFjb25zb2xlW21ldGhvZF0pIHsgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgbWV0aG9kID0gJ2xvZyc7XG4gICAgICB9XG4gICAgICBjb25zb2xlW21ldGhvZF0oLi4ubWVzc2FnZSk7ICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbG9nZ2VyO1xuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oSGFuZGxlYmFycykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBsZXQgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxuICAgICAgJEhhbmRsZWJhcnMgPSByb290LkhhbmRsZWJhcnM7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcbiAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGFuZGxlYmFycztcbiAgfTtcbn1cbiIsImltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQgeyBDT01QSUxFUl9SRVZJU0lPTiwgUkVWSVNJT05fQ0hBTkdFUywgY3JlYXRlRnJhbWUgfSBmcm9tICcuL2Jhc2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXZpc2lvbihjb21waWxlckluZm8pIHtcbiAgY29uc3QgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgICAgY3VycmVudFJldmlzaW9uID0gQ09NUElMRVJfUkVWSVNJT047XG5cbiAgaWYgKGNvbXBpbGVyUmV2aXNpb24gIT09IGN1cnJlbnRSZXZpc2lvbikge1xuICAgIGlmIChjb21waWxlclJldmlzaW9uIDwgY3VycmVudFJldmlzaW9uKSB7XG4gICAgICBjb25zdCBydW50aW1lVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG4gICAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSB0aGUgZW1iZWRkZWQgdmVyc2lvbiBpbmZvIHNpbmNlIHRoZSBydW50aW1lIGRvZXNuJ3Qga25vdyBhYm91dCB0aGlzIHJldmlzaW9uIHlldFxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlKHRlbXBsYXRlU3BlYywgZW52KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghZW52KSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XG4gIH1cbiAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVW5rbm93biB0ZW1wbGF0ZSBvYmplY3Q6ICcgKyB0eXBlb2YgdGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIHRlbXBsYXRlU3BlYy5tYWluLmRlY29yYXRvciA9IHRlbXBsYXRlU3BlYy5tYWluX2Q7XG5cbiAgLy8gTm90ZTogVXNpbmcgZW52LlZNIHJlZmVyZW5jZXMgcmF0aGVyIHRoYW4gbG9jYWwgdmFyIHJlZmVyZW5jZXMgdGhyb3VnaG91dCB0aGlzIHNlY3Rpb24gdG8gYWxsb3dcbiAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzdWVkby1zdXBwb3J0ZWQgQVBJcy5cbiAgZW52LlZNLmNoZWNrUmV2aXNpb24odGVtcGxhdGVTcGVjLmNvbXBpbGVyKTtcblxuICBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsV3JhcHBlcihwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFzaCkge1xuICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcbiAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICBvcHRpb25zLmlkc1swXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFydGlhbCA9IGVudi5WTS5yZXNvbHZlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIGxldCByZXN1bHQgPSBlbnYuVk0uaW52b2tlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIGVudi5jb21waWxlKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0gPSBlbnYuY29tcGlsZShwYXJ0aWFsLCB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJPcHRpb25zLCBlbnYpO1xuICAgICAgcmVzdWx0ID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xuICAgICAgICBsZXQgbGluZXMgPSByZXN1bHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmVzW2ldID0gb3B0aW9ucy5pbmRlbnQgKyBsaW5lc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGUnKTtcbiAgICB9XG4gIH1cblxuICAvLyBKdXN0IGFkZCB3YXRlclxuICBsZXQgY29udGFpbmVyID0ge1xuICAgIHN0cmljdDogZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG4gICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignXCInICsgbmFtZSArICdcIiBub3QgZGVmaW5lZCBpbiAnICsgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpbbmFtZV07XG4gICAgfSxcbiAgICBsb29rdXA6IGZ1bmN0aW9uKGRlcHRocywgbmFtZSkge1xuICAgICAgY29uc3QgbGVuID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxhbWJkYTogZnVuY3Rpb24oY3VycmVudCwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnZnVuY3Rpb24nID8gY3VycmVudC5jYWxsKGNvbnRleHQpIDogY3VycmVudDtcbiAgICB9LFxuXG4gICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcblxuICAgIGZuOiBmdW5jdGlvbihpKSB7XG4gICAgICBsZXQgcmV0ID0gdGVtcGxhdGVTcGVjW2ldO1xuICAgICAgcmV0LmRlY29yYXRvciA9IHRlbXBsYXRlU3BlY1tpICsgJ19kJ107XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBwcm9ncmFtczogW10sXG4gICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgICAgbGV0IHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSxcbiAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24odmFsdWUsIGRlcHRoKSB7XG4gICAgICB3aGlsZSAodmFsdWUgJiYgZGVwdGgtLSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLl9wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBtZXJnZTogZnVuY3Rpb24ocGFyYW0sIGNvbW1vbikge1xuICAgICAgbGV0IG9iaiA9IHBhcmFtIHx8IGNvbW1vbjtcblxuICAgICAgaWYgKHBhcmFtICYmIGNvbW1vbiAmJiAocGFyYW0gIT09IGNvbW1vbikpIHtcbiAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8vIEFuIGVtcHR5IG9iamVjdCB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIG51bGwtY29udGV4dHNcbiAgICBudWxsQ29udGV4dDogT2JqZWN0LnNlYWwoe30pLFxuXG4gICAgbm9vcDogZW52LlZNLm5vb3AsXG4gICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcbiAgfTtcblxuICBmdW5jdGlvbiByZXQoY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG5cbiAgICByZXQuX3NldHVwKG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsICYmIHRlbXBsYXRlU3BlYy51c2VEYXRhKSB7XG4gICAgICBkYXRhID0gaW5pdERhdGEoY29udGV4dCwgZGF0YSk7XG4gICAgfVxuICAgIGxldCBkZXB0aHMsXG4gICAgICAgIGJsb2NrUGFyYW1zID0gdGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zID8gW10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMpIHtcbiAgICAgIGlmIChvcHRpb25zLmRlcHRocykge1xuICAgICAgICBkZXB0aHMgPSBjb250ZXh0ICE9IG9wdGlvbnMuZGVwdGhzWzBdID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBvcHRpb25zLmRlcHRocztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQvKiwgb3B0aW9ucyovKSB7XG4gICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIH1cbiAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcbiAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxuICByZXQuaXNUb3AgPSB0cnVlO1xuXG4gIHJldC5fc2V0dXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xuXG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcbiAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcbiAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gb3B0aW9ucy5kZWNvcmF0b3JzO1xuICAgIH1cbiAgfTtcblxuICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgfTtcbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgZnVuY3Rpb24gcHJvZyhjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgY3VycmVudERlcHRocyA9IGRlcHRocztcbiAgICBpZiAoZGVwdGhzICYmIGNvbnRleHQgIT0gZGVwdGhzWzBdICYmICEoY29udGV4dCA9PT0gY29udGFpbmVyLm51bGxDb250ZXh0ICYmIGRlcHRoc1swXSA9PT0gbnVsbCkpIHtcbiAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGNvbnRhaW5lcixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscyxcbiAgICAgICAgb3B0aW9ucy5kYXRhIHx8IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLFxuICAgICAgICBjdXJyZW50RGVwdGhzKTtcbiAgfVxuXG4gIHByb2cgPSBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKTtcblxuICBwcm9nLnByb2dyYW0gPSBpO1xuICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XG4gIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XG4gIHJldHVybiBwcm9nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAoIXBhcnRpYWwpIHtcbiAgICBpZiAob3B0aW9ucy5uYW1lID09PSAnQHBhcnRpYWwtYmxvY2snKSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xuICAgIG9wdGlvbnMubmFtZSA9IHBhcnRpYWw7XG4gICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gVXNlIHRoZSBjdXJyZW50IGNsb3N1cmUgY29udGV4dCB0byBzYXZlIHRoZSBwYXJ0aWFsLWJsb2NrIGlmIHRoaXMgcGFydGlhbFxuICBjb25zdCBjdXJyZW50UGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XG4gIH1cblxuICBsZXQgcGFydGlhbEJsb2NrO1xuICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAvLyBXcmFwcGVyIGZ1bmN0aW9uIHRvIGdldCBhY2Nlc3MgdG8gY3VycmVudFBhcnRpYWxCbG9jayBmcm9tIHRoZSBjbG9zdXJlXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcbiAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGZ1bmN0aW9uIHBhcnRpYWxCbG9ja1dyYXBwZXIoY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHBhcnRpYWwtYmxvY2sgZnJvbSB0aGUgY2xvc3VyZSBmb3IgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYmxvY2tcbiAgICAgIC8vIGkuZS4gdGhlIHBhcnQgaW5zaWRlIHRoZSBibG9jayBvZiB0aGUgcGFydGlhbCBjYWxsLlxuICAgICAgb3B0aW9ucy5kYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgIG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gY3VycmVudFBhcnRpYWxCbG9jaztcbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlmIChmbi5wYXJ0aWFscykge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFscyA9IFV0aWxzLmV4dGVuZCh7fSwgb3B0aW9ucy5wYXJ0aWFscywgZm4ucGFydGlhbHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XG4gICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcbiAgfVxuXG4gIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgcmV0dXJuICcnOyB9XG5cbmZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEgPyBjcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xuICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcbiAgaWYgKGZuLmRlY29yYXRvcikge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIHByb2cgPSBmbi5kZWNvcmF0b3IocHJvZywgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGhzICYmIGRlcHRoc1swXSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvZztcbn1cbiIsIi8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xuICB0aGlzLnN0cmluZyA9IHN0cmluZztcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBTYWZlU3RyaW5nLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICcnICsgdGhpcy5zdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTYWZlU3RyaW5nO1xuIiwiY29uc3QgZXNjYXBlID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgJ2AnOiAnJiN4NjA7JyxcbiAgJz0nOiAnJiN4M0Q7J1xufTtcblxuY29uc3QgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxuICAgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XG5cbmZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XG4gIHJldHVybiBlc2NhcGVbY2hyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChvYmovKiAsIC4uLnNvdXJjZSAqLykge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XG4gICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGxldCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtc3R5bGUgKi9cbmxldCBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gIH07XG59XG5leHBvcnQge2lzRnVuY3Rpb259O1xuLyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XG59O1xuXG4vLyBPbGRlciBJRSB2ZXJzaW9ucyBkbyBub3QgZGlyZWN0bHkgc3VwcG9ydCBpbmRleE9mIHNvIHdlIG11c3QgaW1wbGVtZW50IG91ciBvd24sIHNhZGx5LlxuZXhwb3J0IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcbiAgICBpZiAoc3RyaW5nICYmIHN0cmluZy50b0hUTUwpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudG9IVE1MKCk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgc3RyaW5nIGNvbnZlcnNpb24gYXMgdGhpcyB3aWxsIGJlIGRvbmUgYnkgdGhlIGFwcGVuZCByZWdhcmRsZXNzIGFuZFxuICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxuICAgIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuICB9XG5cbiAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHsgcmV0dXJuIHN0cmluZzsgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcbiAgbGV0IGZyYW1lID0gZXh0ZW5kKHt9LCBvYmplY3QpO1xuICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xuICByZXR1cm4gZnJhbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xuICBwYXJhbXMucGF0aCA9IGlkcztcbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENvbnRleHRQYXRoKGNvbnRleHRQYXRoLCBpZCkge1xuICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcbn1cbiIsIi8vIFVTQUdFOlxuLy8gdmFyIGhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyk7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxuLy8gdmFyIGxvY2FsID0gaGFuZGxlYmFycy5jcmVhdGUoKTtcblxudmFyIGhhbmRsZWJhcnMgPSByZXF1aXJlKCcuLi9kaXN0L2Nqcy9oYW5kbGViYXJzJylbJ2RlZmF1bHQnXTtcblxudmFyIHByaW50ZXIgPSByZXF1aXJlKCcuLi9kaXN0L2Nqcy9oYW5kbGViYXJzL2NvbXBpbGVyL3ByaW50ZXInKTtcbmhhbmRsZWJhcnMuUHJpbnRWaXNpdG9yID0gcHJpbnRlci5QcmludFZpc2l0b3I7XG5oYW5kbGViYXJzLnByaW50ID0gcHJpbnRlci5wcmludDtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGViYXJzO1xuXG4vLyBQdWJsaXNoIGEgTm9kZS5qcyByZXF1aXJlKCkgaGFuZGxlciBmb3IgLmhhbmRsZWJhcnMgYW5kIC5oYnMgZmlsZXNcbmZ1bmN0aW9uIGV4dGVuc2lvbihtb2R1bGUsIGZpbGVuYW1lKSB7XG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHZhciB0ZW1wbGF0ZVN0cmluZyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBoYW5kbGViYXJzLmNvbXBpbGUodGVtcGxhdGVTdHJpbmcpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZS5leHRlbnNpb25zKSB7XG4gIHJlcXVpcmUuZXh0ZW5zaW9uc1snLmhhbmRsZWJhcnMnXSA9IGV4dGVuc2lvbjtcbiAgcmVxdWlyZS5leHRlbnNpb25zWycuaGJzJ10gPSBleHRlbnNpb247XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gICAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICAgKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gICAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAgICovXG4gIGZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc2V0ID0ge307XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gICAqL1xuICBBcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAgICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gICAqXG4gICAqIEByZXR1cm5zIE51bWJlclxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdmFyIGlzRHVwbGljYXRlID0gdGhpcy5oYXMoYVN0cik7XG4gICAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gICAgfVxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXSA9IGlkeDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgICBpZiAodGhpcy5oYXMoYVN0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gICAqXG4gICAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICAgIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICAgKi9cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBhTnVtYmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICAgKiBmYWlsdXJlLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gICAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gICAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICAgIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICAgIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gICAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gICAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICAgIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAgIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gICAgfVxuXG4gICAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICAgIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgICB9XG5cbiAgICAvLyA2MjogK1xuICAgIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgICByZXR1cm4gNjI7XG4gICAgfVxuXG4gICAgLy8gNjM6IC9cbiAgICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICAgIHJldHVybiA2MztcbiAgICB9XG5cbiAgICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbiAgZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAgICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAgIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAgICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAgICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICAgKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICAgKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAgIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gICAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAgIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAtLWluZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAgICogcG9zaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICAgKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAgICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAgICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAgICpcbiAgICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAgICovXG4gIE1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICAgIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJyYXk7XG4gIH07XG5cbiAgZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3RcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbiAgLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbiAgLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4gIC8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbiAgLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbiAgLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2ZcbiAgLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbiAgLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4gIC8qKlxuICAgKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBUaGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICAgKi9cbiAgZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgICBhcnlbeF0gPSBhcnlbeV07XG4gICAgYXJ5W3ldID0gdGVtcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICAgKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAgICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gICAqL1xuICBmdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAgICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICAgKiBAcGFyYW0ge051bWJlcn0gclxuICAgKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICAgKi9cbiAgZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gICAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gICAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAgIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICAgIGlmIChwIDwgcikge1xuICAgICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgICAgdmFyIGkgPSBwIC0gMTtcblxuICAgICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAgIC8vIHRydWU6XG4gICAgICAvL1xuICAgICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgICAgdmFyIHEgPSBpICsgMTtcblxuICAgICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAgICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAgICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAgICovXG4gIGV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xuICB9XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICAgIH07XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbiAgU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgICB2YXIgbWFwcGluZ3M7XG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gICAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAgICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICAgKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAgICpcbiAgICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwcGluZ3M7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICAgKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAgICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gICAqICAgICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICAgKi9cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICBzb3VyY2VzID0gc291cmNlcy5tYXAodXRpbC5ub3JtYWxpemUpO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICAgKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHNtYztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBwaW5nKCkge1xuICAgIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gICAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gICAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAgICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxpYmxlLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVybDtcbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgICAgbmVlZGxlLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICAgKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICAgKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICAgKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAgICogaW5wdXQuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICAgKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gICAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICAgKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAgICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAgICogICAgICAgZmllbGQuXG4gICAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICAgKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICAgKlxuICAgKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAgICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAgICogdW5zdXBwb3J0ZWQuXG4gICAqXG4gICAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gICAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gICAqXG4gICAqICB7XG4gICAqICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICAgKiAgICBzZWN0aW9uczogW3tcbiAgICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAgICogICAgICBtYXA6IHtcbiAgICogICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gICAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gICAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAgICogICAgICB9XG4gICAqICAgIH1dLFxuICAgKiAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gICAqL1xuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgICBsaW5lOiAtMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIGlmIChzLnVybCkge1xuICAgICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBzb3VyY2VzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIH0pO1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgbmFtZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICA6IDApLFxuICAgICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsYWJsZS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgIDogMClcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3NbaV07XG5cbiAgICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuY29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSlcbiAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbiAgLyoqXG4gICAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAgICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gICAgaWYgKCFhQXJncykge1xuICAgICAgYUFyZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICAgIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBnZW5lcmF0b3I7XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAgICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAgICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICAgKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICAgKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAgICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gICAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gICAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAgICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gICAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICAgKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG4gICAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgICAgLy8gQ2FzZSAxLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAgICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG1hcHBpbmc7XG5cbiAgICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7JztcbiAgICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG5cbiAgICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkpXG4gICAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgICB2YXIgbWFwID0ge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbiAgLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxuICB2YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4gIC8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xuICB2YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbiAgLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuICAvLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuICAvLyB2ZXJzaW9ucyFcbiAgdmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAgICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gICAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICAgKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAgICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICAgKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAgICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gICAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICAgIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gICAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICAgIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gICAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICpcbiAgICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICAgKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICAgKi9cbiAgU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxpbmVDb250ZW50cyA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCk7XG4gICAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgICAgfTtcblxuICAgICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBcIlwiO1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhQ2h1bmspIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICAgKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gICAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgICB2YXIgY2h1bms7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAgICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gICAqXG4gICAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgICB2YXIgbmV3Q2hpbGRyZW47XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICAgIH1cbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAgICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICAgKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gICAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc3RyICs9IGNodW5rO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAgICogbWFwLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgICAgY29kZTogXCJcIixcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gICAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbiAgfTtcblxuICBleHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuICBmdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gICAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgICAgaG9zdDogbWF0Y2hbM10sXG4gICAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICAgIHBhdGg6IG1hdGNoWzVdXG4gICAgfTtcbiAgfVxuICBleHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbiAgZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICAgIHZhciB1cmwgPSAnJztcbiAgICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgdXJsICs9ICcvLyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAgICpcbiAgICogLSBSZXBsYWNlcyBjb25zZXF1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAgICpcbiAgICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gICAgdmFyIHBhdGggPSBhUGF0aDtcbiAgICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHVybC5wYXRoO1xuICAgIH1cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICB9XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbiAgLyoqXG4gICAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gICAqXG4gICAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gICAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICAgKiAgIGZpcnN0LlxuICAgKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAgICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gICAqICAgaXMgcmV0dXJuZWQuXG4gICAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAgICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICAgKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cbiAgICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICAgIGFQYXRoID0gXCIuXCI7XG4gICAgfVxuICAgIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICAgIH1cblxuICAgIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gICAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICAgIH1cblxuICAgIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICAgIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICAgID8gYVBhdGhcbiAgICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGpvaW5lZDtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luO1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cblxuICAgIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gICAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gICAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICAgIHZhciBsZXZlbCA9IDA7XG4gICAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgKytsZXZlbDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxufSk7XG4iLCIvKiEhXG4gKiBIYXNoZXIgPGh0dHA6Ly9naXRodWIuY29tL21pbGxlcm1lZGVpcm9zL2hhc2hlcj5cbiAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gKiBAdmVyc2lvbiAxLjIuMCAoMjAxMy8xMS8xMSAwMzoxOCBQTSlcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5cbjsoZnVuY3Rpb24gKCkge1xudmFyIGZhY3RvcnkgPSBmdW5jdGlvbihzaWduYWxzKXtcblxuLypqc2hpbnQgd2hpdGU6ZmFsc2UqL1xuLypnbG9iYWwgc2lnbmFsczpmYWxzZSwgd2luZG93OmZhbHNlKi9cblxuLyoqXG4gKiBIYXNoZXJcbiAqIEBuYW1lc3BhY2UgSGlzdG9yeSBNYW5hZ2VyIGZvciByaWNoLW1lZGlhIGFwcGxpY2F0aW9ucy5cbiAqIEBuYW1lIGhhc2hlclxuICovXG52YXIgaGFzaGVyID0gKGZ1bmN0aW9uKHdpbmRvdyl7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJpdmF0ZSBWYXJzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyXG5cbiAgICAgICAgLy8gZnJlcXVlbmN5IHRoYXQgaXQgd2lsbCBjaGVjayBoYXNoIHZhbHVlIG9uIElFIDYtNyBzaW5jZSBpdCBkb2Vzbid0XG4gICAgICAgIC8vIHN1cHBvcnQgdGhlIGhhc2hjaGFuZ2UgZXZlbnRcbiAgICAgICAgUE9PTF9JTlRFUlZBTCA9IDI1LFxuXG4gICAgICAgIC8vIGxvY2FsIHN0b3JhZ2UgZm9yIGJyZXZpdHkgYW5kIGJldHRlciBjb21wcmVzc2lvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBoaXN0b3J5ID0gd2luZG93Lmhpc3RvcnksXG4gICAgICAgIFNpZ25hbCA9IHNpZ25hbHMuU2lnbmFsLFxuXG4gICAgICAgIC8vIGxvY2FsIHZhcnMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIGhhc2hlcixcbiAgICAgICAgX2hhc2gsXG4gICAgICAgIF9jaGVja0ludGVydmFsLFxuICAgICAgICBfaXNBY3RpdmUsXG4gICAgICAgIF9mcmFtZSwgLy9pZnJhbWUgdXNlZCBmb3IgbGVnYWN5IElFICg2LTcpXG4gICAgICAgIF9jaGVja0hpc3RvcnksXG4gICAgICAgIF9oYXNoVmFsUmVnZXhwID0gLyMoLiopJC8sXG4gICAgICAgIF9iYXNlVXJsUmVnZXhwID0gLyhcXD8uKil8KFxcIy4qKS8sXG4gICAgICAgIF9oYXNoUmVnZXhwID0gL15cXCMvLFxuXG4gICAgICAgIC8vIHNuaWZmaW5nL2ZlYXR1cmUgZGV0ZWN0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvL2hhY2sgYmFzZWQgb24gdGhpczogaHR0cDovL3dlYnJlZmxlY3Rpb24uYmxvZ3Nwb3QuY29tLzIwMDkvMDEvMzItYnl0ZXMtdG8ta25vdy1pZi15b3VyLWJyb3dzZXItaXMtaWUuaHRtbFxuICAgICAgICBfaXNJRSA9ICghK1wiXFx2MVwiKSxcbiAgICAgICAgLy8gaGFzaGNoYW5nZSBpcyBzdXBwb3J0ZWQgYnkgRkYzLjYrLCBJRTgrLCBDaHJvbWUgNSssIFNhZmFyaSA1KyBidXRcbiAgICAgICAgLy8gZmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgb24gSUUgY29tcGF0aWJpbGl0eSBtb2RlLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNoZWNrIGRvY3VtZW50TW9kZVxuICAgICAgICBfaXNIYXNoQ2hhbmdlU3VwcG9ydGVkID0gKCdvbmhhc2hjaGFuZ2UnIGluIHdpbmRvdykgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlICE9PSA3LFxuICAgICAgICAvL2NoZWNrIGlmIGlzIElFNi03IHNpbmNlIGhhc2ggY2hhbmdlIGlzIG9ubHkgc3VwcG9ydGVkIG9uIElFOCsgYW5kXG4gICAgICAgIC8vY2hhbmdpbmcgaGFzaCB2YWx1ZSBvbiBJRTYtNyBkb2Vzbid0IGdlbmVyYXRlIGhpc3RvcnkgcmVjb3JkLlxuICAgICAgICBfaXNMZWdhY3lJRSA9IF9pc0lFICYmICFfaXNIYXNoQ2hhbmdlU3VwcG9ydGVkLFxuICAgICAgICBfaXNMb2NhbCA9IChsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2ZpbGU6Jyk7XG5cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcml2YXRlIE1ldGhvZHNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBfZXNjYXBlUmVnRXhwKHN0cil7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc3RyIHx8ICcnKS5yZXBsYWNlKC9cXFcvZywgXCJcXFxcJCZcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3RyaW1IYXNoKGhhc2gpe1xuICAgICAgICBpZiAoIWhhc2gpIHJldHVybiAnJztcbiAgICAgICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgX2VzY2FwZVJlZ0V4cChoYXNoZXIucHJlcGVuZEhhc2gpICsgJ3wnICsgX2VzY2FwZVJlZ0V4cChoYXNoZXIuYXBwZW5kSGFzaCkgKyAnJCcsICdnJyk7XG4gICAgICAgIHJldHVybiBoYXNoLnJlcGxhY2UocmVnZXhwLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldFdpbmRvd0hhc2goKXtcbiAgICAgICAgLy9wYXJzZWQgZnVsbCBVUkwgaW5zdGVhZCBvZiBnZXR0aW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGJlY2F1c2UgRmlyZWZveCBkZWNvZGUgaGFzaCB2YWx1ZSAoYW5kIGFsbCB0aGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3QpXG4gICAgICAgIC8vYWxzbyBiZWNhdXNlIG9mIElFOCBidWcgd2l0aCBoYXNoIHF1ZXJ5IGluIGxvY2FsIGZpbGUgW2lzc3VlICM2XVxuICAgICAgICB2YXIgcmVzdWx0ID0gX2hhc2hWYWxSZWdleHAuZXhlYyggaGFzaGVyLmdldFVSTCgpICk7XG4gICAgICAgIHZhciBwYXRoID0gKHJlc3VsdCAmJiByZXN1bHRbMV0pIHx8ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBoYXNoZXIucmF3PyBwYXRoIDogZGVjb2RlVVJJQ29tcG9uZW50KHBhdGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB1c2VyIGRpZCBub3Qgc2V0IGBoYXNoZXIucmF3YCBhbmQgZGVjb2RlVVJJQ29tcG9uZW50XG4gICAgICAgICAgLy8gdGhyb3dzIGFuIGVycm9yIChzZWUgIzU3KVxuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldEZyYW1lSGFzaCgpe1xuICAgICAgICByZXR1cm4gKF9mcmFtZSk/IF9mcmFtZS5jb250ZW50V2luZG93LmZyYW1lSGFzaCA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZUZyYW1lKCl7XG4gICAgICAgIF9mcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBfZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgX2ZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2ZyYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdXBkYXRlRnJhbWUoKXtcbiAgICAgICAgaWYoX2ZyYW1lICYmIF9oYXNoICE9PSBfZ2V0RnJhbWVIYXNoKCkpe1xuICAgICAgICAgICAgdmFyIGZyYW1lRG9jID0gX2ZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgICAgICBmcmFtZURvYy5vcGVuKCk7XG4gICAgICAgICAgICAvL3VwZGF0ZSBpZnJhbWUgY29udGVudCB0byBmb3JjZSBuZXcgaGlzdG9yeSByZWNvcmQuXG4gICAgICAgICAgICAvL2Jhc2VkIG9uIFJlYWxseSBTaW1wbGUgSGlzdG9yeSwgU1dGQWRkcmVzcyBhbmQgWVVJLmhpc3RvcnkuXG4gICAgICAgICAgICBmcmFtZURvYy53cml0ZSgnPGh0bWw+PGhlYWQ+PHRpdGxlPicgKyBkb2N1bWVudC50aXRsZSArICc8L3RpdGxlPjxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPnZhciBmcmFtZUhhc2g9XCInICsgX2hhc2ggKyAnXCI7PC9zY3JpcHQ+PC9oZWFkPjxib2R5PiZuYnNwOzwvYm9keT48L2h0bWw+Jyk7XG4gICAgICAgICAgICBmcmFtZURvYy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlZ2lzdGVyQ2hhbmdlKG5ld0hhc2gsIGlzUmVwbGFjZSl7XG4gICAgICAgIGlmKF9oYXNoICE9PSBuZXdIYXNoKXtcbiAgICAgICAgICAgIHZhciBvbGRIYXNoID0gX2hhc2g7XG4gICAgICAgICAgICBfaGFzaCA9IG5ld0hhc2g7IC8vc2hvdWxkIGNvbWUgYmVmb3JlIGV2ZW50IGRpc3BhdGNoIHRvIG1ha2Ugc3VyZSB1c2VyIGNhbiBnZXQgcHJvcGVyIHZhbHVlIGluc2lkZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBpZihfaXNMZWdhY3lJRSl7XG4gICAgICAgICAgICAgICAgaWYoIWlzUmVwbGFjZSl7XG4gICAgICAgICAgICAgICAgICAgIF91cGRhdGVGcmFtZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9mcmFtZS5jb250ZW50V2luZG93LmZyYW1lSGFzaCA9IG5ld0hhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzaGVyLmNoYW5nZWQuZGlzcGF0Y2goX3RyaW1IYXNoKG5ld0hhc2gpLCBfdHJpbUhhc2gob2xkSGFzaCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9pc0xlZ2FjeUlFKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2NoZWNrSGlzdG9yeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgd2luZG93SGFzaCA9IF9nZXRXaW5kb3dIYXNoKCksXG4gICAgICAgICAgICAgICAgZnJhbWVIYXNoID0gX2dldEZyYW1lSGFzaCgpO1xuICAgICAgICAgICAgaWYoZnJhbWVIYXNoICE9PSBfaGFzaCAmJiBmcmFtZUhhc2ggIT09IHdpbmRvd0hhc2gpe1xuICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGNoYW5nZXMgbWFkZSBwcmVzc2luZyBicm93c2VyIGhpc3RvcnkgYnV0dG9ucy5cbiAgICAgICAgICAgICAgICAvL1dvcmthcm91bmQgc2luY2UgaGlzdG9yeS5iYWNrKCkgYW5kIGhpc3RvcnkuZm9yd2FyZCgpIGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAvL3VwZGF0ZSBoYXNoIHZhbHVlIG9uIElFNi83IGJ1dCB1cGRhdGVzIGNvbnRlbnQgb2YgdGhlIGlmcmFtZS5cbiAgICAgICAgICAgICAgICAvL25lZWRzIHRvIHRyaW0gaGFzaCBzaW5jZSB2YWx1ZSBzdG9yZWQgYWxyZWFkeSBoYXZlXG4gICAgICAgICAgICAgICAgLy9wcmVwZW5kSGFzaCArIGFwcGVuZEhhc2ggZm9yIGZhc3QgY2hlY2suXG4gICAgICAgICAgICAgICAgaGFzaGVyLnNldEhhc2goX3RyaW1IYXNoKGZyYW1lSGFzaCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3dIYXNoICE9PSBfaGFzaCl7XG4gICAgICAgICAgICAgICAgLy9kZXRlY3QgaWYgaGFzaCBjaGFuZ2VkIChtYW51YWxseSBvciB1c2luZyBzZXRIYXNoKVxuICAgICAgICAgICAgICAgIF9yZWdpc3RlckNoYW5nZSh3aW5kb3dIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9jaGVja0hpc3RvcnkgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIHdpbmRvd0hhc2ggPSBfZ2V0V2luZG93SGFzaCgpO1xuICAgICAgICAgICAgaWYod2luZG93SGFzaCAhPT0gX2hhc2gpe1xuICAgICAgICAgICAgICAgIF9yZWdpc3RlckNoYW5nZSh3aW5kb3dIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIoZWxtLCBlVHlwZSwgZm4pe1xuICAgICAgICBpZihlbG0uYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihlVHlwZSwgZm4sIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbG0uYXR0YWNoRXZlbnQpe1xuICAgICAgICAgICAgZWxtLmF0dGFjaEV2ZW50KCdvbicgKyBlVHlwZSwgZm4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsbSwgZVR5cGUsIGZuKXtcbiAgICAgICAgaWYoZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIpe1xuICAgICAgICAgICAgZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZVR5cGUsIGZuLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxtLmRldGFjaEV2ZW50KXtcbiAgICAgICAgICAgIGVsbS5kZXRhY2hFdmVudCgnb24nICsgZVR5cGUsIGZuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYWtlUGF0aChwYXRocyl7XG4gICAgICAgIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzLmpvaW4oaGFzaGVyLnNlcGFyYXRvcik7XG4gICAgICAgIHBhdGggPSBwYXRoPyBoYXNoZXIucHJlcGVuZEhhc2ggKyBwYXRoLnJlcGxhY2UoX2hhc2hSZWdleHAsICcnKSArIGhhc2hlci5hcHBlbmRIYXNoIDogcGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2VuY29kZVBhdGgocGF0aCl7XG4gICAgICAgIC8vdXNlZCBlbmNvZGVVUkkgaW5zdGVhZCBvZiBlbmNvZGVVUklDb21wb25lbnQgdG8gcHJlc2VydmUgJz8nLCAnLycsXG4gICAgICAgIC8vJyMnLiBGaXhlcyBTYWZhcmkgYnVnIFtpc3N1ZSAjOF1cbiAgICAgICAgcGF0aCA9IGVuY29kZVVSSShwYXRoKTtcbiAgICAgICAgaWYoX2lzSUUgJiYgX2lzTG9jYWwpe1xuICAgICAgICAgICAgLy9maXggSUU4IGxvY2FsIGZpbGUgYnVnIFtpc3N1ZSAjNl1cbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcPy8sICclM0YnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHVibGljIChBUEkpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaGFzaGVyID0gLyoqIEBsZW5kcyBoYXNoZXIgKi8ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXNoZXIgVmVyc2lvbiBOdW1iZXJcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqIEBjb25zdGFudFxuICAgICAgICAgKi9cbiAgICAgICAgVkVSU0lPTiA6ICcxLjIuMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvb2xlYW4gZGVjaWRpbmcgaWYgaGFzaGVyIGVuY29kZXMvZGVjb2RlcyB0aGUgaGFzaCBvciBub3QuXG4gICAgICAgICAqIDx1bD5cbiAgICAgICAgICogPGxpPmRlZmF1bHQgdmFsdWU6IGZhbHNlOzwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHJhdyA6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmcgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgSGFzaCB2YWx1ZS5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiA8bGk+ZGVmYXVsdCB2YWx1ZTogJyc7PC9saT5cbiAgICAgICAgICogPGxpPndpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gYGhhc2hlci5nZXRIYXNoKClgPC9saT5cbiAgICAgICAgICogPGxpPmF2b2lkIGNvbmZsaWN0cyB3aXRoIGVsZW1lbnRzIHRoYXQgY29udGFpbiBJRCBlcXVhbCB0byBoYXNoIHZhbHVlOzwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kSGFzaCA6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmcgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgSGFzaCB2YWx1ZS5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiA8bGk+ZGVmYXVsdCB2YWx1ZTogJy8nOzwvbGk+XG4gICAgICAgICAqIDxsaT53aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIGBoYXNoZXIuZ2V0SGFzaCgpYDwvbGk+XG4gICAgICAgICAqIDxsaT5hdm9pZCBjb25mbGljdHMgd2l0aCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gSUQgZXF1YWwgdG8gaGFzaCB2YWx1ZTs8L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHByZXBlbmRIYXNoIDogJy8nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmcgdXNlZCB0byBzcGxpdCBoYXNoIHBhdGhzOyB1c2VkIGJ5IGBoYXNoZXIuZ2V0SGFzaEFzQXJyYXkoKWAgdG8gc3BsaXQgcGF0aHMuXG4gICAgICAgICAqIDx1bD5cbiAgICAgICAgICogPGxpPmRlZmF1bHQgdmFsdWU6ICcvJzs8L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNlcGFyYXRvciA6ICcvJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2lnbmFsIGRpc3BhdGNoZWQgd2hlbiBoYXNoIHZhbHVlIGNoYW5nZXMuXG4gICAgICAgICAqIC0gcGFzcyBjdXJyZW50IGhhc2ggYXMgMXN0IHBhcmFtZXRlciB0byBsaXN0ZW5lcnMgYW5kIHByZXZpb3VzIGhhc2ggdmFsdWUgYXMgMm5kIHBhcmFtZXRlci5cbiAgICAgICAgICogQHR5cGUgc2lnbmFscy5TaWduYWxcbiAgICAgICAgICovXG4gICAgICAgIGNoYW5nZWQgOiBuZXcgU2lnbmFsKCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbCBkaXNwYXRjaGVkIHdoZW4gaGFzaGVyIGlzIHN0b3BwZWQuXG4gICAgICAgICAqIC0gIHBhc3MgY3VycmVudCBoYXNoIGFzIGZpcnN0IHBhcmFtZXRlciB0byBsaXN0ZW5lcnNcbiAgICAgICAgICogQHR5cGUgc2lnbmFscy5TaWduYWxcbiAgICAgICAgICovXG4gICAgICAgIHN0b3BwZWQgOiBuZXcgU2lnbmFsKCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbCBkaXNwYXRjaGVkIHdoZW4gaGFzaGVyIGlzIGluaXRpYWxpemVkLlxuICAgICAgICAgKiAtIHBhc3MgY3VycmVudCBoYXNoIGFzIGZpcnN0IHBhcmFtZXRlciB0byBsaXN0ZW5lcnMuXG4gICAgICAgICAqIEB0eXBlIHNpZ25hbHMuU2lnbmFsXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplZCA6IG5ldyBTaWduYWwoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgbGlzdGVuaW5nL2Rpc3BhdGNoaW5nIGNoYW5nZXMgaW4gdGhlIGhhc2gvaGlzdG9yeS5cbiAgICAgICAgICogPHVsPlxuICAgICAgICAgKiAgIDxsaT5oYXNoZXIgd29uJ3QgZGlzcGF0Y2ggQ0hBTkdFIGV2ZW50cyBieSBtYW51YWxseSB0eXBpbmcgYSBuZXcgdmFsdWUgb3IgcHJlc3NpbmcgdGhlIGJhY2svZm9yd2FyZCBidXR0b25zIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLjwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqL1xuICAgICAgICBpbml0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKF9pc0FjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBfaGFzaCA9IF9nZXRXaW5kb3dIYXNoKCk7XG5cbiAgICAgICAgICAgIC8vdGhvdWdodCBhYm91dCBicmFuY2hpbmcvb3ZlcmxvYWRpbmcgaGFzaGVyLmluaXQoKSB0byBhdm9pZCBjaGVja2luZyBtdWx0aXBsZSB0aW1lcyBidXRcbiAgICAgICAgICAgIC8vZG9uJ3QgdGhpbmsgd29ydGggZG9pbmcgaXQgc2luY2UgaXQgcHJvYmFibHkgd29uJ3QgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgaWYoX2lzSGFzaENoYW5nZVN1cHBvcnRlZCl7XG4gICAgICAgICAgICAgICAgX2FkZExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBfY2hlY2tIaXN0b3J5KTtcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBpZihfaXNMZWdhY3lJRSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCEgX2ZyYW1lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jcmVhdGVGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF91cGRhdGVGcmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKF9jaGVja0hpc3RvcnksIFBPT0xfSU5URVJWQUwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgaGFzaGVyLmluaXRpYWxpemVkLmRpc3BhdGNoKF90cmltSGFzaChfaGFzaCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGxpc3RlbmluZy9kaXNwYXRjaGluZyBjaGFuZ2VzIGluIHRoZSBoYXNoL2hpc3RvcnkuXG4gICAgICAgICAqIDx1bD5cbiAgICAgICAgICogICA8bGk+aGFzaGVyIHdvbid0IGRpc3BhdGNoIENIQU5HRSBldmVudHMgYnkgbWFudWFsbHkgdHlwaW5nIGEgbmV3IHZhbHVlIG9yIHByZXNzaW5nIHRoZSBiYWNrL2ZvcndhcmQgYnV0dG9ucyBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCB1bmxlc3MgeW91IGNhbGwgaGFzaGVyLmluaXQoKSBhZ2Fpbi48L2xpPlxuICAgICAgICAgKiAgIDxsaT5oYXNoZXIgd2lsbCBzdGlsbCBkaXNwYXRjaCBjaGFuZ2VzIG1hZGUgcHJvZ3JhbWF0aWNhbGx5IGJ5IGNhbGxpbmcgaGFzaGVyLnNldEhhc2goKTs8L2xpPlxuICAgICAgICAgKiA8L3VsPlxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZighIF9pc0FjdGl2ZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZihfaXNIYXNoQ2hhbmdlU3VwcG9ydGVkKXtcbiAgICAgICAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIF9jaGVja0hpc3RvcnkpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfY2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgX2NoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGhhc2hlci5zdG9wcGVkLmRpc3BhdGNoKF90cmltSGFzaChfaGFzaCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgICBJZiBoYXNoZXIgaXMgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gdGhlIGJyb3dzZXIgaGlzdG9yeSBhbmQvb3IgaGFzaCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzQWN0aXZlIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBfaXNBY3RpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBVUkwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRVUkwgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHJpZXZlIFVSTCB3aXRob3V0IHF1ZXJ5IHN0cmluZyBhbmQgaGFzaC5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJhc2VVUkwgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hlci5nZXRVUkwoKS5yZXBsYWNlKF9iYXNlVXJsUmVnZXhwLCAnJyk7IC8vcmVtb3ZlcyBldmVyeXRoaW5nIGFmdGVyICc/JyBhbmQvb3IgJyMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBIYXNoIHZhbHVlLCBnZW5lcmF0aW5nIGEgbmV3IGhpc3RvcnkgcmVjb3JkLlxuICAgICAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gcGF0aCAgICBIYXNoIHZhbHVlIHdpdGhvdXQgJyMnLiBIYXNoZXIgd2lsbCBqb2luXG4gICAgICAgICAqIHBhdGggc2VnbWVudHMgdXNpbmcgYGhhc2hlci5zZXBhcmF0b3JgIGFuZCBwcmVwZW5kL2FwcGVuZCBoYXNoIHZhbHVlXG4gICAgICAgICAqIHdpdGggYGhhc2hlci5hcHBlbmRIYXNoYCBhbmQgYGhhc2hlci5wcmVwZW5kSGFzaGBcbiAgICAgICAgICogQGV4YW1wbGUgaGFzaGVyLnNldEhhc2goJ2xvcmVtJywgJ2lwc3VtJywgJ2RvbG9yJykgLT4gJyMvbG9yZW0vaXBzdW0vZG9sb3InXG4gICAgICAgICAqL1xuICAgICAgICBzZXRIYXNoIDogZnVuY3Rpb24ocGF0aCl7XG4gICAgICAgICAgICBwYXRoID0gX21ha2VQYXRoLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZihwYXRoICE9PSBfaGFzaCl7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHN0b3JlIHJhdyB2YWx1ZVxuICAgICAgICAgICAgICAgIF9yZWdpc3RlckNoYW5nZShwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gX2hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2hlY2sgaWYgcGF0aCBpcyBzdGlsbCA9PT0gX2hhc2ggdG8gYXZvaWQgZXJyb3IgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSBvZiBtdWx0aXBsZSBjb25zZWN1dGl2ZSByZWRpcmVjdHMgW2lzc3VlICMzOV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgaGFzaGVyLnJhdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IF9lbmNvZGVQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgcGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBIYXNoIHZhbHVlIHdpdGhvdXQga2VlcGluZyBwcmV2aW91cyBoYXNoIG9uIHRoZSBoaXN0b3J5IHJlY29yZC5cbiAgICAgICAgICogU2ltaWxhciB0byBjYWxsaW5nIGB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcIiMvaGFzaFwiKWAgYnV0IHdpbGwgYWxzbyB3b3JrIG9uIElFNi03LlxuICAgICAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gcGF0aCAgICBIYXNoIHZhbHVlIHdpdGhvdXQgJyMnLiBIYXNoZXIgd2lsbCBqb2luXG4gICAgICAgICAqIHBhdGggc2VnbWVudHMgdXNpbmcgYGhhc2hlci5zZXBhcmF0b3JgIGFuZCBwcmVwZW5kL2FwcGVuZCBoYXNoIHZhbHVlXG4gICAgICAgICAqIHdpdGggYGhhc2hlci5hcHBlbmRIYXNoYCBhbmQgYGhhc2hlci5wcmVwZW5kSGFzaGBcbiAgICAgICAgICogQGV4YW1wbGUgaGFzaGVyLnJlcGxhY2VIYXNoKCdsb3JlbScsICdpcHN1bScsICdkb2xvcicpIC0+ICcjL2xvcmVtL2lwc3VtL2RvbG9yJ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVwbGFjZUhhc2ggOiBmdW5jdGlvbihwYXRoKXtcbiAgICAgICAgICAgIHBhdGggPSBfbWFrZVBhdGguYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmKHBhdGggIT09IF9oYXNoKXtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgc3RvcmUgcmF3IHZhbHVlXG4gICAgICAgICAgICAgICAgX3JlZ2lzdGVyQ2hhbmdlKHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayBpZiBwYXRoIGlzIHN0aWxsID09PSBfaGFzaCB0byBhdm9pZCBlcnJvciBpblxuICAgICAgICAgICAgICAgICAgICAvLyBjYXNlIG9mIG11bHRpcGxlIGNvbnNlY3V0aXZlIHJlZGlyZWN0cyBbaXNzdWUgIzM5XVxuICAgICAgICAgICAgICAgICAgICBpZiAoISBoYXNoZXIucmF3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gX2VuY29kZVBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoJyMnICsgcGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhhc2ggdmFsdWUgd2l0aG91dCAnIycsIGBoYXNoZXIuYXBwZW5kSGFzaGAgYW5kIGBoYXNoZXIucHJlcGVuZEhhc2hgLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFzaCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvL2RpZG4ndCB1c2VkIGFjdHVhbCB2YWx1ZSBvZiB0aGUgYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCB0byBhdm9pZCBicmVha2luZyB0aGUgYXBwbGljYXRpb24gaW4gY2FzZSBgd2luZG93LmxvY2F0aW9uLmhhc2hgIGlzbid0IGF2YWlsYWJsZSBhbmQgYWxzbyBiZWNhdXNlIHZhbHVlIHNob3VsZCBhbHdheXMgYmUgc3luY2hlZC5cbiAgICAgICAgICAgIHJldHVybiBfdHJpbUhhc2goX2hhc2gpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gSGFzaCB2YWx1ZSBzcGxpdCBpbnRvIGFuIEFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SGFzaEFzQXJyYXkgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hlci5nZXRIYXNoKCkuc3BsaXQoaGFzaGVyLnNlcGFyYXRvcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVycywgc3RvcHMgaGFzaGVyIGFuZCBkZXN0cm95IGhhc2hlciBvYmplY3QuXG4gICAgICAgICAqIC0gSU1QT1JUQU5UOiBoYXNoZXIgd29uJ3Qgd29yayBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCBoYXNoZXIgT2JqZWN0IHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaGFzaGVyLnN0b3AoKTtcbiAgICAgICAgICAgIGhhc2hlci5pbml0aWFsaXplZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICBoYXNoZXIuc3RvcHBlZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICBoYXNoZXIuY2hhbmdlZC5kaXNwb3NlKCk7XG4gICAgICAgICAgICBfZnJhbWUgPSBoYXNoZXIgPSB3aW5kb3cuaGFzaGVyID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuICdbaGFzaGVyIHZlcnNpb249XCInKyBoYXNoZXIuVkVSU0lPTiArJ1wiIGhhc2g9XCInKyBoYXNoZXIuZ2V0SGFzaCgpICsnXCJdJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGhhc2hlci5pbml0aWFsaXplZC5tZW1vcml6ZSA9IHRydWU7IC8vc2VlICMzM1xuXG4gICAgcmV0dXJuIGhhc2hlcjtcblxufSh3aW5kb3cpKTtcblxuXG4gICAgcmV0dXJuIGhhc2hlcjtcbn07XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydzaWduYWxzJ10sIGZhY3RvcnkpO1xufSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc2lnbmFscycpKTtcbn0gZWxzZSB7XG4gICAgLypqc2hpbnQgc3ViOnRydWUgKi9cbiAgICB3aW5kb3dbJ2hhc2hlciddID0gZmFjdG9yeSh3aW5kb3dbJ3NpZ25hbHMnXSk7XG59XG5cbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgY2FsbGVlOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSBjcmVhdGVQcm92aWRlcjtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xuXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4uL3V0aWxzL1Byb3BUeXBlcycpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKCkge1xuICBpZiAoZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGlkV2FybkFib3V0UmVjZWl2aW5nU3RvcmUgPSB0cnVlO1xuXG4gICgwLCBfd2FybmluZzIuZGVmYXVsdCkoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyKCkge1xuICB2YXIgX1Byb3ZpZGVyJGNoaWxkQ29udGV4O1xuXG4gIHZhciBzdG9yZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3N0b3JlJztcbiAgdmFyIHN1YktleSA9IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgc3Vic2NyaXB0aW9uS2V5ID0gc3ViS2V5IHx8IHN0b3JlS2V5ICsgJ1N1YnNjcmlwdGlvbic7XG5cbiAgdmFyIFByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gICAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3N0b3JlS2V5XSA9IHRoaXNbc3RvcmVLZXldLCBfcmVmW3N1YnNjcmlwdGlvbktleV0gPSBudWxsLCBfcmVmO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgIF90aGlzW3N0b3JlS2V5XSA9IHByb3BzLnN0b3JlO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBQcm92aWRlcjtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgaWYgKHRoaXNbc3RvcmVLZXldICE9PSBuZXh0UHJvcHMuc3RvcmUpIHtcbiAgICAgICAgd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBfUHJvcFR5cGVzLnN0b3JlU2hhcGUuaXNSZXF1aXJlZCxcbiAgICBjaGlsZHJlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5lbGVtZW50LmlzUmVxdWlyZWRcbiAgfTtcbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtzdG9yZUtleV0gPSBfUHJvcFR5cGVzLnN0b3JlU2hhcGUuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W3N1YnNjcmlwdGlvbktleV0gPSBfUHJvcFR5cGVzLnN1YnNjcmlwdGlvblNoYXBlLCBfUHJvdmlkZXIkY2hpbGRDb250ZXgpO1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlUHJvdmlkZXIoKTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvbm5lY3RBZHZhbmNlZDtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9TdWJzY3JpcHRpb24gPSByZXF1aXJlKCcuLi91dGlscy9TdWJzY3JpcHRpb24nKTtcblxudmFyIF9TdWJzY3JpcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU3Vic2NyaXB0aW9uKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBob3RSZWxvYWRpbmdWZXJzaW9uID0gMDtcbnZhciBkdW1teVN0YXRlID0ge307XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIG1ha2VTZWxlY3RvclN0YXRlZnVsKHNvdXJjZVNlbGVjdG9yLCBzdG9yZSkge1xuICAvLyB3cmFwIHRoZSBzZWxlY3RvciBpbiBhbiBvYmplY3QgdGhhdCB0cmFja3MgaXRzIHJlc3VsdHMgYmV0d2VlbiBydW5zLlxuICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgcnVuOiBmdW5jdGlvbiBydW5Db21wb25lbnRTZWxlY3Rvcihwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHNvdXJjZVNlbGVjdG9yKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgaWYgKG5leHRQcm9wcyAhPT0gc2VsZWN0b3IucHJvcHMgfHwgc2VsZWN0b3IuZXJyb3IpIHtcbiAgICAgICAgICBzZWxlY3Rvci5zaG91bGRDb21wb25lbnRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHNlbGVjdG9yLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICAgIHNlbGVjdG9yLmVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0b3IuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0QWR2YW5jZWQoXG4vKlxuICBzZWxlY3RvckZhY3RvcnkgaXMgYSBmdW5jIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgc2VsZWN0b3IgZnVuY3Rpb24gdXNlZCB0b1xuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcbiAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcbiAgICAgIHRoaW5nOiBzdGF0ZS50aGluZ3NbcHJvcHMudGhpbmdJZF0sXG4gICAgICBzYXZlVGhpbmc6IGZpZWxkcyA9PiBkaXNwYXRjaChhY3Rpb25DcmVhdG9ycy5zYXZlVGhpbmcocHJvcHMudGhpbmdJZCwgZmllbGRzKSksXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXG4gICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcbiAgb3V0c2lkZSBvZiB0aGVpciBzZWxlY3RvciBhcyBhbiBvcHRpbWl6YXRpb24uIE9wdGlvbnMgcGFzc2VkIHRvIGNvbm5lY3RBZHZhbmNlZCBhcmUgcGFzc2VkIHRvXG4gIHRoZSBzZWxlY3RvckZhY3RvcnksIGFsb25nIHdpdGggZGlzcGxheU5hbWUgYW5kIFdyYXBwZWRDb21wb25lbnQsIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICBOb3RlIHRoYXQgc2VsZWN0b3JGYWN0b3J5IGlzIHJlc3BvbnNpYmxlIGZvciBhbGwgY2FjaGluZy9tZW1vaXphdGlvbiBvZiBpbmJvdW5kIGFuZCBvdXRib3VuZFxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcbiAgc2VsZWN0b3IsIG90aGVyd2lzZSB0aGUgQ29ubmVjdCBjb21wb25lbnQgd2lsbCByZS1yZW5kZXIgb24gZXZlcnkgc3RhdGUgb3IgcHJvcHMgY2hhbmdlLlxuKi9cbnNlbGVjdG9yRmFjdG9yeSkge1xuICB2YXIgX2NvbnRleHRUeXBlcywgX2NoaWxkQ29udGV4dFR5cGVzO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkZ2V0RGlzcGxheU5hbWUgPSBfcmVmLmdldERpc3BsYXlOYW1lLFxuICAgICAgZ2V0RGlzcGxheU5hbWUgPSBfcmVmJGdldERpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAnQ29ubmVjdEFkdmFuY2VkKCcgKyBuYW1lICsgJyknO1xuICB9IDogX3JlZiRnZXREaXNwbGF5TmFtZSxcbiAgICAgIF9yZWYkbWV0aG9kTmFtZSA9IF9yZWYubWV0aG9kTmFtZSxcbiAgICAgIG1ldGhvZE5hbWUgPSBfcmVmJG1ldGhvZE5hbWUgPT09IHVuZGVmaW5lZCA/ICdjb25uZWN0QWR2YW5jZWQnIDogX3JlZiRtZXRob2ROYW1lLFxuICAgICAgX3JlZiRyZW5kZXJDb3VudFByb3AgPSBfcmVmLnJlbmRlckNvdW50UHJvcCxcbiAgICAgIHJlbmRlckNvdW50UHJvcCA9IF9yZWYkcmVuZGVyQ291bnRQcm9wID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfcmVmJHJlbmRlckNvdW50UHJvcCxcbiAgICAgIF9yZWYkc2hvdWxkSGFuZGxlU3RhdCA9IF9yZWYuc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzID0gX3JlZiRzaG91bGRIYW5kbGVTdGF0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRzaG91bGRIYW5kbGVTdGF0LFxuICAgICAgX3JlZiRzdG9yZUtleSA9IF9yZWYuc3RvcmVLZXksXG4gICAgICBzdG9yZUtleSA9IF9yZWYkc3RvcmVLZXkgPT09IHVuZGVmaW5lZCA/ICdzdG9yZScgOiBfcmVmJHN0b3JlS2V5LFxuICAgICAgX3JlZiR3aXRoUmVmID0gX3JlZi53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9yZWYkd2l0aFJlZiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHdpdGhSZWYsXG4gICAgICBjb25uZWN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2dldERpc3BsYXlOYW1lJywgJ21ldGhvZE5hbWUnLCAncmVuZGVyQ291bnRQcm9wJywgJ3Nob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcycsICdzdG9yZUtleScsICd3aXRoUmVmJ10pO1xuXG4gIHZhciBzdWJzY3JpcHRpb25LZXkgPSBzdG9yZUtleSArICdTdWJzY3JpcHRpb24nO1xuICB2YXIgdmVyc2lvbiA9IGhvdFJlbG9hZGluZ1ZlcnNpb24rKztcblxuICB2YXIgY29udGV4dFR5cGVzID0gKF9jb250ZXh0VHlwZXMgPSB7fSwgX2NvbnRleHRUeXBlc1tzdG9yZUtleV0gPSBfUHJvcFR5cGVzLnN0b3JlU2hhcGUsIF9jb250ZXh0VHlwZXNbc3Vic2NyaXB0aW9uS2V5XSA9IF9Qcm9wVHlwZXMuc3Vic2NyaXB0aW9uU2hhcGUsIF9jb250ZXh0VHlwZXMpO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSAoX2NoaWxkQ29udGV4dFR5cGVzID0ge30sIF9jaGlsZENvbnRleHRUeXBlc1tzdWJzY3JpcHRpb25LZXldID0gX1Byb3BUeXBlcy5zdWJzY3JpcHRpb25TaGFwZSwgX2NoaWxkQ29udGV4dFR5cGVzKTtcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkodHlwZW9mIFdyYXBwZWRDb21wb25lbnQgPT0gJ2Z1bmN0aW9uJywgJ1lvdSBtdXN0IHBhc3MgYSBjb21wb25lbnQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5ICcgKyAobWV0aG9kTmFtZSArICcuIEluc3RlYWQgcmVjZWl2ZWQgJyArIEpTT04uc3RyaW5naWZ5KFdyYXBwZWRDb21wb25lbnQpKSk7XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lKHdyYXBwZWRDb21wb25lbnROYW1lKTtcblxuICAgIHZhciBzZWxlY3RvckZhY3RvcnlPcHRpb25zID0gX2V4dGVuZHMoe30sIGNvbm5lY3RPcHRpb25zLCB7XG4gICAgICBnZXREaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWUsXG4gICAgICBtZXRob2ROYW1lOiBtZXRob2ROYW1lLFxuICAgICAgcmVuZGVyQ291bnRQcm9wOiByZW5kZXJDb3VudFByb3AsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXM6IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyxcbiAgICAgIHN0b3JlS2V5OiBzdG9yZUtleSxcbiAgICAgIHdpdGhSZWY6IHdpdGhSZWYsXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgQ29ubmVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoQ29ubmVjdCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHNbc3RvcmVLZXldIHx8IGNvbnRleHRbc3RvcmVLZXldO1xuICAgICAgICBfdGhpcy5wcm9wc01vZGUgPSBCb29sZWFuKHByb3BzW3N0b3JlS2V5XSk7XG4gICAgICAgIF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZSA9IF90aGlzLnNldFdyYXBwZWRJbnN0YW5jZS5iaW5kKF90aGlzKTtcblxuICAgICAgICAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcIicgKyBzdG9yZUtleSArICdcIiBpbiBlaXRoZXIgdGhlIGNvbnRleHQgb3IgcHJvcHMgb2YgJyArICgnXCInICsgZGlzcGxheU5hbWUgKyAnXCIuIEVpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcpICsgKCdvciBleHBsaWNpdGx5IHBhc3MgXCInICsgc3RvcmVLZXkgKyAnXCIgYXMgYSBwcm9wIHRvIFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICBfdGhpcy5pbml0U2VsZWN0b3IoKTtcbiAgICAgICAgX3RoaXMuaW5pdFN1YnNjcmlwdGlvbigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICAgICAgdmFyIF9yZWYyO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IHJlY2VpdmVkIHN0b3JlIGZyb20gcHJvcHMsIGl0cyBzdWJzY3JpcHRpb24gc2hvdWxkIGJlIHRyYW5zcGFyZW50XG4gICAgICAgIC8vIHRvIGFueSBkZXNjZW5kYW50cyByZWNlaXZpbmcgc3RvcmUrc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dDsgaXQgcGFzc2VzIGFsb25nXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiBwYXNzZWQgdG8gaXQuIE90aGVyd2lzZSwgaXQgc2hhZG93cyB0aGUgcGFyZW50IHN1YnNjcmlwdGlvbiwgd2hpY2ggYWxsb3dzXG4gICAgICAgIC8vIENvbm5lY3QgdG8gY29udHJvbCBvcmRlcmluZyBvZiBub3RpZmljYXRpb25zIHRvIGZsb3cgdG9wLWRvd24uXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnByb3BzTW9kZSA/IG51bGwgOiB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW3N1YnNjcmlwdGlvbktleV0gPSBzdWJzY3JpcHRpb24gfHwgdGhpcy5jb250ZXh0W3N1YnNjcmlwdGlvbktleV0sIF9yZWYyO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjtcblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZmlyZXMgZHVyaW5nIHNlcnZlciBzaWRlIHJlbmRlcmluZywgYnV0IGNvbXBvbmVudERpZE1vdW50IGFuZFxuICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBkbyBub3QuIEJlY2F1c2Ugb2YgdGhpcywgdHJ5U3Vic2NyaWJlIGhhcHBlbnMgZHVyaW5nIC4uLmRpZE1vdW50LlxuICAgICAgICAvLyBPdGhlcndpc2UsIHVuc3Vic2NyaXB0aW9uIHdvdWxkIG5ldmVyIHRha2UgcGxhY2UgZHVyaW5nIFNTUiwgY2F1c2luZyBhIG1lbW9yeSBsZWFrLlxuICAgICAgICAvLyBUbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjb21wb25lbnQgbWF5IGhhdmUgdHJpZ2dlcmVkIGEgc3RhdGUgY2hhbmdlIGJ5XG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIGFuIGFjdGlvbiBpbiBpdHMgY29tcG9uZW50V2lsbE1vdW50LCB3ZSBoYXZlIHRvIHJlLXJ1biB0aGUgc2VsZWN0IGFuZCBtYXliZVxuICAgICAgICAvLyByZS1yZW5kZXIuXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4obmV4dFByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IG5vb3A7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1biA9IG5vb3A7XG4gICAgICAgIHRoaXMuc2VsZWN0b3Iuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KSh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAoJ3sgd2l0aFJlZjogdHJ1ZSB9IGluIHRoZSBvcHRpb25zIGFyZ3VtZW50IG9mIHRoZSAnICsgbWV0aG9kTmFtZSArICcoKSBjYWxsLicpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gc2V0V3JhcHBlZEluc3RhbmNlKHJlZikge1xuICAgICAgICB0aGlzLndyYXBwZWRJbnN0YW5jZSA9IHJlZjtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTZWxlY3RvciA9IGZ1bmN0aW9uIGluaXRTZWxlY3RvcigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdG9yID0gc2VsZWN0b3JGYWN0b3J5KHRoaXMuc3RvcmUuZGlzcGF0Y2gsIHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gbWFrZVNlbGVjdG9yU3RhdGVmdWwoc291cmNlU2VsZWN0b3IsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLnJ1bih0aGlzLnByb3BzKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmluaXRTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiBpbml0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuO1xuXG4gICAgICAgIC8vIHBhcmVudFN1YidzIHNvdXJjZSBzaG91bGQgbWF0Y2ggd2hlcmUgc3RvcmUgY2FtZSBmcm9tOiBwcm9wcyB2cy4gY29udGV4dC4gQSBjb21wb25lbnRcbiAgICAgICAgLy8gY29ubmVjdGVkIHRvIHRoZSBzdG9yZSB2aWEgcHJvcHMgc2hvdWxkbid0IHVzZSBzdWJzY3JpcHRpb24gZnJvbSBjb250ZXh0LCBvciB2aWNlIHZlcnNhLlxuICAgICAgICB2YXIgcGFyZW50U3ViID0gKHRoaXMucHJvcHNNb2RlID8gdGhpcy5wcm9wcyA6IHRoaXMuY29udGV4dClbc3Vic2NyaXB0aW9uS2V5XTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBuZXcgX1N1YnNjcmlwdGlvbjIuZGVmYXVsdCh0aGlzLnN0b3JlLCBwYXJlbnRTdWIsIHRoaXMub25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyAgdW5tb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLCB3aGVyZSBgdGhpcy5zdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBBblxuICAgICAgICAvLyBleHRyYSBudWxsIGNoZWNrIGV2ZXJ5IGNoYW5nZSBjYW4gYmUgYXZvaWRlZCBieSBjb3B5aW5nIHRoZSBtZXRob2Qgb250byBgdGhpc2AgYW5kIHRoZW5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGl0IHdpdGggYSBuby1vcCBvbiB1bm1vdW50LiBUaGlzIGNhbiBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzXG4gICAgICAgIC8vIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVycyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlXG4gICAgICAgIC8vIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AuXG4gICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicyA9IHRoaXMuc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMuYmluZCh0aGlzLnN1YnNjcmlwdGlvbik7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5vblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5ydW4odGhpcy5wcm9wcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMubm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlID0gdGhpcy5ub3RpZnlOZXN0ZWRTdWJzT25Db21wb25lbnREaWRVcGRhdGU7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZShkdW1teVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUubm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3Vic09uQ29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBgY29tcG9uZW50RGlkVXBkYXRlYCBpcyBjb25kaXRpb25hbGx5IGltcGxlbWVudGVkIHdoZW4gYG9uU3RhdGVDaGFuZ2VgIGRldGVybWluZXMgaXRcbiAgICAgICAgLy8gbmVlZHMgdG8gbm90aWZ5IG5lc3RlZCBzdWJzLiBPbmNlIGNhbGxlZCwgaXQgdW5pbXBsZW1lbnRzIGl0c2VsZiB1bnRpbCBmdXJ0aGVyIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZXMgb2NjdXIuIERvaW5nIGl0IHRoaXMgd2F5IHZzIGhhdmluZyBhIHBlcm1hbmVudCBgY29tcG9uZW50RGlkVXBkYXRlYCB0aGF0IGRvZXNcbiAgICAgICAgLy8gYSBib29sZWFuIGNoZWNrIGV2ZXJ5IHRpbWUgYXZvaWRzIGFuIGV4dHJhIG1ldGhvZCBjYWxsIG1vc3Qgb2YgdGhlIHRpbWUsIHJlc3VsdGluZ1xuICAgICAgICAvLyBpbiBzb21lIHBlcmYgYm9vc3QuXG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5zdWJzY3JpcHRpb24pICYmIHRoaXMuc3Vic2NyaXB0aW9uLmlzU3Vic2NyaWJlZCgpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuYWRkRXh0cmFQcm9wcyA9IGZ1bmN0aW9uIGFkZEV4dHJhUHJvcHMocHJvcHMpIHtcbiAgICAgICAgaWYgKCF3aXRoUmVmICYmICFyZW5kZXJDb3VudFByb3AgJiYgISh0aGlzLnByb3BzTW9kZSAmJiB0aGlzLnN1YnNjcmlwdGlvbikpIHJldHVybiBwcm9wcztcbiAgICAgICAgLy8gbWFrZSBhIHNoYWxsb3cgY29weSBzbyB0aGF0IGZpZWxkcyBhZGRlZCBkb24ndCBsZWFrIHRvIHRoZSBvcmlnaW5hbCBzZWxlY3Rvci5cbiAgICAgICAgLy8gdGhpcyBpcyBlc3BlY2lhbGx5IGltcG9ydGFudCBmb3IgJ3JlZicgc2luY2UgdGhhdCdzIGEgcmVmZXJlbmNlIGJhY2sgdG8gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpbnN0YW5jZS4gYSBzaW5nbGV0b24gbWVtb2l6ZWQgc2VsZWN0b3Igd291bGQgdGhlbiBiZSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAvLyBpbnN0YW5jZSwgcHJldmVudGluZyB0aGUgaW5zdGFuY2UgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZCwgYW5kIHRoYXQgd291bGQgYmUgYmFkXG4gICAgICAgIHZhciB3aXRoRXh0cmFzID0gX2V4dGVuZHMoe30sIHByb3BzKTtcbiAgICAgICAgaWYgKHdpdGhSZWYpIHdpdGhFeHRyYXMucmVmID0gdGhpcy5zZXRXcmFwcGVkSW5zdGFuY2U7XG4gICAgICAgIGlmIChyZW5kZXJDb3VudFByb3ApIHdpdGhFeHRyYXNbcmVuZGVyQ291bnRQcm9wXSA9IHRoaXMucmVuZGVyQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMucHJvcHNNb2RlICYmIHRoaXMuc3Vic2NyaXB0aW9uKSB3aXRoRXh0cmFzW3N1YnNjcmlwdGlvbktleV0gPSB0aGlzLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIHdpdGhFeHRyYXM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzZWxlY3Rvci5lcnJvcikge1xuICAgICAgICAgIHRocm93IHNlbGVjdG9yLmVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIHRoaXMuYWRkRXh0cmFQcm9wcyhzZWxlY3Rvci5wcm9wcykpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gQ29ubmVjdDtcbiAgICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5jaGlsZENvbnRleHRUeXBlcyA9IGNoaWxkQ29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QuY29udGV4dFR5cGVzID0gY29udGV4dFR5cGVzO1xuICAgIENvbm5lY3QucHJvcFR5cGVzID0gY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgdGhpcy5pbml0U2VsZWN0b3IoKTtcblxuICAgICAgICAgIC8vIElmIGFueSBjb25uZWN0ZWQgZGVzY2VuZGFudHMgZG9uJ3QgaG90IHJlbG9hZCAoYW5kIHJlc3Vic2NyaWJlIGluIHRoZSBwcm9jZXNzKSwgdGhlaXJcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMgd2lsbCBiZSBsb3N0IHdoZW4gd2UgdW5zdWJzY3JpYmUuIFVuZm9ydHVuYXRlbHksIGJ5IGNvcHlpbmcgb3ZlciBhbGxcbiAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlIG9sZCB2ZXJzaW9ucyBvZiBjb25uZWN0ZWQgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZVxuICAgICAgICAgIC8vIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXM7IGhvd2V2ZXIsIHRoZWlyIG9uU3RhdGVDaGFuZ2UgZnVuY3Rpb24gaXMgYSBuby1vcCBzbyB0aGlzXG4gICAgICAgICAgLy8gaXNuJ3QgYSBodWdlIGRlYWwuXG4gICAgICAgICAgdmFyIG9sZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBvbGRMaXN0ZW5lcnMgPSB0aGlzLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuZ2V0KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluaXRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmlwdGlvbi5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9ob2lzdE5vblJlYWN0U3RhdGljczIuZGVmYXVsdCkoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmNyZWF0ZUNvbm5lY3QgPSBjcmVhdGVDb25uZWN0O1xuXG52YXIgX2Nvbm5lY3RBZHZhbmNlZCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJyk7XG5cbnZhciBfY29ubmVjdEFkdmFuY2VkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nvbm5lY3RBZHZhbmNlZCk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfbWFwRGlzcGF0Y2hUb1Byb3BzID0gcmVxdWlyZSgnLi9tYXBEaXNwYXRjaFRvUHJvcHMnKTtcblxudmFyIF9tYXBEaXNwYXRjaFRvUHJvcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFwRGlzcGF0Y2hUb1Byb3BzKTtcblxudmFyIF9tYXBTdGF0ZVRvUHJvcHMgPSByZXF1aXJlKCcuL21hcFN0YXRlVG9Qcm9wcycpO1xuXG52YXIgX21hcFN0YXRlVG9Qcm9wczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXBTdGF0ZVRvUHJvcHMpO1xuXG52YXIgX21lcmdlUHJvcHMgPSByZXF1aXJlKCcuL21lcmdlUHJvcHMnKTtcblxudmFyIF9tZXJnZVByb3BzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlUHJvcHMpO1xuXG52YXIgX3NlbGVjdG9yRmFjdG9yeSA9IHJlcXVpcmUoJy4vc2VsZWN0b3JGYWN0b3J5Jyk7XG5cbnZhciBfc2VsZWN0b3JGYWN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdG9yRmFjdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLypcbiAgY29ubmVjdCBpcyBhIGZhY2FkZSBvdmVyIGNvbm5lY3RBZHZhbmNlZC4gSXQgdHVybnMgaXRzIGFyZ3MgaW50byBhIGNvbXBhdGlibGVcbiAgc2VsZWN0b3JGYWN0b3J5LCB3aGljaCBoYXMgdGhlIHNpZ25hdHVyZTpcblxuICAgIChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA9PiBuZXh0RmluYWxQcm9wc1xuICBcbiAgY29ubmVjdCBwYXNzZXMgaXRzIGFyZ3MgdG8gY29ubmVjdEFkdmFuY2VkIGFzIG9wdGlvbnMsIHdoaWNoIHdpbGwgaW4gdHVybiBwYXNzIHRoZW0gdG9cbiAgc2VsZWN0b3JGYWN0b3J5IGVhY2ggdGltZSBhIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCBvciBob3QgcmVsb2FkZWQuXG5cbiAgc2VsZWN0b3JGYWN0b3J5IHJldHVybnMgYSBmaW5hbCBwcm9wcyBzZWxlY3RvciBmcm9tIGl0cyBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsIG1lcmdlUHJvcHMsXG4gIG1lcmdlUHJvcHNGYWN0b3JpZXMsIGFuZCBwdXJlIGFyZ3MuXG5cbiAgVGhlIHJlc3VsdGluZyBmaW5hbCBwcm9wcyBzZWxlY3RvciBpcyBjYWxsZWQgYnkgdGhlIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIHdoZW5ldmVyXG4gIGl0IHJlY2VpdmVzIG5ldyBwcm9wcyBvciBzdG9yZSBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChhcmcsIGZhY3RvcmllcywgbmFtZSkge1xuICBmb3IgKHZhciBpID0gZmFjdG9yaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhY3Rvcmllc1tpXShhcmcpO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIG9mIHR5cGUgJyArIHR5cGVvZiBhcmcgKyAnIGZvciAnICsgbmFtZSArICcgYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCAnICsgb3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZSArICcuJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbi8vIGNyZWF0ZUNvbm5lY3Qgd2l0aCBkZWZhdWx0IGFyZ3MgYnVpbGRzIHRoZSAnb2ZmaWNpYWwnIGNvbm5lY3QgYmVoYXZpb3IuIENhbGxpbmcgaXQgd2l0aFxuLy8gZGlmZmVyZW50IG9wdGlvbnMgb3BlbnMgdXAgc29tZSB0ZXN0aW5nIGFuZCBleHRlbnNpYmlsaXR5IHNjZW5hcmlvc1xuZnVuY3Rpb24gY3JlYXRlQ29ubmVjdCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgX3JlZiRjb25uZWN0SE9DID0gX3JlZi5jb25uZWN0SE9DLFxuICAgICAgY29ubmVjdEhPQyA9IF9yZWYkY29ubmVjdEhPQyA9PT0gdW5kZWZpbmVkID8gX2Nvbm5lY3RBZHZhbmNlZDIuZGVmYXVsdCA6IF9yZWYkY29ubmVjdEhPQyxcbiAgICAgIF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9IF9yZWYubWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID09PSB1bmRlZmluZWQgPyBfbWFwU3RhdGVUb1Byb3BzMi5kZWZhdWx0IDogX3JlZiRtYXBTdGF0ZVRvUHJvcHNGLFxuICAgICAgX3JlZiRtYXBEaXNwYXRjaFRvUHJvID0gX3JlZi5tYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPT09IHVuZGVmaW5lZCA/IF9tYXBEaXNwYXRjaFRvUHJvcHMyLmRlZmF1bHQgOiBfcmVmJG1hcERpc3BhdGNoVG9Qcm8sXG4gICAgICBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPSBfcmVmLm1lcmdlUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtZXJnZVByb3BzRmFjdG9yaWVzID0gX3JlZiRtZXJnZVByb3BzRmFjdG9yID09PSB1bmRlZmluZWQgPyBfbWVyZ2VQcm9wczIuZGVmYXVsdCA6IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvcixcbiAgICAgIF9yZWYkc2VsZWN0b3JGYWN0b3J5ID0gX3JlZi5zZWxlY3RvckZhY3RvcnksXG4gICAgICBzZWxlY3RvckZhY3RvcnkgPSBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9PT0gdW5kZWZpbmVkID8gX3NlbGVjdG9yRmFjdG9yeTIuZGVmYXVsdCA6IF9yZWYkc2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fSxcbiAgICAgICAgX3JlZjIkcHVyZSA9IF9yZWYyLnB1cmUsXG4gICAgICAgIHB1cmUgPSBfcmVmMiRwdXJlID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjIkcHVyZSxcbiAgICAgICAgX3JlZjIkYXJlU3RhdGVzRXF1YWwgPSBfcmVmMi5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVzRXF1YWwgPSBfcmVmMiRhcmVTdGF0ZXNFcXVhbCA9PT0gdW5kZWZpbmVkID8gc3RyaWN0RXF1YWwgOiBfcmVmMiRhcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgX3JlZjIkYXJlT3duUHJvcHNFcXVhID0gX3JlZjIuYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlT3duUHJvcHNFcXVhbCA9IF9yZWYyJGFyZU93blByb3BzRXF1YSA9PT0gdW5kZWZpbmVkID8gX3NoYWxsb3dFcXVhbDIuZGVmYXVsdCA6IF9yZWYyJGFyZU93blByb3BzRXF1YSxcbiAgICAgICAgX3JlZjIkYXJlU3RhdGVQcm9wc0VxID0gX3JlZjIuYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZVByb3BzRXF1YWwgPSBfcmVmMiRhcmVTdGF0ZVByb3BzRXEgPT09IHVuZGVmaW5lZCA/IF9zaGFsbG93RXF1YWwyLmRlZmF1bHQgOiBfcmVmMiRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYyJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYyLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMiRhcmVNZXJnZWRQcm9wc0UgPT09IHVuZGVmaW5lZCA/IF9zaGFsbG93RXF1YWwyLmRlZmF1bHQgOiBfcmVmMiRhcmVNZXJnZWRQcm9wc0UsXG4gICAgICAgIGV4dHJhT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMiwgWydwdXJlJywgJ2FyZVN0YXRlc0VxdWFsJywgJ2FyZU93blByb3BzRXF1YWwnLCAnYXJlU3RhdGVQcm9wc0VxdWFsJywgJ2FyZU1lcmdlZFByb3BzRXF1YWwnXSk7XG5cbiAgICB2YXIgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hdGNoKG1hcFN0YXRlVG9Qcm9wcywgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXRjaChtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWVyZ2VQcm9wcyA9IG1hdGNoKG1lcmdlUHJvcHMsIG1lcmdlUHJvcHNGYWN0b3JpZXMsICdtZXJnZVByb3BzJyk7XG5cbiAgICByZXR1cm4gY29ubmVjdEhPQyhzZWxlY3RvckZhY3RvcnksIF9leHRlbmRzKHtcbiAgICAgIC8vIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXNcbiAgICAgIG1ldGhvZE5hbWU6ICdjb25uZWN0JyxcblxuICAgICAgLy8gdXNlZCB0byBjb21wdXRlIENvbm5lY3QncyBkaXNwbGF5TmFtZSBmcm9tIHRoZSB3cmFwcGVkIGNvbXBvbmVudCdzIGRpc3BsYXlOYW1lLlxuICAgICAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdDb25uZWN0KCcgKyBuYW1lICsgJyknO1xuICAgICAgfSxcblxuICAgICAgLy8gaWYgbWFwU3RhdGVUb1Byb3BzIGlzIGZhbHN5LCB0aGUgQ29ubmVjdCBjb21wb25lbnQgZG9lc24ndCBzdWJzY3JpYmUgdG8gc3RvcmUgc3RhdGUgY2hhbmdlc1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyksXG5cbiAgICAgIC8vIHBhc3NlZCB0aHJvdWdoIHRvIHNlbGVjdG9yRmFjdG9yeVxuICAgICAgaW5pdE1hcFN0YXRlVG9Qcm9wczogaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHM6IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMsXG4gICAgICBpbml0TWVyZ2VQcm9wczogaW5pdE1lcmdlUHJvcHMsXG4gICAgICBwdXJlOiBwdXJlLFxuICAgICAgYXJlU3RhdGVzRXF1YWw6IGFyZVN0YXRlc0VxdWFsLFxuICAgICAgYXJlT3duUHJvcHNFcXVhbDogYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbDogYXJlU3RhdGVQcm9wc0VxdWFsLFxuICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbDogYXJlTWVyZ2VkUHJvcHNFcXVhbFxuXG4gICAgfSwgZXh0cmFPcHRpb25zKSk7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUNvbm5lY3QoKTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLndoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uID0gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb247XG5leHBvcnRzLndoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcgPSB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nO1xuZXhwb3J0cy53aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3QgPSB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNPYmplY3Q7XG5cbnZhciBfcmVkdXggPSByZXF1aXJlKCdyZWR1eCcpO1xuXG52YXIgX3dyYXBNYXBUb1Byb3BzID0gcmVxdWlyZSgnLi93cmFwTWFwVG9Qcm9wcycpO1xuXG5mdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbihtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyAoMCwgX3dyYXBNYXBUb1Byb3BzLndyYXBNYXBUb1Byb3BzRnVuYykobWFwRGlzcGF0Y2hUb1Byb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gKDAsIF93cmFwTWFwVG9Qcm9wcy53cmFwTWFwVG9Qcm9wc0NvbnN0YW50KShmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdChtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnb2JqZWN0JyA/ICgwLCBfd3JhcE1hcFRvUHJvcHMud3JhcE1hcFRvUHJvcHNDb25zdGFudCkoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVkdXguYmluZEFjdGlvbkNyZWF0b3JzKShtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFt3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZywgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0XTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLndoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uID0gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb247XG5leHBvcnRzLndoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcgPSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nO1xuXG52YXIgX3dyYXBNYXBUb1Byb3BzID0gcmVxdWlyZSgnLi93cmFwTWFwVG9Qcm9wcycpO1xuXG5mdW5jdGlvbiB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbihtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyAoMCwgX3dyYXBNYXBUb1Byb3BzLndyYXBNYXBUb1Byb3BzRnVuYykobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gKDAsIF93cmFwTWFwVG9Qcm9wcy53cmFwTWFwVG9Qcm9wc0NvbnN0YW50KShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gW3doZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nXTsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdE1lcmdlUHJvcHMgPSBkZWZhdWx0TWVyZ2VQcm9wcztcbmV4cG9ydHMud3JhcE1lcmdlUHJvcHNGdW5jID0gd3JhcE1lcmdlUHJvcHNGdW5jO1xuZXhwb3J0cy53aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24gPSB3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb247XG5leHBvcnRzLndoZW5NZXJnZVByb3BzSXNPbWl0dGVkID0gd2hlbk1lcmdlUHJvcHNJc09taXR0ZWQ7XG5cbnZhciBfdmVyaWZ5UGxhaW5PYmplY3QgPSByZXF1aXJlKCcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCcpO1xuXG52YXIgX3ZlcmlmeVBsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlcmlmeVBsYWluT2JqZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCBfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgcHVyZSA9IF9yZWYucHVyZSxcbiAgICAgICAgYXJlTWVyZ2VkUHJvcHNFcXVhbCA9IF9yZWYuYXJlTWVyZ2VkUHJvcHNFcXVhbDtcblxuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzID0gdm9pZCAwO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlUHJvcHNQcm94eShzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcykge1xuICAgICAgdmFyIG5leHRNZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuXG4gICAgICBpZiAoaGFzUnVuT25jZSkge1xuICAgICAgICBpZiAoIXB1cmUgfHwgIWFyZU1lcmdlZFByb3BzRXF1YWwobmV4dE1lcmdlZFByb3BzLCBtZXJnZWRQcm9wcykpIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzUnVuT25jZSA9IHRydWU7XG4gICAgICAgIG1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuXG4gICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSAoMCwgX3ZlcmlmeVBsYWluT2JqZWN0Mi5kZWZhdWx0KShtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiB3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24obWVyZ2VQcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1lcmdlUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gW3doZW5NZXJnZVByb3BzSXNGdW5jdGlvbiwgd2hlbk1lcmdlUHJvcHNJc09taXR0ZWRdOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA9IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG5leHBvcnRzLnB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5ID0gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG52YXIgX3ZlcmlmeVN1YnNlbGVjdG9ycyA9IHJlcXVpcmUoJy4vdmVyaWZ5U3Vic2VsZWN0b3JzJyk7XG5cbnZhciBfdmVyaWZ5U3Vic2VsZWN0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlcmlmeVN1YnNlbGVjdG9ycyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaW1wdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihzdGF0ZSwgb3duUHJvcHMpIHtcbiAgICByZXR1cm4gbWVyZ2VQcm9wcyhtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKSwgbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyksIG93blByb3BzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG5cbiAgdmFyIGhhc1J1bkF0TGVhc3RPbmNlID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgdmFyIG93blByb3BzID0gdm9pZCAwO1xuICB2YXIgc3RhdGVQcm9wcyA9IHZvaWQgMDtcbiAgdmFyIGRpc3BhdGNoUHJvcHMgPSB2b2lkIDA7XG4gIHZhciBtZXJnZWRQcm9wcyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBoYW5kbGVGaXJzdENhbGwoZmlyc3RTdGF0ZSwgZmlyc3RPd25Qcm9wcykge1xuICAgIHN0YXRlID0gZmlyc3RTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IGZpcnN0T3duUHJvcHM7XG4gICAgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIGhhc1J1bkF0TGVhc3RPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcblxuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuXG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuXG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICB2YXIgc3RhdGVQcm9wc0NoYW5nZWQgPSAhYXJlU3RhdGVQcm9wc0VxdWFsKG5leHRTdGF0ZVByb3BzLCBzdGF0ZVByb3BzKTtcbiAgICBzdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG5cbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG5cbiAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICB2YXIgcHJvcHNDaGFuZ2VkID0gIWFyZU93blByb3BzRXF1YWwobmV4dE93blByb3BzLCBvd25Qcm9wcyk7XG4gICAgdmFyIHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChuZXh0U3RhdGUsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBvd25Qcm9wcyA9IG5leHRPd25Qcm9wcztcblxuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKSByZXR1cm4gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpO1xuICAgIGlmIChwcm9wc0NoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wcygpO1xuICAgIGlmIChzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgcmV0dXJuIGhhc1J1bkF0TGVhc3RPbmNlID8gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA6IGhhbmRsZUZpcnN0Q2FsbChuZXh0U3RhdGUsIG5leHRPd25Qcm9wcyk7XG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCBtb3JlIGNvbW1lbnRzXG5cbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjIsIFsnaW5pdE1hcFN0YXRlVG9Qcm9wcycsICdpbml0TWFwRGlzcGF0Y2hUb1Byb3BzJywgJ2luaXRNZXJnZVByb3BzJ10pO1xuXG4gIHZhciBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgdmFyIG1hcERpc3BhdGNoVG9Qcm9wcyA9IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWVyZ2VQcm9wcyA9IGluaXRNZXJnZVByb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICgwLCBfdmVyaWZ5U3Vic2VsZWN0b3JzMi5kZWZhdWx0KShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgb3B0aW9ucy5kaXNwbGF5TmFtZSk7XG4gIH1cblxuICB2YXIgc2VsZWN0b3JGYWN0b3J5ID0gb3B0aW9ucy5wdXJlID8gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkgOiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJpZnlTdWJzZWxlY3RvcnM7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUsIGRpc3BsYXlOYW1lKSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWUgZm9yICcgKyBtZXRob2ROYW1lICsgJyBpbiAnICsgZGlzcGxheU5hbWUgKyAnLicpO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICdtYXBTdGF0ZVRvUHJvcHMnIHx8IG1ldGhvZE5hbWUgPT09ICdtYXBEaXNwYXRjaFRvUHJvcHMnKSB7XG4gICAgaWYgKCFzZWxlY3Rvci5oYXNPd25Qcm9wZXJ0eSgnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSgnVGhlIHNlbGVjdG9yIGZvciAnICsgbWV0aG9kTmFtZSArICcgb2YgJyArIGRpc3BsYXlOYW1lICsgJyBkaWQgbm90IHNwZWNpZnkgYSB2YWx1ZSBmb3IgZGVwZW5kc09uT3duUHJvcHMuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJywgZGlzcGxheU5hbWUpO1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMud3JhcE1hcFRvUHJvcHNDb25zdGFudCA9IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQ7XG5leHBvcnRzLmdldERlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHM7XG5leHBvcnRzLndyYXBNYXBUb1Byb3BzRnVuYyA9IHdyYXBNYXBUb1Byb3BzRnVuYztcblxudmFyIF92ZXJpZnlQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4uL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0Jyk7XG5cbnZhciBfdmVyaWZ5UGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVyaWZ5UGxhaW5PYmplY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHZhciBjb25zdGFudCA9IGdldENvbnN0YW50KGRpc3BhdGNoLCBvcHRpb25zKTtcblxuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cblxuLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vLyBcbi8vIEEgbGVuZ3RoIG9mIG9uZSBzaWduYWxzIHRoYXQgbWFwVG9Qcm9wcyBkb2VzIG5vdCBkZXBlbmQgb24gcHJvcHMgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudC5cbi8vIEEgbGVuZ3RoIG9mIHplcm8gaXMgYXNzdW1lZCB0byBtZWFuIG1hcFRvUHJvcHMgaXMgZ2V0dGluZyBhcmdzIHZpYSBhcmd1bWVudHMgb3IgLi4uYXJncyBhbmRcbi8vIHRoZXJlZm9yZSBub3QgcmVwb3J0aW5nIGl0cyBsZW5ndGggYWNjdXJhdGVseS4uXG5mdW5jdGlvbiBnZXREZXBlbmRzT25Pd25Qcm9wcyhtYXBUb1Byb3BzKSB7XG4gIHJldHVybiBtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzICE9PSBudWxsICYmIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IHVuZGVmaW5lZCA/IEJvb2xlYW4obWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgOiBtYXBUb1Byb3BzLmxlbmd0aCAhPT0gMTtcbn1cblxuLy8gVXNlZCBieSB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiBhbmQgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sXG4vLyB0aGlzIGZ1bmN0aW9uIHdyYXBzIG1hcFRvUHJvcHMgaW4gYSBwcm94eSBmdW5jdGlvbiB3aGljaCBkb2VzIHNldmVyYWwgdGhpbmdzOlxuLy8gXG4vLyAgKiBEZXRlY3RzIHdoZXRoZXIgdGhlIG1hcFRvUHJvcHMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGRlcGVuZHMgb24gcHJvcHMsIHdoaWNoXG4vLyAgICBpcyB1c2VkIGJ5IHNlbGVjdG9yRmFjdG9yeSB0byBkZWNpZGUgaWYgaXQgc2hvdWxkIHJlaW52b2tlIG9uIHByb3BzIGNoYW5nZXMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vLyAgICBcbi8vICAqIE9uIGZpcnN0IGNhbGwsIHZlcmlmaWVzIHRoZSBmaXJzdCByZXN1bHQgaXMgYSBwbGFpbiBvYmplY3QsIGluIG9yZGVyIHRvIHdhcm5cbi8vICAgIHRoZSBkZXZlbG9wZXIgdGhhdCB0aGVpciBtYXBUb1Byb3BzIGZ1bmN0aW9uIGlzIG5vdCByZXR1cm5pbmcgYSB2YWxpZCByZXN1bHQuXG4vLyAgICBcbmZ1bmN0aW9uIHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBUb1Byb3BzLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0UHJveHlTZWxlY3RvcihkaXNwYXRjaCwgX3JlZikge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IF9yZWYuZGlzcGxheU5hbWU7XG5cbiAgICB2YXIgcHJveHkgPSBmdW5jdGlvbiBtYXBUb1Byb3BzUHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcmV0dXJuIHByb3h5LmRlcGVuZHNPbk93blByb3BzID8gcHJveHkubWFwVG9Qcm9wcyhzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSA6IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcbiAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IHRydWU7XG5cbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICB2YXIgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcblxuICAgICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykgKDAsIF92ZXJpZnlQbGFpbk9iamVjdDIuZGVmYXVsdCkocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcblxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb25uZWN0ID0gZXhwb3J0cy5jb25uZWN0QWR2YW5jZWQgPSBleHBvcnRzLmNyZWF0ZVByb3ZpZGVyID0gZXhwb3J0cy5Qcm92aWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9Qcm92aWRlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Qcm92aWRlcicpO1xuXG52YXIgX1Byb3ZpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Byb3ZpZGVyKTtcblxudmFyIF9jb25uZWN0QWR2YW5jZWQgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJyk7XG5cbnZhciBfY29ubmVjdEFkdmFuY2VkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nvbm5lY3RBZHZhbmNlZCk7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29ubmVjdC9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5Qcm92aWRlciA9IF9Qcm92aWRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuY3JlYXRlUHJvdmlkZXIgPSBfUHJvdmlkZXIuY3JlYXRlUHJvdmlkZXI7XG5leHBvcnRzLmNvbm5lY3RBZHZhbmNlZCA9IF9jb25uZWN0QWR2YW5jZWQyLmRlZmF1bHQ7XG5leHBvcnRzLmNvbm5lY3QgPSBfY29ubmVjdDIuZGVmYXVsdDsiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnN0b3JlU2hhcGUgPSBleHBvcnRzLnN1YnNjcmlwdGlvblNoYXBlID0gdW5kZWZpbmVkO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1YnNjcmlwdGlvblNoYXBlID0gZXhwb3J0cy5zdWJzY3JpcHRpb25TaGFwZSA9IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xuICB0cnlTdWJzY3JpYmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICB0cnlVbnN1YnNjcmliZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsXG4gIG5vdGlmeU5lc3RlZFN1YnM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICBpc1N1YnNjcmliZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIHN0b3JlU2hhcGUgPSBleHBvcnRzLnN0b3JlU2hhcGUgPSBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWRcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG52YXIgQ0xFQVJFRCA9IG51bGw7XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICAvLyB0aGUgY3VycmVudC9uZXh0IHBhdHRlcm4gaXMgY29waWVkIGZyb20gcmVkdXgncyBjcmVhdGVTdG9yZSBjb2RlLlxuICAvLyBUT0RPOiByZWZhY3RvcitleHBvc2UgdGhhdCBjb2RlIHRvIGJlIHJldXNhYmxlIGhlcmU/XG4gIHZhciBjdXJyZW50ID0gW107XG4gIHZhciBuZXh0ID0gW107XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBuZXh0ID0gQ0xFQVJFRDtcbiAgICAgIGN1cnJlbnQgPSBDTEVBUkVEO1xuICAgIH0sXG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudCA9IG5leHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5lcnNbaV0oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgIG5leHQucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgY3VycmVudCA9PT0gQ0xFQVJFRCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobmV4dCA9PT0gY3VycmVudCkgbmV4dCA9IGN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgbmV4dC5zcGxpY2UobmV4dC5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIsIG9uU3RhdGVDaGFuZ2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic2NyaXB0aW9uKTtcblxuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLm9uU3RhdGVDaGFuZ2UgPSBvblN0YXRlQ2hhbmdlO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgfVxuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm5vdGlmeU5lc3RlZFN1YnMgPSBmdW5jdGlvbiBub3RpZnlOZXN0ZWRTdWJzKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMucGFyZW50U3ViID8gdGhpcy5wYXJlbnRTdWIuYWRkTmVzdGVkU3ViKHRoaXMub25TdGF0ZUNoYW5nZSkgOiB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLm9uU3RhdGVDaGFuZ2UpO1xuXG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRyeVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbDtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHJldHVybiB0cnVlO1xuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJpZnlQbGFpbk9iamVjdDtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyLmRlZmF1bHQpKHZhbHVlKSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkobWV0aG9kTmFtZSArICcoKSBpbiAnICsgZGlzcGxheU5hbWUgKyAnIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICcgKyB2YWx1ZSArICcuJyk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn0iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjQuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuNC4yJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1RJTUVPVVRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnRpbWVvdXQnKSA6IDB4ZWFkMTtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gUmVseWluZyBvbiB0aGUgYGludmFyaWFudCgpYCBpbXBsZW1lbnRhdGlvbiBsZXRzIHVzXG4vLyBoYXZlIHByZXNlcnZlIHRoZSBmb3JtYXQgYW5kIHBhcmFtcyBpbiB0aGUgd3d3IGJ1aWxkcy5cblxuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuLy8gRXhwZXJpbWVudGFsIGVycm9yLWJvdW5kYXJ5IEFQSSB0aGF0IGNhbiByZWNvdmVyIGZyb20gZXJyb3JzIHdpdGhpbiBhIHNpbmdsZVxuLy8gcmVuZGVyIHBoYXNlXG5cbi8vIFN1c3BlbnNlXG52YXIgZW5hYmxlU3VzcGVuc2UgPSBmYWxzZTtcbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBXYXJuIGFib3V0IGxlZ2FjeSBjb250ZXh0IEFQSVxuXG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG4vLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuICB2YXIgcmVmT2JqZWN0ID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7XG4gICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gICEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkICVzLicsIGVsZW1lbnQpIDogdm9pZCAwO1xuXG4gIHZhciBwcm9wTmFtZSA9IHZvaWQgMDtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgdmFyIG5leHROYW1lID0gdm9pZCAwO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXAgPSB2b2lkIDA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgIShjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyhmYWxzZSwgJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgX2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY2hhbmdlZEJpdHM6IDAsXG4gICAgX2NoYW5nZWRCaXRzMjogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuXG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgY29udGV4dC5Db25zdW1lciA9IGNvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgICEodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAhKHJlbmRlci5kZWZhdWx0UHJvcHMgPT0gbnVsbCAmJiByZW5kZXIucHJvcFR5cGVzID09IG51bGwpID8gd2FybmluZyhmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfVElNRU9VVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnQXN5bmNNb2RlJztcbiAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdEZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdSZWFjdFBvcnRhbCc7XG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcignICsgZmliZXIucGVuZGluZ1Byb3BzLmlkICsgJyknO1xuICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICBjYXNlIFJFQUNUX1RJTUVPVVRfVFlQRTpcbiAgICAgIHJldHVybiAnVGltZW91dCc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0eXBlLnJlbmRlci5kaXNwbGF5TmFtZSB8fCB0eXBlLnJlbmRlci5uYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/ICdGb3J3YXJkUmVmKCcgKyBmdW5jdGlvbk5hbWUgKyAnKScgOiAnRm9yd2FyZFJlZic7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSB2b2lkIDA7XG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbnZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xudmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgcmV0dXJuICdSZWFjdC5GcmFnbWVudCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdHlwZS5yZW5kZXIuZGlzcGxheU5hbWUgfHwgdHlwZS5yZW5kZXIubmFtZSB8fCAnJztcbiAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gJ0ZvcndhcmRSZWYoJyArIGZ1bmN0aW9uTmFtZSArICcpJyA6ICdGb3J3YXJkUmVmJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX293bmVyO1xuICAgICAgc3RhY2sgKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBnZXRDb21wb25lbnROYW1lKG93bmVyKSk7XG4gICAgfVxuICAgIHN0YWNrICs9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpIHx8ICcnO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcCA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIG5hbWUgPSB2b2lkIDAsXG4gICAgICBwcm9wVHlwZXMgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIENsYXNzIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgbmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAvLyBGb3J3YXJkUmVmXG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHR5cGUucmVuZGVyLmRpc3BsYXlOYW1lIHx8IHR5cGUucmVuZGVyLm5hbWUgfHwgJyc7XG4gICAgbmFtZSA9IGZ1bmN0aW9uTmFtZSAhPT0gJycgPyAnRm9yd2FyZFJlZignICsgZnVuY3Rpb25OYW1lICsgJyknIDogJ0ZvcndhcmRSZWYnO1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvcFR5cGVzKSB7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKTtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZyhmYWxzZSwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGZyYWdtZW50O1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7XG5cbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB2YXIgdHlwZVN0cmluZyA9IHZvaWQgMDtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuICAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBjcmVhdGVSZWY6IGNyZWF0ZVJlZixcbiAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgZm9yd2FyZFJlZjogZm9yd2FyZFJlZixcblxuICBGcmFnbWVudDogUkVBQ1RfRlJBR01FTlRfVFlQRSxcbiAgU3RyaWN0TW9kZTogUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgdW5zdGFibGVfQXN5bmNNb2RlOiBSRUFDVF9BU1lOQ19NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX1Byb2ZpbGVyOiBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbmlmIChlbmFibGVTdXNwZW5zZSkge1xuICBSZWFjdC5UaW1lb3V0ID0gUkVBQ1RfVElNRU9VVF9UWVBFO1xufVxuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkMy5kZWZhdWx0ID8gUmVhY3QkMy5kZWZhdWx0IDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuNC4yXG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0Jzt2YXIgaz1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPXJlcXVpcmUoXCJmYmpzL2xpYi9pbnZhcmlhbnRcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscT1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxyPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3IsdD1yP1N5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLHU9cj9TeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LHY9cj9TeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik6NjAxMDcsdz1yP1N5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTo2MDEwOCx4PXI/U3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpOjYwMTE0LHk9cj9TeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik6NjAxMDksej1yP1N5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpOjYwMTEwLEE9cj9TeW1ib2wuZm9yKFwicmVhY3QuYXN5bmNfbW9kZVwiKTo2MDExMSxCPVxucj9TeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIik6NjAxMTI7ciYmU3ltYm9sLmZvcihcInJlYWN0LnRpbWVvdXRcIik7dmFyIEM9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO2Z1bmN0aW9uIEQoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9XCIrYSxjPTA7YzxiO2MrKyllKz1cIiZhcmdzW109XCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtuKCExLFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0ICVzIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4gXCIsZSl9XG52YXIgRT17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbigpe30sZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKCl7fX07ZnVuY3Rpb24gRihhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1wO3RoaXMudXBkYXRlcj1lfHxFfUYucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e307Ri5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hP0QoXCI4NVwiKTp2b2lkIDA7dGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLGEsYixcInNldFN0YXRlXCIpfTtGLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsYSxcImZvcmNlVXBkYXRlXCIpfTtmdW5jdGlvbiBHKCl7fVxuRy5wcm90b3R5cGU9Ri5wcm90b3R5cGU7ZnVuY3Rpb24gSChhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1wO3RoaXMudXBkYXRlcj1lfHxFfXZhciBJPUgucHJvdG90eXBlPW5ldyBHO0kuY29uc3RydWN0b3I9SDtrKEksRi5wcm90b3R5cGUpO0kuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEo9e2N1cnJlbnQ6bnVsbH0sSz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LEw9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIE0oYSxiLGUpe3ZhciBjPXZvaWQgMCxkPXt9LGc9bnVsbCxoPW51bGw7aWYobnVsbCE9Yilmb3IoYyBpbiB2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYpLHZvaWQgMCE9PWIua2V5JiYoZz1cIlwiK2Iua2V5KSxiKUsuY2FsbChiLGMpJiYhTC5oYXNPd25Qcm9wZXJ0eShjKSYmKGRbY109YltjXSk7dmFyIGY9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1mKWQuY2hpbGRyZW49ZTtlbHNlIGlmKDE8Zil7Zm9yKHZhciBsPUFycmF5KGYpLG09MDttPGY7bSsrKWxbbV09YXJndW1lbnRzW20rMl07ZC5jaGlsZHJlbj1sfWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihjIGluIGY9YS5kZWZhdWx0UHJvcHMsZil2b2lkIDA9PT1kW2NdJiYoZFtjXT1mW2NdKTtyZXR1cm57JCR0eXBlb2Y6dCx0eXBlOmEsa2V5OmcscmVmOmgscHJvcHM6ZCxfb3duZXI6Si5jdXJyZW50fX1cbmZ1bmN0aW9uIE4oYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PXR9ZnVuY3Rpb24gZXNjYXBlKGEpe3ZhciBiPXtcIj1cIjpcIj0wXCIsXCI6XCI6XCI9MlwifTtyZXR1cm5cIiRcIisoXCJcIithKS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgTz0vXFwvKy9nLFA9W107ZnVuY3Rpb24gUShhLGIsZSxjKXtpZihQLmxlbmd0aCl7dmFyIGQ9UC5wb3AoKTtkLnJlc3VsdD1hO2Qua2V5UHJlZml4PWI7ZC5mdW5jPWU7ZC5jb250ZXh0PWM7ZC5jb3VudD0wO3JldHVybiBkfXJldHVybntyZXN1bHQ6YSxrZXlQcmVmaXg6YixmdW5jOmUsY29udGV4dDpjLGNvdW50OjB9fWZ1bmN0aW9uIFIoYSl7YS5yZXN1bHQ9bnVsbDthLmtleVByZWZpeD1udWxsO2EuZnVuYz1udWxsO2EuY29udGV4dD1udWxsO2EuY291bnQ9MDsxMD5QLmxlbmd0aCYmUC5wdXNoKGEpfVxuZnVuY3Rpb24gUyhhLGIsZSxjKXt2YXIgZD10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09ZHx8XCJib29sZWFuXCI9PT1kKWE9bnVsbDt2YXIgZz0hMTtpZihudWxsPT09YSlnPSEwO2Vsc2Ugc3dpdGNoKGQpe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6Zz0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgdDpjYXNlIHU6Zz0hMH19aWYoZylyZXR1cm4gZShjLGEsXCJcIj09PWI/XCIuXCIrVChhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaD0wO2g8YS5sZW5ndGg7aCsrKXtkPWFbaF07dmFyIGY9YitUKGQsaCk7Zys9UyhkLGYsZSxjKX1lbHNlIGlmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/Zj1udWxsOihmPUMmJmFbQ118fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1mLmNhbGwoYSksXG5oPTA7IShkPWEubmV4dCgpKS5kb25lOylkPWQudmFsdWUsZj1iK1QoZCxoKyspLGcrPVMoZCxmLGUsYyk7ZWxzZVwib2JqZWN0XCI9PT1kJiYoZT1cIlwiK2EsRChcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWU/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZSxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gVChhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gVShhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBWKGEsYixlKXt2YXIgYz1hLnJlc3VsdCxkPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1coYSxjLGUscS50aGF0UmV0dXJuc0FyZ3VtZW50KTpudWxsIT1hJiYoTihhKSYmKGI9ZCsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTyxcIiQmL1wiKStcIi9cIikrZSxhPXskJHR5cGVvZjp0LHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn0pLGMucHVzaChhKSl9ZnVuY3Rpb24gVyhhLGIsZSxjLGQpe3ZhciBnPVwiXCI7bnVsbCE9ZSYmKGc9KFwiXCIrZSkucmVwbGFjZShPLFwiJCYvXCIpK1wiL1wiKTtiPVEoYixnLGMsZCk7bnVsbD09YXx8UyhhLFwiXCIsVixiKTtSKGIpfVxudmFyIFg9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGM9W107VyhhLGMsbnVsbCxiLGUpO3JldHVybiBjfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9UShudWxsLG51bGwsYixlKTtudWxsPT1hfHxTKGEsXCJcIixVLGIpO1IoYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6UyhhLFwiXCIscS50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107VyhhLGIsbnVsbCxxLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe04oYSk/dm9pZCAwOkQoXCIxNDNcIik7cmV0dXJuIGF9fSxjcmVhdGVSZWY6ZnVuY3Rpb24oKXtyZXR1cm57Y3VycmVudDpudWxsfX0sQ29tcG9uZW50OkYsUHVyZUNvbXBvbmVudDpILGNyZWF0ZUNvbnRleHQ6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj1udWxsKTthPXskJHR5cGVvZjp6LFxuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOmIsX2RlZmF1bHRWYWx1ZTphLF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF9jaGFuZ2VkQml0czowLF9jaGFuZ2VkQml0czI6MCxQcm92aWRlcjpudWxsLENvbnN1bWVyOm51bGx9O2EuUHJvdmlkZXI9eyQkdHlwZW9mOnksX2NvbnRleHQ6YX07cmV0dXJuIGEuQ29uc3VtZXI9YX0sZm9yd2FyZFJlZjpmdW5jdGlvbihhKXtyZXR1cm57JCR0eXBlb2Y6QixyZW5kZXI6YX19LEZyYWdtZW50OnYsU3RyaWN0TW9kZTp3LHVuc3RhYmxlX0FzeW5jTW9kZTpBLHVuc3RhYmxlX1Byb2ZpbGVyOngsY3JlYXRlRWxlbWVudDpNLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZSl7bnVsbD09PWF8fHZvaWQgMD09PWE/RChcIjI2N1wiLGEpOnZvaWQgMDt2YXIgYz12b2lkIDAsZD1rKHt9LGEucHJvcHMpLGc9YS5rZXksaD1hLnJlZixmPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoaD1iLnJlZixmPUouY3VycmVudCk7dm9pZCAwIT09XG5iLmtleSYmKGc9XCJcIitiLmtleSk7dmFyIGw9dm9pZCAwO2EudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyYmKGw9YS50eXBlLmRlZmF1bHRQcm9wcyk7Zm9yKGMgaW4gYilLLmNhbGwoYixjKSYmIUwuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPXZvaWQgMD09PWJbY10mJnZvaWQgMCE9PWw/bFtjXTpiW2NdKX1jPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09YylkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGMpe2w9QXJyYXkoYyk7Zm9yKHZhciBtPTA7bTxjO20rKylsW21dPWFyZ3VtZW50c1ttKzJdO2QuY2hpbGRyZW49bH1yZXR1cm57JCR0eXBlb2Y6dCx0eXBlOmEudHlwZSxrZXk6ZyxyZWY6aCxwcm9wczpkLF9vd25lcjpmfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1NLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0saXNWYWxpZEVsZW1lbnQ6Tix2ZXJzaW9uOlwiMTYuNC4yXCIsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudE93bmVyOkosXG5hc3NpZ246a319LFk9e2RlZmF1bHQ6WH0sWj1ZJiZYfHxZO21vZHVsZS5leHBvcnRzPVouZGVmYXVsdD9aLmRlZmF1bHQ6WjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKFwicHJvZHVjdGlvblwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb21wb3NlID0gcmVxdWlyZSgncmVkdXgnKS5jb21wb3NlO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb21wb3NlV2l0aERldlRvb2xzID0gKFxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID9cbiAgICB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDpcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSByZXR1cm4gY29tcG9zZTtcbiAgICAgIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuKTtcblxuZXhwb3J0cy5kZXZUb29sc0VuaGFuY2VyID0gKFxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/XG4gICAgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOlxuICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb24obm9vcCkgeyByZXR1cm4gbm9vcDsgfSB9XG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBhcHBseU1pZGRsZXdhcmU7XG5cbnZhciBfY29tcG9zZSA9IHJlcXVpcmUoJy4vY29tcG9zZScpO1xuXG52YXIgX2NvbXBvc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcG9zZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbJ2RlZmF1bHQnXS5hcHBseSh1bmRlZmluZWQsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzWydkZWZhdWx0J10gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbk5hbWUgPSBhY3Rpb25UeXBlICYmICdcIicgKyBhY3Rpb25UeXBlLnRvU3RyaW5nKCkgKyAnXCInIHx8ICdhbiBhY3Rpb24nO1xuXG4gIHJldHVybiAnR2l2ZW4gYWN0aW9uICcgKyBhY3Rpb25OYW1lICsgJywgcmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkLiAnICsgJ1RvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gJyArICdJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC4nO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb25cXCd0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgJyArICd5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMlsnZGVmYXVsdCddKSgnTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlID0gdm9pZCAwO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNoYXBlKGZpbmFsUmVkdWNlcnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2hhcGVBc3NlcnRpb25FcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVbX2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbXBvc2U7XG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHVuZGVmaW5lZDtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICAgKlxuICAgKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gICAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAgICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAgICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAgICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICAgKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gICAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gICAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAgICovXG59O2Z1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyWydkZWZhdWx0J10pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMlsnZGVmYXVsdCddXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbJ2RlZmF1bHQnXV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn0iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICAoMCwgX3dhcm5pbmcyWydkZWZhdWx0J10pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gX2JpbmRBY3Rpb25DcmVhdG9yczJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMlsnZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufSIsIi8qanNsaW50IG9uZXZhcjp0cnVlLCB1bmRlZjp0cnVlLCBuZXdjYXA6dHJ1ZSwgcmVnZXhwOnRydWUsIGJpdHdpc2U6dHJ1ZSwgbWF4ZXJyOjUwLCBpbmRlbnQ6NCwgd2hpdGU6ZmFsc2UsIG5vbWVuOmZhbHNlLCBwbHVzcGx1czpmYWxzZSAqL1xuLypnbG9iYWwgZGVmaW5lOmZhbHNlLCByZXF1aXJlOmZhbHNlLCBleHBvcnRzOmZhbHNlLCBtb2R1bGU6ZmFsc2UsIHNpZ25hbHM6ZmFsc2UgKi9cblxuLyoqIEBsaWNlbnNlXG4gKiBKUyBTaWduYWxzIDxodHRwOi8vbWlsbGVybWVkZWlyb3MuZ2l0aHViLmNvbS9qcy1zaWduYWxzLz5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogQXV0aG9yOiBNaWxsZXIgTWVkZWlyb3NcbiAqIFZlcnNpb246IDEuMC4wIC0gQnVpbGQ6IDI2OCAoMjAxMi8xMS8yOSAwNTo0OCBQTSlcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKXtcblxuICAgIC8vIFNpZ25hbEJpbmRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGJpbmRpbmcgYmV0d2VlbiBhIFNpZ25hbCBhbmQgYSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKiA8YnIgLz4tIDxzdHJvbmc+VGhpcyBpcyBhbiBpbnRlcm5hbCBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkbid0IGJlIGNhbGxlZCBieSByZWd1bGFyIHVzZXJzLjwvc3Ryb25nPlxuICAgICAqIDxiciAvPi0gaW5zcGlyZWQgYnkgSm9hIEViZXJ0IEFTMyBTaWduYWxCaW5kaW5nIGFuZCBSb2JlcnQgUGVubmVyJ3MgU2xvdCBjbGFzc2VzLlxuICAgICAqIEBhdXRob3IgTWlsbGVyIE1lZGVpcm9zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICogQG5hbWUgU2lnbmFsQmluZGluZ1xuICAgICAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWwgUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgSGFuZGxlciBmdW5jdGlvbiBib3VuZCB0byB0aGUgc2lnbmFsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpc3RlbmVyQ29udGV4dF0gQ29udGV4dCBvbiB3aGljaCBsaXN0ZW5lciB3aWxsIGJlIGV4ZWN1dGVkIChvYmplY3QgdGhhdCBzaG91bGQgcmVwcmVzZW50IHRoZSBgdGhpc2AgdmFyaWFibGUgaW5zaWRlIGxpc3RlbmVyIGZ1bmN0aW9uKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiAoZGVmYXVsdCA9IDApLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbEJpbmRpbmcoc2lnbmFsLCBsaXN0ZW5lciwgaXNPbmNlLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gYm91bmQgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGJpbmRpbmcgc2hvdWxkIGJlIGV4ZWN1dGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXNPbmNlID0gaXNPbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAbWVtYmVyT2YgU2lnbmFsQmluZGluZy5wcm90b3R5cGVcbiAgICAgICAgICogQG5hbWUgY29udGV4dFxuICAgICAgICAgKiBAdHlwZSBPYmplY3R8dW5kZWZpbmVkfG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGxpc3RlbmVyQ29udGV4dDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIFNpZ25hbCBvYmplY3QgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqIEB0eXBlIFNpZ25hbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2lnbmFsID0gc2lnbmFsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBwcmlvcml0eVxuICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcbiAgICB9XG5cbiAgICBTaWduYWxCaW5kaW5nLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYmluZGluZyBpcyBhY3RpdmUgYW5kIHNob3VsZCBiZSBleGVjdXRlZC5cbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZlIDogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBsaXN0ZW5lciBkdXJpbmcgYFNpZ25hbC5kaXNwYXRjaGAgYW5kIGBTaWduYWxCaW5kaW5nLmV4ZWN1dGVgLiAoY3VycmllZCBwYXJhbWV0ZXJzKVxuICAgICAgICAgKiBAdHlwZSBBcnJheXxudWxsXG4gICAgICAgICAqL1xuICAgICAgICBwYXJhbXMgOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGxpc3RlbmVyIHBhc3NpbmcgYXJiaXRyYXJ5IHBhcmFtZXRlcnMuXG4gICAgICAgICAqIDxwPklmIGJpbmRpbmcgd2FzIGFkZGVkIHVzaW5nIGBTaWduYWwuYWRkT25jZSgpYCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHNpZ25hbCBkaXNwYXRjaCBxdWV1ZSwgdGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgc2lnbmFsIGRpc3BhdGNoLjwvcD5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc0Fycl0gQXJyYXkgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGxpc3RlbmVyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHJldHVybmVkIGJ5IHRoZSBsaXN0ZW5lci5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWN1dGUgOiBmdW5jdGlvbiAocGFyYW1zQXJyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlclJldHVybiwgcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICEhdGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcz8gdGhpcy5wYXJhbXMuY29uY2F0KHBhcmFtc0FycikgOiBwYXJhbXNBcnI7XG4gICAgICAgICAgICAgICAgaGFuZGxlclJldHVybiA9IHRoaXMuX2xpc3RlbmVyLmFwcGx5KHRoaXMuY29udGV4dCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJSZXR1cm47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGFjaCBiaW5kaW5nIGZyb20gc2lnbmFsLlxuICAgICAgICAgKiAtIGFsaWFzIHRvOiBteVNpZ25hbC5yZW1vdmUobXlCaW5kaW5nLmdldExpc3RlbmVyKCkpO1xuICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwgb3IgYG51bGxgIGlmIGJpbmRpbmcgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXRhY2ggOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0JvdW5kKCk/IHRoaXMuX3NpZ25hbC5yZW1vdmUodGhpcy5fbGlzdGVuZXIsIHRoaXMuY29udGV4dCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYmluZGluZyBpcyBzdGlsbCBib3VuZCB0byB0aGUgc2lnbmFsIGFuZCBoYXZlIGEgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpc0JvdW5kIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICghIXRoaXMuX3NpZ25hbCAmJiAhIXRoaXMuX2xpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgU2lnbmFsQmluZGluZyB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb25jZS5cbiAgICAgICAgICovXG4gICAgICAgIGlzT25jZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09uY2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBIYW5kbGVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzaWduYWwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMaXN0ZW5lciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsfSBTaWduYWwgdGhhdCBsaXN0ZW5lciBpcyBjdXJyZW50bHkgYm91bmQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTaWduYWwgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgaW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Rlc3Ryb3kgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2lnbmFsO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29udGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdbU2lnbmFsQmluZGluZyBpc09uY2U6JyArIHRoaXMuX2lzT25jZSArJywgaXNCb3VuZDonKyB0aGlzLmlzQm91bmQoKSArJywgYWN0aXZlOicgKyB0aGlzLmFjdGl2ZSArICddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4vKmdsb2JhbCBTaWduYWxCaW5kaW5nOmZhbHNlKi9cblxuICAgIC8vIFNpZ25hbCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcihsaXN0ZW5lciwgZm5OYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2xpc3RlbmVyIGlzIGEgcmVxdWlyZWQgcGFyYW0gb2Yge2ZufSgpIGFuZCBzaG91bGQgYmUgYSBGdW5jdGlvbi4nLnJlcGxhY2UoJ3tmbn0nLCBmbk5hbWUpICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiA8YnIgLz4tIGluc3BpcmVkIGJ5IFJvYmVydCBQZW5uZXIncyBBUzMgU2lnbmFscy5cbiAgICAgKiBAbmFtZSBTaWduYWxcbiAgICAgKiBAYXV0aG9yIE1pbGxlciBNZWRlaXJvc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpZ25hbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIEFycmF5LjxTaWduYWxCaW5kaW5nPlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5mb3JjZSBkaXNwYXRjaCB0byBhd2F5cyB3b3JrIG9uIHNhbWUgY29udGV4dCAoIzQ3KVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgU2lnbmFsLnByb3RvdHlwZS5kaXNwYXRjaC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIFNpZ25hbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpZ25hbHMgVmVyc2lvbiBOdW1iZXJcbiAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cbiAgICAgICAgVkVSU0lPTiA6ICcxLjAuMCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIFNpZ25hbCBzaG91bGQga2VlcCByZWNvcmQgb2YgcHJldmlvdXNseSBkaXNwYXRjaGVkIHBhcmFtZXRlcnMgYW5kXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZSBsaXN0ZW5lciBkdXJpbmcgYGFkZCgpYC9gYWRkT25jZSgpYCBpZiBTaWduYWwgd2FzXG4gICAgICAgICAqIGFscmVhZHkgZGlzcGF0Y2hlZCBiZWZvcmUuXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIG1lbW9yaXplIDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zaG91bGRQcm9wYWdhdGUgOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBTaWduYWwgaXMgYWN0aXZlIGFuZCBzaG91bGQgYnJvYWRjYXN0IGV2ZW50cy5cbiAgICAgICAgICogPHA+PHN0cm9uZz5JTVBPUlRBTlQ6PC9zdHJvbmc+IFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBkdXJpbmcgYSBkaXNwYXRjaCB3aWxsIG9ubHkgYWZmZWN0IHRoZSBuZXh0IGRpc3BhdGNoLCBpZiB5b3Ugd2FudCB0byBzdG9wIHRoZSBwcm9wYWdhdGlvbiBvZiBhIHNpZ25hbCB1c2UgYGhhbHQoKWAgaW5zdGVhZC48L3A+XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZSA6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlZ2lzdGVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGlzT25jZSwgbGlzdGVuZXJDb250ZXh0LCBwcmlvcml0eSkge1xuXG4gICAgICAgICAgICB2YXIgcHJldkluZGV4ID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQpLFxuICAgICAgICAgICAgICAgIGJpbmRpbmc7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMuX2JpbmRpbmdzW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuaXNPbmNlKCkgIT09IGlzT25jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgYWRkJysgKGlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlbiBhZGQnKyAoIWlzT25jZT8gJycgOiAnT25jZScpICsnKCkgdGhlIHNhbWUgbGlzdGVuZXIgd2l0aG91dCByZW1vdmluZyB0aGUgcmVsYXRpb25zaGlwIGZpcnN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IG5ldyBTaWduYWxCaW5kaW5nKHRoaXMsIGxpc3RlbmVyLCBpc09uY2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRoaXMubWVtb3JpemUgJiYgdGhpcy5fcHJldlBhcmFtcyl7XG4gICAgICAgICAgICAgICAgYmluZGluZy5leGVjdXRlKHRoaXMuX3ByZXZQYXJhbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTaWduYWxCaW5kaW5nfSBiaW5kaW5nXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkQmluZGluZyA6IGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAvL3NpbXBsaWZpZWQgaW5zZXJ0aW9uIHNvcnRcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fYmluZGluZ3MubGVuZ3RoO1xuICAgICAgICAgICAgZG8geyAtLW47IH0gd2hpbGUgKHRoaXMuX2JpbmRpbmdzW25dICYmIGJpbmRpbmcuX3ByaW9yaXR5IDw9IHRoaXMuX2JpbmRpbmdzW25dLl9wcmlvcml0eSk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncy5zcGxpY2UobiArIDEsIDAsIGJpbmRpbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfaW5kZXhPZkxpc3RlbmVyIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX2JpbmRpbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBjdXI7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gdGhpcy5fYmluZGluZ3Nbbl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5fbGlzdGVuZXIgPT09IGxpc3RlbmVyICYmIGN1ci5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIFNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBpZiBTaWduYWwgaGFzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBoYXMgOiBmdW5jdGlvbiAobGlzdGVuZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbmRleE9mTGlzdGVuZXIobGlzdGVuZXIsIGNvbnRleHQpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbC5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgU2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGlzdGVuZXJDb250ZXh0XSBDb250ZXh0IG9uIHdoaWNoIGxpc3RlbmVyIHdpbGwgYmUgZXhlY3V0ZWQgKG9iamVjdCB0aGF0IHNob3VsZCByZXByZXNlbnQgdGhlIGB0aGlzYCB2YXJpYWJsZSBpbnNpZGUgbGlzdGVuZXIgZnVuY3Rpb24pLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW3ByaW9yaXR5XSBUaGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIGV2ZW50IGxpc3RlbmVyLiBMaXN0ZW5lcnMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgbGlzdGVuZXJzIHdpdGggbG93ZXIgcHJpb3JpdHkuIExpc3RlbmVycyB3aXRoIHNhbWUgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBleGVjdXRlZCBhdCB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IHdlcmUgYWRkZWQuIChkZWZhdWx0ID0gMClcbiAgICAgICAgICogQHJldHVybiB7U2lnbmFsQmluZGluZ30gQW4gT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBiZXR3ZWVuIHRoZSBTaWduYWwgYW5kIGxpc3RlbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgbGlzdGVuZXIgdG8gdGhlIHNpZ25hbCB0aGF0IHNob3VsZCBiZSByZW1vdmVkIGFmdGVyIGZpcnN0IGV4ZWN1dGlvbiAod2lsbCBiZSBleGVjdXRlZCBvbmx5IG9uY2UpLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBTaWduYWwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0ZW5lckNvbnRleHRdIENvbnRleHQgb24gd2hpY2ggbGlzdGVuZXIgd2lsbCBiZSBleGVjdXRlZCAob2JqZWN0IHRoYXQgc2hvdWxkIHJlcHJlc2VudCB0aGUgYHRoaXNgIHZhcmlhYmxlIGluc2lkZSBsaXN0ZW5lciBmdW5jdGlvbikuXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcHJpb3JpdHldIFRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGUgZXZlbnQgbGlzdGVuZXIuIExpc3RlbmVycyB3aXRoIGhpZ2hlciBwcmlvcml0eSB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZSBsaXN0ZW5lcnMgd2l0aCBsb3dlciBwcmlvcml0eS4gTGlzdGVuZXJzIHdpdGggc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgd2VyZSBhZGRlZC4gKGRlZmF1bHQgPSAwKVxuICAgICAgICAgKiBAcmV0dXJuIHtTaWduYWxCaW5kaW5nfSBBbiBPYmplY3QgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIGJldHdlZW4gdGhlIFNpZ25hbCBhbmQgbGlzdGVuZXIuXG4gICAgICAgICAqL1xuICAgICAgICBhZGRPbmNlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBsaXN0ZW5lckNvbnRleHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAnYWRkT25jZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXIobGlzdGVuZXIsIHRydWUsIGxpc3RlbmVyQ29udGV4dCwgcHJpb3JpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBFeGVjdXRpb24gY29udGV4dCAoc2luY2UgeW91IGNhbiBhZGQgdGhlIHNhbWUgaGFuZGxlciBtdWx0aXBsZSB0aW1lcyBpZiBleGVjdXRpbmcgaW4gYSBkaWZmZXJlbnQgY29udGV4dCkuXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBMaXN0ZW5lciBoYW5kbGVyIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKGxpc3RlbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyLCAncmVtb3ZlJyk7XG5cbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5faW5kZXhPZkxpc3RlbmVyKGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzW2ldLl9kZXN0cm95KCk7IC8vbm8gcmVhc29uIHRvIGEgU2lnbmFsQmluZGluZyBleGlzdCBpZiBpdCBpc24ndCBhdHRhY2hlZCB0byBhIHNpZ25hbFxuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQWxsIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobi0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ3Nbbl0uX2Rlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgU2lnbmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtTGlzdGVuZXJzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQsIGJsb2NraW5nIHRoZSBkaXNwYXRjaCB0byBuZXh0IGxpc3RlbmVycyBvbiB0aGUgcXVldWUuXG4gICAgICAgICAqIDxwPjxzdHJvbmc+SU1QT1JUQU5UOjwvc3Ryb25nPiBzaG91bGQgYmUgY2FsbGVkIG9ubHkgZHVyaW5nIHNpZ25hbCBkaXNwYXRjaCwgY2FsbGluZyBpdCBiZWZvcmUvYWZ0ZXIgZGlzcGF0Y2ggd29uJ3QgYWZmZWN0IHNpZ25hbCBicm9hZGNhc3QuPC9wPlxuICAgICAgICAgKiBAc2VlIFNpZ25hbC5wcm90b3R5cGUuZGlzYWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgaGFsdCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaC9Ccm9hZGNhc3QgU2lnbmFsIHRvIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIFBhcmFtZXRlcnMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIGVhY2ggaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoIDogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCEgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXNBcnIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIG4gPSB0aGlzLl9iaW5kaW5ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1lbW9yaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IHBhcmFtc0FycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEgbikge1xuICAgICAgICAgICAgICAgIC8vc2hvdWxkIGNvbWUgYWZ0ZXIgbWVtb3JpemVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3Muc2xpY2UoKTsgLy9jbG9uZSBhcnJheSBpbiBjYXNlIGFkZC9yZW1vdmUgaXRlbXMgZHVyaW5nIGRpc3BhdGNoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRQcm9wYWdhdGUgPSB0cnVlOyAvL2luIGNhc2UgYGhhbHRgIHdhcyBjYWxsZWQgYmVmb3JlIGRpc3BhdGNoIG9yIGR1cmluZyB0aGUgcHJldmlvdXMgZGlzcGF0Y2guXG5cbiAgICAgICAgICAgIC8vZXhlY3V0ZSBhbGwgY2FsbGJhY2tzIHVudGlsIGVuZCBvZiB0aGUgbGlzdCBvciB1bnRpbCBhIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCBvciBzdG9wcyBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy9yZXZlcnNlIGxvb3Agc2luY2UgbGlzdGVuZXJzIHdpdGggaGlnaGVyIHByaW9yaXR5IHdpbGwgYmUgYWRkZWQgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICAgICAgZG8geyBuLS07IH0gd2hpbGUgKGJpbmRpbmdzW25dICYmIHRoaXMuX3Nob3VsZFByb3BhZ2F0ZSAmJiBiaW5kaW5nc1tuXS5leGVjdXRlKHBhcmFtc0FycikgIT09IGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yZ2V0IG1lbW9yaXplZCBhcmd1bWVudHMuXG4gICAgICAgICAqIEBzZWUgU2lnbmFsLm1lbW9yaXplXG4gICAgICAgICAqL1xuICAgICAgICBmb3JnZXQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdGhpcy5fcHJldlBhcmFtcyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbGwgYmluZGluZ3MgZnJvbSBzaWduYWwgYW5kIGRlc3Ryb3kgYW55IHJlZmVyZW5jZSB0byBleHRlcm5hbCBvYmplY3RzIChkZXN0cm95IFNpZ25hbCBvYmplY3QpLlxuICAgICAgICAgKiA8cD48c3Ryb25nPklNUE9SVEFOVDo8L3N0cm9uZz4gY2FsbGluZyBhbnkgbWV0aG9kIG9uIHRoZSBzaWduYWwgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkaXNwb3NlIHdpbGwgdGhyb3cgZXJyb3JzLjwvcD5cbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JpbmRpbmdzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3ByZXZQYXJhbXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnW1NpZ25hbCBhY3RpdmU6JysgdGhpcy5hY3RpdmUgKycgbnVtTGlzdGVuZXJzOicrIHRoaXMuZ2V0TnVtTGlzdGVuZXJzKCkgKyddJztcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gTmFtZXNwYWNlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIG5hbWVzcGFjZVxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbmFtZSBzaWduYWxzXG4gICAgICovXG4gICAgdmFyIHNpZ25hbHMgPSBTaWduYWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZXZlbnQgYnJvYWRjYXN0ZXJcbiAgICAgKiBAc2VlIFNpZ25hbFxuICAgICAqL1xuICAgIC8vIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2VlICNnaC00NClcbiAgICBzaWduYWxzLlNpZ25hbCA9IFNpZ25hbDtcblxuXG5cbiAgICAvL2V4cG9ydHMgdG8gbXVsdGlwbGUgZW52aXJvbm1lbnRzXG4gICAgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXsgLy9BTURcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpZ25hbHM7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpeyAvL25vZGVcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBzaWduYWxzO1xuICAgIH0gZWxzZSB7IC8vYnJvd3NlclxuICAgICAgICAvL3VzZSBzdHJpbmcgYmVjYXVzZSBvZiBHb29nbGUgY2xvc3VyZSBjb21waWxlciBBRFZBTkNFRF9NT0RFXG4gICAgICAgIC8qanNsaW50IHN1Yjp0cnVlICovXG4gICAgICAgIGdsb2JhbFsnc2lnbmFscyddID0gc2lnbmFscztcbiAgICB9XG5cbn0odGhpcykpO1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyJyk7XG52YXIgcmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pcy1vYmplY3QnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpLmJpbmQobnVsbCwgUmVxdWVzdCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJpc29uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciB0cmltID0gJycudHJpbVxuICA/IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9XG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IodmFyIHN1YmtleSBpbiB2YWwpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSArICdbJyArIHN1YmtleSArICddJywgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID1cbiAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICdhcHBsaWNhdGlvbi94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxuIHJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHNlcmlhbGl6ZSxcbiAgICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbiB9O1xuXG4gLyoqXG4gICogRGVmYXVsdCBwYXJzZXJzLlxuICAqXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAgKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gICogICAgIH07XG4gICpcbiAgKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2Vcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGxpbmVzLnBvcCgpOyAvLyB0cmFpbGluZyBDUkxGXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgcmV0dXJuIC9bXFwvK11qc29uXFxiLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXMoc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKSxcbiAgICAgICAga2V5ID0gcGFydHMuc2hpZnQoKSxcbiAgICAgICAgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICAgIGlmIChrZXkgJiYgdmFsKSBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucmVxID0gcmVxO1xuICB0aGlzLnhociA9IHRoaXMucmVxLnhocjtcbiAgLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xuICB0aGlzLnRleHQgPSAoKHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyAmJiAodGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHx8IHR5cGVvZiB0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKVxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dFxuICAgICA6IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IHRoaXMucmVxLnhoci5zdGF0dXNUZXh0O1xuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG4gIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICA/IHRoaXMuX3BhcnNlQm9keSh0aGlzLnRleHQgPyB0aGlzLnRleHQgOiB0aGlzLnhoci5yZXNwb25zZSlcbiAgICA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gIC8vIGNvbnRlbnQtdHlwZVxuICB2YXIgY3QgPSB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gIHRoaXMudHlwZSA9IHR5cGUoY3QpO1xuXG4gIC8vIHBhcmFtc1xuICB2YXIgb2JqID0gcGFyYW1zKGN0KTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICghcGFyc2UgJiYgaXNKU09OKHRoaXMudHlwZSkpIHtcbiAgICBwYXJzZSA9IHJlcXVlc3QucGFyc2VbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgfVxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIChzdHIubGVuZ3RoIHx8IHN0ciBpbnN0YW5jZW9mIE9iamVjdClcbiAgICA/IHBhcnNlKHN0cilcbiAgICA6IG51bGw7XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAvLyBzdGF0dXMgLyBjbGFzc1xuICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAvLyBiYXNpY3NcbiAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgIDogZmFsc2U7XG5cbiAgLy8gc3VnYXJcbiAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gc2VsZi54aHIgJiYgc2VsZi54aHIucmVzcG9uc2VUZXh0ID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogbnVsbDtcbiAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgZXJyLnN0YXR1c0NvZGUgPSBzZWxmLnhociAmJiBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAocmVzLnN0YXR1cyA8IDIwMCB8fCByZXMuc3RhdHVzID49IDMwMCkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBuZXdfZXJyID0gZTsgLy8gIzk4NSB0b3VjaGluZyByZXMgbWF5IGNhdXNlIElOVkFMSURfU1RBVEVfRVJSIG9uIG9sZCBBbmRyb2lkXG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgcmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuZm9yICh2YXIga2V5IGluIHJlcXVlc3RCYXNlKSB7XG4gIFJlcXVlc3QucHJvdG90eXBlW2tleV0gPSByZXF1ZXN0QmFzZVtrZXldO1xufVxuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCByZXNwb25zZVR5cGUgdG8gYHZhbGAuIFByZXNlbnRseSB2YWxpZCByZXNwb25zZVR5cGVzIGFyZSAnYmxvYicgYW5kXG4gKiAnYXJyYXlidWZmZXInLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycgb3IgJ2Jhc2ljJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpYydcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBzdHIpO1xuICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYGZpbGVuYW1lYC5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5hdHRhY2goJ2NvbnRlbnQnLCBuZXcgQmxvYihbJzxhIGlkPVwiYVwiPjxiIGlkPVwiYlwiPmhleSE8L2I+PC9hPiddLCB7IHR5cGU6IFwidGV4dC9odG1sXCJ9KSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmaWVsZCwgZmlsZSwgZmlsZW5hbWUpe1xuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUgfHwgZmlsZS5uYW1lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZ2V0Rm9ybURhdGEgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhpcy5fZm9ybURhdGEgPSBuZXcgcm9vdC5Gb3JtRGF0YSgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mb3JtRGF0YTtcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgaWYgKHF1ZXJ5KSB7XG4gICAgdGhpcy51cmwgKz0gfnRoaXMudXJsLmluZGV4T2YoJz8nKVxuICAgICAgPyAnJicgKyBxdWVyeVxuICAgICAgOiAnPycgKyBxdWVyeTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4aHIgPSB0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCk7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGRhdGEgPSB0aGlzLl9mb3JtRGF0YSB8fCB0aGlzLl9kYXRhO1xuXG4gIC8vIHN0b3JlIGNhbGxiYWNrXG4gIHRoaXMuX2NhbGxiYWNrID0gZm4gfHwgbm9vcDtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICB2YXIgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICgwID09IHN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQpIHJldHVybiBzZWxmLl90aW1lb3V0RXJyb3IoKTtcbiAgICAgIGlmIChzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgdmFyIGhhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfVxuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgICAgIHNlbGYuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfVxuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2FwcGVuZFF1ZXJ5U3RyaW5nKCk7XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgfSBlbHNlIHtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICgnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX3NlcmlhbGl6ZXIgfHwgcmVxdWVzdC5zZXJpYWxpemVbY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdIDogJyddO1xuICAgIGlmICghc2VyaWFsaXplICYmIGlzSlNPTihjb250ZW50VHlwZSkpIHNlcmlhbGl6ZSA9IHJlcXVlc3Quc2VyaWFsaXplWydhcHBsaWNhdGlvbi9qc29uJ107XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIDogbnVsbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdGAuXG4gKi9cblxucmVxdWVzdC5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdPUFRJT05TJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIHRoaXMuX3RpbWVvdXQgPSAwO1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dCB0byBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQobXMpe1xuICB0aGlzLl90aW1lb3V0ID0gbXM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuZXhwb3J0cy50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3Qpe1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpOyBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn1cblxuZXhwb3J0cy5jYXRjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbmV4cG9ydHMuZ2V0SGVhZGVyID0gZXhwb3J0cy5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuZXhwb3J0cy51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG5cbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgIHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnRvSlNPTiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyXG4gIH07XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIFRPRE86IGZ1dHVyZSBwcm9vZiwgbW92ZSB0byBjb21wb2VudCBsYW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIC8vIG1lcmdlXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghb2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIi8vIFRoZSBub2RlIGFuZCBicm93c2VyIG1vZHVsZXMgZXhwb3NlIHZlcnNpb25zIG9mIHRoaXMgd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGJvdW5kIGFzIGZpcnN0IGFyZ3VtZW50XG4vKipcbiAqIElzc3VlIGEgcmVxdWVzdDpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICByZXF1ZXN0KCdHRVQnLCAnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJykuZW5kKGNhbGxiYWNrKVxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVxdWVzdChSZXF1ZXN0Q29uc3RydWN0b3IsIG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcignR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcbiAgfVxuXG4gIC8vIHVybCBmaXJzdFxuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0Q29uc3RydWN0b3IoJ0dFVCcsIG1ldGhvZCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlcXVlc3RDb25zdHJ1Y3RvcihtZXRob2QsIHVybCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wb255ZmlsbCA9IHJlcXVpcmUoJy4vcG9ueWZpbGwuanMnKTtcblxudmFyIF9wb255ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb255ZmlsbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIHJvb3Q7IC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSAoMCwgX3BvbnlmaWxsMlsnZGVmYXVsdCddKShyb290KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJlc3VsdDsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGw7XG5mdW5jdGlvbiBzeW1ib2xPYnNlcnZhYmxlUG9ueWZpbGwocm9vdCkge1xuXHR2YXIgcmVzdWx0O1xuXHR2YXIgX1N5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgX1N5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChfU3ltYm9sLm9ic2VydmFibGUpIHtcblx0XHRcdHJlc3VsdCA9IF9TeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gX1N5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0X1N5bWJvbC5vYnNlcnZhYmxlID0gcmVzdWx0O1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXN1bHQgPSAnQEBvYnNlcnZhYmxlJztcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOS4xXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE4IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4gIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzIHx8XG4gICAgICAgICAgICB7fTtcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBTeW1ib2xQcm90byA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMsXG4gICAgICBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGVpciBvbGQgbW9kdWxlIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICAvLyAoYG5vZGVUeXBlYCBpcyBjaGVja2VkIHRvIGVuc3VyZSB0aGF0IGBtb2R1bGVgXG4gIC8vIGFuZCBgZXhwb3J0c2AgYXJlIG5vdCBIVE1MIGVsZW1lbnRzLilcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmICFleHBvcnRzLm5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS45LjEnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBidWlsdGluSXRlcmF0ZWU7XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBpZGVudGl0eWAsXG4gIC8vIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXy5pdGVyYXRlZSAhPT0gYnVpbHRpbkl0ZXJhdGVlKSByZXR1cm4gXy5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiAhXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGFyZ0NvdW50IGFyZ3VtZW50LlxuICBfLml0ZXJhdGVlID0gYnVpbHRpbkl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbiAgLy8gYXJndW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgdmFsdWVzIHRvIG9wZXJhdGVcbiAgLy8gb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAvLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4gIC8vIHRoZSBsYXN0IGFyZ3VtZW50LiBTaW1pbGFyIHRvIEVTNuKAmXMgXCJyZXN0IHBhcmFtZXRlclwiLlxuICB2YXIgcmVzdEFyZ3VtZW50cyA9IGZ1bmN0aW9uKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKSxcbiAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIHJlc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgc2hhbGxvd1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKTtcbiAgfVxuXG4gIHZhciBkZWVwR2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdC5cbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBzaGFsbG93UHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgdmFyIGNyZWF0ZVJlZHVjZSA9IGZ1bmN0aW9uKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+PSAzO1xuICAgICAgcmV0dXJuIHJlZHVjZXIob2JqLCBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KSwgbWVtbywgaW5pdGlhbCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleUZpbmRlciA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmZpbmRJbmRleCA6IF8uZmluZEtleTtcbiAgICB2YXIga2V5ID0ga2V5RmluZGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwgcGF0aCwgYXJncykge1xuICAgIHZhciBjb250ZXh0UGF0aCwgZnVuYztcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhdGgpKSB7XG4gICAgICBmdW5jID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShwYXRoKSkge1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBmdW5jO1xuICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkZWVwR2V0KGNvbnRleHQsIGNvbnRleHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBtZXRob2QgPSBjb250ZXh0W3BhdGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5zYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24gdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmNsb25lKG9iaikgOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IF8ucmFuZG9tKGluZGV4LCBsYXN0KTtcbiAgICAgIHZhciB0ZW1wID0gc2FtcGxlW2luZGV4XTtcbiAgICAgIHNhbXBsZVtpbmRleF0gPSBzYW1wbGVbcmFuZF07XG4gICAgICBzYW1wbGVbcmFuZF0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlLnNsaWNlKDAsIG4pO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4KyssXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IsIHBhcnRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFydGl0aW9uID8gW1tdLCBbXV0gOiB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChoYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgdmFyIHJlU3RyU3ltYm9sID0gL1teXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRmZmZdL2c7XG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChfLmlzU3RyaW5nKG9iaikpIHtcbiAgICAgIC8vIEtlZXAgc3Vycm9nYXRlIHBhaXIgY2hhcmFjdGVycyB0b2dldGhlclxuICAgICAgcmV0dXJuIG9iai5tYXRjaChyZVN0clN5bWJvbCk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIHBhc3MpIHtcbiAgICByZXN1bHRbcGFzcyA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiBuID09IG51bGwgPyB2b2lkIDAgOiBbXTtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBCb29sZWFuKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCBvdGhlckFycmF5cykge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4gIC8vIGlzIG5vdCBhIG9uZS10by1vbmUgZnVuY3Rpb24sIHNvIHByb3ZpZGluZyBhbiBpdGVyYXRlZSB3aWxsIGRpc2FibGVcbiAgLy8gdGhlIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIHJlc3QpIHtcbiAgICByZXN0ID0gZmxhdHRlbihyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzLlxuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gcmVzdEFyZ3VtZW50cyhfLnVuemlwKTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIFBhc3NpbmcgYnkgcGFpcnMgaXMgdGhlIHJldmVyc2Ugb2YgXy5wYWlycy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBDaHVuayBhIHNpbmdsZSBhcnJheSBpbnRvIG11bHRpcGxlIGFycmF5cywgZWFjaCBjb250YWluaW5nIGBjb3VudGAgb3IgZmV3ZXJcbiAgLy8gaXRlbXMuXG4gIF8uY2h1bmsgPSBmdW5jdGlvbihhcnJheSwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCB8fCBjb3VudCA8IDEpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmNhbGwoYXJyYXksIGksIGkgKz0gY291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbiAgLy8gcHJlLWZpbGxlZC4gU2V0IGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIGZvciBhIGN1c3RvbSBwbGFjZWhvbGRlciBhcmd1bWVudC5cbiAgXy5wYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfLnBhcnRpYWwucGxhY2Vob2xkZXI7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBwbGFjZWhvbGRlciA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIF8ucGFydGlhbC5wbGFjZWhvbGRlciA9IF87XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICB9KTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFoYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH0pO1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChhcmdzKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcmdzKSB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICB2YXIgY2FsbE5vdyA9ICF0aW1lb3V0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IF8uZGVsYXkobGF0ZXIsIHdhaXQsIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICBfLnJlc3RBcmd1bWVudHMgPSByZXN0QXJndW1lbnRzO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgdmFyIGNvbGxlY3ROb25FbnVtUHJvcHMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChoYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgLlxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKGhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdC5cbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0ge307XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgXy5vYmplY3QuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgLlxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoZGVmYXVsdHMpIG9iaiA9IE9iamVjdChvYmopO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCFkZWZhdWx0cyB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKS5cbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcGljayBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGBvYmpgIGhhcyBrZXkgYGtleWAuXG4gIHZhciBrZXlJbk9iaiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpdGVyYXRlZSA9IGtleXNbMF07XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGtleXNbMV0pO1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gXy5tYXAoZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxLCBkZWVwRXE7XG4gIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiO1xuICAgIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICBkZWVwRXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IsIGlzTWFwLCBpc1dlYWtNYXAsIGlzU2V0LCBpc1dlYWtTZXQuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJywgJ1N5bWJvbCcsICdNYXAnLCAnV2Vha01hcCcsICdTZXQnLCAnV2Vha1NldCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBTYWZhcmkgOCAoIzE5MjkpLCBhbmQgUGhhbnRvbUpTICgjMjIzNikuXG4gIHZhciBub2RlbGlzdCA9IHJvb3QuZG9jdW1lbnQgJiYgcm9vdC5kb2N1bWVudC5jaGlsZE5vZGVzO1xuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGVsaXN0ICE9ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhXy5pc1N5bWJvbChvYmopICYmIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gP1xuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBpc05hTihvYmopO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBoYXMob2JqLCBwYXRoKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2ldO1xuICAgICAgaWYgKG9iaiA9PSBudWxsIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhbGVuZ3RoO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGV4ZXMuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBzaGFsbG93UHJvcGVydHkocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAhXy5pc0FycmF5KHBhdGgpID8gb2JqW3BhdGhdIDogZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIFRyYXZlcnNlcyB0aGUgY2hpbGRyZW4gb2YgYG9iamAgYWxvbmcgYHBhdGhgLiBJZiBhIGNoaWxkIGlzIGEgZnVuY3Rpb24sIGl0XG4gIC8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuICAvLyBjaGlsZCwgb3IgYGZhbGxiYWNrYCBpZiBhbnkgY2hpbGQgaXMgdW5kZWZpbmVkLlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkgcGF0aCA9IFtwYXRoXTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2suY2FsbChvYmopIDogZmFsbGJhY2s7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpbcGF0aFtpXV07XG4gICAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSBmYWxsYmFjaztcbiAgICAgICAgaSA9IGxlbmd0aDsgLy8gRW5zdXJlIHdlIGRvbid0IGNvbnRpbnVlIGl0ZXJhdGluZy5cbiAgICAgIH1cbiAgICAgIG9iaiA9IF8uaXNGdW5jdGlvbihwcm9wKSA/IHByb3AuY2FsbChvYmopIDogcHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHZhciByZW5kZXI7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgY2hhaW5SZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl93cmFwcGVkKTtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufSgpKTtcbiJdfQ==
